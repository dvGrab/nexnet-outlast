/**
 * Name: READYORNOT
 * Version: 0.0.1
 */

#include "pch.h"

namespace CG
{
	// --------------------------------------------------
	// # Structs Functions
	// --------------------------------------------------
	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAccuracyVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAccuracyVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AccuracyVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityState.CreateTransition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FActivityStateTransition                    InStateTransition                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class UActivityState* UActivityState::CreateTransition(const struct FActivityStateTransition& InStateTransition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityState.CreateTransition");
		
		UActivityState_CreateTransition_Params params {};
		params.InStateTransition = InStateTransition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityState.BindEventTick
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FScriptDelegate                              Delegate                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UActivityState* UActivityState::BindEventTick(const class FScriptDelegate& Delegate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityState.BindEventTick");
		
		UActivityState_BindEventTick_Params params {};
		params.Delegate = Delegate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityState.BindEventExit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FScriptDelegate                              Delegate                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UActivityState* UActivityState::BindEventExit(const class FScriptDelegate& Delegate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityState.BindEventExit");
		
		UActivityState_BindEventExit_Params params {};
		params.Delegate = Delegate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityState.BindEventEnter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FScriptDelegate                              Delegate                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UActivityState* UActivityState::BindEventEnter(const class FScriptDelegate& Delegate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityState.BindEventEnter");
		
		UActivityState_BindEventEnter_Params params {};
		params.Delegate = Delegate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ActivityState.ActivityStateUpdate__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActivityState::ActivityStateUpdate__DelegateSignature(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ActivityState.ActivityStateUpdate__DelegateSignature");
		
		UActivityState_ActivityStateUpdate__DelegateSignature_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ActivityState.ActivityStateEvent__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UActivityState::ActivityStateEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ActivityState.ActivityStateEvent__DelegateSignature");
		
		UActivityState_ActivityStateEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActivityState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActivityState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ActivityState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityFiniteStateMachine.IsMachineInitialized
	 * 		Flags  -> ()
	 */
	bool UActivityFiniteStateMachine::IsMachineInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityFiniteStateMachine.IsMachineInitialized");
		
		UActivityFiniteStateMachine_IsMachineInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityFiniteStateMachine.GetStateByName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InStateName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UActivityState* UActivityFiniteStateMachine::GetStateByName(const class FString& InStateName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityFiniteStateMachine.GetStateByName");
		
		UActivityFiniteStateMachine_GetStateByName_Params params {};
		params.InStateName = InStateName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityFiniteStateMachine.GetStateByID
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InStateID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UActivityState* UActivityFiniteStateMachine::GetStateByID(int32_t InStateID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityFiniteStateMachine.GetStateByID");
		
		UActivityFiniteStateMachine_GetStateByID_Params params {};
		params.InStateID = InStateID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityFiniteStateMachine.GetActiveState
	 * 		Flags  -> ()
	 */
	class UActivityState* UActivityFiniteStateMachine::GetActiveState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityFiniteStateMachine.GetActiveState");
		
		UActivityFiniteStateMachine_GetActiveState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityFiniteStateMachine.AddState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      NewStateName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FActivityStateTransition>            Transitions                                                (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class UActivityState* UActivityFiniteStateMachine::AddState(const class FString& NewStateName, TArray<struct FActivityStateTransition> Transitions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityFiniteStateMachine.AddState");
		
		UActivityFiniteStateMachine_AddState_Params params {};
		params.NewStateName = NewStateName;
		params.Transitions = Transitions;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActivityFiniteStateMachine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActivityFiniteStateMachine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ActivityFiniteStateMachine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityManager.SetStartDelay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewDelayTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActivityManager::SetStartDelay(float NewDelayTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityManager.SetStartDelay");
		
		UActivityManager_SetStartDelay_Params params {};
		params.NewDelayTime = NewDelayTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityManager.GiveActivityTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               InActivity                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticCharacter*                        InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOverrideCurrentActivity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bClearActivityList                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UActivityManager::GiveActivityTo(class UBaseActivity* InActivity, class ACyberneticCharacter* InCharacter, bool bOverrideCurrentActivity, bool bClearActivityList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityManager.GiveActivityTo");
		
		UActivityManager_GiveActivityTo_Params params {};
		params.InActivity = InActivity;
		params.InCharacter = InCharacter;
		params.bOverrideCurrentActivity = bOverrideCurrentActivity;
		params.bClearActivityList = bClearActivityList;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityManager.GiveActivitiesTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UBaseActivity*>                       InActivities                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class ACyberneticCharacter*                        InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOverrideCurrentActivity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bClearActivityList                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UActivityManager::GiveActivitiesTo(TArray<class UBaseActivity*> InActivities, class ACyberneticCharacter* InCharacter, bool bOverrideCurrentActivity, bool bClearActivityList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityManager.GiveActivitiesTo");
		
		UActivityManager_GiveActivitiesTo_Params params {};
		params.InActivities = InActivities;
		params.InCharacter = InCharacter;
		params.bOverrideCurrentActivity = bOverrideCurrentActivity;
		params.bClearActivityList = bClearActivityList;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityManager.GetStartDelay
	 * 		Flags  -> ()
	 */
	float UActivityManager::GetStartDelay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityManager.GetStartDelay");
		
		UActivityManager_GetStartDelay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityManager.Get
	 * 		Flags  -> ()
	 */
	class UActivityManager* UActivityManager::Get()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityManager.Get");
		
		UActivityManager_Get_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityManager.CreateActivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     ContextObject                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      InActivityClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InActivityName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InActivityStartDelay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseActivity* UActivityManager::CreateActivity(class UObject* ContextObject, class UClass* InActivityClass, const class FString& InActivityName, float InActivityStartDelay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityManager.CreateActivity");
		
		UActivityManager_CreateActivity_Params params {};
		params.ContextObject = ContextObject;
		params.InActivityClass = InActivityClass;
		params.InActivityName = InActivityName;
		params.InActivityStartDelay = InActivityStartDelay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ActivityManager.CanGiveActivityTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               InActivity                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticCharacter*                        InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UActivityManager::CanGiveActivityTo(class UBaseActivity* InActivity, class ACyberneticCharacter* InCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ActivityManager.CanGiveActivityTo");
		
		UActivityManager_CanGiveActivityTo_Params params {};
		params.InActivity = InActivity;
		params.InCharacter = InCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActivityManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActivityManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ActivityManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AActivityRouteActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AActivityRouteActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ActivityRouteActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AActorSpawnPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AActorSpawnPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ActorSpawnPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AdminGameControls.KickPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                KickingPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        reason                                                     (Parm, NativeAccessSpecifierPublic)
	 */
	void UAdminGameControls::KickPlayer(class APlayerState* KickingPlayerState, const class FText& reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AdminGameControls.KickPlayer");
		
		UAdminGameControls_KickPlayer_Params params {};
		params.KickingPlayerState = KickingPlayerState;
		params.reason = reason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AdminGameControls.IsAdmin
	 * 		Flags  -> ()
	 */
	bool UAdminGameControls::IsAdmin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AdminGameControls.IsAdmin");
		
		UAdminGameControls_IsAdmin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AdminGameControls.GetKickablePlayers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class APlayerState*>                        KickablePlayers                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UAdminGameControls::GetKickablePlayers(TArray<class APlayerState*>* KickablePlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AdminGameControls.GetKickablePlayers");
		
		UAdminGameControls_GetKickablePlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (KickablePlayers != nullptr)
			*KickablePlayers = params.KickablePlayers;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAdminGameControls.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAdminGameControls::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AdminGameControls");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.WantsAbort
	 * 		Flags  -> ()
	 */
	bool UAIAction::WantsAbort()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.WantsAbort");
		
		UAIAction_WantsAbort_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.Tick_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAIAction::Tick_Blueprint(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.Tick_Blueprint");
		
		UAIAction_Tick_Blueprint_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.ShouldPerformAction
	 * 		Flags  -> ()
	 */
	bool UAIAction::ShouldPerformAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.ShouldPerformAction");
		
		UAIAction_ShouldPerformAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.RequestMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAIAction::RequestMove(const struct FCoreUObject_FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.RequestMove");
		
		UAIAction_RequestMove_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.OnSucceededToConsider_Blueprint
	 * 		Flags  -> ()
	 */
	void UAIAction::OnSucceededToConsider_Blueprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.OnSucceededToConsider_Blueprint");
		
		UAIAction_OnSucceededToConsider_Blueprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.OnPathFound_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PathId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERonNavigationQueryResult                          Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAIAction::OnPathFound_Blueprint(int32_t PathId, ERonNavigationQueryResult Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.OnPathFound_Blueprint");
		
		UAIAction_OnPathFound_Blueprint_Params params {};
		params.PathId = PathId;
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.OnPathFound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PathId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERonNavigationQueryResult                          Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAIAction::OnPathFound(int32_t PathId, ERonNavigationQueryResult Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.OnPathFound");
		
		UAIAction_OnPathFound_Params params {};
		params.PathId = PathId;
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.OnMoveComplete_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AAIController*                               Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            RequestID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAIAction::OnMoveComplete_Blueprint(class AAIController* Controller, int32_t RequestID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.OnMoveComplete_Blueprint");
		
		UAIAction_OnMoveComplete_Blueprint_Params params {};
		params.Controller = Controller;
		params.RequestID = RequestID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.OnMoveComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AAIController*                               Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            RequestID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAIAction::OnMoveComplete(class AAIController* Controller, int32_t RequestID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.OnMoveComplete");
		
		UAIAction_OnMoveComplete_Params params {};
		params.Controller = Controller;
		params.RequestID = RequestID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.OnFailedToConsider_Blueprint
	 * 		Flags  -> ()
	 */
	void UAIAction::OnFailedToConsider_Blueprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.OnFailedToConsider_Blueprint");
		
		UAIAction_OnFailedToConsider_Blueprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.OnCreate_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAIAction::OnCreate_Blueprint(class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.OnCreate_Blueprint");
		
		UAIAction_OnCreate_Blueprint_Params params {};
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.InitAction_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAIAction::InitAction_Blueprint(class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.InitAction_Blueprint");
		
		UAIAction_InitAction_Blueprint_Params params {};
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.GetCharacter
	 * 		Flags  -> ()
	 */
	class ACyberneticCharacter* UAIAction::GetCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.GetCharacter");
		
		UAIAction_GetCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.GetActionRunCount
	 * 		Flags  -> ()
	 */
	int32_t UAIAction::GetActionRunCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.GetActionRunCount");
		
		UAIAction_GetActionRunCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.GetActionData
	 * 		Flags  -> ()
	 */
	struct FAIActionData UAIAction::GetActionData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.GetActionData");
		
		UAIAction_GetActionData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.EndAction_Blueprint
	 * 		Flags  -> ()
	 */
	void UAIAction::EndAction_Blueprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.EndAction_Blueprint");
		
		UAIAction_EndAction_Blueprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.BeginAction_Blueprint
	 * 		Flags  -> ()
	 */
	void UAIAction::BeginAction_Blueprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.BeginAction_Blueprint");
		
		UAIAction_BeginAction_Blueprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIAction.AbortAction
	 * 		Flags  -> ()
	 */
	void UAIAction::AbortAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIAction.AbortAction");
		
		UAIAction_AbortAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AIAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIActionConsideration.Score
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAIActionDecisionContext                    Context                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccess                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UAIActionConsideration::Score(const struct FAIActionDecisionContext& Context, bool* bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIActionConsideration.Score");
		
		UAIActionConsideration_Score_Params params {};
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bSuccess != nullptr)
			*bSuccess = params.bSuccess;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIActionConsideration.EvaluateResponseCurve
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UAIActionConsideration::EvaluateResponseCurve(float Score)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIActionConsideration.EvaluateResponseCurve");
		
		UAIActionConsideration_EvaluateResponseCurve_Params params {};
		params.Score = Score;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIActionConsideration.CalculateCurve
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UAIActionConsideration::CalculateCurve(float X)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIActionConsideration.CalculateCurve");
		
		UAIActionConsideration_CalculateCurve_Params params {};
		params.X = X;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIActionConsideration.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIActionConsideration::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AIActionConsideration");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIActionGate.CanOpen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAIActionDecisionContext                    Context                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UAIActionGate::CanOpen(const struct FAIActionDecisionContext& Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIActionGate.CanOpen");
		
		UAIActionGate_CanOpen_Params params {};
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIActionGate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIActionGate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AIActionGate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIActionPresetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIActionPresetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AIActionPresetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIArchetypeData.AssignActionPreset
	 * 		Flags  -> ()
	 */
	void UAIArchetypeData::AssignActionPreset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIArchetypeData.AssignActionPreset");
		
		UAIArchetypeData_AssignActionPreset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIArchetypeData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIArchetypeData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AIArchetypeData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AIData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.OnAllAISpawned_Blueprint
	 * 		Flags  -> ()
	 */
	void AAIFactionManager::OnAllAISpawned_Blueprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.OnAllAISpawned_Blueprint");
		
		AAIFactionManager_OnAllAISpawned_Blueprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.OnAISpottedNeutral_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        Spotter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Neutral                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AAIFactionManager::OnAISpottedNeutral_Blueprint(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Neutral)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.OnAISpottedNeutral_Blueprint");
		
		AAIFactionManager_OnAISpottedNeutral_Blueprint_Params params {};
		params.Spotter = Spotter;
		params.Neutral = Neutral;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.OnAISpottedNeutral
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        Spotter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Neutral                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AAIFactionManager::OnAISpottedNeutral(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Neutral)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.OnAISpottedNeutral");
		
		AAIFactionManager_OnAISpottedNeutral_Params params {};
		params.Spotter = Spotter;
		params.Neutral = Neutral;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.OnAISpottedFriendly_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        Spotter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Friendly                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AAIFactionManager::OnAISpottedFriendly_Blueprint(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Friendly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.OnAISpottedFriendly_Blueprint");
		
		AAIFactionManager_OnAISpottedFriendly_Blueprint_Params params {};
		params.Spotter = Spotter;
		params.Friendly = Friendly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.OnAISpottedFriendly
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        Spotter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Friendly                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AAIFactionManager::OnAISpottedFriendly(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Friendly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.OnAISpottedFriendly");
		
		AAIFactionManager_OnAISpottedFriendly_Params params {};
		params.Spotter = Spotter;
		params.Friendly = Friendly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.OnAISpottedEnemy_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        Spotter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Enemy                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AAIFactionManager::OnAISpottedEnemy_Blueprint(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Enemy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.OnAISpottedEnemy_Blueprint");
		
		AAIFactionManager_OnAISpottedEnemy_Blueprint_Params params {};
		params.Spotter = Spotter;
		params.Enemy = Enemy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.OnAISpottedEnemy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        Spotter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Enemy                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AAIFactionManager::OnAISpottedEnemy(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Enemy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.OnAISpottedEnemy");
		
		AAIFactionManager_OnAISpottedEnemy_Params params {};
		params.Spotter = Spotter;
		params.Enemy = Enemy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.OnAIAdded_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AAIFactionManager::OnAIAdded_Blueprint(class ACyberneticCharacter* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.OnAIAdded_Blueprint");
		
		AAIFactionManager_OnAIAdded_Blueprint_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.IsTeamFull
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFactionSuspectTeam                         InTeam                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool AAIFactionManager::IsTeamFull(const struct FFactionSuspectTeam& InTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.IsTeamFull");
		
		AAIFactionManager_IsTeamFull_Params params {};
		params.InTeam = InTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.IsSuspectInTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASuspectCharacter*                           InSuspect                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FFactionSuspectTeam                         OutTeam                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool AAIFactionManager::IsSuspectInTeam(class ASuspectCharacter* InSuspect, struct FFactionSuspectTeam* OutTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.IsSuspectInTeam");
		
		AAIFactionManager_IsSuspectInTeam_Params params {};
		params.InSuspect = InSuspect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTeam != nullptr)
			*OutTeam = params.OutTeam;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.GetTeamTacticFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASuspectCharacter*                           InSuspect                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAITeamTactic                                      OutTactic                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AAIFactionManager::GetTeamTacticFor(class ASuspectCharacter* InSuspect, EAITeamTactic* OutTactic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.GetTeamTacticFor");
		
		AAIFactionManager_GetTeamTacticFor_Params params {};
		params.InSuspect = InSuspect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTactic != nullptr)
			*OutTactic = params.OutTactic;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.GetTeamIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASuspectCharacter*                           InSuspect                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AAIFactionManager::GetTeamIndex(class ASuspectCharacter* InSuspect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.GetTeamIndex");
		
		AAIFactionManager_GetTeamIndex_Params params {};
		params.InSuspect = InSuspect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.GetSuspectsInTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASuspectCharacter*                           InSuspect                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ASuspectCharacter*>                   OutSuspects                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeSelf                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AAIFactionManager::GetSuspectsInTeam(class ASuspectCharacter* InSuspect, TArray<class ASuspectCharacter*>* OutSuspects, bool bIncludeSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.GetSuspectsInTeam");
		
		AAIFactionManager_GetSuspectsInTeam_Params params {};
		params.InSuspect = InSuspect;
		params.bIncludeSelf = bIncludeSelf;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSuspects != nullptr)
			*OutSuspects = params.OutSuspects;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.GetAllSuspects
	 * 		Flags  -> ()
	 */
	TArray<class ASuspectCharacter*> AAIFactionManager::GetAllSuspects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.GetAllSuspects");
		
		AAIFactionManager_GetAllSuspects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.GetAllLeaders
	 * 		Flags  -> ()
	 */
	TArray<class ACyberneticCharacter*> AAIFactionManager::GetAllLeaders()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.GetAllLeaders");
		
		AAIFactionManager_GetAllLeaders_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.GetAllCivilians
	 * 		Flags  -> ()
	 */
	TArray<class ACivilianCharacter*> AAIFactionManager::GetAllCivilians()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.GetAllCivilians");
		
		AAIFactionManager_GetAllCivilians_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.GetAllCharacters
	 * 		Flags  -> ()
	 */
	TArray<class ACyberneticCharacter*> AAIFactionManager::GetAllCharacters()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.GetAllCharacters");
		
		AAIFactionManager_GetAllCharacters_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.FindClosestSuspect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class ASuspectCharacter*>                   OtherSuspects                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class ASuspectCharacter*                           Suspect                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxDistance                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASuspectCharacter* AAIFactionManager::FindClosestSuspect(TArray<class ASuspectCharacter*> OtherSuspects, class ASuspectCharacter* Suspect, float MaxDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.FindClosestSuspect");
		
		AAIFactionManager_FindClosestSuspect_Params params {};
		params.OtherSuspects = OtherSuspects;
		params.Suspect = Suspect;
		params.MaxDistance = MaxDistance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.AreTeamSpotsAvailable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            OutIndex                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AAIFactionManager::AreTeamSpotsAvailable(int32_t* OutIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.AreTeamSpotsAvailable");
		
		AAIFactionManager_AreTeamSpotsAvailable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutIndex != nullptr)
			*OutIndex = params.OutIndex;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AIFactionManager.AlertOtherSuspectsInTeam_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASuspectCharacter*                           Suspect                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Enemy                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AAIFactionManager::AlertOtherSuspectsInTeam_Blueprint(class ASuspectCharacter* Suspect, class AReadyOrNotCharacter* Enemy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AIFactionManager.AlertOtherSuspectsInTeam_Blueprint");
		
		AAIFactionManager_AlertOtherSuspectsInTeam_Blueprint_Params params {};
		params.Suspect = Suspect;
		params.Enemy = Enemy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAIFactionManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAIFactionManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AIFactionManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AISafeZone.OnOverlapEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AAISafeZone::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AISafeZone.OnOverlapEnd");
		
		AAISafeZone_OnOverlapEnd_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AISafeZone.OnOverlapBegin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AAISafeZone::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AISafeZone.OnOverlapBegin");
		
		AAISafeZone_OnOverlapBegin_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAISafeZone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAISafeZone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AISafeZone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AISpawn.TransferSpawnDataToRosterSpawnData
	 * 		Flags  -> ()
	 */
	void AAISpawn::TransferSpawnDataToRosterSpawnData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AISpawn.TransferSpawnDataToRosterSpawnData");
		
		AAISpawn_TransferSpawnDataToRosterSpawnData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AISpawn.GetSuspectSpawnData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FSpawnData>                          OutSpawnData                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool AAISpawn::GetSuspectSpawnData(TArray<struct FSpawnData>* OutSpawnData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AISpawn.GetSuspectSpawnData");
		
		AAISpawn_GetSuspectSpawnData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSpawnData != nullptr)
			*OutSpawnData = params.OutSpawnData;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AISpawn.GetSpawningTeamType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSpawnData                                  Sd                                                         (Parm, NativeAccessSpecifierPublic)
	 */
	ETeamType AAISpawn::GetSpawningTeamType(const struct FSpawnData& Sd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AISpawn.GetSpawningTeamType");
		
		AAISpawn_GetSpawningTeamType_Params params {};
		params.Sd = Sd;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AISpawn.GetSpawnedCharacterDeffered
	 * 		Flags  -> ()
	 */
	class ACyberneticCharacter* AAISpawn::GetSpawnedCharacterDeffered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AISpawn.GetSpawnedCharacterDeffered");
		
		AAISpawn_GetSpawnedCharacterDeffered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AISpawn.GetDefaultSpawningTeamType
	 * 		Flags  -> ()
	 */
	ETeamType AAISpawn::GetDefaultSpawningTeamType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AISpawn.GetDefaultSpawningTeamType");
		
		AAISpawn_GetDefaultSpawningTeamType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AISpawn.GetCivilianSpawnData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FSpawnData>                          OutSpawnData                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool AAISpawn::GetCivilianSpawnData(TArray<struct FSpawnData>* OutSpawnData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AISpawn.GetCivilianSpawnData");
		
		AAISpawn_GetCivilianSpawnData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSpawnData != nullptr)
			*OutSpawnData = params.OutSpawnData;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AISpawn.DoSpawn
	 * 		Flags  -> ()
	 */
	bool AAISpawn::DoSpawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AISpawn.DoSpawn");
		
		AAISpawn_DoSpawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAISpawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAISpawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AISpawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AITest.Investigate
	 * 		Flags  -> ()
	 */
	void AAITest::Investigate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AITest.Investigate");
		
		AAITest_Investigate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AITest.DestroyTestCharacter
	 * 		Flags  -> ()
	 */
	void AAITest::DestroyTestCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AITest.DestroyTestCharacter");
		
		AAITest_DestroyTestCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAITest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAITest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AITest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.UpdatePreviousResource
	 * 		Flags  -> ()
	 */
	void UResourceComponent::UpdatePreviousResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.UpdatePreviousResource");
		
		UResourceComponent_UpdatePreviousResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.ToggleUnlimitedResource
	 * 		Flags  -> ()
	 */
	void UResourceComponent::ToggleUnlimitedResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.ToggleUnlimitedResource");
		
		UResourceComponent_ToggleUnlimitedResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.SetUnlimitedResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceComponent::SetUnlimitedResource(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.SetUnlimitedResource");
		
		UResourceComponent_SetUnlimitedResource_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.SetResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewResourceAmount                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceComponent::SetResource(float NewResourceAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.SetResource");
		
		UResourceComponent_SetResource_Params params {};
		params.NewResourceAmount = NewResourceAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.SetMaxResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewMaxResource                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceComponent::SetMaxResource(float NewMaxResource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.SetMaxResource");
		
		UResourceComponent_SetMaxResource_Params params {};
		params.NewMaxResource = NewMaxResource;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.SetCurrentResourceToMax
	 * 		Flags  -> ()
	 */
	void UResourceComponent::SetCurrentResourceToMax()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.SetCurrentResourceToMax");
		
		UResourceComponent_SetCurrentResourceToMax_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.Server_UpdatePreviousResource
	 * 		Flags  -> ()
	 */
	void UResourceComponent::Server_UpdatePreviousResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.Server_UpdatePreviousResource");
		
		UResourceComponent_Server_UpdatePreviousResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.Server_ToggleUnlimitedResource
	 * 		Flags  -> ()
	 */
	void UResourceComponent::Server_ToggleUnlimitedResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.Server_ToggleUnlimitedResource");
		
		UResourceComponent_Server_ToggleUnlimitedResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.Server_SetUnlimitedResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceComponent::Server_SetUnlimitedResource(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.Server_SetUnlimitedResource");
		
		UResourceComponent_Server_SetUnlimitedResource_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.Server_SetResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewResourceAmount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceComponent::Server_SetResource(float NewResourceAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.Server_SetResource");
		
		UResourceComponent_Server_SetResource_Params params {};
		params.NewResourceAmount = NewResourceAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.Server_SetMaxResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewMaxResource                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceComponent::Server_SetMaxResource(float NewMaxResource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.Server_SetMaxResource");
		
		UResourceComponent_Server_SetMaxResource_Params params {};
		params.NewMaxResource = NewMaxResource;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.Server_SetCurrentResourceToMax
	 * 		Flags  -> ()
	 */
	void UResourceComponent::Server_SetCurrentResourceToMax()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.Server_SetCurrentResourceToMax");
		
		UResourceComponent_Server_SetCurrentResourceToMax_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.Server_ResetResource
	 * 		Flags  -> ()
	 */
	void UResourceComponent::Server_ResetResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.Server_ResetResource");
		
		UResourceComponent_Server_ResetResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.Server_InitResource
	 * 		Flags  -> ()
	 */
	void UResourceComponent::Server_InitResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.Server_InitResource");
		
		UResourceComponent_Server_InitResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.Server_IncreaseResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceComponent::Server_IncreaseResource(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.Server_IncreaseResource");
		
		UResourceComponent_Server_IncreaseResource_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.Server_EnableUnlimitedResource
	 * 		Flags  -> ()
	 */
	void UResourceComponent::Server_EnableUnlimitedResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.Server_EnableUnlimitedResource");
		
		UResourceComponent_Server_EnableUnlimitedResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.Server_DisableUnlimitedResource
	 * 		Flags  -> ()
	 */
	void UResourceComponent::Server_DisableUnlimitedResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.Server_DisableUnlimitedResource");
		
		UResourceComponent_Server_DisableUnlimitedResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.Server_DepleteResource
	 * 		Flags  -> ()
	 */
	void UResourceComponent::Server_DepleteResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.Server_DepleteResource");
		
		UResourceComponent_Server_DepleteResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.Server_DecreaseResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceComponent::Server_DecreaseResource(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.Server_DecreaseResource");
		
		UResourceComponent_Server_DecreaseResource_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.ResetResource
	 * 		Flags  -> ()
	 */
	void UResourceComponent::ResetResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.ResetResource");
		
		UResourceComponent_ResetResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ResourceComponent.OnLowResourceSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Resource                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceComponent::OnLowResourceSignature__DelegateSignature(float Resource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ResourceComponent.OnLowResourceSignature__DelegateSignature");
		
		UResourceComponent_OnLowResourceSignature__DelegateSignature_Params params {};
		params.Resource = Resource;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ResourceComponent.OnFullResourceSignature__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UResourceComponent::OnFullResourceSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ResourceComponent.OnFullResourceSignature__DelegateSignature");
		
		UResourceComponent_OnFullResourceSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ResourceComponent.OnDepletedResourceSignature__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UResourceComponent::OnDepletedResourceSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ResourceComponent.OnDepletedResourceSignature__DelegateSignature");
		
		UResourceComponent_OnDepletedResourceSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.IsUnlimitedResourceEnabled
	 * 		Flags  -> ()
	 */
	bool UResourceComponent::IsUnlimitedResourceEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.IsUnlimitedResourceEnabled");
		
		UResourceComponent_IsUnlimitedResourceEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.IsResourceBelow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ResourceValue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UResourceComponent::IsResourceBelow(float ResourceValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.IsResourceBelow");
		
		UResourceComponent_IsResourceBelow_Params params {};
		params.ResourceValue = ResourceValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.IsResourceAtOrBelow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ResourceValue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UResourceComponent::IsResourceAtOrBelow(float ResourceValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.IsResourceAtOrBelow");
		
		UResourceComponent_IsResourceAtOrBelow_Params params {};
		params.ResourceValue = ResourceValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.IsResourceAtOrAbove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ResourceValue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UResourceComponent::IsResourceAtOrAbove(float ResourceValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.IsResourceAtOrAbove");
		
		UResourceComponent_IsResourceAtOrAbove_Params params {};
		params.ResourceValue = ResourceValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.IsResourceAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ResourceValue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UResourceComponent::IsResourceAt(float ResourceValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.IsResourceAt");
		
		UResourceComponent_IsResourceAt_Params params {};
		params.ResourceValue = ResourceValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.IsResourceAbove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ResourceValue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UResourceComponent::IsResourceAbove(float ResourceValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.IsResourceAbove");
		
		UResourceComponent_IsResourceAbove_Params params {};
		params.ResourceValue = ResourceValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.IsLowResource
	 * 		Flags  -> ()
	 */
	bool UResourceComponent::IsLowResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.IsLowResource");
		
		UResourceComponent_IsLowResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.IsHalfResource
	 * 		Flags  -> ()
	 */
	bool UResourceComponent::IsHalfResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.IsHalfResource");
		
		UResourceComponent_IsHalfResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.IsFullResource
	 * 		Flags  -> ()
	 */
	bool UResourceComponent::IsFullResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.IsFullResource");
		
		UResourceComponent_IsFullResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.IsDepleted
	 * 		Flags  -> ()
	 */
	bool UResourceComponent::IsDepleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.IsDepleted");
		
		UResourceComponent_IsDepleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.IncreaseResourceByRate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Rate                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceComponent::IncreaseResourceByRate(float Rate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.IncreaseResourceByRate");
		
		UResourceComponent_IncreaseResourceByRate_Params params {};
		params.Rate = Rate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.IncreaseResource_Expression
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UResourceComponent::IncreaseResource_Expression(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.IncreaseResource_Expression");
		
		UResourceComponent_IncreaseResource_Expression_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.IncreaseResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceComponent::IncreaseResource(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.IncreaseResource");
		
		UResourceComponent_IncreaseResource_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.HasResource
	 * 		Flags  -> ()
	 */
	bool UResourceComponent::HasResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.HasResource");
		
		UResourceComponent_HasResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.GetResourceName
	 * 		Flags  -> ()
	 */
	class FName UResourceComponent::GetResourceName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.GetResourceName");
		
		UResourceComponent_GetResourceName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.GetPreviousResource
	 * 		Flags  -> ()
	 */
	float UResourceComponent::GetPreviousResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.GetPreviousResource");
		
		UResourceComponent_GetPreviousResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.GetOriginalMaxResource
	 * 		Flags  -> ()
	 */
	float UResourceComponent::GetOriginalMaxResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.GetOriginalMaxResource");
		
		UResourceComponent_GetOriginalMaxResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.GetNormalizedResource
	 * 		Flags  -> ()
	 */
	float UResourceComponent::GetNormalizedResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.GetNormalizedResource");
		
		UResourceComponent_GetNormalizedResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.GetMaxResource
	 * 		Flags  -> ()
	 */
	float UResourceComponent::GetMaxResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.GetMaxResource");
		
		UResourceComponent_GetMaxResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.GetLowResourceThreshold
	 * 		Flags  -> ()
	 */
	float UResourceComponent::GetLowResourceThreshold()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.GetLowResourceThreshold");
		
		UResourceComponent_GetLowResourceThreshold_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.GetLowResource
	 * 		Flags  -> ()
	 */
	float UResourceComponent::GetLowResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.GetLowResource");
		
		UResourceComponent_GetLowResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.GetHalfResource
	 * 		Flags  -> ()
	 */
	float UResourceComponent::GetHalfResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.GetHalfResource");
		
		UResourceComponent_GetHalfResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.GetCurrentResource
	 * 		Flags  -> ()
	 */
	float UResourceComponent::GetCurrentResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.GetCurrentResource");
		
		UResourceComponent_GetCurrentResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.EnableUnlimitedResource
	 * 		Flags  -> ()
	 */
	void UResourceComponent::EnableUnlimitedResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.EnableUnlimitedResource");
		
		UResourceComponent_EnableUnlimitedResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.DisableUnlimitedResource
	 * 		Flags  -> ()
	 */
	void UResourceComponent::DisableUnlimitedResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.DisableUnlimitedResource");
		
		UResourceComponent_DisableUnlimitedResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.DepleteResource
	 * 		Flags  -> ()
	 */
	void UResourceComponent::DepleteResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.DepleteResource");
		
		UResourceComponent_DepleteResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.DecreaseResourceByRate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Rate                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceComponent::DecreaseResourceByRate(float Rate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.DecreaseResourceByRate");
		
		UResourceComponent_DecreaseResourceByRate_Params params {};
		params.Rate = Rate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.DecreaseResource_Expression
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UResourceComponent::DecreaseResource_Expression(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.DecreaseResource_Expression");
		
		UResourceComponent_DecreaseResource_Expression_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ResourceComponent.DecreaseResource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UResourceComponent::DecreaseResource(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ResourceComponent.DecreaseResource");
		
		UResourceComponent_DecreaseResource_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UResourceComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UResourceComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ResourceComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AmmoComponent.GetAmmoUsagePerSecond
	 * 		Flags  -> ()
	 */
	float UAmmoComponent::GetAmmoUsagePerSecond()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AmmoComponent.GetAmmoUsagePerSecond");
		
		UAmmoComponent_GetAmmoUsagePerSecond_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAmmoComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAmmoComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AmmoComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAmmoRefillBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAmmoRefillBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AmmoRefillBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedDecal.SetAnimatedDecalMaterial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AAnimatedDecal::SetAnimatedDecalMaterial(class UMaterialInterface* Material)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedDecal.SetAnimatedDecalMaterial");
		
		AAnimatedDecal_SetAnimatedDecalMaterial_Params params {};
		params.Material = Material;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedDecal.GetRuntimeFloatCurveValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRuntimeFloatCurve                          Curve                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AAnimatedDecal::GetRuntimeFloatCurveValue(const struct FRuntimeFloatCurve& Curve, float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedDecal.GetRuntimeFloatCurveValue");
		
		AAnimatedDecal_GetRuntimeFloatCurveValue_Params params {};
		params.Curve = Curve;
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAnimatedDecal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAnimatedDecal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimatedDecal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedIconWidget.UnPauseIconAnim
	 * 		Flags  -> ()
	 */
	void UAnimatedIconWidget::UnPauseIconAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedIconWidget.UnPauseIconAnim");
		
		UAnimatedIconWidget_UnPauseIconAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedIconWidget.StopInteractAnim
	 * 		Flags  -> ()
	 */
	void UAnimatedIconWidget::StopInteractAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedIconWidget.StopInteractAnim");
		
		UAnimatedIconWidget_StopInteractAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedIconWidget.StopFocusAnim
	 * 		Flags  -> ()
	 */
	void UAnimatedIconWidget::StopFocusAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedIconWidget.StopFocusAnim");
		
		UAnimatedIconWidget_StopFocusAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedIconWidget.SetInteractState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValid                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnimatedIconWidget::SetInteractState(bool bValid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedIconWidget.SetInteractState");
		
		UAnimatedIconWidget_SetInteractState_Params params {};
		params.bValid = bValid;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedIconWidget.SetInteractIconSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InInteractCircleSize                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InInteractIconSize                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnimatedIconWidget::SetInteractIconSize(float InInteractCircleSize, float InInteractIconSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedIconWidget.SetInteractIconSize");
		
		UAnimatedIconWidget_SetInteractIconSize_Params params {};
		params.InInteractCircleSize = InInteractCircleSize;
		params.InInteractIconSize = InInteractIconSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedIconWidget.SetCurrentProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Percent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnimatedIconWidget::SetCurrentProgress(float Percent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedIconWidget.SetCurrentProgress");
		
		UAnimatedIconWidget_SetCurrentProgress_Params params {};
		params.Percent = Percent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedIconWidget.SetActiveIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnimatedIconWidget::SetActiveIcon(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedIconWidget.SetActiveIcon");
		
		UAnimatedIconWidget_SetActiveIcon_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedIconWidget.PlayInteractAnim
	 * 		Flags  -> ()
	 */
	void UAnimatedIconWidget::PlayInteractAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedIconWidget.PlayInteractAnim");
		
		UAnimatedIconWidget_PlayInteractAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedIconWidget.PlayFocusAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bReverse                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnimatedIconWidget::PlayFocusAnim(bool bReverse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedIconWidget.PlayFocusAnim");
		
		UAnimatedIconWidget_PlayFocusAnim_Params params {};
		params.bReverse = bReverse;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedIconWidget.PauseIconAnim
	 * 		Flags  -> ()
	 */
	void UAnimatedIconWidget::PauseIconAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedIconWidget.PauseIconAnim");
		
		UAnimatedIconWidget_PauseIconAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimatedIconWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimatedIconWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimatedIconWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedIconWidget_Imprint.SetIconImage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTexture2D*                                  NewIconImage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnimatedIconWidget_Imprint::SetIconImage(class UTexture2D* NewIconImage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedIconWidget_Imprint.SetIconImage");
		
		UAnimatedIconWidget_Imprint_SetIconImage_Params params {};
		params.NewIconImage = NewIconImage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimatedIconWidget_Imprint.Init
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        InWorldLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  InIconImage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnimatedIconWidget_Imprint::Init(const struct FCoreUObject_FVector& InWorldLocation, class UTexture2D* InIconImage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimatedIconWidget_Imprint.Init");
		
		UAnimatedIconWidget_Imprint_Init_Params params {};
		params.InWorldLocation = InWorldLocation;
		params.InIconImage = InIconImage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimatedIconWidget_Imprint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimatedIconWidget_Imprint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimatedIconWidget_Imprint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimCharacterMovementLibrary.UpdateCharacterMovementSnapshot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                     WorldTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        WorldVelocity                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        WorldAcceleration                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsOnGround                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RootYawOffset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAnimCharacterMovementSnapshot              Snapshot                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UAnimCharacterMovementLibrary::UpdateCharacterMovementSnapshot(const struct FTransform& WorldTransform, const struct FCoreUObject_FVector& WorldVelocity, const struct FCoreUObject_FVector& WorldAcceleration, bool bIsOnGround, float RootYawOffset, struct FAnimCharacterMovementSnapshot* Snapshot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimCharacterMovementLibrary.UpdateCharacterMovementSnapshot");
		
		UAnimCharacterMovementLibrary_UpdateCharacterMovementSnapshot_Params params {};
		params.WorldTransform = WorldTransform;
		params.WorldVelocity = WorldVelocity;
		params.WorldAcceleration = WorldAcceleration;
		params.bIsOnGround = bIsOnGround;
		params.RootYawOffset = RootYawOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Snapshot != nullptr)
			*Snapshot = params.Snapshot;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimCharacterMovementLibrary.SelectAnimForCardinalDirection
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EAnimCardinalDirection                             CardinalDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCardinalDirectionAnimSet                   AnimSet                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UAnimSequence* UAnimCharacterMovementLibrary::SelectAnimForCardinalDirection(EAnimCardinalDirection CardinalDirection, const struct FCardinalDirectionAnimSet& AnimSet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimCharacterMovementLibrary.SelectAnimForCardinalDirection");
		
		UAnimCharacterMovementLibrary_SelectAnimForCardinalDirection_Params params {};
		params.CardinalDirection = CardinalDirection;
		params.AnimSet = AnimSet;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimCharacterMovementLibrary.PredictGroundMovementStopLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAnimCharacterMovementSnapshot              MovementSnapshot                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FAnimCharacterMovementPredictionSnapshot    PredictionSnapshot                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector UAnimCharacterMovementLibrary::PredictGroundMovementStopLocation(const struct FAnimCharacterMovementSnapshot& MovementSnapshot, const struct FAnimCharacterMovementPredictionSnapshot& PredictionSnapshot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimCharacterMovementLibrary.PredictGroundMovementStopLocation");
		
		UAnimCharacterMovementLibrary_PredictGroundMovementStopLocation_Params params {};
		params.MovementSnapshot = MovementSnapshot;
		params.PredictionSnapshot = PredictionSnapshot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimCharacterMovementLibrary.PredictGroundMovementPivotLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAnimCharacterMovementSnapshot              MovementSnapshot                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              GroundFriction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector UAnimCharacterMovementLibrary::PredictGroundMovementPivotLocation(const struct FAnimCharacterMovementSnapshot& MovementSnapshot, float GroundFriction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimCharacterMovementLibrary.PredictGroundMovementPivotLocation");
		
		UAnimCharacterMovementLibrary_PredictGroundMovementPivotLocation_Params params {};
		params.MovementSnapshot = MovementSnapshot;
		params.GroundFriction = GroundFriction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimCharacterMovementLibrary.GetCardinalDirectionFromAngle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EAnimCardinalDirection                             PreviousCardinalDirection                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DirectionAngleInDegrees                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DeadZoneAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EAnimCardinalDirection UAnimCharacterMovementLibrary::GetCardinalDirectionFromAngle(EAnimCardinalDirection PreviousCardinalDirection, float DirectionAngleInDegrees, float DeadZoneAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimCharacterMovementLibrary.GetCardinalDirectionFromAngle");
		
		UAnimCharacterMovementLibrary_GetCardinalDirectionFromAngle_Params params {};
		params.PreviousCardinalDirection = PreviousCardinalDirection;
		params.DirectionAngleInDegrees = DirectionAngleInDegrees;
		params.DeadZoneAngle = DeadZoneAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimCharacterMovementLibrary.CalculateDirAngle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        CurVel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FRotator                       CurActorRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FRotator                       DirRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              ClampMin                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ClampMax                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CurDirAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UAnimCharacterMovementLibrary::CalculateDirAngle(const struct FCoreUObject_FVector& CurVel, const struct FCoreUObject_FRotator& CurActorRotation, const struct FCoreUObject_FRotator& DirRotation, float ClampMin, float ClampMax, float CurDirAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimCharacterMovementLibrary.CalculateDirAngle");
		
		UAnimCharacterMovementLibrary_CalculateDirAngle_Params params {};
		params.CurVel = CurVel;
		params.CurActorRotation = CurActorRotation;
		params.DirRotation = DirRotation;
		params.ClampMin = ClampMin;
		params.ClampMax = ClampMax;
		params.CurDirAngle = CurDirAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimCharacterMovementLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimCharacterMovementLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimCharacterMovementLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimDistanceMatchingLibrary.CalculateDistanceMatchingStates
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  CurrentCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCharacterMovementComponent*                 CurrentMovementComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDistanceMatchingType                              DistanceMatchingCurrentState                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAnimCharacterMovementSnapshot              MovementSnapshot                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FAnimCharacterMovementPredictionSnapshot    PredictionSnapshot                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UWorld*                                      TargetWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinPivotAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        LastActorLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCardinalDirectionSnapshot                  PivotingCardinalDirSnapShot                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FPredictionResult                           StartMarker                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FPredictionResult                           StopMarker                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FPredictionResult                           PivotMarker                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FPredictionResult                           TakeOffMarker                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FPredictionResult                           ApexMarker                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FPredictionResult                           LandingMarker                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bSMStartRuleset                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSMStopRuleset                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsAICharacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnimDistanceMatchingLibrary::CalculateDistanceMatchingStates(float DeltaTime, class ACharacter* CurrentCharacter, class UCharacterMovementComponent* CurrentMovementComponent, EDistanceMatchingType* DistanceMatchingCurrentState, const struct FAnimCharacterMovementSnapshot& MovementSnapshot, const struct FAnimCharacterMovementPredictionSnapshot& PredictionSnapshot, class UWorld* TargetWorld, float MinPivotAngle, TArray<class AActor*> ActorsToIgnore, struct FCoreUObject_FVector* LastActorLocation, struct FCardinalDirectionSnapshot* PivotingCardinalDirSnapShot, struct FPredictionResult* StartMarker, struct FPredictionResult* StopMarker, struct FPredictionResult* PivotMarker, struct FPredictionResult* TakeOffMarker, struct FPredictionResult* ApexMarker, struct FPredictionResult* LandingMarker, bool* bSMStartRuleset, bool* bSMStopRuleset, bool bIsAICharacter, bool bShowDebug)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimDistanceMatchingLibrary.CalculateDistanceMatchingStates");
		
		UAnimDistanceMatchingLibrary_CalculateDistanceMatchingStates_Params params {};
		params.DeltaTime = DeltaTime;
		params.CurrentCharacter = CurrentCharacter;
		params.CurrentMovementComponent = CurrentMovementComponent;
		params.MovementSnapshot = MovementSnapshot;
		params.PredictionSnapshot = PredictionSnapshot;
		params.TargetWorld = TargetWorld;
		params.MinPivotAngle = MinPivotAngle;
		params.ActorsToIgnore = ActorsToIgnore;
		params.bIsAICharacter = bIsAICharacter;
		params.bShowDebug = bShowDebug;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DistanceMatchingCurrentState != nullptr)
			*DistanceMatchingCurrentState = params.DistanceMatchingCurrentState;
		if (LastActorLocation != nullptr)
			*LastActorLocation = params.LastActorLocation;
		if (PivotingCardinalDirSnapShot != nullptr)
			*PivotingCardinalDirSnapShot = params.PivotingCardinalDirSnapShot;
		if (StartMarker != nullptr)
			*StartMarker = params.StartMarker;
		if (StopMarker != nullptr)
			*StopMarker = params.StopMarker;
		if (PivotMarker != nullptr)
			*PivotMarker = params.PivotMarker;
		if (TakeOffMarker != nullptr)
			*TakeOffMarker = params.TakeOffMarker;
		if (ApexMarker != nullptr)
			*ApexMarker = params.ApexMarker;
		if (LandingMarker != nullptr)
			*LandingMarker = params.LandingMarker;
		if (bSMStartRuleset != nullptr)
			*bSMStartRuleset = params.bSMStartRuleset;
		if (bSMStopRuleset != nullptr)
			*bSMStopRuleset = params.bSMStopRuleset;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimDistanceMatchingLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimDistanceMatchingLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimDistanceMatchingLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimInputCapsuleLocomotionBlueprintLibrary.UpdateCapsuleLocomotionAnimInput
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAnimInput_CapsuleLocomotion                CapsuleLocomotionAnimInput                                 (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UAnimInputCapsuleLocomotionBlueprintLibrary::UpdateCapsuleLocomotionAnimInput(class APawn* Pawn, struct FAnimInput_CapsuleLocomotion* CapsuleLocomotionAnimInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimInputCapsuleLocomotionBlueprintLibrary.UpdateCapsuleLocomotionAnimInput");
		
		UAnimInputCapsuleLocomotionBlueprintLibrary_UpdateCapsuleLocomotionAnimInput_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (CapsuleLocomotionAnimInput != nullptr)
			*CapsuleLocomotionAnimInput = params.CapsuleLocomotionAnimInput;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimInputCapsuleLocomotionBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimInputCapsuleLocomotionBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimInputCapsuleLocomotionBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_AIDoorBreachKick.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_AIDoorBreachKick::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_AIDoorBreachKick");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_AIDoorBreachShotgun.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_AIDoorBreachShotgun::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_AIDoorBreachShotgun");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_AIThrowGrenadeComplete.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_AIThrowGrenadeComplete::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_AIThrowGrenadeComplete");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_AIThrowPendingItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_AIThrowPendingItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_AIThrowPendingItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ApplyArteryDamage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ApplyArteryDamage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_ApplyArteryDamage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ApplyMeleeDamage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ApplyMeleeDamage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_ApplyMeleeDamage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_Breach_C2Detonate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_Breach_C2Detonate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_Breach_C2Detonate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_Breach_C2Placed.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_Breach_C2Placed::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_Breach_C2Placed");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ChangeBodySocket.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ChangeBodySocket::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_ChangeBodySocket");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ChangeCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ChangeCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_ChangeCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_CollectEvidence.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_CollectEvidence::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_CollectEvidence");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_CompleteHeal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_CompleteHeal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_CompleteHeal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_DisableWeaponFOV.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_DisableWeaponFOV::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_DisableWeaponFOV");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_DisarmTrap.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_DisarmTrap::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_DisarmTrap");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_DoorKickBreak.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_DoorKickBreak::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_DoorKickBreak");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_DoorKickFailure.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_DoorKickFailure::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_DoorKickFailure");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_EquipItemOfClass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_EquipItemOfClass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_EquipItemOfClass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_EquipLastItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_EquipLastItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_EquipLastItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ForceFireWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ForceFireWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_ForceFireWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ForceRagdoll.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ForceRagdoll::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_ForceRagdoll");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_GetupComplete.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_GetupComplete::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_GetupComplete");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ItemSwitchSocket.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ItemSwitchSocket::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_ItemSwitchSocket");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_KillMyself.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_KillMyself::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_KillMyself");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_LockPickDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_LockPickDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_LockPickDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_MirrorDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_MirrorDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_MirrorDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_NextMag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_NextMag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_NextMag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_OnCheckedDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_OnCheckedDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_OnCheckedDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_OnLandmarkProxyUse.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_OnLandmarkProxyUse::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_OnLandmarkProxyUse");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_PickupItemComplete.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_PickupItemComplete::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_PickupItemComplete");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_PlayMontage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_PlayMontage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_PlayMontage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_PlayPostProcessEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_PlayPostProcessEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_PlayPostProcessEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_PreMissionWeaponVis.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_PreMissionWeaponVis::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_PreMissionWeaponVis");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_PushQueuedDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_PushQueuedDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_PushQueuedDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_RemovePlacedC2.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_RemovePlacedC2::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_RemovePlacedC2");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USetControlRotationToCamBoneAnimNotify.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USetControlRotationToCamBoneAnimNotify::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SetControlRotationToCamBoneAnimNotify");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_SetCoverFirePose.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_SetCoverFirePose::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_SetCoverFirePose");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_SetCoverHidePose.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_SetCoverHidePose::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_SetCoverHidePose");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_SetCoverIdlePose.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_SetCoverIdlePose::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_SetCoverIdlePose");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_SetHoleTraversalPose.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_SetHoleTraversalPose::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_SetHoleTraversalPose");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_SetStrafe.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_SetStrafe::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_SetStrafe");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_SpawnThrownItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_SpawnThrownItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_SpawnThrownItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_SpawnWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_SpawnWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_SpawnWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_HideBoneVis.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_HideBoneVis::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotifyState_HideBoneVis");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ToggleEquipmentVis.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ToggleEquipmentVis::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_ToggleEquipmentVis");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_WedgeDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_WedgeDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotify_WedgeDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_SpawnLight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_SpawnLight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimNotifyState_SpawnLight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimTurnInPlaceLibrary.UpdateTurnInPlace
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAllowTurnInPlace                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHoldYawOffset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsTurnTransitionStateRelevant                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bClampYawOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              YawOffsetLimit                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FRotator                       MeshWorldRotation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FAnimTurnInPlaceAnimSet                     AnimSet                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FAnimTurnInPlaceState                       TurnInPlaceState                                           (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              TurnInPlaceSpeedMultiplier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnimTurnInPlaceLibrary::UpdateTurnInPlace(float DeltaTime, bool bAllowTurnInPlace, bool bHoldYawOffset, bool bIsTurnTransitionStateRelevant, bool bClampYawOffset, float YawOffsetLimit, const struct FCoreUObject_FRotator& MeshWorldRotation, const struct FAnimTurnInPlaceAnimSet& AnimSet, struct FAnimTurnInPlaceState* TurnInPlaceState, float TurnInPlaceSpeedMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimTurnInPlaceLibrary.UpdateTurnInPlace");
		
		UAnimTurnInPlaceLibrary_UpdateTurnInPlace_Params params {};
		params.DeltaTime = DeltaTime;
		params.bAllowTurnInPlace = bAllowTurnInPlace;
		params.bHoldYawOffset = bHoldYawOffset;
		params.bIsTurnTransitionStateRelevant = bIsTurnTransitionStateRelevant;
		params.bClampYawOffset = bClampYawOffset;
		params.YawOffsetLimit = YawOffsetLimit;
		params.MeshWorldRotation = MeshWorldRotation;
		params.AnimSet = AnimSet;
		params.TurnInPlaceSpeedMultiplier = TurnInPlaceSpeedMultiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TurnInPlaceState != nullptr)
			*TurnInPlaceState = params.TurnInPlaceState;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AnimTurnInPlaceLibrary.PostProcessYawOffset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              YawOffset                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LastYawOffset                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LastPostProcessedYawOffset                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              TurnAroundTimeToGo                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              TurnAroundBlendTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnimTurnInPlaceLibrary::PostProcessYawOffset(float DeltaSeconds, float* YawOffset, float* LastYawOffset, float* LastPostProcessedYawOffset, float* TurnAroundTimeToGo, float TurnAroundBlendTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AnimTurnInPlaceLibrary.PostProcessYawOffset");
		
		UAnimTurnInPlaceLibrary_PostProcessYawOffset_Params params {};
		params.DeltaSeconds = DeltaSeconds;
		params.TurnAroundBlendTime = TurnAroundBlendTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (YawOffset != nullptr)
			*YawOffset = params.YawOffset;
		if (LastYawOffset != nullptr)
			*LastYawOffset = params.LastYawOffset;
		if (LastPostProcessedYawOffset != nullptr)
			*LastPostProcessedYawOffset = params.LastPostProcessedYawOffset;
		if (TurnAroundTimeToGo != nullptr)
			*TurnAroundTimeToGo = params.TurnAroundTimeToGo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimTurnInPlaceLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimTurnInPlaceLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AnimTurnInPlaceLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ArmourResourceComponent.SetResistance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewResistancePercentage                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UArmourResourceComponent::SetResistance(float NewResistancePercentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ArmourResourceComponent.SetResistance");
		
		UArmourResourceComponent_SetResistance_Params params {};
		params.NewResistancePercentage = NewResistancePercentage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ArmourResourceComponent.SetMaxTickets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewMax                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UArmourResourceComponent::SetMaxTickets(int32_t NewMax)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ArmourResourceComponent.SetMaxTickets");
		
		UArmourResourceComponent_SetMaxTickets_Params params {};
		params.NewMax = NewMax;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ArmourResourceComponent.GetResistancePercentage
	 * 		Flags  -> ()
	 */
	float UArmourResourceComponent::GetResistancePercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ArmourResourceComponent.GetResistancePercentage");
		
		UArmourResourceComponent_GetResistancePercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ArmourResourceComponent.GetRemainingTickets
	 * 		Flags  -> ()
	 */
	int32_t UArmourResourceComponent::GetRemainingTickets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ArmourResourceComponent.GetRemainingTickets");
		
		UArmourResourceComponent_GetRemainingTickets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ArmourResourceComponent.GetMaxTickets
	 * 		Flags  -> ()
	 */
	int32_t UArmourResourceComponent::GetMaxTickets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ArmourResourceComponent.GetMaxTickets");
		
		UArmourResourceComponent_GetMaxTickets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArmourResourceComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArmourResourceComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ArmourResourceComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.ThrottleAI
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode::ThrottleAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.ThrottleAI");
		
		AReadyOrNotGameMode_ThrottleAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.SwapPlayerTeams
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode::SwapPlayerTeams()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.SwapPlayerTeams");
		
		AReadyOrNotGameMode_SwapPlayerTeams_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.StartMatch
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode::StartMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.StartMatch");
		
		AReadyOrNotGameMode_StartMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.SpawnSpectator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                     SpawnTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class ASpectatorPawn* AReadyOrNotGameMode::SpawnSpectator(class APlayerController* Controller, class UClass* Class, const struct FTransform& SpawnTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.SpawnSpectator");
		
		AReadyOrNotGameMode_SpawnSpectator_Params params {};
		params.Controller = Controller;
		params.Class = Class;
		params.SpawnTransform = SpawnTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.SpawnPlayerCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                     SpawnTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class APlayerCharacter* AReadyOrNotGameMode::SpawnPlayerCharacter(class APlayerController* Controller, class UClass* Class, const struct FTransform& SpawnTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.SpawnPlayerCharacter");
		
		AReadyOrNotGameMode_SpawnPlayerCharacter_Params params {};
		params.Controller = Controller;
		params.Class = Class;
		params.SpawnTransform = SpawnTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.ShouldCountDownTimelimitNow
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotGameMode::ShouldCountDownTimelimitNow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.ShouldCountDownTimelimitNow");
		
		AReadyOrNotGameMode_ShouldCountDownTimelimitNow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.SetPassword
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      newPassword                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::SetPassword(const class FString& newPassword)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.SetPassword");
		
		AReadyOrNotGameMode_SetPassword_Params params {};
		params.newPassword = newPassword;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.SetMatchState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMatchState                                        NewMatchState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::SetMatchState(EMatchState NewMatchState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.SetMatchState");
		
		AReadyOrNotGameMode_SetMatchState_Params params {};
		params.NewMatchState = NewMatchState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.RestartGame
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode::RestartGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.RestartGame");
		
		AReadyOrNotGameMode_RestartGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.RespawnPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceSpectator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::RespawnPlayer(class APlayerController* Player, bool bForceSpectator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.RespawnPlayer");
		
		AReadyOrNotGameMode_RespawnPlayer_Params params {};
		params.Player = Player;
		params.bForceSpectator = bForceSpectator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.RespawnDeadPlayersOnTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::RespawnDeadPlayersOnTeam(ETeamType Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.RespawnDeadPlayersOnTeam");
		
		AReadyOrNotGameMode_RespawnDeadPlayersOnTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.RespawnDeadPlayers
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode::RespawnDeadPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.RespawnDeadPlayers");
		
		AReadyOrNotGameMode_RespawnDeadPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.RespawnAllPlayersOnTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::RespawnAllPlayersOnTeam(ETeamType Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.RespawnAllPlayersOnTeam");
		
		AReadyOrNotGameMode_RespawnAllPlayersOnTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.RespawnAllPlayers
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode::RespawnAllPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.RespawnAllPlayers");
		
		AReadyOrNotGameMode_RespawnAllPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.RemoveDeadPlayerAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotGameMode::RemoveDeadPlayerAt(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.RemoveDeadPlayerAt");
		
		AReadyOrNotGameMode_RemoveDeadPlayerAt_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.RemoveDeadPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           InPlayerController                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotGameMode::RemoveDeadPlayer(class APlayerController* InPlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.RemoveDeadPlayer");
		
		AReadyOrNotGameMode_RemoveDeadPlayer_Params params {};
		params.InPlayerController = InPlayerController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.RefreshSession
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode::RefreshSession()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.RefreshSession");
		
		AReadyOrNotGameMode_RefreshSession_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.ProcessServerTravel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAbsolute                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::ProcessServerTravel(const class FString& URL, bool bAbsolute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.ProcessServerTravel");
		
		AReadyOrNotGameMode_ProcessServerTravel_Params params {};
		params.URL = URL;
		params.bAbsolute = bAbsolute;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.PlayerTakenDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::PlayerTakenDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.PlayerTakenDamage");
		
		AReadyOrNotGameMode_PlayerTakenDamage_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.PlayerKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::PlayerKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.PlayerKilled");
		
		AReadyOrNotGameMode_PlayerKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.PlayerFreed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACharacter*                                  Freed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  Freer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::PlayerFreed(class ACharacter* Freed, class ACharacter* Freer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.PlayerFreed");
		
		AReadyOrNotGameMode_PlayerFreed_Params params {};
		params.Freed = Freed;
		params.Freer = Freer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.PlayerDowned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DownedCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::PlayerDowned(class AReadyOrNotCharacter* DownedCharacter, class AReadyOrNotCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.PlayerDowned");
		
		AReadyOrNotGameMode_PlayerDowned_Params params {};
		params.DownedCharacter = DownedCharacter;
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.PlayerArrested
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ArrestedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::PlayerArrested(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.PlayerArrested");
		
		AReadyOrNotGameMode_PlayerArrested_Params params {};
		params.ArrestedCharacter = ArrestedCharacter;
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotGameMode.OnPlayerRespawned__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::OnPlayerRespawned__DelegateSignature(class APawn* Pawn, class APlayerController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotGameMode.OnPlayerRespawned__DelegateSignature");
		
		AReadyOrNotGameMode_OnPlayerRespawned__DelegateSignature_Params params {};
		params.Pawn = Pawn;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.OnOutOfBoundsTimeLimitEnded
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode::OnOutOfBoundsTimeLimitEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.OnOutOfBoundsTimeLimitEnded");
		
		AReadyOrNotGameMode_OnOutOfBoundsTimeLimitEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotGameMode.OnMatchStateChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMatchState                                        NewMatchState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::OnMatchStateChanged__DelegateSignature(EMatchState NewMatchState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotGameMode.OnMatchStateChanged__DelegateSignature");
		
		AReadyOrNotGameMode_OnMatchStateChanged__DelegateSignature_Params params {};
		params.NewMatchState = NewMatchState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotGameMode.OnMatchStarted__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode::OnMatchStarted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotGameMode.OnMatchStarted__DelegateSignature");
		
		AReadyOrNotGameMode_OnMatchStarted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.OnBanStatusChecked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SteamId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsBanned                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      BanReason                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsMySteamId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::OnBanStatusChecked(const class FString& SteamId, bool bIsBanned, const class FString& BanReason, bool bIsMySteamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.OnBanStatusChecked");
		
		AReadyOrNotGameMode_OnBanStatusChecked_Params params {};
		params.SteamId = SteamId;
		params.bIsBanned = bIsBanned;
		params.BanReason = BanReason;
		params.bIsMySteamId = bIsMySteamId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.NextGame
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode::NextGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.NextGame");
		
		AReadyOrNotGameMode_NextGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.KickPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           KickedPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        KickReason                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotGameMode::KickPlayer(class APlayerController* KickedPlayer, const class FText& KickReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.KickPlayer");
		
		AReadyOrNotGameMode_KickPlayer_Params params {};
		params.KickedPlayer = KickedPlayer;
		params.KickReason = KickReason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.IsTeamDead
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeArrestedAsDead                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotGameMode::IsTeamDead(ETeamType Team, bool bIncludeArrestedAsDead)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.IsTeamDead");
		
		AReadyOrNotGameMode_IsTeamDead_Params params {};
		params.Team = Team;
		params.bIncludeArrestedAsDead = bIncludeArrestedAsDead;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.GetThisPlayersStartPointByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      IncomingName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AActor* AReadyOrNotGameMode::GetThisPlayersStartPointByTag(class APlayerController* Player, const class FString& IncomingName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.GetThisPlayersStartPointByTag");
		
		AReadyOrNotGameMode_GetThisPlayersStartPointByTag_Params params {};
		params.Player = Player;
		params.IncomingName = IncomingName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.GetReadyOrNotGameState
	 * 		Flags  -> ()
	 */
	class AReadyOrNotGameState* AReadyOrNotGameMode::GetReadyOrNotGameState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.GetReadyOrNotGameState");
		
		AReadyOrNotGameMode_GetReadyOrNotGameState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.GetReadyOrNotGameSession
	 * 		Flags  -> ()
	 */
	class AReadyOrNotGameSession* AReadyOrNotGameMode::GetReadyOrNotGameSession()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.GetReadyOrNotGameSession");
		
		AReadyOrNotGameMode_GetReadyOrNotGameSession_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.GetMatchState
	 * 		Flags  -> ()
	 */
	EMatchState AReadyOrNotGameMode::GetMatchState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.GetMatchState");
		
		AReadyOrNotGameMode_GetMatchState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.GetAllPlayerCharactersInWorld
	 * 		Flags  -> ()
	 */
	TArray<class APlayerCharacter*> AReadyOrNotGameMode::GetAllPlayerCharactersInWorld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.GetAllPlayerCharactersInWorld");
		
		AReadyOrNotGameMode_GetAllPlayerCharactersInWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.DoesLevelRequireGeneration
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotGameMode::DoesLevelRequireGeneration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.DoesLevelRequireGeneration");
		
		AReadyOrNotGameMode_DoesLevelRequireGeneration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.CheckToAnnounceTeamkill
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACharacter*                                  InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::CheckToAnnounceTeamkill(class ACharacter* InstigatorCharacter, class ACharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.CheckToAnnounceTeamkill");
		
		AReadyOrNotGameMode_CheckToAnnounceTeamkill_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.AreAllPlayersDead
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotGameMode::AreAllPlayersDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.AreAllPlayersDead");
		
		AReadyOrNotGameMode_AreAllPlayersDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode.AddAbuse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Abuser                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticCharacter*                        Abused                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode::AddAbuse(class AReadyOrNotCharacter* Abuser, class ACyberneticCharacter* Abused)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode.AddAbuse");
		
		AReadyOrNotGameMode_AddAbuse_Params params {};
		params.Abuser = Abuser;
		params.Abused = Abused;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode_PVP.TimeLimitVictoryConditions
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode_PVP::TimeLimitVictoryConditions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode_PVP.TimeLimitVictoryConditions");
		
		AReadyOrNotGameMode_PVP_TimeLimitVictoryConditions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode_PVP.TimelimitReached
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode_PVP::TimelimitReached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode_PVP.TimelimitReached");
		
		AReadyOrNotGameMode_PVP_TimelimitReached_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode_PVP.RoundWonTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          WinningTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode_PVP::RoundWonTeam(ETeamType WinningTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode_PVP.RoundWonTeam");
		
		AReadyOrNotGameMode_PVP_RoundWonTeam_Params params {};
		params.WinningTeam = WinningTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode_PVP.RoundWon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AReadyOrNotPlayerState*>              WinningPlayers                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode_PVP::RoundWon(TArray<class AReadyOrNotPlayerState*> WinningPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode_PVP.RoundWon");
		
		AReadyOrNotGameMode_PVP_RoundWon_Params params {};
		params.WinningPlayers = WinningPlayers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode_PVP.RoundEnd
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode_PVP::RoundEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode_PVP.RoundEnd");
		
		AReadyOrNotGameMode_PVP_RoundEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotGameMode_PVP.OnRoundWon__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          WinningTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode_PVP::OnRoundWon__DelegateSignature(ETeamType WinningTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotGameMode_PVP.OnRoundWon__DelegateSignature");
		
		AReadyOrNotGameMode_PVP_OnRoundWon__DelegateSignature_Params params {};
		params.WinningTeam = WinningTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode_PVP.OnRoundStarted
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode_PVP::OnRoundStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode_PVP.OnRoundStarted");
		
		AReadyOrNotGameMode_PVP_OnRoundStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotGameMode_PVP.OnRoundStart__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode_PVP::OnRoundStart__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotGameMode_PVP.OnRoundStart__DelegateSignature");
		
		AReadyOrNotGameMode_PVP_OnRoundStart__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode_PVP.OnRoundEnded
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode_PVP::OnRoundEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode_PVP.OnRoundEnded");
		
		AReadyOrNotGameMode_PVP_OnRoundEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotGameMode_PVP.OnRoundEnd__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode_PVP::OnRoundEnd__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotGameMode_PVP.OnRoundEnd__DelegateSignature");
		
		AReadyOrNotGameMode_PVP_OnRoundEnd__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotGameMode_PVP.OnMatchStart__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode_PVP::OnMatchStart__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotGameMode_PVP.OnMatchStart__DelegateSignature");
		
		AReadyOrNotGameMode_PVP_OnMatchStart__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode_PVP.NextRound
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode_PVP::NextRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode_PVP.NextRound");
		
		AReadyOrNotGameMode_PVP_NextRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode_PVP.Multicast_SetWinningTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          WinningTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode_PVP::Multicast_SetWinningTeam(ETeamType WinningTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode_PVP.Multicast_SetWinningTeam");
		
		AReadyOrNotGameMode_PVP_Multicast_SetWinningTeam_Params params {};
		params.WinningTeam = WinningTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode_PVP.MatchEnd
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameMode_PVP::MatchEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode_PVP.MatchEnd");
		
		AReadyOrNotGameMode_PVP_MatchEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode_PVP.CheckRoundEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameMode_PVP::CheckRoundEnd(float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode_PVP.CheckRoundEnd");
		
		AReadyOrNotGameMode_PVP_CheckRoundEnd_Params params {};
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameMode_PVP.AnyDeathsOnWinningTeam
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotGameMode_PVP::AnyDeathsOnWinningTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameMode_PVP.AnyDeathsOnWinningTeam");
		
		AReadyOrNotGameMode_PVP_AnyDeathsOnWinningTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotGameMode_PVP.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotGameMode_PVP::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotGameMode_PVP");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AArrestAndRescueGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AArrestAndRescueGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ArrestAndRescueGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.SkipMVPScreen
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::SkipMVPScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.SkipMVPScreen");
		
		AReadyOrNotGameState_SkipMVPScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.SetTimeDilationSynced
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              TimeDilation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::SetTimeDilationSynced(float TimeDilation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.SetTimeDilationSynced");
		
		AReadyOrNotGameState_SetTimeDilationSynced_Params params {};
		params.TimeDilation = TimeDilation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.ResetReplicatedTimers
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::ResetReplicatedTimers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.ResetReplicatedTimers");
		
		AReadyOrNotGameState_ResetReplicatedTimers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveYellListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveYellListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveYellListener");
		
		AReadyOrNotGameState_RemoveYellListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveWeaponClearingListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveWeaponClearingListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveWeaponClearingListener");
		
		AReadyOrNotGameState_RemoveWeaponClearingListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveUncuffedListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveUncuffedListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveUncuffedListener");
		
		AReadyOrNotGameState_RemoveUncuffedListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveSpawnListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveSpawnListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveSpawnListener");
		
		AReadyOrNotGameState_RemoveSpawnListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveRoundEndListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveRoundEndListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveRoundEndListener");
		
		AReadyOrNotGameState_RemoveRoundEndListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveReportListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveReportListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveReportListener");
		
		AReadyOrNotGameState_RemoveReportListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveInjuryListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveInjuryListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveInjuryListener");
		
		AReadyOrNotGameState_RemoveInjuryListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveIncapacitationListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveIncapacitationListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveIncapacitationListener");
		
		AReadyOrNotGameState_RemoveIncapacitationListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveGameStartListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveGameStartListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveGameStartListener");
		
		AReadyOrNotGameState_RemoveGameStartListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveGamePreStartListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveGamePreStartListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveGamePreStartListener");
		
		AReadyOrNotGameState_RemoveGamePreStartListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveGameEndListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveGameEndListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveGameEndListener");
		
		AReadyOrNotGameState_RemoveGameEndListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveEvidenceListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveEvidenceListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveEvidenceListener");
		
		AReadyOrNotGameState_RemoveEvidenceListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveDeathListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveDeathListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveDeathListener");
		
		AReadyOrNotGameState_RemoveDeathListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.RemoveArrestListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::RemoveArrestListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.RemoveArrestListener");
		
		AReadyOrNotGameState_RemoveArrestListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.PlayerKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::PlayerKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.PlayerKilled");
		
		AReadyOrNotGameState_PlayerKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.PlayerArrested
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ArrestedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::PlayerArrested(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.PlayerArrested");
		
		AReadyOrNotGameState_PlayerArrested_Params params {};
		params.ArrestedCharacter = ArrestedCharacter;
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.OverWriteModeNameText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        newModeName                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::OverWriteModeNameText(const class FText& newModeName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.OverWriteModeNameText");
		
		AReadyOrNotGameState_OverWriteModeNameText_Params params {};
		params.newModeName = newModeName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotGameState.OnWinsUpdated__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::OnWinsUpdated__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotGameState.OnWinsUpdated__DelegateSignature");
		
		AReadyOrNotGameState_OnWinsUpdated__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotGameState.OnUpdateKillFeed__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Causer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::OnUpdateKillFeed__DelegateSignature(class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotGameState.OnUpdateKillFeed__DelegateSignature");
		
		AReadyOrNotGameState_OnUpdateKillFeed__DelegateSignature_Params params {};
		params.Causer = Causer;
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.OnSequenceStartedFunc
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ULevelSequence*                              LevelSequence                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::OnSequenceStartedFunc(class ULevelSequence* LevelSequence)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.OnSequenceStartedFunc");
		
		AReadyOrNotGameState_OnSequenceStartedFunc_Params params {};
		params.LevelSequence = LevelSequence;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotGameState.OnSequenceStarted__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ULevelSequence*                              LevelSequence                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::OnSequenceStarted__DelegateSignature(class ULevelSequence* LevelSequence)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotGameState.OnSequenceStarted__DelegateSignature");
		
		AReadyOrNotGameState_OnSequenceStarted__DelegateSignature_Params params {};
		params.LevelSequence = LevelSequence;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.OnRep_WinsUpdated
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::OnRep_WinsUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.OnRep_WinsUpdated");
		
		AReadyOrNotGameState_OnRep_WinsUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.OnRep_StreamSeed
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::OnRep_StreamSeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.OnRep_StreamSeed");
		
		AReadyOrNotGameState_OnRep_StreamSeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.OnRep_NextHost
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::OnRep_NextHost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.OnRep_NextHost");
		
		AReadyOrNotGameState_OnRep_NextHost_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.OnRep_MatchState
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::OnRep_MatchState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.OnRep_MatchState");
		
		AReadyOrNotGameState_OnRep_MatchState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.OnRep_DrawPointDataChanged
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::OnRep_DrawPointDataChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.OnRep_DrawPointDataChanged");
		
		AReadyOrNotGameState_OnRep_DrawPointDataChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.OnRep_CustomTimeDilation
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::OnRep_CustomTimeDilation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.OnRep_CustomTimeDilation");
		
		AReadyOrNotGameState_OnRep_CustomTimeDilation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.OnLoadoutFinished
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::OnLoadoutFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.OnLoadoutFinished");
		
		AReadyOrNotGameState_OnLoadoutFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotGameState.OnChatMessage__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRChatMessage                               Message                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::OnChatMessage__DelegateSignature(const struct FRChatMessage& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotGameState.OnChatMessage__DelegateSignature");
		
		AReadyOrNotGameState_OnChatMessage__DelegateSignature_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.OnAuthenticationResponse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSerialFound                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSerialValid                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      failedReason                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::OnAuthenticationResponse(bool bSuccess, bool bSerialFound, bool bSerialValid, const class FString& failedReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.OnAuthenticationResponse");
		
		AReadyOrNotGameState_OnAuthenticationResponse_Params params {};
		params.bSuccess = bSuccess;
		params.bSerialFound = bSerialFound;
		params.bSerialValid = bSerialValid;
		params.failedReason = failedReason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.OnAlphaAccessChecked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bBanned                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      BanReason                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::OnAlphaAccessChecked(bool bBanned, const class FString& BanReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.OnAlphaAccessChecked");
		
		AReadyOrNotGameState_OnAlphaAccessChecked_Params params {};
		params.bBanned = bBanned;
		params.BanReason = BanReason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_StopSequence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ULevelSequence*                              Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_StopSequence(class ULevelSequence* Sequence)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_StopSequence");
		
		AReadyOrNotGameState_Multicast_StopSequence_Params params {};
		params.Sequence = Sequence;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_PlaySequence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ULevelSequence*                              Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_PlaySequence(class ULevelSequence* Sequence)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_PlaySequence");
		
		AReadyOrNotGameState_Multicast_PlaySequence_Params params {};
		params.Sequence = Sequence;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_PlayAnnouncerForTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SpeechRowName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_PlayAnnouncerForTeam(const class FString& SpeechRowName, ETeamType TeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_PlayAnnouncerForTeam");
		
		AReadyOrNotGameState_Multicast_PlayAnnouncerForTeam_Params params {};
		params.SpeechRowName = SpeechRowName;
		params.TeamType = TeamType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnYell
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Yeller                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_OnYell(class AReadyOrNotCharacter* Yeller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnYell");
		
		AReadyOrNotGameState_Multicast_OnYell_Params params {};
		params.Yeller = Yeller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnWeaponCleared
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   WeaponActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_OnWeaponCleared(class ABaseItem* WeaponActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnWeaponCleared");
		
		AReadyOrNotGameState_Multicast_OnWeaponCleared_Params params {};
		params.WeaponActor = WeaponActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnTargetUncuffed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ArrestedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Uncuffer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_OnTargetUncuffed(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* Uncuffer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnTargetUncuffed");
		
		AReadyOrNotGameState_Multicast_OnTargetUncuffed_Params params {};
		params.ArrestedCharacter = ArrestedCharacter;
		params.Uncuffer = Uncuffer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnTargetReported
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Reporter                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ReportedTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_OnTargetReported(class AReadyOrNotCharacter* Reporter, class UObject* ReportedTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnTargetReported");
		
		AReadyOrNotGameState_Multicast_OnTargetReported_Params params {};
		params.Reporter = Reporter;
		params.ReportedTarget = ReportedTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnTargetBecameReportable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_OnTargetBecameReportable(class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnTargetBecameReportable");
		
		AReadyOrNotGameState_Multicast_OnTargetBecameReportable_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnRoundReset
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::Multicast_OnRoundReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnRoundReset");
		
		AReadyOrNotGameState_Multicast_OnRoundReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnRoundEnded
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::Multicast_OnRoundEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnRoundEnded");
		
		AReadyOrNotGameState_Multicast_OnRoundEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnGameStarted
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::Multicast_OnGameStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnGameStarted");
		
		AReadyOrNotGameState_Multicast_OnGameStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnGamePreStarted
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::Multicast_OnGamePreStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnGamePreStarted");
		
		AReadyOrNotGameState_Multicast_OnGamePreStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnGameEnded
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::Multicast_OnGameEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnGameEnded");
		
		AReadyOrNotGameState_Multicast_OnGameEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnEvidencePickedUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   EvidenceActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_OnEvidencePickedUp(class ABaseItem* EvidenceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnEvidencePickedUp");
		
		AReadyOrNotGameState_Multicast_OnEvidencePickedUp_Params params {};
		params.EvidenceActor = EvidenceActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnEvidenceDropped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   EvidenceActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_OnEvidenceDropped(class ABaseItem* EvidenceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnEvidenceDropped");
		
		AReadyOrNotGameState_Multicast_OnEvidenceDropped_Params params {};
		params.EvidenceActor = EvidenceActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnCharacterSpawned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        SpawnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_OnCharacterSpawned(class AReadyOrNotCharacter* SpawnedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnCharacterSpawned");
		
		AReadyOrNotGameState_Multicast_OnCharacterSpawned_Params params {};
		params.SpawnedCharacter = SpawnedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnCharacterInjured
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_OnCharacterInjured(class AReadyOrNotCharacter* Victim, float Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnCharacterInjured");
		
		AReadyOrNotGameState_Multicast_OnCharacterInjured_Params params {};
		params.Victim = Victim;
		params.Damage = Damage;
		params.DamageEvent = DamageEvent;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnCharacterIncapacitated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Inflictor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_OnCharacterIncapacitated(class AReadyOrNotCharacter* Victim, class AReadyOrNotCharacter* Killer, class AActor* Inflictor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnCharacterIncapacitated");
		
		AReadyOrNotGameState_Multicast_OnCharacterIncapacitated_Params params {};
		params.Victim = Victim;
		params.Killer = Killer;
		params.Inflictor = Inflictor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnCharacterDied
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Inflictor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_OnCharacterDied(class AReadyOrNotCharacter* Victim, class AReadyOrNotCharacter* Killer, class AActor* Inflictor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnCharacterDied");
		
		AReadyOrNotGameState_Multicast_OnCharacterDied_Params params {};
		params.Victim = Victim;
		params.Killer = Killer;
		params.Inflictor = Inflictor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnArrestOccurred
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ArrestedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Arrester                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_OnArrestOccurred(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* Arrester)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_OnArrestOccurred");
		
		AReadyOrNotGameState_Multicast_OnArrestOccurred_Params params {};
		params.ArrestedCharacter = ArrestedCharacter;
		params.Arrester = Arrester;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_BroadcastChatMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRChatMessage                               ChatMessage                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_BroadcastChatMessage(const struct FRChatMessage& ChatMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_BroadcastChatMessage");
		
		AReadyOrNotGameState_Multicast_BroadcastChatMessage_Params params {};
		params.ChatMessage = ChatMessage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_AnnounceTeamReinforcements
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          TeamSpawned                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Multicast_AnnounceTeamReinforcements(ETeamType TeamSpawned)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_AnnounceTeamReinforcements");
		
		AReadyOrNotGameState_Multicast_AnnounceTeamReinforcements_Params params {};
		params.TeamSpawned = TeamSpawned;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Multicast_AnnounceSuddenDeath
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::Multicast_AnnounceSuddenDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Multicast_AnnounceSuddenDeath");
		
		AReadyOrNotGameState_Multicast_AnnounceSuddenDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.LoadStartupWidgetsAfterLoadingScreen
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::LoadStartupWidgetsAfterLoadingScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.LoadStartupWidgetsAfterLoadingScreen");
		
		AReadyOrNotGameState_LoadStartupWidgetsAfterLoadingScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.IsEveryoneReady
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotGameState::IsEveryoneReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.IsEveryoneReady");
		
		AReadyOrNotGameState_IsEveryoneReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.IsAdminPlayerController
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotGameState::IsAdminPlayerController(class APlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.IsAdminPlayerController");
		
		AReadyOrNotGameState_IsAdminPlayerController_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetWinningScore
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bUsesScoring                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AReadyOrNotGameState::GetWinningScore(bool* bUsesScoring)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetWinningScore");
		
		AReadyOrNotGameState_GetWinningScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bUsesScoring != nullptr)
			*bUsesScoring = params.bUsesScoring;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetTotalMissionAbuseCount
	 * 		Flags  -> ()
	 */
	int32_t AReadyOrNotGameState::GetTotalMissionAbuseCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetTotalMissionAbuseCount");
		
		AReadyOrNotGameState_GetTotalMissionAbuseCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetTeamScore
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AReadyOrNotGameState::GetTeamScore(ETeamType Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetTeamScore");
		
		AReadyOrNotGameState_GetTeamScore_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetRemainingRounds
	 * 		Flags  -> ()
	 */
	int32_t AReadyOrNotGameState::GetRemainingRounds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetRemainingRounds");
		
		AReadyOrNotGameState_GetRemainingRounds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetPlayerStatesOnTeamOrderedByScore
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AReadyOrNotPlayerState*>              PlayerStates                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::GetPlayerStatesOnTeamOrderedByScore(ETeamType Team, TArray<class AReadyOrNotPlayerState*>* PlayerStates)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetPlayerStatesOnTeamOrderedByScore");
		
		AReadyOrNotGameState_GetPlayerStatesOnTeamOrderedByScore_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PlayerStates != nullptr)
			*PlayerStates = params.PlayerStates;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetPlayerStatesOfTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class AReadyOrNotPlayerState*> AReadyOrNotGameState::GetPlayerStatesOfTeam(ETeamType Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetPlayerStatesOfTeam");
		
		AReadyOrNotGameState_GetPlayerStatesOfTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetPlayersAvailableForVote
	 * 		Flags  -> ()
	 */
	TArray<class AReadyOrNotPlayerState*> AReadyOrNotGameState::GetPlayersAvailableForVote()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetPlayersAvailableForVote");
		
		AReadyOrNotGameState_GetPlayersAvailableForVote_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetNextMapMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Map                                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Mode                                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::GetNextMapMode(class FString* Map, class FString* Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetNextMapMode");
		
		AReadyOrNotGameState_GetNextMapMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Map != nullptr)
			*Map = params.Map;
		if (Mode != nullptr)
			*Mode = params.Mode;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetMostRecentBadAIActionReport
	 * 		Flags  -> ()
	 */
	class ABadAIAction* AReadyOrNotGameState::GetMostRecentBadAIActionReport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetMostRecentBadAIActionReport");
		
		AReadyOrNotGameState_GetMostRecentBadAIActionReport_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetMaxSwatScore
	 * 		Flags  -> ()
	 */
	int32_t AReadyOrNotGameState::GetMaxSwatScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetMaxSwatScore");
		
		AReadyOrNotGameState_GetMaxSwatScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetMaxSuspectScore
	 * 		Flags  -> ()
	 */
	int32_t AReadyOrNotGameState::GetMaxSuspectScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetMaxSuspectScore");
		
		AReadyOrNotGameState_GetMaxSuspectScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetMapURL
	 * 		Flags  -> ()
	 */
	class FString AReadyOrNotGameState::GetMapURL()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetMapURL");
		
		AReadyOrNotGameState_GetMapURL_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetGameModeSettings
	 * 		Flags  -> ()
	 */
	struct FGameModeSettings AReadyOrNotGameState::GetGameModeSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetGameModeSettings");
		
		AReadyOrNotGameState_GetGameModeSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetDeploymentStatusOfPlayers
	 * 		Flags  -> ()
	 */
	TArray<struct FDeploymentStatus> AReadyOrNotGameState::GetDeploymentStatusOfPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetDeploymentStatusOfPlayers");
		
		AReadyOrNotGameState_GetDeploymentStatusOfPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetCurrentSwatScore
	 * 		Flags  -> ()
	 */
	int32_t AReadyOrNotGameState::GetCurrentSwatScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetCurrentSwatScore");
		
		AReadyOrNotGameState_GetCurrentSwatScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetCurrentSuspectScore
	 * 		Flags  -> ()
	 */
	int32_t AReadyOrNotGameState::GetCurrentSuspectScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetCurrentSuspectScore");
		
		AReadyOrNotGameState_GetCurrentSuspectScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetCurrentProfile
	 * 		Flags  -> ()
	 */
	class UReadyOrNotProfile* AReadyOrNotGameState::GetCurrentProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetCurrentProfile");
		
		AReadyOrNotGameState_GetCurrentProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.GetControllersAvailableForVote
	 * 		Flags  -> ()
	 */
	TArray<class AReadyOrNotPlayerController*> AReadyOrNotGameState::GetControllersAvailableForVote()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.GetControllersAvailableForVote");
		
		AReadyOrNotGameState_GetControllersAvailableForVote_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.Client_BindCharacterEvents
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameState::Client_BindCharacterEvents(class APlayerCharacter* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.Client_BindCharacterEvents");
		
		AReadyOrNotGameState_Client_BindCharacterEvents_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddYellListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddYellListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddYellListener");
		
		AReadyOrNotGameState_AddYellListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddWeaponClearingListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddWeaponClearingListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddWeaponClearingListener");
		
		AReadyOrNotGameState_AddWeaponClearingListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddUncuffedListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddUncuffedListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddUncuffedListener");
		
		AReadyOrNotGameState_AddUncuffedListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddSpawnListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddSpawnListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddSpawnListener");
		
		AReadyOrNotGameState_AddSpawnListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddRoundEndListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddRoundEndListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddRoundEndListener");
		
		AReadyOrNotGameState_AddRoundEndListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddReportListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddReportListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddReportListener");
		
		AReadyOrNotGameState_AddReportListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddInjuryListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddInjuryListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddInjuryListener");
		
		AReadyOrNotGameState_AddInjuryListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddIncapacitationListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddIncapacitationListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddIncapacitationListener");
		
		AReadyOrNotGameState_AddIncapacitationListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddGameStartListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddGameStartListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddGameStartListener");
		
		AReadyOrNotGameState_AddGameStartListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddGamePreStartListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddGamePreStartListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddGamePreStartListener");
		
		AReadyOrNotGameState_AddGamePreStartListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddGameEndListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddGameEndListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddGameEndListener");
		
		AReadyOrNotGameState_AddGameEndListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddEvidenceListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddEvidenceListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddEvidenceListener");
		
		AReadyOrNotGameState_AddEvidenceListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddDeathListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddDeathListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddDeathListener");
		
		AReadyOrNotGameState_AddDeathListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameState.AddArrestListener
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameState::AddArrestListener()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameState.AddArrestListener");
		
		AReadyOrNotGameState_AddArrestListener_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotGameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotGameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotGameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AArrestAndRescueGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AArrestAndRescueGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ArrestAndRescueGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.StartActivity_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AAIController*                               Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::StartActivity_Blueprint(class AAIController* Owner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.StartActivity_Blueprint");
		
		UBaseActivity_StartActivity_Blueprint_Params params {};
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.ShouldForceStrafe
	 * 		Flags  -> ()
	 */
	bool UBaseActivity::ShouldForceStrafe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.ShouldForceStrafe");
		
		UBaseActivity_ShouldForceStrafe_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.ShouldForceNoStrafe
	 * 		Flags  -> ()
	 */
	bool UBaseActivity::ShouldForceNoStrafe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.ShouldForceNoStrafe");
		
		UBaseActivity_ShouldForceNoStrafe_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.SetLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        NewLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRequestMove                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CustomExtent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::SetLocation(const struct FCoreUObject_FVector& NewLocation, bool bRequestMove, const struct FCoreUObject_FVector& CustomExtent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.SetLocation");
		
		UBaseActivity_SetLocation_Params params {};
		params.NewLocation = NewLocation;
		params.bRequestMove = bRequestMove;
		params.CustomExtent = CustomExtent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.SetActivityName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      NewActivityName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::SetActivityName(const class FString& NewActivityName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.SetActivityName");
		
		UBaseActivity_SetActivityName_Params params {};
		params.NewActivityName = NewActivityName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.SetActivityMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bCanMove                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::SetActivityMove(bool bCanMove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.SetActivityMove");
		
		UBaseActivity_SetActivityMove_Params params {};
		params.bCanMove = bCanMove;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.ResetData
	 * 		Flags  -> ()
	 */
	void UBaseActivity::ResetData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.ResetData");
		
		UBaseActivity_ResetData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.PerformActivity_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::PerformActivity_Blueprint(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.PerformActivity_Blueprint");
		
		UBaseActivity_PerformActivity_Blueprint_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.OverrideFocalPoint_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        FocalPoint                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBaseActivity::OverrideFocalPoint_Blueprint(struct FCoreUObject_FVector* FocalPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.OverrideFocalPoint_Blueprint");
		
		UBaseActivity_OverrideFocalPoint_Blueprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (FocalPoint != nullptr)
			*FocalPoint = params.FocalPoint;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BaseActivity.OnStartActivity__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               Activity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::OnStartActivity__DelegateSignature(class UBaseActivity* Activity, class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BaseActivity.OnStartActivity__DelegateSignature");
		
		UBaseActivity_OnStartActivity__DelegateSignature_Params params {};
		params.Activity = Activity;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BaseActivity.OnSoftFinishActivity__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               Activity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::OnSoftFinishActivity__DelegateSignature(class UBaseActivity* Activity, class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BaseActivity.OnSoftFinishActivity__DelegateSignature");
		
		UBaseActivity_OnSoftFinishActivity__DelegateSignature_Params params {};
		params.Activity = Activity;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BaseActivity.OnPerformActivity__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               Activity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::OnPerformActivity__DelegateSignature(class UBaseActivity* Activity, class ACyberneticController* Controller, float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BaseActivity.OnPerformActivity__DelegateSignature");
		
		UBaseActivity_OnPerformActivity__DelegateSignature_Params params {};
		params.Activity = Activity;
		params.Controller = Controller;
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.OnKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::OnKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.OnKilled");
		
		UBaseActivity_OnKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.OnIncapacitated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        IncapacitatedCharacter                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::OnIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.OnIncapacitated");
		
		UBaseActivity_OnIncapacitated_Params params {};
		params.IncapacitatedCharacter = IncapacitatedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BaseActivity.OnFinishActivity__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               Activity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::OnFinishActivity__DelegateSignature(class UBaseActivity* Activity, class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BaseActivity.OnFinishActivity__DelegateSignature");
		
		UBaseActivity_OnFinishActivity__DelegateSignature_Params params {};
		params.Activity = Activity;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.IsProgressActivity
	 * 		Flags  -> ()
	 */
	bool UBaseActivity::IsProgressActivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.IsProgressActivity");
		
		UBaseActivity_IsProgressActivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.IsNoMoveActivity
	 * 		Flags  -> ()
	 */
	bool UBaseActivity::IsNoMoveActivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.IsNoMoveActivity");
		
		UBaseActivity_IsNoMoveActivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.IsActivitySoftComplete
	 * 		Flags  -> ()
	 */
	bool UBaseActivity::IsActivitySoftComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.IsActivitySoftComplete");
		
		UBaseActivity_IsActivitySoftComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.IsActivityPaused
	 * 		Flags  -> ()
	 */
	bool UBaseActivity::IsActivityPaused()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.IsActivityPaused");
		
		UBaseActivity_IsActivityPaused_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.IsActivityInitialized
	 * 		Flags  -> ()
	 */
	bool UBaseActivity::IsActivityInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.IsActivityInitialized");
		
		UBaseActivity_IsActivityInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.IsActivityComplete
	 * 		Flags  -> ()
	 */
	bool UBaseActivity::IsActivityComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.IsActivityComplete");
		
		UBaseActivity_IsActivityComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.HasStartedActivity
	 * 		Flags  -> ()
	 */
	bool UBaseActivity::HasStartedActivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.HasStartedActivity");
		
		UBaseActivity_HasStartedActivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.HasReachedLocation_AsPercentage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        StartLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Percentage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBaseActivity::HasReachedLocation_AsPercentage(const struct FCoreUObject_FVector& StartLocation, float Percentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.HasReachedLocation_AsPercentage");
		
		UBaseActivity_HasReachedLocation_AsPercentage_Params params {};
		params.StartLocation = StartLocation;
		params.Percentage = Percentage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.HasReachedLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Tolerance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBaseActivity::HasReachedLocation(float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.HasReachedLocation");
		
		UBaseActivity_HasReachedLocation_Params params {};
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.GetOwningController
	 * 		Flags  -> ()
	 */
	class ACyberneticController* UBaseActivity::GetOwningController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.GetOwningController");
		
		UBaseActivity_GetOwningController_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.GetLocation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector UBaseActivity::GetLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.GetLocation");
		
		UBaseActivity_GetLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.GetDistanceToLocation
	 * 		Flags  -> ()
	 */
	float UBaseActivity::GetDistanceToLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.GetDistanceToLocation");
		
		UBaseActivity_GetDistanceToLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.GetCharacter
	 * 		Flags  -> ()
	 */
	class ACyberneticCharacter* UBaseActivity::GetCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.GetCharacter");
		
		UBaseActivity_GetCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.GetActiveStateUptime
	 * 		Flags  -> ()
	 */
	float UBaseActivity::GetActiveStateUptime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.GetActiveStateUptime");
		
		UBaseActivity_GetActiveStateUptime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.GetActiveStateName
	 * 		Flags  -> ()
	 */
	class FString UBaseActivity::GetActiveStateName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.GetActiveStateName");
		
		UBaseActivity_GetActiveStateName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.GetActiveStateID
	 * 		Flags  -> ()
	 */
	int32_t UBaseActivity::GetActiveStateID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.GetActiveStateID");
		
		UBaseActivity_GetActiveStateID_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.FinishedActivity_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::FinishedActivity_Blueprint(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.FinishedActivity_Blueprint");
		
		UBaseActivity_FinishedActivity_Blueprint_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.EquipWeapon
	 * 		Flags  -> ()
	 */
	void UBaseActivity::EquipWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.EquipWeapon");
		
		UBaseActivity_EquipWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.EquipItemOfClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      InItemClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::EquipItemOfClass(class UClass* InItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.EquipItemOfClass");
		
		UBaseActivity_EquipItemOfClass_Params params {};
		params.InItemClass = InItemClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.EquipItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      InItemCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseActivity::EquipItem(EItemCategory InItemCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.EquipItem");
		
		UBaseActivity_EquipItem_Params params {};
		params.InItemCategory = InItemCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.CanOverrideActivity
	 * 		Flags  -> ()
	 */
	bool UBaseActivity::CanOverrideActivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.CanOverrideActivity");
		
		UBaseActivity_CanOverrideActivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseActivity.CanBePushed
	 * 		Flags  -> ()
	 */
	bool UBaseActivity::CanBePushed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseActivity.CanBePushed");
		
		UBaseActivity_CanBePushed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.HasTeamReachedPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Tolerance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTeamBaseActivity::HasTeamReachedPosition(float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.HasTeamReachedPosition");
		
		UTeamBaseActivity_HasTeamReachedPosition_Params params {};
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.HasSquadmateReachedLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     SquadPosition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Tolerance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTeamBaseActivity::HasSquadmateReachedLocation(ESquadPosition SquadPosition, float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.HasSquadmateReachedLocation");
		
		UTeamBaseActivity_HasSquadmateReachedLocation_Params params {};
		params.SquadPosition = SquadPosition;
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.HasAnySquadmateGotLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        TestLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Tolerance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTeamBaseActivity::HasAnySquadmateGotLocation(const struct FCoreUObject_FVector& TestLocation, float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.HasAnySquadmateGotLocation");
		
		UTeamBaseActivity_HasAnySquadmateGotLocation_Params params {};
		params.TestLocation = TestLocation;
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetSquadPositionHasReachedDestination
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     SquadPosition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTeamBaseActivity::GetSquadPositionHasReachedDestination(ESquadPosition SquadPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetSquadPositionHasReachedDestination");
		
		UTeamBaseActivity_GetSquadPositionHasReachedDestination_Params params {};
		params.SquadPosition = SquadPosition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetSquadPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOnlyOverride                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ESquadPosition UTeamBaseActivity::GetSquadPosition(bool bOnlyOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetSquadPosition");
		
		UTeamBaseActivity_GetSquadPosition_Params params {};
		params.bOnlyOverride = bOnlyOverride;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetSquadLeader
	 * 		Flags  -> ()
	 */
	class AReadyOrNotCharacter* UTeamBaseActivity::GetSquadLeader()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetSquadLeader");
		
		UTeamBaseActivity_GetSquadLeader_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetLocationOfCharacterAtSquadPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector UTeamBaseActivity::GetLocationOfCharacterAtSquadPosition(ESquadPosition A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetLocationOfCharacterAtSquadPosition");
		
		UTeamBaseActivity_GetLocationOfCharacterAtSquadPosition_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetDistanceToDestinationForSquadPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     SquadPosition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UTeamBaseActivity::GetDistanceToDestinationForSquadPosition(ESquadPosition SquadPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetDistanceToDestinationForSquadPosition");
		
		UTeamBaseActivity_GetDistanceToDestinationForSquadPosition_Params params {};
		params.SquadPosition = SquadPosition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetDistanceToCommandLocationForSquadPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UTeamBaseActivity::GetDistanceToCommandLocationForSquadPosition(ESquadPosition A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetDistanceToCommandLocationForSquadPosition");
		
		UTeamBaseActivity_GetDistanceToCommandLocationForSquadPosition_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetDistanceToCommandLocation
	 * 		Flags  -> ()
	 */
	float UTeamBaseActivity::GetDistanceToCommandLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetDistanceToCommandLocation");
		
		UTeamBaseActivity_GetDistanceToCommandLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetDistanceBetweenSquadmates
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESquadPosition                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UTeamBaseActivity::GetDistanceBetweenSquadmates(ESquadPosition A, ESquadPosition B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetDistanceBetweenSquadmates");
		
		UTeamBaseActivity_GetDistanceBetweenSquadmates_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetDestinationLocationAtSquadPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector UTeamBaseActivity::GetDestinationLocationAtSquadPosition(ESquadPosition A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetDestinationLocationAtSquadPosition");
		
		UTeamBaseActivity_GetDestinationLocationAtSquadPosition_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetCommandTeam
	 * 		Flags  -> ()
	 */
	ETeamType UTeamBaseActivity::GetCommandTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetCommandTeam");
		
		UTeamBaseActivity_GetCommandTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetCommandNormal
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector UTeamBaseActivity::GetCommandNormal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetCommandNormal");
		
		UTeamBaseActivity_GetCommandNormal_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetCommandLocation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector UTeamBaseActivity::GetCommandLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetCommandLocation");
		
		UTeamBaseActivity_GetCommandLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetCharacterClosestToLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        TestLocation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ACyberneticCharacter* UTeamBaseActivity::GetCharacterClosestToLocation(const struct FCoreUObject_FVector& TestLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetCharacterClosestToLocation");
		
		UTeamBaseActivity_GetCharacterClosestToLocation_Params params {};
		params.TestLocation = TestLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetCharacterClosestToCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ACyberneticCharacter* UTeamBaseActivity::GetCharacterClosestToCharacter(class ACyberneticCharacter* InCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetCharacterClosestToCharacter");
		
		UTeamBaseActivity_GetCharacterClosestToCharacter_Params params {};
		params.InCharacter = InCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBaseActivity.GetCharacterAtSquadPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     SquadPosition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ACyberneticCharacter* UTeamBaseActivity::GetCharacterAtSquadPosition(ESquadPosition SquadPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBaseActivity.GetCharacterAtSquadPosition");
		
		UTeamBaseActivity_GetCharacterAtSquadPosition_Params params {};
		params.SquadPosition = SquadPosition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamBaseActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamBaseActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamBaseActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArrestSuspectActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArrestSuspectActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ArrestSuspectActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ArrestTargetActivity.TickMoveToStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UArrestTargetActivity::TickMoveToStage(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ArrestTargetActivity.TickMoveToStage");
		
		UArrestTargetActivity_TickMoveToStage_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ArrestTargetActivity.TickArrestStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UArrestTargetActivity::TickArrestStage(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ArrestTargetActivity.TickArrestStage");
		
		UArrestTargetActivity_TickArrestStage_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ArrestTargetActivity.OnArresterKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UArrestTargetActivity::OnArresterKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ArrestTargetActivity.OnArresterKilled");
		
		UArrestTargetActivity_OnArresterKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ArrestTargetActivity.EnterMoveToStage
	 * 		Flags  -> ()
	 */
	void UArrestTargetActivity::EnterMoveToStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ArrestTargetActivity.EnterMoveToStage");
		
		UArrestTargetActivity_EnterMoveToStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ArrestTargetActivity.EnterArrestStage
	 * 		Flags  -> ()
	 */
	void UArrestTargetActivity::EnterArrestStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ArrestTargetActivity.EnterArrestStage");
		
		UArrestTargetActivity_EnterArrestStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ArrestTargetActivity.CanArrest
	 * 		Flags  -> ()
	 */
	bool UArrestTargetActivity::CanArrest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ArrestTargetActivity.CanArrest");
		
		UArrestTargetActivity_CanArrest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArrestTargetActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArrestTargetActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ArrestTargetActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Objective.TickObjective_BP
	 * 		Flags  -> ()
	 */
	void AObjective::TickObjective_BP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Objective.TickObjective_BP");
		
		AObjective_TickObjective_BP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Objective.OnObjectiveFailed
	 * 		Flags  -> ()
	 */
	void AObjective::OnObjectiveFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Objective.OnObjectiveFailed");
		
		AObjective_OnObjectiveFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Objective.OnObjectiveCreated
	 * 		Flags  -> ()
	 */
	void AObjective::OnObjectiveCreated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Objective.OnObjectiveCreated");
		
		AObjective_OnObjectiveCreated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Objective.OnObjectiveCompleted
	 * 		Flags  -> ()
	 */
	void AObjective::OnObjectiveCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Objective.OnObjectiveCompleted");
		
		AObjective_OnObjectiveCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Objective.ObjectiveFailed
	 * 		Flags  -> ()
	 */
	void AObjective::ObjectiveFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Objective.ObjectiveFailed");
		
		AObjective_ObjectiveFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Objective.ObjectiveCompleted
	 * 		Flags  -> ()
	 */
	void AObjective::ObjectiveCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Objective.ObjectiveCompleted");
		
		AObjective_ObjectiveCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Objective.IsObjectiveInProgress
	 * 		Flags  -> ()
	 */
	bool AObjective::IsObjectiveInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Objective.IsObjectiveInProgress");
		
		AObjective_IsObjectiveInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Objective.IsObjectiveFailed
	 * 		Flags  -> ()
	 */
	bool AObjective::IsObjectiveFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Objective.IsObjectiveFailed");
		
		AObjective_IsObjectiveFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Objective.IsObjectiveCompleted
	 * 		Flags  -> ()
	 */
	bool AObjective::IsObjectiveCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Objective.IsObjectiveCompleted");
		
		AObjective_IsObjectiveCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Objective.GetObjectiveStatus
	 * 		Flags  -> ()
	 */
	EObjectiveStatus AObjective::GetObjectiveStatus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Objective.GetObjectiveStatus");
		
		AObjective_GetObjectiveStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AObjective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AObjective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Objective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AArrestXSuspects.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AArrestXSuspects::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ArrestXSuspects");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ASequenceInteraction.OnSequencerFinished
	 * 		Flags  -> ()
	 */
	void AASequenceInteraction::OnSequencerFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ASequenceInteraction.OnSequencerFinished");
		
		AASequenceInteraction_OnSequencerFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ASequenceInteraction.OnBoxOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AASequenceInteraction::OnBoxOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ASequenceInteraction.OnBoxOverlap");
		
		AASequenceInteraction_OnBoxOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ASequenceInteraction.OnBoxEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AASequenceInteraction::OnBoxEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ASequenceInteraction.OnBoxEndOverlap");
		
		AASequenceInteraction_OnBoxEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AASequenceInteraction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AASequenceInteraction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ASequenceInteraction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedWidget
	 * 		Flags  -> ()
	 */
	class UClass* UAsyncLoader::GetLazyLoadedWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedWidget");
		
		UAsyncLoader_GetLazyLoadedWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedWeapon
	 * 		Flags  -> ()
	 */
	class UClass* UAsyncLoader::GetLazyLoadedWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedWeapon");
		
		UAsyncLoader_GetLazyLoadedWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedSoundCue
	 * 		Flags  -> ()
	 */
	class USoundCue* UAsyncLoader::GetLazyLoadedSoundCue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedSoundCue");
		
		UAsyncLoader_GetLazyLoadedSoundCue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedSkeletalMesh
	 * 		Flags  -> ()
	 */
	class USkeletalMesh* UAsyncLoader::GetLazyLoadedSkeletalMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedSkeletalMesh");
		
		UAsyncLoader_GetLazyLoadedSkeletalMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedReadyOrNotGameModeArray
	 * 		Flags  -> ()
	 */
	TArray<class UClass*> UAsyncLoader::GetLazyLoadedReadyOrNotGameModeArray()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedReadyOrNotGameModeArray");
		
		UAsyncLoader_GetLazyLoadedReadyOrNotGameModeArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedParticleSystem
	 * 		Flags  -> ()
	 */
	class UParticleSystem* UAsyncLoader::GetLazyLoadedParticleSystem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedParticleSystem");
		
		UAsyncLoader_GetLazyLoadedParticleSystem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedObject
	 * 		Flags  -> ()
	 */
	class UObject* UAsyncLoader::GetLazyLoadedObject()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedObject");
		
		UAsyncLoader_GetLazyLoadedObject_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedMesh
	 * 		Flags  -> ()
	 */
	class UStaticMesh* UAsyncLoader::GetLazyLoadedMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedMesh");
		
		UAsyncLoader_GetLazyLoadedMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedMaterialInstance
	 * 		Flags  -> ()
	 */
	class UMaterialInstance* UAsyncLoader::GetLazyLoadedMaterialInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedMaterialInstance");
		
		UAsyncLoader_GetLazyLoadedMaterialInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedItem
	 * 		Flags  -> ()
	 */
	class UClass* UAsyncLoader::GetLazyLoadedItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedItem");
		
		UAsyncLoader_GetLazyLoadedItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedImage
	 * 		Flags  -> ()
	 */
	class UTexture2D* UAsyncLoader::GetLazyLoadedImage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedImage");
		
		UAsyncLoader_GetLazyLoadedImage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedClassArray
	 * 		Flags  -> ()
	 */
	TArray<class UClass*> UAsyncLoader::GetLazyLoadedClassArray()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedClassArray");
		
		UAsyncLoader_GetLazyLoadedClassArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedClass
	 * 		Flags  -> ()
	 */
	class UClass* UAsyncLoader::GetLazyLoadedClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedClass");
		
		UAsyncLoader_GetLazyLoadedClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedAnimSequence
	 * 		Flags  -> ()
	 */
	class UAnimSequence* UAsyncLoader::GetLazyLoadedAnimSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedAnimSequence");
		
		UAsyncLoader_GetLazyLoadedAnimSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.AsyncLoader.GetLazyLoadedAnimMontage
	 * 		Flags  -> ()
	 */
	class UAnimMontage* UAsyncLoader::GetLazyLoadedAnimMontage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.AsyncLoader.GetLazyLoadedAnimMontage");
		
		UAsyncLoader_GetLazyLoadedAnimMontage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAsyncLoader.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAsyncLoader::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.AsyncLoader");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BadAIAction.ReportBadAIAction
	 * 		Flags  -> ()
	 */
	void ABadAIAction::ReportBadAIAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BadAIAction.ReportBadAIAction");
		
		ABadAIAction_ReportBadAIAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BadAIAction.Report
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bReportToLog                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDrawString                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABadAIAction::Report(bool bReportToLog, bool bDrawString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BadAIAction.Report");
		
		ABadAIAction_Report_Params params {};
		params.bReportToLog = bReportToLog;
		params.bDrawString = bDrawString;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BadAIAction.RemoveReport
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bReportToLog                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDrawString                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABadAIAction::RemoveReport(bool bReportToLog, bool bDrawString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BadAIAction.RemoveReport");
		
		ABadAIAction_RemoveReport_Params params {};
		params.bReportToLog = bReportToLog;
		params.bDrawString = bDrawString;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BadAIAction.RemoveBadAIAction
	 * 		Flags  -> ()
	 */
	void ABadAIAction::RemoveBadAIAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BadAIAction.RemoveBadAIAction");
		
		ABadAIAction_RemoveBadAIAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BadAIAction.AddNote
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        InSummary                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        InDescription                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ABadAIAction::AddNote(const class FText& InSummary, const class FText& InDescription)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BadAIAction.AddNote");
		
		ABadAIAction_AddNote_Params params {};
		params.InSummary = InSummary;
		params.InDescription = InDescription;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABadAIAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABadAIAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BadAIAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.StunTick
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::StunTick(EStunType StunType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.StunTick");
		
		ABaseItem_StunTick_Params params {};
		params.StunType = StunType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.StunnedWhileEquipped
	 * 		Flags  -> ()
	 */
	void ABaseItem::StunnedWhileEquipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.StunnedWhileEquipped");
		
		ABaseItem_StunnedWhileEquipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.StopTPMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::StopTPMontage(class UAnimMontage* AnimMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.StopTPMontage");
		
		ABaseItem_StopTPMontage_Params params {};
		params.AnimMontage = AnimMontage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.StopFPMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::StopFPMontage(class UAnimMontage* AnimMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.StopFPMontage");
		
		ABaseItem_StopFPMontage_Params params {};
		params.AnimMontage = AnimMontage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.ShouldHideInPictureInPictureScopes
	 * 		Flags  -> ()
	 */
	bool ABaseItem::ShouldHideInPictureInPictureScopes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.ShouldHideInPictureInPictureScopes");
		
		ABaseItem_ShouldHideInPictureInPictureScopes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.SetupBaseEvents
	 * 		Flags  -> ()
	 */
	void ABaseItem::SetupBaseEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.SetupBaseEvents");
		
		ABaseItem_SetupBaseEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.Server_SetMasterPoseComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::Server_SetMasterPoseComponent(class USkeletalMeshComponent* Mesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.Server_SetMasterPoseComponent");
		
		ABaseItem_Server_SetMasterPoseComponent_Params params {};
		params.Mesh = Mesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.Server_PlayTPMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                NewMontage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::Server_PlayTPMontage(class UAnimMontage* NewMontage, float PlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.Server_PlayTPMontage");
		
		ABaseItem_Server_PlayTPMontage_Params params {};
		params.NewMontage = NewMontage;
		params.PlayRate = PlayRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.Server_ApplyPointDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        HitFromDirection                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::Server_ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, const struct FCoreUObject_FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, class UClass* DamageTypeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.Server_ApplyPointDamage");
		
		ABaseItem_Server_ApplyPointDamage_Params params {};
		params.DamagedActor = DamagedActor;
		params.BaseDamage = BaseDamage;
		params.HitFromDirection = HitFromDirection;
		params.HitInfo = HitInfo;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageTypeClass = DamageTypeClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.PlayWeaponCleaning
	 * 		Flags  -> ()
	 */
	void ABaseItem::PlayWeaponCleaning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.PlayWeaponCleaning");
		
		ABaseItem_PlayWeaponCleaning_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.PlayTPMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                NewMontage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::PlayTPMontage(class UAnimMontage* NewMontage, float PlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.PlayTPMontage");
		
		ABaseItem_PlayTPMontage_Params params {};
		params.NewMontage = NewMontage;
		params.PlayRate = PlayRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.PlayFPMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                NewMontage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::PlayFPMontage(class UAnimMontage* NewMontage, float PlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.PlayFPMontage");
		
		ABaseItem_PlayFPMontage_Params params {};
		params.NewMontage = NewMontage;
		params.PlayRate = PlayRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.PlayFMODAudio
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFMODEvent*                                  Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::PlayFMODAudio(class UFMODEvent* Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.PlayFMODAudio");
		
		ABaseItem_PlayFMODAudio_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.PlayDraw
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bDrawFirst                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ABaseItem::PlayDraw(bool bDrawFirst)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.PlayDraw");
		
		ABaseItem_PlayDraw_Params params {};
		params.bDrawFirst = bDrawFirst;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.PlayDoorPushAnimation
	 * 		Flags  -> ()
	 */
	void ABaseItem::PlayDoorPushAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.PlayDoorPushAnimation");
		
		ABaseItem_PlayDoorPushAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.PlayButtonPushAnimation
	 * 		Flags  -> ()
	 */
	void ABaseItem::PlayButtonPushAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.PlayButtonPushAnimation");
		
		ABaseItem_PlayButtonPushAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.OnRep_MasterPoseComponent
	 * 		Flags  -> ()
	 */
	void ABaseItem::OnRep_MasterPoseComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.OnRep_MasterPoseComponent");
		
		ABaseItem_OnRep_MasterPoseComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.OnRep_IsDropping
	 * 		Flags  -> ()
	 */
	void ABaseItem::OnRep_IsDropping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.OnRep_IsDropping");
		
		ABaseItem_OnRep_IsDropping_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.OnRep_AttachmentRep
	 * 		Flags  -> ()
	 */
	void ABaseItem::OnRep_AttachmentRep()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.OnRep_AttachmentRep");
		
		ABaseItem_OnRep_AttachmentRep_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.OnPhysicsImpact
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::OnPhysicsImpact(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.OnPhysicsImpact");
		
		ABaseItem_OnPhysicsImpact_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.OnOwnerPossessed
	 * 		Flags  -> ()
	 */
	void ABaseItem::OnOwnerPossessed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.OnOwnerPossessed");
		
		ABaseItem_OnOwnerPossessed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.OnMeshComponentHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::OnMeshComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.OnMeshComponentHit");
		
		ABaseItem_OnMeshComponentHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.OnItemUsed
	 * 		Flags  -> ()
	 */
	void ABaseItem::OnItemUsed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.OnItemUsed");
		
		ABaseItem_OnItemUsed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.OnItemUseComplete
	 * 		Flags  -> ()
	 */
	void ABaseItem::OnItemUseComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.OnItemUseComplete");
		
		ABaseItem_OnItemUseComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.OnItemPrimaryUseEnd
	 * 		Flags  -> ()
	 */
	void ABaseItem::OnItemPrimaryUseEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.OnItemPrimaryUseEnd");
		
		ABaseItem_OnItemPrimaryUseEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.OnItemPrimaryUse
	 * 		Flags  -> ()
	 */
	void ABaseItem::OnItemPrimaryUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.OnItemPrimaryUse");
		
		ABaseItem_OnItemPrimaryUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.OnItemEndUse
	 * 		Flags  -> ()
	 */
	void ABaseItem::OnItemEndUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.OnItemEndUse");
		
		ABaseItem_OnItemEndUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BaseItem.OnItemAttachmentsChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemAttachment                                    AttachmentChanged                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::OnItemAttachmentsChanged__DelegateSignature(EItemAttachment AttachmentChanged)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BaseItem.OnItemAttachmentsChanged__DelegateSignature");
		
		ABaseItem_OnItemAttachmentsChanged__DelegateSignature_Params params {};
		params.AttachmentChanged = AttachmentChanged;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BaseItem.OnEvidenceCollected__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ABaseItem::OnEvidenceCollected__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BaseItem.OnEvidenceCollected__DelegateSignature");
		
		ABaseItem_OnEvidenceCollected__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.NextFireMode
	 * 		Flags  -> ()
	 */
	void ABaseItem::NextFireMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.NextFireMode");
		
		ABaseItem_NextFireMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.Multicast_PlayTPMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                NewMontage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::Multicast_PlayTPMontage(class UAnimMontage* NewMontage, float PlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.Multicast_PlayTPMontage");
		
		ABaseItem_Multicast_PlayTPMontage_Params params {};
		params.NewMontage = NewMontage;
		params.PlayRate = PlayRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.Multicast_MarkAsEvidence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bMarkAsEvidence                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::Multicast_MarkAsEvidence(bool bMarkAsEvidence)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.Multicast_MarkAsEvidence");
		
		ABaseItem_Multicast_MarkAsEvidence_Params params {};
		params.bMarkAsEvidence = bMarkAsEvidence;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.MarkAsEvidence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bMarkAsEvidence                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::MarkAsEvidence(bool bMarkAsEvidence)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.MarkAsEvidence");
		
		ABaseItem_MarkAsEvidence_Params params {};
		params.bMarkAsEvidence = bMarkAsEvidence;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.LastStunTick
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::LastStunTick(EStunType StunType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.LastStunTick");
		
		ABaseItem_LastStunTick_Params params {};
		params.StunType = StunType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.IsPlayingStunnedEndAnimation
	 * 		Flags  -> ()
	 */
	bool ABaseItem::IsPlayingStunnedEndAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.IsPlayingStunnedEndAnimation");
		
		ABaseItem_IsPlayingStunnedEndAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.IsPlayingStunnedAnimation
	 * 		Flags  -> ()
	 */
	bool ABaseItem::IsPlayingStunnedAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.IsPlayingStunnedAnimation");
		
		ABaseItem_IsPlayingStunnedAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.IsMontagePlaying
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeFP                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeTP                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ABaseItem::IsMontagePlaying(class UAnimMontage* Montage, bool bIncludeFP, bool bIncludeTP)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.IsMontagePlaying");
		
		ABaseItem_IsMontagePlaying_Params params {};
		params.Montage = Montage;
		params.bIncludeFP = bIncludeFP;
		params.bIncludeTP = bIncludeTP;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.IsLocallyControlled
	 * 		Flags  -> ()
	 */
	bool ABaseItem::IsLocallyControlled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.IsLocallyControlled");
		
		ABaseItem_IsLocallyControlled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.IsEquipped
	 * 		Flags  -> ()
	 */
	bool ABaseItem::IsEquipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.IsEquipped");
		
		ABaseItem_IsEquipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.IsDoorPushAnimationPlaying
	 * 		Flags  -> ()
	 */
	bool ABaseItem::IsDoorPushAnimationPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.IsDoorPushAnimationPlaying");
		
		ABaseItem_IsDoorPushAnimationPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.IsDepleted
	 * 		Flags  -> ()
	 */
	bool ABaseItem::IsDepleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.IsDepleted");
		
		ABaseItem_IsDepleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.IsCurrentlyReloading
	 * 		Flags  -> ()
	 */
	bool ABaseItem::IsCurrentlyReloading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.IsCurrentlyReloading");
		
		ABaseItem_IsCurrentlyReloading_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.IsCollidesWhileNotEquipped
	 * 		Flags  -> ()
	 */
	bool ABaseItem::IsCollidesWhileNotEquipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.IsCollidesWhileNotEquipped");
		
		ABaseItem_IsCollidesWhileNotEquipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.IsButtonPushAnimationPlaying
	 * 		Flags  -> ()
	 */
	bool ABaseItem::IsButtonPushAnimationPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.IsButtonPushAnimationPlaying");
		
		ABaseItem_IsButtonPushAnimationPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.IsBlockingAnimationPlaying
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<EBlockingAnimationExclusion>                Exclusions                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool ABaseItem::IsBlockingAnimationPlaying(TArray<EBlockingAnimationExclusion> Exclusions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.IsBlockingAnimationPlaying");
		
		ABaseItem_IsBlockingAnimationPlaying_Params params {};
		params.Exclusions = Exclusions;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.InterpToTargetScale
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        NewScale                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::InterpToTargetScale(const struct FCoreUObject_FVector& NewScale, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.InterpToTargetScale");
		
		ABaseItem_InterpToTargetScale_Params params {};
		params.NewScale = NewScale;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.HasDoorPushAnimation
	 * 		Flags  -> ()
	 */
	bool ABaseItem::HasDoorPushAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.HasDoorPushAnimation");
		
		ABaseItem_HasDoorPushAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.HasButtonPushAnimation
	 * 		Flags  -> ()
	 */
	bool ABaseItem::HasButtonPushAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.HasButtonPushAnimation");
		
		ABaseItem_HasButtonPushAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.GetWeight
	 * 		Flags  -> ()
	 */
	float ABaseItem::GetWeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.GetWeight");
		
		ABaseItem_GetWeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.GetLowReadyRange
	 * 		Flags  -> ()
	 */
	float ABaseItem::GetLowReadyRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.GetLowReadyRange");
		
		ABaseItem_GetLowReadyRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.GetItemMesh
	 * 		Flags  -> ()
	 */
	class USkeletalMeshComponent* ABaseItem::GetItemMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.GetItemMesh");
		
		ABaseItem_GetItemMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.GetEquipSocket
	 * 		Flags  -> ()
	 */
	class FName ABaseItem::GetEquipSocket()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.GetEquipSocket");
		
		ABaseItem_GetEquipSocket_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.GetCurrentTPMontage
	 * 		Flags  -> ()
	 */
	class UAnimMontage* ABaseItem::GetCurrentTPMontage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.GetCurrentTPMontage");
		
		ABaseItem_GetCurrentTPMontage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.GetCurrentFPMontage
	 * 		Flags  -> ()
	 */
	class UAnimMontage* ABaseItem::GetCurrentFPMontage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.GetCurrentFPMontage");
		
		ABaseItem_GetCurrentFPMontage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.EndStunWhileEquipped
	 * 		Flags  -> ()
	 */
	void ABaseItem::EndStunWhileEquipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.EndStunWhileEquipped");
		
		ABaseItem_EndStunWhileEquipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.EnableOutline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActorOutlineType                                  OutlineType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::EnableOutline(EActorOutlineType OutlineType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.EnableOutline");
		
		ABaseItem_EnableOutline_Params params {};
		params.OutlineType = OutlineType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.DisableOutline
	 * 		Flags  -> ()
	 */
	void ABaseItem::DisableOutline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.DisableOutline");
		
		ABaseItem_DisableOutline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.DisableOrEnableAnimation
	 * 		Flags  -> ()
	 */
	void ABaseItem::DisableOrEnableAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.DisableOrEnableAnimation");
		
		ABaseItem_DisableOrEnableAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.DetachStatic
	 * 		Flags  -> ()
	 */
	void ABaseItem::DetachStatic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.DetachStatic");
		
		ABaseItem_DetachStatic_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.ContainsItemCategory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      TestCategory                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ABaseItem::ContainsItemCategory(EItemCategory TestCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.ContainsItemCategory");
		
		ABaseItem_ContainsItemCategory_Params params {};
		params.TestCategory = TestCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.ClientPlayDraw
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bDrawFirst                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::ClientPlayDraw(bool bDrawFirst)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.ClientPlayDraw");
		
		ABaseItem_ClientPlayDraw_Params params {};
		params.bDrawFirst = bDrawFirst;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.Client_StopItemAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FWeaponAnim                                 InWeaponAnim                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyTP                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::Client_StopItemAnimation(const struct FWeaponAnim& InWeaponAnim, bool bOnlyTP)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.Client_StopItemAnimation");
		
		ABaseItem_Client_StopItemAnimation_Params params {};
		params.InWeaponAnim = InWeaponAnim;
		params.bOnlyTP = bOnlyTP;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.Client_SetFPModelVisibility
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bVisibility                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::Client_SetFPModelVisibility(bool bVisibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.Client_SetFPModelVisibility");
		
		ABaseItem_Client_SetFPModelVisibility_Params params {};
		params.bVisibility = bVisibility;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.Client_PlayItemAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FWeaponAnim                                 InWeaponAnim                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestartIfAlreadyPlaying                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyLocal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyTP                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::Client_PlayItemAnimation(const struct FWeaponAnim& InWeaponAnim, bool bRestartIfAlreadyPlaying, bool bOnlyLocal, bool bOnlyTP)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.Client_PlayItemAnimation");
		
		ABaseItem_Client_PlayItemAnimation_Params params {};
		params.InWeaponAnim = InWeaponAnim;
		params.bRestartIfAlreadyPlaying = bRestartIfAlreadyPlaying;
		params.bOnlyLocal = bOnlyLocal;
		params.bOnlyTP = bOnlyTP;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.Client_PlayFPMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                NewMontage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::Client_PlayFPMontage(class UAnimMontage* NewMontage, float PlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.Client_PlayFPMontage");
		
		ABaseItem_Client_PlayFPMontage_Params params {};
		params.NewMontage = NewMontage;
		params.PlayRate = PlayRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.Client_OnItemPickedUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      NewOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEquipped                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::Client_OnItemPickedUp(class AActor* NewOwner, bool bEquipped)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.Client_OnItemPickedUp");
		
		ABaseItem_Client_OnItemPickedUp_Params params {};
		params.NewOwner = NewOwner;
		params.bEquipped = bEquipped;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.CanShowActionSlot1
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ABaseItem::CanShowActionSlot1(class AReadyOrNotCharacter* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.CanShowActionSlot1");
		
		ABaseItem_CanShowActionSlot1_Params params {};
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.CanEquip
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ToCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ABaseItem::CanEquip(class AReadyOrNotCharacter* ToCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.CanEquip");
		
		ABaseItem_CanEquip_Params params {};
		params.ToCharacter = ToCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.CancelCurrentReloadAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bCancel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::CancelCurrentReloadAction(bool bCancel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.CancelCurrentReloadAction");
		
		ABaseItem_CancelCurrentReloadAction_Params params {};
		params.bCancel = bCancel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.BP_AttachmentRep
	 * 		Flags  -> ()
	 */
	void ABaseItem::BP_AttachmentRep()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.BP_AttachmentRep");
		
		ABaseItem_BP_AttachmentRep_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.AttachStatic
	 * 		Flags  -> ()
	 */
	void ABaseItem::AttachStatic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.AttachStatic");
		
		ABaseItem_AttachStatic_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseItem.ApplyLookupData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bUpdateDefaultObject                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseItem::ApplyLookupData(bool bUpdateDefaultObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseItem.ApplyLookupData");
		
		ABaseItem_ApplyLookupData_Params params {};
		params.bUpdateDefaultObject = bUpdateDefaultObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABaseItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABaseItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABaseDeployableGear.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABaseDeployableGear::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseDeployableGear");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BallisticsShield.Server_SetLowered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldLower                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABallisticsShield::Server_SetLowered(bool bShouldLower)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BallisticsShield.Server_SetLowered");
		
		ABallisticsShield_Server_SetLowered_Params params {};
		params.bShouldLower = bShouldLower;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BallisticsShield.OnTPShieldHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ABallisticsShield::OnTPShieldHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BallisticsShield.OnTPShieldHit");
		
		ABallisticsShield_OnTPShieldHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BallisticsShield.GlassUpdate
	 * 		Flags  -> ()
	 */
	void ABallisticsShield::GlassUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BallisticsShield.GlassUpdate");
		
		ABallisticsShield_GlassUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BallisticsShield.DamageShieldGlass
	 * 		Flags  -> ()
	 */
	void ABallisticsShield::DamageShieldGlass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BallisticsShield.DamageShieldGlass");
		
		ABallisticsShield_DamageShieldGlass_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BallisticsShield.Client_SetPistol
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   newPistol                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABallisticsShield::Client_SetPistol(class ABaseItem* newPistol)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BallisticsShield.Client_SetPistol");
		
		ABallisticsShield_Client_SetPistol_Params params {};
		params.newPistol = newPistol;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BallisticsShield.Client_PlayShieldHitSound
	 * 		Flags  -> ()
	 */
	void ABallisticsShield::Client_PlayShieldHitSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BallisticsShield.Client_PlayShieldHitSound");
		
		ABallisticsShield_Client_PlayShieldHitSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABallisticsShield.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABallisticsShield::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BallisticsShield");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseActivityProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseActivityProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseActivityProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseArmour.HasRemainingProtection
	 * 		Flags  -> ()
	 */
	bool ABaseArmour::HasRemainingProtection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseArmour.HasRemainingProtection");
		
		ABaseArmour_HasRemainingProtection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseArmour.GetDurabilityPercentage
	 * 		Flags  -> ()
	 */
	float ABaseArmour::GetDurabilityPercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseArmour.GetDurabilityPercentage");
		
		ABaseArmour_GetDurabilityPercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABaseArmour.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABaseArmour::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseArmour");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.TrackEnemyKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::TrackEnemyKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.TrackEnemyKilled");
		
		UBaseCombatActivity_TrackEnemyKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.TrackEnemyFire
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        FromCharacter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseMagazineWeapon*                         Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        fireDirection                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::TrackEnemyFire(class AReadyOrNotCharacter* FromCharacter, class ABaseMagazineWeapon* Weapon, const struct FCoreUObject_FVector& fireDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.TrackEnemyFire");
		
		UBaseCombatActivity_TrackEnemyFire_Params params {};
		params.FromCharacter = FromCharacter;
		params.Weapon = Weapon;
		params.fireDirection = fireDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.StopScriptedFire
	 * 		Flags  -> ()
	 */
	void UBaseCombatActivity::StopScriptedFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.StopScriptedFire");
		
		UBaseCombatActivity_StopScriptedFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.StopMoveIntoLineOfSight
	 * 		Flags  -> ()
	 */
	void UBaseCombatActivity::StopMoveIntoLineOfSight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.StopMoveIntoLineOfSight");
		
		UBaseCombatActivity_StopMoveIntoLineOfSight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.StartRunningCombatMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseCombatMoveActivity*                     CombatMove                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::StartRunningCombatMove(class UBaseCombatMoveActivity* CombatMove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.StartRunningCombatMove");
		
		UBaseCombatActivity_StartRunningCombatMove_Params params {};
		params.CombatMove = CombatMove;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.ScriptedFireAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        InLocation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOverrideTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AccuracyPenaltyMultiplier                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::ScriptedFireAtLocation(const struct FCoreUObject_FVector& InLocation, float InTime, bool bOverrideTarget, float AccuracyPenaltyMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.ScriptedFireAtLocation");
		
		UBaseCombatActivity_ScriptedFireAtLocation_Params params {};
		params.InLocation = InLocation;
		params.InTime = InTime;
		params.bOverrideTarget = bOverrideTarget;
		params.AccuracyPenaltyMultiplier = AccuracyPenaltyMultiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.ScriptedFireAtActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOverrideTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AccuracyPenaltyMultiplier                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::ScriptedFireAtActor(class AActor* InActor, float InTime, bool bOverrideTarget, float AccuracyPenaltyMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.ScriptedFireAtActor");
		
		UBaseCombatActivity_ScriptedFireAtActor_Params params {};
		params.InActor = InActor;
		params.InTime = InTime;
		params.bOverrideTarget = bOverrideTarget;
		params.AccuracyPenaltyMultiplier = AccuracyPenaltyMultiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.PlayDeadStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               Activity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::PlayDeadStarted(class UBaseActivity* Activity, class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.PlayDeadStarted");
		
		UBaseCombatActivity_PlayDeadStarted_Params params {};
		params.Activity = Activity;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.PlayDeadFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               Activity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::PlayDeadFinished(class UBaseActivity* Activity, class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.PlayDeadFinished");
		
		UBaseCombatActivity_PlayDeadFinished_Params params {};
		params.Activity = Activity;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.PerformStrafeLogic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::PerformStrafeLogic(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.PerformStrafeLogic");
		
		UBaseCombatActivity_PerformStrafeLogic_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.PerformNoStrafeLogic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::PerformNoStrafeLogic(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.PerformNoStrafeLogic");
		
		UBaseCombatActivity_PerformNoStrafeLogic_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BaseCombatActivity.OnTrackNewEnemy__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        NewTrackedEnemy                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::OnTrackNewEnemy__DelegateSignature(class AReadyOrNotCharacter* NewTrackedEnemy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BaseCombatActivity.OnTrackNewEnemy__DelegateSignature");
		
		UBaseCombatActivity_OnTrackNewEnemy__DelegateSignature_Params params {};
		params.NewTrackedEnemy = NewTrackedEnemy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.OnTakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::OnTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.OnTakeDamage");
		
		UBaseCombatActivity_OnTakeDamage_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.OnSuicideFakeOutSuccess
	 * 		Flags  -> ()
	 */
	void UBaseCombatActivity::OnSuicideFakeOutSuccess()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.OnSuicideFakeOutSuccess");
		
		UBaseCombatActivity_OnSuicideFakeOutSuccess_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.OnStunned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.OnStunned");
		
		UBaseCombatActivity_OnStunned_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.OnRequestCoverLandmark
	 * 		Flags  -> ()
	 */
	void UBaseCombatActivity::OnRequestCoverLandmark()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.OnRequestCoverLandmark");
		
		UBaseCombatActivity_OnRequestCoverLandmark_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.OnRequestCover
	 * 		Flags  -> ()
	 */
	void UBaseCombatActivity::OnRequestCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.OnRequestCover");
		
		UBaseCombatActivity_OnRequestCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.OnNoCoverFound
	 * 		Flags  -> ()
	 */
	void UBaseCombatActivity::OnNoCoverFound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.OnNoCoverFound");
		
		UBaseCombatActivity_OnNoCoverFound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.OnCoverLandmarkExit
	 * 		Flags  -> ()
	 */
	void UBaseCombatActivity::OnCoverLandmarkExit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.OnCoverLandmarkExit");
		
		UBaseCombatActivity_OnCoverLandmarkExit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.OnCoverFound
	 * 		Flags  -> ()
	 */
	void UBaseCombatActivity::OnCoverFound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.OnCoverFound");
		
		UBaseCombatActivity_OnCoverFound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.OnCoverExit
	 * 		Flags  -> ()
	 */
	void UBaseCombatActivity::OnCoverExit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.OnCoverExit");
		
		UBaseCombatActivity_OnCoverExit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.MoveIntoLineOfSight
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        ToLocation                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::MoveIntoLineOfSight(const struct FCoreUObject_FVector& ToLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.MoveIntoLineOfSight");
		
		UBaseCombatActivity_MoveIntoLineOfSight_Params params {};
		params.ToLocation = ToLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.IsRunningCombatMoveActivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBaseCombatActivity::IsRunningCombatMoveActivity(class UClass* Class)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.IsRunningCombatMoveActivity");
		
		UBaseCombatActivity_IsRunningCombatMoveActivity_Params params {};
		params.Class = Class;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.IsFocusingOnActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBaseCombatActivity::IsFocusingOnActor(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.IsFocusingOnActor");
		
		UBaseCombatActivity_IsFocusingOnActor_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.GetCombatMoveActivity
	 * 		Flags  -> ()
	 */
	class UBaseCombatMoveActivity* UBaseCombatActivity::GetCombatMoveActivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.GetCombatMoveActivity");
		
		UBaseCombatActivity_GetCombatMoveActivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.FinishCombatMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatActivity::FinishCombatMove(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.FinishCombatMove");
		
		UBaseCombatActivity_FinishCombatMove_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.EnterStrafeState
	 * 		Flags  -> ()
	 */
	void UBaseCombatActivity::EnterStrafeState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.EnterStrafeState");
		
		UBaseCombatActivity_EnterStrafeState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatActivity.EnterNoStrafeState
	 * 		Flags  -> ()
	 */
	void UBaseCombatActivity::EnterNoStrafeState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatActivity.EnterNoStrafeState");
		
		UBaseCombatActivity_EnterNoStrafeState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseCombatActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseCombatActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseCombatActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatMoveActivity.RequestCombatMove_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatMoveActivity::RequestCombatMove_Blueprint(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatMoveActivity.RequestCombatMove_Blueprint");
		
		UBaseCombatMoveActivity_RequestCombatMove_Blueprint_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatMoveActivity.HasLOSToEnemy
	 * 		Flags  -> ()
	 */
	bool UBaseCombatMoveActivity::HasLOSToEnemy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatMoveActivity.HasLOSToEnemy");
		
		UBaseCombatMoveActivity_HasLOSToEnemy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatMoveActivity.HasAnyOtherCombatMoveGotLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        TestLocation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBaseCombatMoveActivity::HasAnyOtherCombatMoveGotLocation(const struct FCoreUObject_FVector& TestLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatMoveActivity.HasAnyOtherCombatMoveGotLocation");
		
		UBaseCombatMoveActivity_HasAnyOtherCombatMoveGotLocation_Params params {};
		params.TestLocation = TestLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatMoveActivity.GetInterruptActivity
	 * 		Flags  -> ()
	 */
	class UBaseActivity* UBaseCombatMoveActivity::GetInterruptActivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatMoveActivity.GetInterruptActivity");
		
		UBaseCombatMoveActivity_GetInterruptActivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatMoveActivity.GenerateNavigablePoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        GenAroundLoc                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FNavGenerationParameters                    NavGenerationParameters                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<struct FCoreUObject_FVector>                OutLocations                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatMoveActivity::GenerateNavigablePoints(const struct FCoreUObject_FVector& GenAroundLoc, const struct FNavGenerationParameters& NavGenerationParameters, TArray<struct FCoreUObject_FVector>* OutLocations)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatMoveActivity.GenerateNavigablePoints");
		
		UBaseCombatMoveActivity_GenerateNavigablePoints_Params params {};
		params.GenAroundLoc = GenAroundLoc;
		params.NavGenerationParameters = NavGenerationParameters;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocations != nullptr)
			*OutLocations = params.OutLocations;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseCombatMoveActivity.FinishCombatMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseCombatMoveActivity::FinishCombatMove(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseCombatMoveActivity.FinishCombatMove");
		
		UBaseCombatMoveActivity_FinishCombatMove_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseCombatMoveActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseCombatMoveActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseCombatMoveActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.UpdateServerPath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FVector_NetQuantize>                 Path                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Bounce1                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Bounce2                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Bounce3                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseGrenade::UpdateServerPath(TArray<struct FVector_NetQuantize> Path, int32_t Bounce1, int32_t Bounce2, int32_t Bounce3)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.UpdateServerPath");
		
		ABaseGrenade_UpdateServerPath_Params params {};
		params.Path = Path;
		params.Bounce1 = Bounce1;
		params.Bounce2 = Bounce2;
		params.Bounce3 = Bounce3;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.SetFullyPrimed
	 * 		Flags  -> ()
	 */
	void ABaseGrenade::SetFullyPrimed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.SetFullyPrimed");
		
		ABaseGrenade_SetFullyPrimed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.Server_UpdateThrowPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Position                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseGrenade::Server_UpdateThrowPosition(const struct FCoreUObject_FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.Server_UpdateThrowPosition");
		
		ABaseGrenade_Server_UpdateThrowPosition_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.Server_ThrowGrenade
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOverarmThrow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        ThrowDirection                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        ThrowStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseGrenade::Server_ThrowGrenade(bool bOverarmThrow, const struct FCoreUObject_FVector& ThrowDirection, const struct FCoreUObject_FVector& ThrowStart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.Server_ThrowGrenade");
		
		ABaseGrenade_Server_ThrowGrenade_Params params {};
		params.bOverarmThrow = bOverarmThrow;
		params.ThrowDirection = ThrowDirection;
		params.ThrowStart = ThrowStart;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.Server_StartFastThrow
	 * 		Flags  -> ()
	 */
	void ABaseGrenade::Server_StartFastThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.Server_StartFastThrow");
		
		ABaseGrenade_Server_StartFastThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.Server_SetThrowOverarm
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bThrowOverarm                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bQuickThrow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseGrenade::Server_SetThrowOverarm(bool bThrowOverarm, bool bQuickThrow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.Server_SetThrowOverarm");
		
		ABaseGrenade_Server_SetThrowOverarm_Params params {};
		params.bThrowOverarm = bThrowOverarm;
		params.bQuickThrow = bQuickThrow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.OnRep_GrenadeUsed
	 * 		Flags  -> ()
	 */
	void ABaseGrenade::OnRep_GrenadeUsed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.OnRep_GrenadeUsed");
		
		ABaseGrenade_OnRep_GrenadeUsed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.OnRep_GrenadePath
	 * 		Flags  -> ()
	 */
	void ABaseGrenade::OnRep_GrenadePath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.OnRep_GrenadePath");
		
		ABaseGrenade_OnRep_GrenadePath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BaseGrenade.OnGrenadeThrown__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseGrenade*                                ThrownGrenade                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseGrenade::OnGrenadeThrown__DelegateSignature(class ABaseGrenade* ThrownGrenade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BaseGrenade.OnGrenadeThrown__DelegateSignature");
		
		ABaseGrenade_OnGrenadeThrown__DelegateSignature_Params params {};
		params.ThrownGrenade = ThrownGrenade;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.OnGrenadeBounceSoundStopped
	 * 		Flags  -> ()
	 */
	void ABaseGrenade::OnGrenadeBounceSoundStopped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.OnGrenadeBounceSoundStopped");
		
		ABaseGrenade_OnGrenadeBounceSoundStopped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BaseGrenade.OnDetonate__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ABaseGrenade::OnDetonate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BaseGrenade.OnDetonate__DelegateSignature");
		
		ABaseGrenade_OnDetonate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.Multicast_OnDeadDropped
	 * 		Flags  -> ()
	 */
	void ABaseGrenade::Multicast_OnDeadDropped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.Multicast_OnDeadDropped");
		
		ABaseGrenade_Multicast_OnDeadDropped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.Multicast_GrenadeThrow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOverarmThrow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        ThrowDirection                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        ThrowStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseGrenade::Multicast_GrenadeThrow(bool bOverarmThrow, const struct FCoreUObject_FVector& ThrowDirection, const struct FCoreUObject_FVector& ThrowStart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.Multicast_GrenadeThrow");
		
		ABaseGrenade_Multicast_GrenadeThrow_Params params {};
		params.bOverarmThrow = bOverarmThrow;
		params.ThrowDirection = ThrowDirection;
		params.ThrowStart = ThrowStart;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.Multicast_DetonationEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        CalculatedForce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseGrenade::Multicast_DetonationEffects(const struct FCoreUObject_FVector& CalculatedForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.Multicast_DetonationEffects");
		
		ABaseGrenade_Multicast_DetonationEffects_Params params {};
		params.CalculatedForce = CalculatedForce;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.Multicast_AddImpulse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Impulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        FromLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseGrenade::Multicast_AddImpulse(const struct FCoreUObject_FVector& Impulse, const struct FCoreUObject_FVector& FromLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.Multicast_AddImpulse");
		
		ABaseGrenade_Multicast_AddImpulse_Params params {};
		params.Impulse = Impulse;
		params.FromLocation = FromLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.IsOutside
	 * 		Flags  -> ()
	 */
	bool ABaseGrenade::IsOutside()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.IsOutside");
		
		ABaseGrenade_IsOutside_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.DoThrowFast
	 * 		Flags  -> ()
	 */
	void ABaseGrenade::DoThrowFast()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.DoThrowFast");
		
		ABaseGrenade_DoThrowFast_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseGrenade.Detonate
	 * 		Flags  -> ()
	 */
	void ABaseGrenade::Detonate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseGrenade.Detonate");
		
		ABaseGrenade_Detonate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABaseGrenade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABaseGrenade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseGrenade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.ResetRecoilSettingsToDefault
	 * 		Flags  -> ()
	 */
	void ABaseWeapon::ResetRecoilSettingsToDefault()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.ResetRecoilSettingsToDefault");
		
		ABaseWeapon_ResetRecoilSettingsToDefault_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.RemoveAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bScopedAttachment                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMuzzleAttachment                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUnderbarrelAttachment                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOverbarrelAttachment                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bStockAttachment                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGripAttachment                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIlluminatorAttachment                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAmmunitionAttachment                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseWeapon::RemoveAttachment(bool bScopedAttachment, bool bMuzzleAttachment, bool bUnderbarrelAttachment, bool bOverbarrelAttachment, bool bStockAttachment, bool bGripAttachment, bool bIlluminatorAttachment, bool bAmmunitionAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.RemoveAttachment");
		
		ABaseWeapon_RemoveAttachment_Params params {};
		params.bScopedAttachment = bScopedAttachment;
		params.bMuzzleAttachment = bMuzzleAttachment;
		params.bUnderbarrelAttachment = bUnderbarrelAttachment;
		params.bOverbarrelAttachment = bOverbarrelAttachment;
		params.bStockAttachment = bStockAttachment;
		params.bGripAttachment = bGripAttachment;
		params.bIlluminatorAttachment = bIlluminatorAttachment;
		params.bAmmunitionAttachment = bAmmunitionAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.PlayFiringModeAnimation
	 * 		Flags  -> ()
	 */
	void ABaseWeapon::PlayFiringModeAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.PlayFiringModeAnimation");
		
		ABaseWeapon_PlayFiringModeAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.OnWeaponReloadStarted
	 * 		Flags  -> ()
	 */
	void ABaseWeapon::OnWeaponReloadStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.OnWeaponReloadStarted");
		
		ABaseWeapon_OnWeaponReloadStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.OnWeaponReloadComplete
	 * 		Flags  -> ()
	 */
	void ABaseWeapon::OnWeaponReloadComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.OnWeaponReloadComplete");
		
		ABaseWeapon_OnWeaponReloadComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BaseWeapon.OnWeaponFireModeChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EFireMode                                          newFireMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseWeapon::OnWeaponFireModeChanged__DelegateSignature(EFireMode newFireMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BaseWeapon.OnWeaponFireModeChanged__DelegateSignature");
		
		ABaseWeapon_OnWeaponFireModeChanged__DelegateSignature_Params params {};
		params.newFireMode = newFireMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.OnWeaponFiredEnd
	 * 		Flags  -> ()
	 */
	void ABaseWeapon::OnWeaponFiredEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.OnWeaponFiredEnd");
		
		ABaseWeapon_OnWeaponFiredEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.OnWeaponFired
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FRotator                       fireDirection                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ABaseWeapon::OnWeaponFired(const struct FCoreUObject_FRotator& fireDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.OnWeaponFired");
		
		ABaseWeapon_OnWeaponFired_Params params {};
		params.fireDirection = fireDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.OnEndAimDownSights
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bWasAiming                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseWeapon::OnEndAimDownSights(bool bWasAiming)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.OnEndAimDownSights");
		
		ABaseWeapon_OnEndAimDownSights_Params params {};
		params.bWasAiming = bWasAiming;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.OnAimDownSights
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bWasAiming                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseWeapon::OnAimDownSights(bool bWasAiming)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.OnAimDownSights");
		
		ABaseWeapon_OnAimDownSights_Params params {};
		params.bWasAiming = bWasAiming;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.IsLethalWeapon
	 * 		Flags  -> ()
	 */
	bool ABaseWeapon::IsLethalWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.IsLethalWeapon");
		
		ABaseWeapon_IsLethalWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.IsLessLethalWeapon
	 * 		Flags  -> ()
	 */
	bool ABaseWeapon::IsLessLethalWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.IsLessLethalWeapon");
		
		ABaseWeapon_IsLessLethalWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.GetUnderbarrelAnimationType
	 * 		Flags  -> ()
	 */
	EWeaponUnderbarrelAnimationType ABaseWeapon::GetUnderbarrelAnimationType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.GetUnderbarrelAnimationType");
		
		ABaseWeapon_GetUnderbarrelAnimationType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.GetSpread
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FRotator ABaseWeapon::GetSpread()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.GetSpread");
		
		ABaseWeapon_GetSpread_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.GetRecoil
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FRotator ABaseWeapon::GetRecoil()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.GetRecoil");
		
		ABaseWeapon_GetRecoil_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.GetLightAttachment
	 * 		Flags  -> ()
	 */
	class ULightAttachment* ABaseWeapon::GetLightAttachment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.GetLightAttachment");
		
		ABaseWeapon_GetLightAttachment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.GetLaserAttachment
	 * 		Flags  -> ()
	 */
	class ULaserAttachment* ABaseWeapon::GetLaserAttachment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.GetLaserAttachment");
		
		ABaseWeapon_GetLaserAttachment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.EnableGlimmer
	 * 		Flags  -> ()
	 */
	void ABaseWeapon::EnableGlimmer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.EnableGlimmer");
		
		ABaseWeapon_EnableGlimmer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.DisableGlimmer
	 * 		Flags  -> ()
	 */
	void ABaseWeapon::DisableGlimmer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.DisableGlimmer");
		
		ABaseWeapon_DisableGlimmer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.CanReload
	 * 		Flags  -> ()
	 */
	bool ABaseWeapon::CanReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.CanReload");
		
		ABaseWeapon_CanReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.CanAddAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      AttachmentClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ABaseWeapon::CanAddAttachment(class UClass* AttachmentClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.CanAddAttachment");
		
		ABaseWeapon_CanAddAttachment_Params params {};
		params.AttachmentClass = AttachmentClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.AddMagazineCountFromAttachments
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              AddAmount                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseWeapon::AddMagazineCountFromAttachments(float AddAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.AddMagazineCountFromAttachments");
		
		ABaseWeapon_AddMagazineCountFromAttachments_Params params {};
		params.AddAmount = AddAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWeapon.AddAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReplicateAttachment                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseWeapon::AddAttachment(class UClass* Class, bool bReplicateAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWeapon.AddAttachment");
		
		ABaseWeapon_AddAttachment_Params params {};
		params.Class = Class;
		params.bReplicateAttachment = bReplicateAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABaseWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABaseWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.SetMagazineCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                AmmoTypes                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::SetMagazineCount(int32_t Count, TArray<class FName> AmmoTypes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.SetMagazineCount");
		
		ABaseMagazineWeapon_SetMagazineCount_Params params {};
		params.Count = Count;
		params.AmmoTypes = AmmoTypes;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.Server_SetTacticalReload
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsTacticalReload                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::Server_SetTacticalReload(bool bIsTacticalReload)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.Server_SetTacticalReload");
		
		ABaseMagazineWeapon_Server_SetTacticalReload_Params params {};
		params.bIsTacticalReload = bIsTacticalReload;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.Server_SetReloading
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsReloading                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::Server_SetReloading(bool bIsReloading)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.Server_SetReloading");
		
		ABaseMagazineWeapon_Server_SetReloading_Params params {};
		params.bIsReloading = bIsReloading;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.Server_SetDesiredAmmoTypeIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::Server_SetDesiredAmmoTypeIndex(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.Server_SetDesiredAmmoTypeIndex");
		
		ABaseMagazineWeapon_Server_SetDesiredAmmoTypeIndex_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.Server_SetCancelReloading
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::Server_SetCancelReloading(bool bNewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.Server_SetCancelReloading");
		
		ABaseMagazineWeapon_Server_SetCancelReloading_Params params {};
		params.bNewValue = bNewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.Server_OnFire
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FRotator                       Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        SpawnLoc                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Seed                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::Server_OnFire(const struct FCoreUObject_FRotator& Direction, const struct FCoreUObject_FVector& SpawnLoc, int32_t Seed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.Server_OnFire");
		
		ABaseMagazineWeapon_Server_OnFire_Params params {};
		params.Direction = Direction;
		params.SpawnLoc = SpawnLoc;
		params.Seed = Seed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.Server_NextMagazine
	 * 		Flags  -> ()
	 */
	void ABaseMagazineWeapon::Server_NextMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.Server_NextMagazine");
		
		ABaseMagazineWeapon_Server_NextMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.Server_AddMagazine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FMagazine                                   Magazine                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::Server_AddMagazine(const struct FMagazine& Magazine)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.Server_AddMagazine");
		
		ABaseMagazineWeapon_Server_AddMagazine_Params params {};
		params.Magazine = Magazine;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.ReplenishAmmo
	 * 		Flags  -> ()
	 */
	void ABaseMagazineWeapon::ReplenishAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.ReplenishAmmo");
		
		ABaseMagazineWeapon_ReplenishAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.RemoveAmmo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ABaseMagazineWeapon::RemoveAmmo(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.RemoveAmmo");
		
		ABaseMagazineWeapon_RemoveAmmo_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.PlaySound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USoundCue*                                   Cue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::PlaySound(class USoundCue* Cue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.PlaySound");
		
		ABaseMagazineWeapon_PlaySound_Params params {};
		params.Cue = Cue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.PlayBulletWhizz
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Pan                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::PlayBulletWhizz(float Pan)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.PlayBulletWhizz");
		
		ABaseMagazineWeapon_PlayBulletWhizz_Params params {};
		params.Pan = Pan;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BaseMagazineWeapon.OnWeaponMagCheck__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseMagazineWeapon*                         Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::OnWeaponMagCheck__DelegateSignature(class ABaseMagazineWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BaseMagazineWeapon.OnWeaponMagCheck__DelegateSignature");
		
		ABaseMagazineWeapon_OnWeaponMagCheck__DelegateSignature_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BaseMagazineWeapon.OnWeaponFire__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseMagazineWeapon*                         Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bServer                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::OnWeaponFire__DelegateSignature(class ABaseMagazineWeapon* Weapon, bool bServer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BaseMagazineWeapon.OnWeaponFire__DelegateSignature");
		
		ABaseMagazineWeapon_OnWeaponFire__DelegateSignature_Params params {};
		params.Weapon = Weapon;
		params.bServer = bServer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.OnReloadAnimEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EReloadAnimEvent                                   Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::OnReloadAnimEvent(EReloadAnimEvent Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.OnReloadAnimEvent");
		
		ABaseMagazineWeapon_OnReloadAnimEvent_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.OnNewFireModeAnimEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EFireMode                                          newFireMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::OnNewFireModeAnimEvent(EFireMode newFireMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.OnNewFireModeAnimEvent");
		
		ABaseMagazineWeapon_OnNewFireModeAnimEvent_Params params {};
		params.newFireMode = newFireMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.OnFire
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FRotator                       Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        SpawnLoc                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::OnFire(const struct FCoreUObject_FRotator& Direction, const struct FCoreUObject_FVector& SpawnLoc)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.OnFire");
		
		ABaseMagazineWeapon_OnFire_Params params {};
		params.Direction = Direction;
		params.SpawnLoc = SpawnLoc;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.Multicast_SpawnShell
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOnlyLocallyControlled                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSkipLocallyControlled                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::Multicast_SpawnShell(bool bOnlyLocallyControlled, bool bSkipLocallyControlled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.Multicast_SpawnShell");
		
		ABaseMagazineWeapon_Multicast_SpawnShell_Params params {};
		params.bOnlyLocallyControlled = bOnlyLocallyControlled;
		params.bSkipLocallyControlled = bSkipLocallyControlled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.Multicast_SpawnParticleEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSkipAuthority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSkipLocalOwner                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::Multicast_SpawnParticleEffects(bool bSkipAuthority, bool bSkipLocalOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.Multicast_SpawnParticleEffects");
		
		ABaseMagazineWeapon_Multicast_SpawnParticleEffects_Params params {};
		params.bSkipAuthority = bSkipAuthority;
		params.bSkipLocalOwner = bSkipLocalOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.Multicast_SimulateFireForViewTargets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector_NetQuantize100                      DirectionNet                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize100                      SpawnLoc                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Seed                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::Multicast_SimulateFireForViewTargets(const struct FVector_NetQuantize100& DirectionNet, const struct FVector_NetQuantize100& SpawnLoc, int32_t Seed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.Multicast_SimulateFireForViewTargets");
		
		ABaseMagazineWeapon_Multicast_SimulateFireForViewTargets_Params params {};
		params.DirectionNet = DirectionNet;
		params.SpawnLoc = SpawnLoc;
		params.Seed = Seed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.Multicast_OnFire
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector_NetQuantize100                      DirectionNet                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize100                      SpawnLoc                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Seed                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::Multicast_OnFire(const struct FVector_NetQuantize100& DirectionNet, const struct FVector_NetQuantize100& SpawnLoc, int32_t Seed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.Multicast_OnFire");
		
		ABaseMagazineWeapon_Multicast_OnFire_Params params {};
		params.DirectionNet = DirectionNet;
		params.SpawnLoc = SpawnLoc;
		params.Seed = Seed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.Multicast_HandleSupression
	 * 		Flags  -> ()
	 */
	void ABaseMagazineWeapon::Multicast_HandleSupression()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.Multicast_HandleSupression");
		
		ABaseMagazineWeapon_Multicast_HandleSupression_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.Multicast_DoHitScan
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                     SpawnTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bLocalOnly                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ProjectileNumber                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Seed                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABaseMagazineWeapon::Multicast_DoHitScan(const struct FTransform& SpawnTransform, bool bLocalOnly, int32_t ProjectileNumber, int32_t Seed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.Multicast_DoHitScan");
		
		ABaseMagazineWeapon_Multicast_DoHitScan_Params params {};
		params.SpawnTransform = SpawnTransform;
		params.bLocalOnly = bLocalOnly;
		params.ProjectileNumber = ProjectileNumber;
		params.Seed = Seed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.InSingleMode
	 * 		Flags  -> ()
	 */
	bool ABaseMagazineWeapon::InSingleMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.InSingleMode");
		
		ABaseMagazineWeapon_InSingleMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.InSafeMode
	 * 		Flags  -> ()
	 */
	bool ABaseMagazineWeapon::InSafeMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.InSafeMode");
		
		ABaseMagazineWeapon_InSafeMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.InFullAutoMode
	 * 		Flags  -> ()
	 */
	bool ABaseMagazineWeapon::InFullAutoMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.InFullAutoMode");
		
		ABaseMagazineWeapon_InFullAutoMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.InBurstMode
	 * 		Flags  -> ()
	 */
	bool ABaseMagazineWeapon::InBurstMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.InBurstMode");
		
		ABaseMagazineWeapon_InBurstMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.HasAnyAmmo
	 * 		Flags  -> ()
	 */
	bool ABaseMagazineWeapon::HasAnyAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.HasAnyAmmo");
		
		ABaseMagazineWeapon_HasAnyAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.HasAmmo
	 * 		Flags  -> ()
	 */
	bool ABaseMagazineWeapon::HasAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.HasAmmo");
		
		ABaseMagazineWeapon_HasAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.GivenAmmoFromAmmoBag
	 * 		Flags  -> ()
	 */
	void ABaseMagazineWeapon::GivenAmmoFromAmmoBag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.GivenAmmoFromAmmoBag");
		
		ABaseMagazineWeapon_GivenAmmoFromAmmoBag_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.GetNextAmmo
	 * 		Flags  -> ()
	 */
	float ABaseMagazineWeapon::GetNextAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.GetNextAmmo");
		
		ABaseMagazineWeapon_GetNextAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.GetMagazineScreenName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FMagazine                                   Magazine                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class FText ABaseMagazineWeapon::GetMagazineScreenName(const struct FMagazine& Magazine)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.GetMagazineScreenName");
		
		ABaseMagazineWeapon_GetMagazineScreenName_Params params {};
		params.Magazine = Magazine;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.GetMagazineCount
	 * 		Flags  -> ()
	 */
	int32_t ABaseMagazineWeapon::GetMagazineCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.GetMagazineCount");
		
		ABaseMagazineWeapon_GetMagazineCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.GetMagazineAmmoPercentage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            MagazineIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ABaseMagazineWeapon::GetMagazineAmmoPercentage(int32_t MagazineIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.GetMagazineAmmoPercentage");
		
		ABaseMagazineWeapon_GetMagazineAmmoPercentage_Params params {};
		params.MagazineIndex = MagazineIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.GetCurrentMagazine
	 * 		Flags  -> ()
	 */
	struct FMagazine ABaseMagazineWeapon::GetCurrentMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.GetCurrentMagazine");
		
		ABaseMagazineWeapon_GetCurrentMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.GetCurrentAmmoPercentage
	 * 		Flags  -> ()
	 */
	float ABaseMagazineWeapon::GetCurrentAmmoPercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.GetCurrentAmmoPercentage");
		
		ABaseMagazineWeapon_GetCurrentAmmoPercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.GetAmmoWeight
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ABaseMagazineWeapon::GetAmmoWeight(int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.GetAmmoWeight");
		
		ABaseMagazineWeapon_GetAmmoWeight_Params params {};
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.GetAmmoInMagazine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ABaseMagazineWeapon::GetAmmoInMagazine(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.GetAmmoInMagazine");
		
		ABaseMagazineWeapon_GetAmmoInMagazine_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.GetAmmo
	 * 		Flags  -> ()
	 */
	float ABaseMagazineWeapon::GetAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.GetAmmo");
		
		ABaseMagazineWeapon_GetAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.FindNextMagIndex
	 * 		Flags  -> ()
	 */
	void ABaseMagazineWeapon::FindNextMagIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.FindNextMagIndex");
		
		ABaseMagazineWeapon_FindNextMagIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagazineWeapon.AllMagsEmpty
	 * 		Flags  -> ()
	 */
	bool ABaseMagazineWeapon::AllMagsEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagazineWeapon.AllMagsEmpty");
		
		ABaseMagazineWeapon_AllMagsEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABaseMagazineWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABaseMagazineWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseMagazineWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagPouch.ShowMagazine
	 * 		Flags  -> ()
	 */
	void ABaseMagPouch::ShowMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagPouch.ShowMagazine");
		
		ABaseMagPouch_ShowMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagPouch.OpenPouch
	 * 		Flags  -> ()
	 */
	void ABaseMagPouch::OpenPouch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagPouch.OpenPouch");
		
		ABaseMagPouch_OpenPouch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagPouch.HideMagazine
	 * 		Flags  -> ()
	 */
	void ABaseMagPouch::HideMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagPouch.HideMagazine");
		
		ABaseMagPouch_HideMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseMagPouch.ClosePouch
	 * 		Flags  -> ()
	 */
	void ABaseMagPouch::ClosePouch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseMagPouch.ClosePouch");
		
		ABaseMagPouch_ClosePouch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABaseMagPouch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABaseMagPouch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseMagPouch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameplayEffect.Server_ResetEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bMulticast                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameplayEffect::Server_ResetEffect(bool bMulticast)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameplayEffect.Server_ResetEffect");
		
		UReadyOrNotGameplayEffect_Server_ResetEffect_Params params {};
		params.bMulticast = bMulticast;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameplayEffect.Server_Initialize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMulticast                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameplayEffect::Server_Initialize(class AActor* InActor, bool bMulticast)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameplayEffect.Server_Initialize");
		
		UReadyOrNotGameplayEffect_Server_Initialize_Params params {};
		params.InActor = InActor;
		params.bMulticast = bMulticast;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameplayEffect.Server_ApplyEffectFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMulticast                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameplayEffect::Server_ApplyEffectFor(float Seconds, bool bMulticast)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameplayEffect.Server_ApplyEffectFor");
		
		UReadyOrNotGameplayEffect_Server_ApplyEffectFor_Params params {};
		params.Seconds = Seconds;
		params.bMulticast = bMulticast;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameplayEffect.Server_ApplyEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bMulticast                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameplayEffect::Server_ApplyEffect(bool bMulticast)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameplayEffect.Server_ApplyEffect");
		
		UReadyOrNotGameplayEffect_Server_ApplyEffect_Params params {};
		params.bMulticast = bMulticast;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameplayEffect.ResetEffect
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameplayEffect::ResetEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameplayEffect.ResetEffect");
		
		UReadyOrNotGameplayEffect_ResetEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameplayEffect.OnEffectExpired
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameplayEffect::OnEffectExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameplayEffect.OnEffectExpired");
		
		UReadyOrNotGameplayEffect_OnEffectExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameplayEffect.Multicast_ResetEffect
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameplayEffect::Multicast_ResetEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameplayEffect.Multicast_ResetEffect");
		
		UReadyOrNotGameplayEffect_Multicast_ResetEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameplayEffect.Multicast_Initialize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameplayEffect::Multicast_Initialize(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameplayEffect.Multicast_Initialize");
		
		UReadyOrNotGameplayEffect_Multicast_Initialize_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameplayEffect.Multicast_ApplyEffectFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameplayEffect::Multicast_ApplyEffectFor(float Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameplayEffect.Multicast_ApplyEffectFor");
		
		UReadyOrNotGameplayEffect_Multicast_ApplyEffectFor_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameplayEffect.Multicast_ApplyEffect
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameplayEffect::Multicast_ApplyEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameplayEffect.Multicast_ApplyEffect");
		
		UReadyOrNotGameplayEffect_Multicast_ApplyEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameplayEffect.Initialize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameplayEffect::Initialize(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameplayEffect.Initialize");
		
		UReadyOrNotGameplayEffect_Initialize_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameplayEffect.ApplyEffectFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameplayEffect::ApplyEffectFor(float Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameplayEffect.ApplyEffectFor");
		
		UReadyOrNotGameplayEffect_ApplyEffectFor_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameplayEffect.ApplyEffect
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameplayEffect::ApplyEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameplayEffect.ApplyEffect");
		
		UReadyOrNotGameplayEffect_ApplyEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotGameplayEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotGameplayEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotGameplayEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBasePlayerEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBasePlayerEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BasePlayerEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseQuestNode.StartQuestNodeAction
	 * 		Flags  -> ()
	 */
	void UBaseQuestNode::StartQuestNodeAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseQuestNode.StartQuestNodeAction");
		
		UBaseQuestNode_StartQuestNodeAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BaseQuestNode.OnQuestNodeStarted__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UBaseQuestNode::OnQuestNodeStarted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BaseQuestNode.OnQuestNodeStarted__DelegateSignature");
		
		UBaseQuestNode_OnQuestNodeStarted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseQuestNode.GetOwningPlayer
	 * 		Flags  -> ()
	 */
	class APlayerCharacter* UBaseQuestNode::GetOwningPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseQuestNode.GetOwningPlayer");
		
		UBaseQuestNode_GetOwningPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseQuestNode.GetInProgress
	 * 		Flags  -> ()
	 */
	bool UBaseQuestNode::GetInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseQuestNode.GetInProgress");
		
		UBaseQuestNode_GetInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseQuestNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseQuestNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseQuestNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseRadialMenuScript.Initialize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URadialWidgetBase*                           InRadialMenuOwner                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseRadialMenuScript::Initialize(class URadialWidgetBase* InRadialMenuOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseRadialMenuScript.Initialize");
		
		UBaseRadialMenuScript_Initialize_Params params {};
		params.InRadialMenuOwner = InRadialMenuOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseRadialMenuScript.ExecuteScript
	 * 		Flags  -> ()
	 */
	void UBaseRadialMenuScript::ExecuteScript()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseRadialMenuScript.ExecuteScript");
		
		UBaseRadialMenuScript_ExecuteScript_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseRadialMenuScript.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseRadialMenuScript::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseRadialMenuScript");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseShell.OnHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ABaseShell::OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseShell.OnHit");
		
		ABaseShell_OnHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABaseShell.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABaseShell::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseShell");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseTeamQuestNode.UpdateSWATCommands
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USwatCommandWidget*                          Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FSwatCommand>                        SwatCommands                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UBaseTeamQuestNode::UpdateSWATCommands(class USwatCommandWidget* Widget, TArray<struct FSwatCommand>* SwatCommands)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseTeamQuestNode.UpdateSWATCommands");
		
		UBaseTeamQuestNode_UpdateSWATCommands_Params params {};
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SwatCommands != nullptr)
			*SwatCommands = params.SwatCommands;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseTeamQuestNode.GetSWATManager
	 * 		Flags  -> ()
	 */
	class ASWATManager* UBaseTeamQuestNode::GetSWATManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseTeamQuestNode.GetSWATManager");
		
		UBaseTeamQuestNode_GetSWATManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseTeamQuestNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseTeamQuestNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseTeamQuestNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.UpdateDebugInfo
	 * 		Flags  -> ()
	 */
	bool UBaseWidget::UpdateDebugInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.UpdateDebugInfo");
		
		UBaseWidget_UpdateDebugInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.ToggleWidgetVisibility
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNotHitTestable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseWidget::ToggleWidgetVisibility(bool bNotHitTestable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.ToggleWidgetVisibility");
		
		UBaseWidget_ToggleWidgetVisibility_Params params {};
		params.bNotHitTestable = bNotHitTestable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.StopWidgetAnimation_Internal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidgetAnimation*                            InWidgetAnimation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseWidget::StopWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.StopWidgetAnimation_Internal");
		
		UBaseWidget_StopWidgetAnimation_Internal_Params params {};
		params.InWidgetAnimation = InWidgetAnimation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.ShowWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNotHitTestable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseWidget::ShowWidget(bool bNotHitTestable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.ShowWidget");
		
		UBaseWidget_ShowWidget_Params params {};
		params.bNotHitTestable = bNotHitTestable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.PlayWidgetAnimation_Internal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidgetAnimation*                            InWidgetAnimation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRestartIfAlreadyPlaying                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseWidget::PlayWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation, bool bRestartIfAlreadyPlaying)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.PlayWidgetAnimation_Internal");
		
		UBaseWidget_PlayWidgetAnimation_Internal_Params params {};
		params.InWidgetAnimation = InWidgetAnimation;
		params.bRestartIfAlreadyPlaying = bRestartIfAlreadyPlaying;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.PlaySoundEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFMODEvent*                                  SoundEffectToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseWidget::PlaySoundEffect(class UFMODEvent* SoundEffectToPlay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.PlaySoundEffect");
		
		UBaseWidget_PlaySoundEffect_Params params {};
		params.SoundEffectToPlay = SoundEffectToPlay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.PauseWidgetAnimation_Internal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidgetAnimation*                            InWidgetAnimation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseWidget::PauseWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.PauseWidgetAnimation_Internal");
		
		UBaseWidget_PauseWidgetAnimation_Internal_Params params {};
		params.InWidgetAnimation = InWidgetAnimation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.IsMouseAxisBeyondThreshold
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector2D                      InMouseDelta                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBaseWidget::IsMouseAxisBeyondThreshold(const struct FCoreUObject_FVector2D& InMouseDelta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.IsMouseAxisBeyondThreshold");
		
		UBaseWidget_IsMouseAxisBeyondThreshold_Params params {};
		params.InMouseDelta = InMouseDelta;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.IsGamepadAxisBeyondThreshold
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector2D                      InGamepadAxis                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBaseWidget::IsGamepadAxisBeyondThreshold(const struct FCoreUObject_FVector2D& InGamepadAxis)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.IsGamepadAxisBeyondThreshold");
		
		UBaseWidget_IsGamepadAxisBeyondThreshold_Params params {};
		params.InGamepadAxis = InGamepadAxis;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.IsBlockingAnimationPlaying
	 * 		Flags  -> ()
	 */
	bool UBaseWidget::IsBlockingAnimationPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.IsBlockingAnimationPlaying");
		
		UBaseWidget_IsBlockingAnimationPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.HideWidget
	 * 		Flags  -> ()
	 */
	void UBaseWidget::HideWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.HideWidget");
		
		UBaseWidget_HideWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.HasMouseMoved
	 * 		Flags  -> ()
	 */
	bool UBaseWidget::HasMouseMoved()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.HasMouseMoved");
		
		UBaseWidget_HasMouseMoved_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.GetMousePosition
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector2D UBaseWidget::GetMousePosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.GetMousePosition");
		
		UBaseWidget_GetMousePosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.GetMouseDelta
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector2D UBaseWidget::GetMouseDelta()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.GetMouseDelta");
		
		UBaseWidget_GetMouseDelta_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BaseWidget.GetCenterScreenPosition
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector2D UBaseWidget::GetCenterScreenPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BaseWidget.GetCenterScreenPosition");
		
		UBaseWidget_GetCenterScreenPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BaseWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.StunDamage.ScriptedStunEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStunDamage::ScriptedStunEvent(class AReadyOrNotCharacter* Victim, float* Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.StunDamage.ScriptedStunEvent");
		
		UStunDamage_ScriptedStunEvent_Params params {};
		params.Victim = Victim;
		params.DamageEvent = DamageEvent;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Damage != nullptr)
			*Damage = params.Damage;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStunDamage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStunDamage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.StunDamage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBeanbagDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBeanbagDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BeanbagDamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BecomesWet.StartBecomingWet
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              WetnessRate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBecomesWet::StartBecomingWet(float WetnessRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BecomesWet.StartBecomingWet");
		
		UBecomesWet_StartBecomingWet_Params params {};
		params.WetnessRate = WetnessRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BecomesWet.StartBecomingDry
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DrynessRate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBecomesWet::StartBecomingDry(float DrynessRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BecomesWet.StartBecomingDry");
		
		UBecomesWet_StartBecomingDry_Params params {};
		params.DrynessRate = DrynessRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBecomesWet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBecomesWet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BecomesWet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BleedComponent.StopBleeding
	 * 		Flags  -> ()
	 */
	void UBleedComponent::StopBleeding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BleedComponent.StopBleeding");
		
		UBleedComponent_StopBleeding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BleedComponent.StartBleeding
	 * 		Flags  -> ()
	 */
	void UBleedComponent::StartBleeding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BleedComponent.StartBleeding");
		
		UBleedComponent_StartBleeding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BleedComponent.IsBleeding
	 * 		Flags  -> ()
	 */
	bool UBleedComponent::IsBleeding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BleedComponent.IsBleeding");
		
		UBleedComponent_IsBleeding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BleedComponent.GetHealCount
	 * 		Flags  -> ()
	 */
	float UBleedComponent::GetHealCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BleedComponent.GetHealCount");
		
		UBleedComponent_GetHealCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BleedComponent.GetBleedTime
	 * 		Flags  -> ()
	 */
	float UBleedComponent::GetBleedTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BleedComponent.GetBleedTime");
		
		UBleedComponent_GetBleedTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BleedComponent.DoHeal
	 * 		Flags  -> ()
	 */
	void UBleedComponent::DoHeal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BleedComponent.DoHeal");
		
		UBleedComponent_DoHeal_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BleedComponent.CanHeal
	 * 		Flags  -> ()
	 */
	bool UBleedComponent::CanHeal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BleedComponent.CanHeal");
		
		UBleedComponent_CanHeal_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBleedComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBleedComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BleedComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBleedDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBleedDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BleedDamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlendRagdollAnimNotifyState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlendRagdollAnimNotifyState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BlendRagdollAnimNotifyState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBloodData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBloodData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BloodData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABloodPool.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABloodPool::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BloodPool");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.BombActor.OnBombDefusedSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABombActor*                                  DefusedBomb                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABombActor::OnBombDefusedSignature__DelegateSignature(class ABombActor* DefusedBomb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.BombActor.OnBombDefusedSignature__DelegateSignature");
		
		ABombActor_OnBombDefusedSignature__DelegateSignature_Params params {};
		params.DefusedBomb = DefusedBomb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BombActor.Multicast_PlayBombExplodeSFX
	 * 		Flags  -> ()
	 */
	void ABombActor::Multicast_PlayBombExplodeSFX()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BombActor.Multicast_PlayBombExplodeSFX");
		
		ABombActor_Multicast_PlayBombExplodeSFX_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BombActor.GetBombState
	 * 		Flags  -> ()
	 */
	EBombState ABombActor::GetBombState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BombActor.GetBombState");
		
		ABombActor_GetBombState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BombActor.Explode
	 * 		Flags  -> ()
	 */
	void ABombActor::Explode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BombActor.Explode");
		
		ABombActor_Explode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABombActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABombActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BombActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.UnloadCustomizationLevels
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::UnloadCustomizationLevels(class UWorld* WorldContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.UnloadCustomizationLevels");
		
		UBpGameplayHelperLib_UnloadCustomizationLevels_Params params {};
		params.WorldContext = WorldContext;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.ToggleGrenadeDrawDebug
	 * 		Flags  -> ()
	 */
	void UBpGameplayHelperLib::ToggleGrenadeDrawDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.ToggleGrenadeDrawDebug");
		
		UBpGameplayHelperLib_ToggleGrenadeDrawDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.ToggleFriendlyNameplates
	 * 		Flags  -> ()
	 */
	void UBpGameplayHelperLib::ToggleFriendlyNameplates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.ToggleFriendlyNameplates");
		
		UBpGameplayHelperLib_ToggleFriendlyNameplates_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.ShowLoadoutOnMeshes
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSavedLoadout                               Loadout                                                    (Parm, NativeAccessSpecifierPublic)
	 * 		class USkeletalMeshComponent*                      BodyMesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMeshComponent*                      HeadMesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMeshComponent*                      ArmorMesh                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMeshComponent*                      ItemMesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStaticMeshComponent*                        ItemMagMesh                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::ShowLoadoutOnMeshes(const struct FSavedLoadout& Loadout, class USkeletalMeshComponent* BodyMesh, class USkeletalMeshComponent* HeadMesh, class USkeletalMeshComponent* ArmorMesh, class USkeletalMeshComponent* ItemMesh, class UStaticMeshComponent* ItemMagMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.ShowLoadoutOnMeshes");
		
		UBpGameplayHelperLib_ShowLoadoutOnMeshes_Params params {};
		params.Loadout = Loadout;
		params.BodyMesh = BodyMesh;
		params.HeadMesh = HeadMesh;
		params.ArmorMesh = ArmorMesh;
		params.ItemMesh = ItemMesh;
		params.ItemMagMesh = ItemMagMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetUseMeshpainting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bUseMeshPainting                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetUseMeshpainting(bool bUseMeshPainting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetUseMeshpainting");
		
		UBpGameplayHelperLib_SetUseMeshpainting_Params params {};
		params.bUseMeshPainting = bUseMeshPainting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetShowFPS
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowFPS                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetShowFPS(bool bShowFPS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetShowFPS");
		
		UBpGameplayHelperLib_SetShowFPS_Params params {};
		params.bShowFPS = bShowFPS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetShowControls
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowControls                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetShowControls(bool bShowControls)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetShowControls");
		
		UBpGameplayHelperLib_SetShowControls_Params params {};
		params.bShowControls = bShowControls;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetShellLifetime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ShellLifeTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetShellLifetime(float ShellLifeTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetShellLifetime");
		
		UBpGameplayHelperLib_SetShellLifetime_Params params {};
		params.ShellLifeTime = ShellLifeTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetSendMapStatistics
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSendMapStatistics                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetSendMapStatistics(bool bSendMapStatistics)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetSendMapStatistics");
		
		UBpGameplayHelperLib_SetSendMapStatistics_Params params {};
		params.bSendMapStatistics = bSendMapStatistics;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetPublicLobbyCooldown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetPublicLobbyCooldown(int32_t Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetPublicLobbyCooldown");
		
		UBpGameplayHelperLib_SetPublicLobbyCooldown_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetMouseSensitivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              MouseSensitivity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetMouseSensitivity(float MouseSensitivity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetMouseSensitivity");
		
		UBpGameplayHelperLib_SetMouseSensitivity_Params params {};
		params.MouseSensitivity = MouseSensitivity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetMouseInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInvertVertical                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInvertHorizontal                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetMouseInverted(bool bInvertVertical, bool bInvertHorizontal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetMouseInverted");
		
		UBpGameplayHelperLib_SetMouseInverted_Params params {};
		params.bInvertVertical = bInvertVertical;
		params.bInvertHorizontal = bInvertHorizontal;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetMicInputGain
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              MicInputGain                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetMicInputGain(float MicInputGain)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetMicInputGain");
		
		UBpGameplayHelperLib_SetMicInputGain_Params params {};
		params.MicInputGain = MicInputGain;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetLastConnectedServerIP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      IP                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetLastConnectedServerIP(const class FString& IP)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetLastConnectedServerIP");
		
		UBpGameplayHelperLib_SetLastConnectedServerIP_Params params {};
		params.IP = IP;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetFreelookSensitivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Sensitivity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetFreelookSensitivity(float Sensitivity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetFreelookSensitivity");
		
		UBpGameplayHelperLib_SetFreelookSensitivity_Params params {};
		params.Sensitivity = Sensitivity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetFoV
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              FOV                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetFoV(float FOV)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetFoV");
		
		UBpGameplayHelperLib_SetFoV_Params params {};
		params.FOV = FOV;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetFlashlightShadows
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFlashLightShadows                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetFlashlightShadows(bool bFlashLightShadows)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetFlashlightShadows");
		
		UBpGameplayHelperLib_SetFlashlightShadows_Params params {};
		params.bFlashLightShadows = bFlashLightShadows;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SetBounceLightEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bBounceLightEnabled                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SetBounceLightEnabled(bool bBounceLightEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SetBounceLightEnabled");
		
		UBpGameplayHelperLib_SetBounceLightEnabled_Params params {};
		params.bBounceLightEnabled = bBounceLightEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveZoomADSSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bZoomADS                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveZoomADSSetting(bool bZoomADS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveZoomADSSetting");
		
		UBpGameplayHelperLib_SaveZoomADSSetting_Params params {};
		params.bZoomADS = bZoomADS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveVOIPVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveVOIPVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveVOIPVolume");
		
		UBpGameplayHelperLib_SaveVOIPVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveUIVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveUIVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveUIVolume");
		
		UBpGameplayHelperLib_SaveUIVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveToggleADS
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               ToggleADS                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveToggleADS(bool ToggleADS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveToggleADS");
		
		UBpGameplayHelperLib_SaveToggleADS_Params params {};
		params.ToggleADS = ToggleADS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveTeamViewSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TeamViewFPS                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveTeamViewSetting(bool bEnabled, int32_t TeamViewFPS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveTeamViewSetting");
		
		UBpGameplayHelperLib_SaveTeamViewSetting_Params params {};
		params.bEnabled = bEnabled;
		params.TeamViewFPS = TeamViewFPS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveShowTeamStatus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowTeamStatus                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveShowTeamStatus(bool bShowTeamStatus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveShowTeamStatus");
		
		UBpGameplayHelperLib_SaveShowTeamStatus_Params params {};
		params.bShowTeamStatus = bShowTeamStatus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveShowPlayerIconSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowPlayerIcon                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveShowPlayerIconSetting(bool bShowPlayerIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveShowPlayerIconSetting");
		
		UBpGameplayHelperLib_SaveShowPlayerIconSetting_Params params {};
		params.bShowPlayerIcon = bShowPlayerIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveShowHUDSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowHUD                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveShowHUDSetting(bool bShowHUD)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveShowHUDSetting");
		
		UBpGameplayHelperLib_SaveShowHUDSetting_Params params {};
		params.bShowHUD = bShowHUD;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveShowHesitationBarSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowHesitationBar                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveShowHesitationBarSetting(bool bShowHesitationBar)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveShowHesitationBarSetting");
		
		UBpGameplayHelperLib_SaveShowHesitationBarSetting_Params params {};
		params.bShowHesitationBar = bShowHesitationBar;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveShowHealthIconSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowHealthIcons                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveShowHealthIconSetting(bool bShowHealthIcons)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveShowHealthIconSetting");
		
		UBpGameplayHelperLib_SaveShowHealthIconSetting_Params params {};
		params.bShowHealthIcons = bShowHealthIcons;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveShowCommandMarkersSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowCommandMarkers                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveShowCommandMarkersSetting(bool bShowCommandMarkers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveShowCommandMarkersSetting");
		
		UBpGameplayHelperLib_SaveShowCommandMarkersSetting_Params params {};
		params.bShowCommandMarkers = bShowCommandMarkers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveShowCommandContextHintSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowCommandContextHint                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveShowCommandContextHintSetting(bool bShowCommandContextHint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveShowCommandContextHintSetting");
		
		UBpGameplayHelperLib_SaveShowCommandContextHintSetting_Params params {};
		params.bShowCommandContextHint = bShowCommandContextHint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveShotgunSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EShotgunReloadType                                 ShotgunReloadType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveShotgunSettings(EShotgunReloadType ShotgunReloadType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveShotgunSettings");
		
		UBpGameplayHelperLib_SaveShotgunSettings_Params params {};
		params.ShotgunReloadType = ShotgunReloadType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveSFXVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveSFXVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveSFXVolume");
		
		UBpGameplayHelperLib_SaveSFXVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveSettings
	 * 		Flags  -> ()
	 */
	bool UBpGameplayHelperLib::SaveSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveSettings");
		
		UBpGameplayHelperLib_SaveSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveServersideChecksum
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bServerSideChecksumEnabled                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveServersideChecksum(bool bServerSideChecksumEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveServersideChecksum");
		
		UBpGameplayHelperLib_SaveServersideChecksum_Params params {};
		params.bServerSideChecksumEnabled = bServerSideChecksumEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveSelectedAudioDevice
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InAudioDevice                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveSelectedAudioDevice(const class FString& InAudioDevice)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveSelectedAudioDevice");
		
		UBpGameplayHelperLib_SaveSelectedAudioDevice_Params params {};
		params.InAudioDevice = InAudioDevice;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveScoreReadoutSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScoreReadoutMode                                  InScoreReadoutMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveScoreReadoutSetting(EScoreReadoutMode InScoreReadoutMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveScoreReadoutSetting");
		
		UBpGameplayHelperLib_SaveScoreReadoutSetting_Params params {};
		params.InScoreReadoutMode = InScoreReadoutMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveSafeZoneSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              SafeZoneX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SafeZoneY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveSafeZoneSettings(float SafeZoneX, float SafeZoneY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveSafeZoneSettings");
		
		UBpGameplayHelperLib_SaveSafeZoneSettings_Params params {};
		params.SafeZoneX = SafeZoneX;
		params.SafeZoneY = SafeZoneY;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SavePlayerDetails
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlayerDetails                              PlayerDetails                                              (Parm, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SavePlayerDetails(const struct FPlayerDetails& PlayerDetails)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SavePlayerDetails");
		
		UBpGameplayHelperLib_SavePlayerDetails_Params params {};
		params.PlayerDetails = PlayerDetails;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SavePiPResolutionScale
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ResolutionScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SavePiPResolutionScale(float ResolutionScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SavePiPResolutionScale");
		
		UBpGameplayHelperLib_SavePiPResolutionScale_Params params {};
		params.ResolutionScale = ResolutionScale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SavePiPFPS
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FPS                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SavePiPFPS(bool bEnabled, float FPS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SavePiPFPS");
		
		UBpGameplayHelperLib_SavePiPFPS_Params params {};
		params.bEnabled = bEnabled;
		params.FPS = FPS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveOptiwandViewMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EOptiwandViewMode                                  OptiwandViewMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveOptiwandViewMode(EOptiwandViewMode OptiwandViewMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveOptiwandViewMode");
		
		UBpGameplayHelperLib_SaveOptiwandViewMode_Params params {};
		params.OptiwandViewMode = OptiwandViewMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveNVGStyle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENVGStyle                                          NewNVGStyle                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveNVGStyle(ENVGStyle NewNVGStyle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveNVGStyle");
		
		UBpGameplayHelperLib_SaveNVGStyle_Params params {};
		params.NewNVGStyle = NewNVGStyle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveMusicVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveMusicVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveMusicVolume");
		
		UBpGameplayHelperLib_SaveMusicVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveMirrorResolutionScale
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ResolutionScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveMirrorResolutionScale(float ResolutionScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveMirrorResolutionScale");
		
		UBpGameplayHelperLib_SaveMirrorResolutionScale_Params params {};
		params.ResolutionScale = ResolutionScale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveMirrorReflectionEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveMirrorReflectionEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveMirrorReflectionEnabled");
		
		UBpGameplayHelperLib_SaveMirrorReflectionEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveMirrorEnabledOnlyInLobby
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveMirrorEnabledOnlyInLobby(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveMirrorEnabledOnlyInLobby");
		
		UBpGameplayHelperLib_SaveMirrorEnabledOnlyInLobby_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveMirrorDynamicShadowsEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowDynamicShadows                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveMirrorDynamicShadowsEnabled(bool bShowDynamicShadows)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveMirrorDynamicShadowsEnabled");
		
		UBpGameplayHelperLib_SaveMirrorDynamicShadowsEnabled_Params params {};
		params.bShowDynamicShadows = bShowDynamicShadows;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveMirrorDecalsEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowDecals                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveMirrorDecalsEnabled(bool bShowDecals)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveMirrorDecalsEnabled");
		
		UBpGameplayHelperLib_SaveMirrorDecalsEnabled_Params params {};
		params.bShowDecals = bShowDecals;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveMirrorAntiAliasEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowAntiAlias                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveMirrorAntiAliasEnabled(bool bShowAntiAlias)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveMirrorAntiAliasEnabled");
		
		UBpGameplayHelperLib_SaveMirrorAntiAliasEnabled_Params params {};
		params.bShowAntiAlias = bShowAntiAlias;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveMaxShellsInWorld
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewMaxShells                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveMaxShellsInWorld(int32_t NewMaxShells)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveMaxShellsInWorld");
		
		UBpGameplayHelperLib_SaveMaxShellsInWorld_Params params {};
		params.NewMaxShells = NewMaxShells;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveMasterVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveMasterVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveMasterVolume");
		
		UBpGameplayHelperLib_SaveMasterVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSavedLoadout                               Loadout                                                    (Parm, NativeAccessSpecifierPublic)
	 * 		class FString                                      LoadoutName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveLoadout(const struct FSavedLoadout& Loadout, const class FString& LoadoutName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveLoadout");
		
		UBpGameplayHelperLib_SaveLoadout_Params params {};
		params.Loadout = Loadout;
		params.LoadoutName = LoadoutName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveLicenseSave
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ULicenseSave*                                LevelStats                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::SaveLicenseSave(class ULicenseSave* LevelStats)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveLicenseSave");
		
		UBpGameplayHelperLib_SaveLicenseSave_Params params {};
		params.LevelStats = LevelStats;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveItemSelectionStyleSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemSelectionInterfaceType                        ItemSelectionInterface                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveItemSelectionStyleSettings(EItemSelectionInterfaceType ItemSelectionInterface)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveItemSelectionStyleSettings");
		
		UBpGameplayHelperLib_SaveItemSelectionStyleSettings_Params params {};
		params.ItemSelectionInterface = ItemSelectionInterface;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveHUDSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowHUD                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCurvedHUD                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowCompass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ShowWeaponHUD                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowMagazineHUD                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowChat                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSwayHUD                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               b2DReload                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              IconScale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              QuickThrowScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            FireModeDisplayOption                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowMultiplayerNames                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowButtonPrompts                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveHUDSettings(bool bShowHUD, bool bCurvedHUD, bool bShowCompass, bool ShowWeaponHUD, bool bShowMagazineHUD, bool bShowChat, bool bSwayHUD, bool b2DReload, float IconScale, float QuickThrowScale, int32_t FireModeDisplayOption, bool bShowMultiplayerNames, bool bShowButtonPrompts)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveHUDSettings");
		
		UBpGameplayHelperLib_SaveHUDSettings_Params params {};
		params.bShowHUD = bShowHUD;
		params.bCurvedHUD = bCurvedHUD;
		params.bShowCompass = bShowCompass;
		params.ShowWeaponHUD = ShowWeaponHUD;
		params.bShowMagazineHUD = bShowMagazineHUD;
		params.bShowChat = bShowChat;
		params.bSwayHUD = bSwayHUD;
		params.b2DReload = b2DReload;
		params.IconScale = IconScale;
		params.QuickThrowScale = QuickThrowScale;
		params.FireModeDisplayOption = FireModeDisplayOption;
		params.bShowMultiplayerNames = bShowMultiplayerNames;
		params.bShowButtonPrompts = bShowButtonPrompts;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveHotkeyHintSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowHotkeyHint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveHotkeyHintSetting(bool bShowHotkeyHint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveHotkeyHintSetting");
		
		UBpGameplayHelperLib_SaveHotkeyHintSetting_Params params {};
		params.bShowHotkeyHint = bShowHotkeyHint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveHitmarkerSfxEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHitmarkerSfxEnabled                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveHitmarkerSfxEnabled(bool bHitmarkerSfxEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveHitmarkerSfxEnabled");
		
		UBpGameplayHelperLib_SaveHitmarkerSfxEnabled_Params params {};
		params.bHitmarkerSfxEnabled = bHitmarkerSfxEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveGrenadeSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGrenadeThrowSettingType                           GrenadeThrowType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveGrenadeSettings(EGrenadeThrowSettingType GrenadeThrowType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveGrenadeSettings");
		
		UBpGameplayHelperLib_SaveGrenadeSettings_Params params {};
		params.GrenadeThrowType = GrenadeThrowType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveEmptyMagReloadSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEmptyMagReloadType                                EmptyMagReloadType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveEmptyMagReloadSettings(EEmptyMagReloadType EmptyMagReloadType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveEmptyMagReloadSettings");
		
		UBpGameplayHelperLib_SaveEmptyMagReloadSettings_Params params {};
		params.EmptyMagReloadType = EmptyMagReloadType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveDefaultCommandAsOption
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            DefaultCommandOption                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DefaultDoorUnknownCommandOption                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DefaultDoorOpenCommandOption                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DefaultDoorLockedCommandOption                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DefaultDoorUnlockedCommandOption                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveDefaultCommandAsOption(int32_t DefaultCommandOption, int32_t DefaultDoorUnknownCommandOption, int32_t DefaultDoorOpenCommandOption, int32_t DefaultDoorLockedCommandOption, int32_t DefaultDoorUnlockedCommandOption)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveDefaultCommandAsOption");
		
		UBpGameplayHelperLib_SaveDefaultCommandAsOption_Params params {};
		params.DefaultCommandOption = DefaultCommandOption;
		params.DefaultDoorUnknownCommandOption = DefaultDoorUnknownCommandOption;
		params.DefaultDoorOpenCommandOption = DefaultDoorOpenCommandOption;
		params.DefaultDoorLockedCommandOption = DefaultDoorLockedCommandOption;
		params.DefaultDoorUnlockedCommandOption = DefaultDoorUnlockedCommandOption;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.SaveDefaultCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESwatCommand                                       DefaultCommand                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESwatCommand                                       DefaultDoorUnknownCommand                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESwatCommand                                       DefaultDoorOpenCommand                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESwatCommand                                       DefaultDoorLockedCommand                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESwatCommand                                       DefaultDoorUnlockedCommand                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::SaveDefaultCommand(ESwatCommand DefaultCommand, ESwatCommand DefaultDoorUnknownCommand, ESwatCommand DefaultDoorOpenCommand, ESwatCommand DefaultDoorLockedCommand, ESwatCommand DefaultDoorUnlockedCommand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.SaveDefaultCommand");
		
		UBpGameplayHelperLib_SaveDefaultCommand_Params params {};
		params.DefaultCommand = DefaultCommand;
		params.DefaultDoorUnknownCommand = DefaultDoorUnknownCommand;
		params.DefaultDoorOpenCommand = DefaultDoorOpenCommand;
		params.DefaultDoorLockedCommand = DefaultDoorLockedCommand;
		params.DefaultDoorUnlockedCommand = DefaultDoorUnlockedCommand;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.RemoveWidgetFromViewport
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      WidgetName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::RemoveWidgetFromViewport(const class FString& WidgetName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.RemoveWidgetFromViewport");
		
		UBpGameplayHelperLib_RemoveWidgetFromViewport_Params params {};
		params.WidgetName = WidgetName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.ReloadSettings
	 * 		Flags  -> ()
	 */
	bool UBpGameplayHelperLib::ReloadSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.ReloadSettings");
		
		UBpGameplayHelperLib_ReloadSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.PlayInterfaceSound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInterfaceSoundType                                SoundClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::PlayInterfaceSound(class UWorld* WorldContext, EInterfaceSoundType SoundClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.PlayInterfaceSound");
		
		UBpGameplayHelperLib_PlayInterfaceSound_Params params {};
		params.WorldContext = WorldContext;
		params.SoundClass = SoundClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadZoomADSSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bZoomADS                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadZoomADSSetting(bool* bZoomADS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadZoomADSSetting");
		
		UBpGameplayHelperLib_LoadZoomADSSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bZoomADS != nullptr)
			*bZoomADS = params.bZoomADS;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadToggleADS
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               ToggleADS                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadToggleADS(bool* ToggleADS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadToggleADS");
		
		UBpGameplayHelperLib_LoadToggleADS_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ToggleADS != nullptr)
			*ToggleADS = params.ToggleADS;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadTeamViewFPSSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TeamViewFPS                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadTeamViewFPSSetting(bool* bEnabled, int32_t* TeamViewFPS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadTeamViewFPSSetting");
		
		UBpGameplayHelperLib_LoadTeamViewFPSSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bEnabled != nullptr)
			*bEnabled = params.bEnabled;
		if (TeamViewFPS != nullptr)
			*TeamViewFPS = params.TeamViewFPS;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadShowTeamStatus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowTeamStatus                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadShowTeamStatus(bool* bShowTeamStatus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadShowTeamStatus");
		
		UBpGameplayHelperLib_LoadShowTeamStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowTeamStatus != nullptr)
			*bShowTeamStatus = params.bShowTeamStatus;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadShowPlayerNamesSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowPlayerNames                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadShowPlayerNamesSetting(bool* bShowPlayerNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadShowPlayerNamesSetting");
		
		UBpGameplayHelperLib_LoadShowPlayerNamesSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowPlayerNames != nullptr)
			*bShowPlayerNames = params.bShowPlayerNames;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadShowPlayerIconSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowPlayerIcon                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadShowPlayerIconSetting(bool* bShowPlayerIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadShowPlayerIconSetting");
		
		UBpGameplayHelperLib_LoadShowPlayerIconSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowPlayerIcon != nullptr)
			*bShowPlayerIcon = params.bShowPlayerIcon;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadShowHUDSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowHUD                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadShowHUDSetting(bool* bShowHUD)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadShowHUDSetting");
		
		UBpGameplayHelperLib_LoadShowHUDSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowHUD != nullptr)
			*bShowHUD = params.bShowHUD;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadShowHesitationBarSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowHesitationBar                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadShowHesitationBarSetting(bool* bShowHesitationBar)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadShowHesitationBarSetting");
		
		UBpGameplayHelperLib_LoadShowHesitationBarSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowHesitationBar != nullptr)
			*bShowHesitationBar = params.bShowHesitationBar;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadShowHealthIconSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowHealthIcons                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadShowHealthIconSetting(bool* bShowHealthIcons)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadShowHealthIconSetting");
		
		UBpGameplayHelperLib_LoadShowHealthIconSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowHealthIcons != nullptr)
			*bShowHealthIcons = params.bShowHealthIcons;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadShowCommandMarkersSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowCommandMarkers                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadShowCommandMarkersSetting(bool* bShowCommandMarkers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadShowCommandMarkersSetting");
		
		UBpGameplayHelperLib_LoadShowCommandMarkersSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowCommandMarkers != nullptr)
			*bShowCommandMarkers = params.bShowCommandMarkers;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadShowCommandContextHintSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowCommandContextHint                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadShowCommandContextHintSetting(bool* bShowCommandContextHint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadShowCommandContextHintSetting");
		
		UBpGameplayHelperLib_LoadShowCommandContextHintSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowCommandContextHint != nullptr)
			*bShowCommandContextHint = params.bShowCommandContextHint;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadShotgunSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EShotgunReloadType                                 ShotgunReloadType                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadShotgunSettings(EShotgunReloadType* ShotgunReloadType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadShotgunSettings");
		
		UBpGameplayHelperLib_LoadShotgunSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ShotgunReloadType != nullptr)
			*ShotgunReloadType = params.ShotgunReloadType;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadServersideChecksum
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bServerSideChecksumEnabled                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadServersideChecksum(bool* bServerSideChecksumEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadServersideChecksum");
		
		UBpGameplayHelperLib_LoadServersideChecksum_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bServerSideChecksumEnabled != nullptr)
			*bServerSideChecksumEnabled = params.bServerSideChecksumEnabled;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadSelectedAudioDevice
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      OutAudioDevice                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadSelectedAudioDevice(class FString* OutAudioDevice)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadSelectedAudioDevice");
		
		UBpGameplayHelperLib_LoadSelectedAudioDevice_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutAudioDevice != nullptr)
			*OutAudioDevice = params.OutAudioDevice;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadScoreReadoutSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScoreReadoutMode                                  OutScoreReadoutMode                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadScoreReadoutSetting(EScoreReadoutMode* OutScoreReadoutMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadScoreReadoutSetting");
		
		UBpGameplayHelperLib_LoadScoreReadoutSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutScoreReadoutMode != nullptr)
			*OutScoreReadoutMode = params.OutScoreReadoutMode;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadSafeZoneSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              SafeZoneX                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SafeZoneY                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadSafeZoneSettings(float* SafeZoneX, float* SafeZoneY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadSafeZoneSettings");
		
		UBpGameplayHelperLib_LoadSafeZoneSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SafeZoneX != nullptr)
			*SafeZoneX = params.SafeZoneX;
		if (SafeZoneY != nullptr)
			*SafeZoneY = params.SafeZoneY;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadPlayerDetails
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlayerDetails                              PlayerDetails                                              (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadPlayerDetails(struct FPlayerDetails* PlayerDetails)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadPlayerDetails");
		
		UBpGameplayHelperLib_LoadPlayerDetails_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PlayerDetails != nullptr)
			*PlayerDetails = params.PlayerDetails;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadPiPResolutionScale
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ResolutionScale                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadPiPResolutionScale(float* ResolutionScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadPiPResolutionScale");
		
		UBpGameplayHelperLib_LoadPiPResolutionScale_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ResolutionScale != nullptr)
			*ResolutionScale = params.ResolutionScale;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadPiPFPS
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FPS                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadPiPFPS(bool* bEnabled, float* FPS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadPiPFPS");
		
		UBpGameplayHelperLib_LoadPiPFPS_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bEnabled != nullptr)
			*bEnabled = params.bEnabled;
		if (FPS != nullptr)
			*FPS = params.FPS;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadOptiwandViewMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EOptiwandViewMode                                  OptiwandViewMode                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadOptiwandViewMode(EOptiwandViewMode* OptiwandViewMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadOptiwandViewMode");
		
		UBpGameplayHelperLib_LoadOptiwandViewMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OptiwandViewMode != nullptr)
			*OptiwandViewMode = params.OptiwandViewMode;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadNVGStyle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENVGStyle                                          NVGStyle                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadNVGStyle(ENVGStyle* NVGStyle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadNVGStyle");
		
		UBpGameplayHelperLib_LoadNVGStyle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (NVGStyle != nullptr)
			*NVGStyle = params.NVGStyle;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadMirrorResolutionScale
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ResolutionScale                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadMirrorResolutionScale(float* ResolutionScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadMirrorResolutionScale");
		
		UBpGameplayHelperLib_LoadMirrorResolutionScale_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ResolutionScale != nullptr)
			*ResolutionScale = params.ResolutionScale;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadMirrorReflectionEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadMirrorReflectionEnabled(bool* bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadMirrorReflectionEnabled");
		
		UBpGameplayHelperLib_LoadMirrorReflectionEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bEnabled != nullptr)
			*bEnabled = params.bEnabled;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadMirrorEnabledOnlyInLobby
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadMirrorEnabledOnlyInLobby(bool* bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadMirrorEnabledOnlyInLobby");
		
		UBpGameplayHelperLib_LoadMirrorEnabledOnlyInLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bEnabled != nullptr)
			*bEnabled = params.bEnabled;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadMirrorDynamicShadowsEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowDynamicShadows                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadMirrorDynamicShadowsEnabled(bool* bShowDynamicShadows)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadMirrorDynamicShadowsEnabled");
		
		UBpGameplayHelperLib_LoadMirrorDynamicShadowsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowDynamicShadows != nullptr)
			*bShowDynamicShadows = params.bShowDynamicShadows;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadMirrorDecalsEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowDecals                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadMirrorDecalsEnabled(bool* bShowDecals)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadMirrorDecalsEnabled");
		
		UBpGameplayHelperLib_LoadMirrorDecalsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowDecals != nullptr)
			*bShowDecals = params.bShowDecals;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadMirrorAntiAliasEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowAntiAlias                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadMirrorAntiAliasEnabled(bool* bShowAntiAlias)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadMirrorAntiAliasEnabled");
		
		UBpGameplayHelperLib_LoadMirrorAntiAliasEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowAntiAlias != nullptr)
			*bShowAntiAlias = params.bShowAntiAlias;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadMaxShellsInWorld
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            MaxShells                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadMaxShellsInWorld(int32_t* MaxShells)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadMaxShellsInWorld");
		
		UBpGameplayHelperLib_LoadMaxShellsInWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MaxShells != nullptr)
			*MaxShells = params.MaxShells;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadLoadoutAndEquipPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSavedLoadout                               Loadout                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        EquipPlayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      LoadoutName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadLoadoutAndEquipPlayer(struct FSavedLoadout* Loadout, class AReadyOrNotCharacter* EquipPlayer, const class FString& LoadoutName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadLoadoutAndEquipPlayer");
		
		UBpGameplayHelperLib_LoadLoadoutAndEquipPlayer_Params params {};
		params.EquipPlayer = EquipPlayer;
		params.LoadoutName = LoadoutName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Loadout != nullptr)
			*Loadout = params.Loadout;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSavedLoadout                               Loadout                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      LoadoutName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadLoadout(struct FSavedLoadout* Loadout, const class FString& LoadoutName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadLoadout");
		
		UBpGameplayHelperLib_LoadLoadout_Params params {};
		params.LoadoutName = LoadoutName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Loadout != nullptr)
			*Loadout = params.Loadout;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadLicenseSave
	 * 		Flags  -> ()
	 */
	class ULicenseSave* UBpGameplayHelperLib::LoadLicenseSave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadLicenseSave");
		
		UBpGameplayHelperLib_LoadLicenseSave_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadItemSelectionStyleSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemSelectionInterfaceType                        ItemSelectionInterface                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadItemSelectionStyleSettings(EItemSelectionInterfaceType* ItemSelectionInterface)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadItemSelectionStyleSettings");
		
		UBpGameplayHelperLib_LoadItemSelectionStyleSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ItemSelectionInterface != nullptr)
			*ItemSelectionInterface = params.ItemSelectionInterface;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadHUDSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowHUD                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCurvedHUD                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowCompass                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowWeaponHUD                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowMagazineHUD                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowChat                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSwayHUD                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               b2DReload                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              IconScale                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              QuickThrowScale                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            FireModeDisplayOption                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowPlayerNames                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowButtonPrompts                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadHUDSettings(bool* bShowHUD, bool* bCurvedHUD, bool* bShowCompass, bool* bShowWeaponHUD, bool* bShowMagazineHUD, bool* bShowChat, bool* bSwayHUD, bool* b2DReload, float* IconScale, float* QuickThrowScale, int32_t* FireModeDisplayOption, bool* bShowPlayerNames, bool* bShowButtonPrompts)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadHUDSettings");
		
		UBpGameplayHelperLib_LoadHUDSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowHUD != nullptr)
			*bShowHUD = params.bShowHUD;
		if (bCurvedHUD != nullptr)
			*bCurvedHUD = params.bCurvedHUD;
		if (bShowCompass != nullptr)
			*bShowCompass = params.bShowCompass;
		if (bShowWeaponHUD != nullptr)
			*bShowWeaponHUD = params.bShowWeaponHUD;
		if (bShowMagazineHUD != nullptr)
			*bShowMagazineHUD = params.bShowMagazineHUD;
		if (bShowChat != nullptr)
			*bShowChat = params.bShowChat;
		if (bSwayHUD != nullptr)
			*bSwayHUD = params.bSwayHUD;
		if (b2DReload != nullptr)
			*b2DReload = params.b2DReload;
		if (IconScale != nullptr)
			*IconScale = params.IconScale;
		if (QuickThrowScale != nullptr)
			*QuickThrowScale = params.QuickThrowScale;
		if (FireModeDisplayOption != nullptr)
			*FireModeDisplayOption = params.FireModeDisplayOption;
		if (bShowPlayerNames != nullptr)
			*bShowPlayerNames = params.bShowPlayerNames;
		if (bShowButtonPrompts != nullptr)
			*bShowButtonPrompts = params.bShowButtonPrompts;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadHotkeyHintSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowHotkeyHint                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadHotkeyHintSetting(bool* bShowHotkeyHint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadHotkeyHintSetting");
		
		UBpGameplayHelperLib_LoadHotkeyHintSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowHotkeyHint != nullptr)
			*bShowHotkeyHint = params.bShowHotkeyHint;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadGrenadeSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGrenadeThrowSettingType                           GrenadeThrowType                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadGrenadeSettings(EGrenadeThrowSettingType* GrenadeThrowType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadGrenadeSettings");
		
		UBpGameplayHelperLib_LoadGrenadeSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (GrenadeThrowType != nullptr)
			*GrenadeThrowType = params.GrenadeThrowType;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadEmptyMagReloadSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEmptyMagReloadType                                EmptyMagReloadType                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadEmptyMagReloadSettings(EEmptyMagReloadType* EmptyMagReloadType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadEmptyMagReloadSettings");
		
		UBpGameplayHelperLib_LoadEmptyMagReloadSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (EmptyMagReloadType != nullptr)
			*EmptyMagReloadType = params.EmptyMagReloadType;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadDefaultCommandsAsOption
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            DefaultCommandOption                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DefaultDoorUnknownCommandOption                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DefaultDoorOpenCommandOption                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DefaultDoorLockedCommandOption                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DefaultDoorUnlockedCommandOption                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadDefaultCommandsAsOption(int32_t* DefaultCommandOption, int32_t* DefaultDoorUnknownCommandOption, int32_t* DefaultDoorOpenCommandOption, int32_t* DefaultDoorLockedCommandOption, int32_t* DefaultDoorUnlockedCommandOption)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadDefaultCommandsAsOption");
		
		UBpGameplayHelperLib_LoadDefaultCommandsAsOption_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DefaultCommandOption != nullptr)
			*DefaultCommandOption = params.DefaultCommandOption;
		if (DefaultDoorUnknownCommandOption != nullptr)
			*DefaultDoorUnknownCommandOption = params.DefaultDoorUnknownCommandOption;
		if (DefaultDoorOpenCommandOption != nullptr)
			*DefaultDoorOpenCommandOption = params.DefaultDoorOpenCommandOption;
		if (DefaultDoorLockedCommandOption != nullptr)
			*DefaultDoorLockedCommandOption = params.DefaultDoorLockedCommandOption;
		if (DefaultDoorUnlockedCommandOption != nullptr)
			*DefaultDoorUnlockedCommandOption = params.DefaultDoorUnlockedCommandOption;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadDefaultCommands
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESwatCommand                                       DefaultCommand                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESwatCommand                                       DefaultDoorUnknownCommand                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESwatCommand                                       DefaultDoorOpenCommand                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESwatCommand                                       DefaultDoorLockedCommand                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESwatCommand                                       DefaultDoorUnlockedCommand                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::LoadDefaultCommands(ESwatCommand* DefaultCommand, ESwatCommand* DefaultDoorUnknownCommand, ESwatCommand* DefaultDoorOpenCommand, ESwatCommand* DefaultDoorLockedCommand, ESwatCommand* DefaultDoorUnlockedCommand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadDefaultCommands");
		
		UBpGameplayHelperLib_LoadDefaultCommands_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DefaultCommand != nullptr)
			*DefaultCommand = params.DefaultCommand;
		if (DefaultDoorUnknownCommand != nullptr)
			*DefaultDoorUnknownCommand = params.DefaultDoorUnknownCommand;
		if (DefaultDoorOpenCommand != nullptr)
			*DefaultDoorOpenCommand = params.DefaultDoorOpenCommand;
		if (DefaultDoorLockedCommand != nullptr)
			*DefaultDoorLockedCommand = params.DefaultDoorLockedCommand;
		if (DefaultDoorUnlockedCommand != nullptr)
			*DefaultDoorUnlockedCommand = params.DefaultDoorUnlockedCommand;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.LoadCustomizationLevels
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::LoadCustomizationLevels(class UWorld* WorldContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.LoadCustomizationLevels");
		
		UBpGameplayHelperLib_LoadCustomizationLevels_Params params {};
		params.WorldContext = WorldContext;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsSupporterOnlyBuild
	 * 		Flags  -> ()
	 */
	bool UBpGameplayHelperLib::IsSupporterOnlyBuild()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsSupporterOnlyBuild");
		
		UBpGameplayHelperLib_IsSupporterOnlyBuild_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsShowHUDEnabled
	 * 		Flags  -> ()
	 */
	bool UBpGameplayHelperLib::IsShowHUDEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsShowHUDEnabled");
		
		UBpGameplayHelperLib_IsShowHUDEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsShippingBuild
	 * 		Flags  -> ()
	 */
	bool UBpGameplayHelperLib::IsShippingBuild()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsShippingBuild");
		
		UBpGameplayHelperLib_IsShippingBuild_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsRTXDMOBuild
	 * 		Flags  -> ()
	 */
	bool UBpGameplayHelperLib::IsRTXDMOBuild()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsRTXDMOBuild");
		
		UBpGameplayHelperLib_IsRTXDMOBuild_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsPvPSupported
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLevelDataLookupTable                       LookupTable                                                (Parm, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::IsPvPSupported(const struct FLevelDataLookupTable& LookupTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsPvPSupported");
		
		UBpGameplayHelperLib_IsPvPSupported_Params params {};
		params.LookupTable = LookupTable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsPreMissionBriefingBeforeLoadout
	 * 		Flags  -> ()
	 */
	bool UBpGameplayHelperLib::IsPreMissionBriefingBeforeLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsPreMissionBriefingBeforeLoadout");
		
		UBpGameplayHelperLib_IsPreMissionBriefingBeforeLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsObjectiveTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        LocalPlayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::IsObjectiveTarget(class AReadyOrNotCharacter* Target, class AReadyOrNotCharacter* LocalPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsObjectiveTarget");
		
		UBpGameplayHelperLib_IsObjectiveTarget_Params params {};
		params.Target = Target;
		params.LocalPlayer = LocalPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsInPublicLobbyCooldown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              SecondsRemaining                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::IsInPublicLobbyCooldown(float* SecondsRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsInPublicLobbyCooldown");
		
		UBpGameplayHelperLib_IsInPublicLobbyCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SecondsRemaining != nullptr)
			*SecondsRemaining = params.SecondsRemaining;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsFriendly
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotGameState*                        GameState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamOne                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamTwo                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::IsFriendly(class AReadyOrNotGameState* GameState, ETeamType TeamOne, ETeamType TeamTwo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsFriendly");
		
		UBpGameplayHelperLib_IsFriendly_Params params {};
		params.GameState = GameState;
		params.TeamOne = TeamOne;
		params.TeamTwo = TeamTwo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsEnemy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          TeamOne                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamTwo                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::IsEnemy(ETeamType TeamOne, ETeamType TeamTwo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsEnemy");
		
		UBpGameplayHelperLib_IsEnemy_Params params {};
		params.TeamOne = TeamOne;
		params.TeamTwo = TeamTwo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsEditorBuild
	 * 		Flags  -> ()
	 */
	bool UBpGameplayHelperLib::IsEditorBuild()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsEditorBuild");
		
		UBpGameplayHelperLib_IsEditorBuild_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsDMOPVPOnly
	 * 		Flags  -> ()
	 */
	bool UBpGameplayHelperLib::IsDMOPVPOnly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsDMOPVPOnly");
		
		UBpGameplayHelperLib_IsDMOPVPOnly_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsDMOMatchMake
	 * 		Flags  -> ()
	 */
	bool UBpGameplayHelperLib::IsDMOMatchMake()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsDMOMatchMake");
		
		UBpGameplayHelperLib_IsDMOMatchMake_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsDMOBuild
	 * 		Flags  -> ()
	 */
	bool UBpGameplayHelperLib::IsDMOBuild()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsDMOBuild");
		
		UBpGameplayHelperLib_IsDMOBuild_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsDLCLocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::IsDLCLocked(class UClass* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsDLCLocked");
		
		UBpGameplayHelperLib_IsDLCLocked_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.IsCOOPSupported
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLevelDataLookupTable                       LookupTable                                                (Parm, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::IsCOOPSupported(const struct FLevelDataLookupTable& LookupTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.IsCOOPSupported");
		
		UBpGameplayHelperLib_IsCOOPSupported_Params params {};
		params.LookupTable = LookupTable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.HasWidgetInViewport
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      WidgetName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::HasWidgetInViewport(const class FString& WidgetName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.HasWidgetInViewport");
		
		UBpGameplayHelperLib_HasWidgetInViewport_Params params {};
		params.WidgetName = WidgetName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.HasLineOfSightLoc
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              ignoredActors                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		ECollisionChannel                                  CollisionChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::HasLineOfSightLoc(class UWorld* WorldContext, const struct FCoreUObject_FVector& A, const struct FCoreUObject_FVector& B, TArray<class AActor*> ignoredActors, ECollisionChannel CollisionChannel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.HasLineOfSightLoc");
		
		UBpGameplayHelperLib_HasLineOfSightLoc_Params params {};
		params.WorldContext = WorldContext;
		params.A = A;
		params.B = B;
		params.ignoredActors = ignoredActors;
		params.CollisionChannel = CollisionChannel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.HasLineOfSightExt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Observer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::HasLineOfSightExt(class AActor* Observer, class AActor* B, struct FHitResult* HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.HasLineOfSightExt");
		
		UBpGameplayHelperLib_HasLineOfSightExt_Params params {};
		params.Observer = Observer;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (HitResult != nullptr)
			*HitResult = params.HitResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.HasLineOfSight
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Observer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::HasLineOfSight(class AActor* Observer, class AActor* B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.HasLineOfSight");
		
		UBpGameplayHelperLib_HasLineOfSight_Params params {};
		params.Observer = Observer;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetWorldStatic
	 * 		Flags  -> ()
	 */
	class UWorld* UBpGameplayHelperLib::GetWorldStatic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetWorldStatic");
		
		UBpGameplayHelperLib_GetWorldStatic_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetWorldBP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UWorld* UBpGameplayHelperLib::GetWorldBP(class APlayerController* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetWorldBP");
		
		UBpGameplayHelperLib_GetWorldBP_Params params {};
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetWidgetsFromViewport
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      WidgetName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UUserWidget*> UBpGameplayHelperLib::GetWidgetsFromViewport(const class FString& WidgetName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetWidgetsFromViewport");
		
		UBpGameplayHelperLib_GetWidgetsFromViewport_Params params {};
		params.WidgetName = WidgetName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetWidgetDataFromLookupData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      WidgetName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FWidgetLookupData UBpGameplayHelperLib::GetWidgetDataFromLookupData(const class FString& WidgetName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetWidgetDataFromLookupData");
		
		UBpGameplayHelperLib_GetWidgetDataFromLookupData_Params params {};
		params.WidgetName = WidgetName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetWidgetData
	 * 		Flags  -> ()
	 */
	class UWidgetsData* UBpGameplayHelperLib::GetWidgetData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetWidgetData");
		
		UBpGameplayHelperLib_GetWidgetData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetVolumes
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              MasterVolume                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              UIVolume                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SFXVolume                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MusicVolume                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              VOIPVolume                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetVolumes(float* MasterVolume, float* UIVolume, float* SFXVolume, float* MusicVolume, float* VOIPVolume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetVolumes");
		
		UBpGameplayHelperLib_GetVolumes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MasterVolume != nullptr)
			*MasterVolume = params.MasterVolume;
		if (UIVolume != nullptr)
			*UIVolume = params.UIVolume;
		if (SFXVolume != nullptr)
			*SFXVolume = params.SFXVolume;
		if (MusicVolume != nullptr)
			*MusicVolume = params.MusicVolume;
		if (VOIPVolume != nullptr)
			*VOIPVolume = params.VOIPVolume;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetUseMeshpainting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bUseMeshPainting                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetUseMeshpainting(bool* bUseMeshPainting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetUseMeshpainting");
		
		UBpGameplayHelperLib_GetUseMeshpainting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bUseMeshPainting != nullptr)
			*bUseMeshPainting = params.bUseMeshPainting;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetTrapLookupDataTable
	 * 		Flags  -> ()
	 */
	class UDataTable* UBpGameplayHelperLib::GetTrapLookupDataTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetTrapLookupDataTable");
		
		UBpGameplayHelperLib_GetTrapLookupDataTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetSuspectArmourDataTable
	 * 		Flags  -> ()
	 */
	class UDataTable* UBpGameplayHelperLib::GetSuspectArmourDataTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetSuspectArmourDataTable");
		
		UBpGameplayHelperLib_GetSuspectArmourDataTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetSpeechLookupDataTable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Speaker                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDataTable* UBpGameplayHelperLib::GetSpeechLookupDataTable(const class FString& Speaker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetSpeechLookupDataTable");
		
		UBpGameplayHelperLib_GetSpeechLookupDataTable_Params params {};
		params.Speaker = Speaker;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetSingleplayerProfile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      LoadSlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UReadyOrNotSingleplayerProfile* UBpGameplayHelperLib::GetSingleplayerProfile(const class FString& LoadSlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetSingleplayerProfile");
		
		UBpGameplayHelperLib_GetSingleplayerProfile_Params params {};
		params.LoadSlotName = LoadSlotName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetShowFPS
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowFPS                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetShowFPS(bool* bShowFPS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetShowFPS");
		
		UBpGameplayHelperLib_GetShowFPS_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowFPS != nullptr)
			*bShowFPS = params.bShowFPS;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetShowControls
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowControls                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetShowControls(bool* bShowControls)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetShowControls");
		
		UBpGameplayHelperLib_GetShowControls_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShowControls != nullptr)
			*bShowControls = params.bShowControls;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetShellLifetime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ShellLifeTime                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetShellLifetime(float* ShellLifeTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetShellLifetime");
		
		UBpGameplayHelperLib_GetShellLifetime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ShellLifeTime != nullptr)
			*ShellLifeTime = params.ShellLifeTime;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetSendMapStatistics
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSendMapStatistics                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetSendMapStatistics(bool* bSendMapStatistics)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetSendMapStatistics");
		
		UBpGameplayHelperLib_GetSendMapStatistics_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bSendMapStatistics != nullptr)
			*bSendMapStatistics = params.bSendMapStatistics;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetRONGameInstance
	 * 		Flags  -> ()
	 */
	class UReadyOrNotGameInstance* UBpGameplayHelperLib::GetRONGameInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetRONGameInstance");
		
		UBpGameplayHelperLib_GetRONGameInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetRoNData
	 * 		Flags  -> ()
	 */
	class UDataSingleton* UBpGameplayHelperLib::GetRoNData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetRoNData");
		
		UBpGameplayHelperLib_GetRoNData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetRandomLoadingScreenTip
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Tip                                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetRandomLoadingScreenTip(class FText* Tip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetRandomLoadingScreenTip");
		
		UBpGameplayHelperLib_GetRandomLoadingScreenTip_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Tip != nullptr)
			*Tip = params.Tip;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetRadialDamageData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRadialDamageEvent                          DamageEvent                                                (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Origin                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BaseDamage                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinimumDamage                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InnerRadius                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OuterRadius                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DamageFalloff                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::GetRadialDamageData(const struct FRadialDamageEvent& DamageEvent, struct FCoreUObject_FVector* Origin, float* BaseDamage, float* MinimumDamage, float* InnerRadius, float* OuterRadius, float* DamageFalloff)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetRadialDamageData");
		
		UBpGameplayHelperLib_GetRadialDamageData_Params params {};
		params.DamageEvent = DamageEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Origin != nullptr)
			*Origin = params.Origin;
		if (BaseDamage != nullptr)
			*BaseDamage = params.BaseDamage;
		if (MinimumDamage != nullptr)
			*MinimumDamage = params.MinimumDamage;
		if (InnerRadius != nullptr)
			*InnerRadius = params.InnerRadius;
		if (OuterRadius != nullptr)
			*OuterRadius = params.OuterRadius;
		if (DamageFalloff != nullptr)
			*DamageFalloff = params.DamageFalloff;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetProjectVersionAsInt
	 * 		Flags  -> ()
	 */
	int32_t UBpGameplayHelperLib::GetProjectVersionAsInt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetProjectVersionAsInt");
		
		UBpGameplayHelperLib_GetProjectVersionAsInt_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetProjectVersion
	 * 		Flags  -> ()
	 */
	class FString UBpGameplayHelperLib::GetProjectVersion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetProjectVersion");
		
		UBpGameplayHelperLib_GetProjectVersion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetPointDamageData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPointDamageEvent                           DamageEvent                                                (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantizeNormal                   ShotDirection                                              (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitInfo                                                    (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::GetPointDamageData(const struct FPointDamageEvent& DamageEvent, float* Damage, struct FVector_NetQuantizeNormal* ShotDirection, struct FHitResult* HitInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetPointDamageData");
		
		UBpGameplayHelperLib_GetPointDamageData_Params params {};
		params.DamageEvent = DamageEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Damage != nullptr)
			*Damage = params.Damage;
		if (ShotDirection != nullptr)
			*ShotDirection = params.ShotDirection;
		if (HitInfo != nullptr)
			*HitInfo = params.HitInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetPenetrationData
	 * 		Flags  -> ()
	 */
	class UPenetrationData* UBpGameplayHelperLib::GetPenetrationData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetPenetrationData");
		
		UBpGameplayHelperLib_GetPenetrationData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetPairedInteractionDataTable
	 * 		Flags  -> ()
	 */
	class UDataTable* UBpGameplayHelperLib::GetPairedInteractionDataTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetPairedInteractionDataTable");
		
		UBpGameplayHelperLib_GetPairedInteractionDataTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetMusicData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMusicData* UBpGameplayHelperLib::GetMusicData(class UWorld* WorldContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetMusicData");
		
		UBpGameplayHelperLib_GetMusicData_Params params {};
		params.WorldContext = WorldContext;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetMultiplayerProfile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      LoadSlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UReadyOrNotMultiplayerProfile* UBpGameplayHelperLib::GetMultiplayerProfile(const class FString& LoadSlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetMultiplayerProfile");
		
		UBpGameplayHelperLib_GetMultiplayerProfile_Params params {};
		params.LoadSlotName = LoadSlotName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetMoveStyleDataTable
	 * 		Flags  -> ()
	 */
	class UDataTable* UBpGameplayHelperLib::GetMoveStyleDataTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetMoveStyleDataTable");
		
		UBpGameplayHelperLib_GetMoveStyleDataTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetMouseSensitivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              MouseSensitvity                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetMouseSensitivity(float* MouseSensitvity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetMouseSensitivity");
		
		UBpGameplayHelperLib_GetMouseSensitivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MouseSensitvity != nullptr)
			*MouseSensitvity = params.MouseSensitvity;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetMouseInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInvertVertical                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInvertHorizontal                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetMouseInverted(bool* bInvertVertical, bool* bInvertHorizontal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetMouseInverted");
		
		UBpGameplayHelperLib_GetMouseInverted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bInvertVertical != nullptr)
			*bInvertVertical = params.bInvertVertical;
		if (bInvertHorizontal != nullptr)
			*bInvertHorizontal = params.bInvertHorizontal;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetMicInputGain
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              MicInputGain                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetMicInputGain(float* MicInputGain)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetMicInputGain");
		
		UBpGameplayHelperLib_GetMicInputGain_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MicInputGain != nullptr)
			*MicInputGain = params.MicInputGain;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetMetaProfile
	 * 		Flags  -> ()
	 */
	class UReadyOrNotMetaProfile* UBpGameplayHelperLib::GetMetaProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetMetaProfile");
		
		UBpGameplayHelperLib_GetMetaProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetMapStatistics
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AMapStatisticsSystem* UBpGameplayHelperLib::GetMapStatistics(class UWorld* WorldContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetMapStatistics");
		
		UBpGameplayHelperLib_GetMapStatistics_Params params {};
		params.WorldContext = WorldContext;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetMapDetailsFromName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MapName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLevelDataLookupTable UBpGameplayHelperLib::GetMapDetailsFromName(const class FString& MapName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetMapDetailsFromName");
		
		UBpGameplayHelperLib_GetMapDetailsFromName_Params params {};
		params.MapName = MapName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetLookupData
	 * 		Flags  -> ()
	 */
	class ULookupData* UBpGameplayHelperLib::GetLookupData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetLookupData");
		
		UBpGameplayHelperLib_GetLookupData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetLocalPlayerState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AReadyOrNotPlayerState* UBpGameplayHelperLib::GetLocalPlayerState(class UWorld* World)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetLocalPlayerState");
		
		UBpGameplayHelperLib_GetLocalPlayerState_Params params {};
		params.World = World;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetLocalization
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Target                                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetLocalization(class FString* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetLocalization");
		
		UBpGameplayHelperLib_GetLocalization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Target != nullptr)
			*Target = params.Target;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetLoadURLFromData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLevelDataLookupTable                       LookUp                                                     (Parm, NativeAccessSpecifierPublic)
	 */
	class FString UBpGameplayHelperLib::GetLoadURLFromData(const struct FLevelDataLookupTable& LookUp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetLoadURLFromData");
		
		UBpGameplayHelperLib_GetLoadURLFromData_Params params {};
		params.LookUp = LookUp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetLoadoutNames
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FString>                              LoadoutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetLoadoutNames(TArray<class FString>* LoadoutNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetLoadoutNames");
		
		UBpGameplayHelperLib_GetLoadoutNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (LoadoutNames != nullptr)
			*LoadoutNames = params.LoadoutNames;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetLoadingScreenLevelImage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Level                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UBpGameplayHelperLib::GetLoadingScreenLevelImage(const class FString& Level)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetLoadingScreenLevelImage");
		
		UBpGameplayHelperLib_GetLoadingScreenLevelImage_Params params {};
		params.Level = Level;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetLoadGameInstance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      LoadSlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UReadyOrNotSaveGame* UBpGameplayHelperLib::GetLoadGameInstance(const class FString& LoadSlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetLoadGameInstance");
		
		UBpGameplayHelperLib_GetLoadGameInstance_Params params {};
		params.LoadSlotName = LoadSlotName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetLevels
	 * 		Flags  -> ()
	 */
	TArray<struct FLevelDataLookupTable> UBpGameplayHelperLib::GetLevels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetLevels");
		
		UBpGameplayHelperLib_GetLevels_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetLevelLookupDataTable
	 * 		Flags  -> ()
	 */
	class UDataTable* UBpGameplayHelperLib::GetLevelLookupDataTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetLevelLookupDataTable");
		
		UBpGameplayHelperLib_GetLevelLookupDataTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetLevelData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLevelDataLookupTable UBpGameplayHelperLib::GetLevelData(class UWorld* WorldContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetLevelData");
		
		UBpGameplayHelperLib_GetLevelData_Params params {};
		params.WorldContext = WorldContext;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetLastConnectedServerIP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      IP                                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetLastConnectedServerIP(class FString* IP)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetLastConnectedServerIP");
		
		UBpGameplayHelperLib_GetLastConnectedServerIP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (IP != nullptr)
			*IP = params.IP;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetItemLookupDataTable
	 * 		Flags  -> ()
	 */
	class UDataTable* UBpGameplayHelperLib::GetItemLookupDataTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetItemLookupDataTable");
		
		UBpGameplayHelperLib_GetItemLookupDataTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetItemData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItemData* UBpGameplayHelperLib::GetItemData(class UWorld* WorldContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetItemData");
		
		UBpGameplayHelperLib_GetItemData_Params params {};
		params.WorldContext = WorldContext;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetHUDWidget
	 * 		Flags  -> ()
	 */
	class UHumanCharacterHUD_V2* UBpGameplayHelperLib::GetHUDWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetHUDWidget");
		
		UBpGameplayHelperLib_GetHUDWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetHitmarkerSfxEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHitmarkerSfxEnabled                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetHitmarkerSfxEnabled(bool* bHitmarkerSfxEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetHitmarkerSfxEnabled");
		
		UBpGameplayHelperLib_GetHitmarkerSfxEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bHitmarkerSfxEnabled != nullptr)
			*bHitmarkerSfxEnabled = params.bHitmarkerSfxEnabled;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetGameModeSettingsLookupDataTable
	 * 		Flags  -> ()
	 */
	class UDataTable* UBpGameplayHelperLib::GetGameModeSettingsLookupDataTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetGameModeSettingsLookupDataTable");
		
		UBpGameplayHelperLib_GetGameModeSettingsLookupDataTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetGameInstance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UReadyOrNotGameInstance* UBpGameplayHelperLib::GetGameInstance(class UWorld* WorldContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetGameInstance");
		
		UBpGameplayHelperLib_GetGameInstance_Params params {};
		params.WorldContext = WorldContext;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetFriendlyModeFromECoopMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECOOPMode                                          InCoopMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UBpGameplayHelperLib::GetFriendlyModeFromECoopMode(ECOOPMode InCoopMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetFriendlyModeFromECoopMode");
		
		UBpGameplayHelperLib_GetFriendlyModeFromECoopMode_Params params {};
		params.InCoopMode = InCoopMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetFriendlyMapAndModeFromName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InUrl                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OutInternalMapName                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OutFriendlyMap                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OutFriendlyMode                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::GetFriendlyMapAndModeFromName(const class FString& InUrl, class FString* OutInternalMapName, class FString* OutFriendlyMap, class FString* OutFriendlyMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetFriendlyMapAndModeFromName");
		
		UBpGameplayHelperLib_GetFriendlyMapAndModeFromName_Params params {};
		params.InUrl = InUrl;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutInternalMapName != nullptr)
			*OutInternalMapName = params.OutInternalMapName;
		if (OutFriendlyMap != nullptr)
			*OutFriendlyMap = params.OutFriendlyMap;
		if (OutFriendlyMode != nullptr)
			*OutFriendlyMode = params.OutFriendlyMode;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetFreelookSensitivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Sensitivity                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetFreelookSensitivity(float* Sensitivity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetFreelookSensitivity");
		
		UBpGameplayHelperLib_GetFreelookSensitivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Sensitivity != nullptr)
			*Sensitivity = params.Sensitivity;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetFoV
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              FOV                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetFoV(float* FOV)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetFoV");
		
		UBpGameplayHelperLib_GetFoV_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (FOV != nullptr)
			*FOV = params.FOV;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetFlashlightShadows
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFlashLightShadows                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetFlashlightShadows(bool* bFlashLightShadows)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetFlashlightShadows");
		
		UBpGameplayHelperLib_GetFlashlightShadows_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bFlashLightShadows != nullptr)
			*bFlashLightShadows = params.bFlashLightShadows;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetFirstWidgetFromViewport
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      WidgetName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UUserWidget* UBpGameplayHelperLib::GetFirstWidgetFromViewport(const class FString& WidgetName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetFirstWidgetFromViewport");
		
		UBpGameplayHelperLib_GetFirstWidgetFromViewport_Params params {};
		params.WidgetName = WidgetName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetFirstAlivePlayerControlledCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APlayerCharacter* UBpGameplayHelperLib::GetFirstAlivePlayerControlledCharacter(class UWorld* WorldContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetFirstAlivePlayerControlledCharacter");
		
		UBpGameplayHelperLib_GetFirstAlivePlayerControlledCharacter_Params params {};
		params.WorldContext = WorldContext;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetExperimentalFeatures
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bExperimentalFeatures                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetExperimentalFeatures(bool* bExperimentalFeatures)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetExperimentalFeatures");
		
		UBpGameplayHelperLib_GetExperimentalFeatures_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bExperimentalFeatures != nullptr)
			*bExperimentalFeatures = params.bExperimentalFeatures;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetDoorLookupDataTable
	 * 		Flags  -> ()
	 */
	class UDataTable* UBpGameplayHelperLib::GetDoorLookupDataTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetDoorLookupDataTable");
		
		UBpGameplayHelperLib_GetDoorLookupDataTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetDMOTeamType
	 * 		Flags  -> ()
	 */
	ETeamType UBpGameplayHelperLib::GetDMOTeamType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetDMOTeamType");
		
		UBpGameplayHelperLib_GetDMOTeamType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetDMOGameMode
	 * 		Flags  -> ()
	 */
	class FString UBpGameplayHelperLib::GetDMOGameMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetDMOGameMode");
		
		UBpGameplayHelperLib_GetDMOGameMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetDMOAddress
	 * 		Flags  -> ()
	 */
	class FString UBpGameplayHelperLib::GetDMOAddress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetDMOAddress");
		
		UBpGameplayHelperLib_GetDMOAddress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetDistanceBetweenActors2D
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UBpGameplayHelperLib::GetDistanceBetweenActors2D(class AActor* Actor1, class AActor* Actor2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetDistanceBetweenActors2D");
		
		UBpGameplayHelperLib_GetDistanceBetweenActors2D_Params params {};
		params.Actor1 = Actor1;
		params.Actor2 = Actor2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetDistanceBetweenActors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UBpGameplayHelperLib::GetDistanceBetweenActors(class AActor* Actor1, class AActor* Actor2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetDistanceBetweenActors");
		
		UBpGameplayHelperLib_GetDistanceBetweenActors_Params params {};
		params.Actor1 = Actor1;
		params.Actor2 = Actor2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetCurrentProfile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UReadyOrNotProfile* UBpGameplayHelperLib::GetCurrentProfile(class UWorld* WorldContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetCurrentProfile");
		
		UBpGameplayHelperLib_GetCurrentProfile_Params params {};
		params.WorldContext = WorldContext;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetConversationLookupDataTable
	 * 		Flags  -> ()
	 */
	class UDataTable* UBpGameplayHelperLib::GetConversationLookupDataTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetConversationLookupDataTable");
		
		UBpGameplayHelperLib_GetConversationLookupDataTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetClosestActiveSuspect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMustHaveTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASuspectCharacter* UBpGameplayHelperLib::GetClosestActiveSuspect(const struct FCoreUObject_FVector& Location, float Distance, bool bMustHaveTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetClosestActiveSuspect");
		
		UBpGameplayHelperLib_GetClosestActiveSuspect_Params params {};
		params.Location = Location;
		params.Distance = Distance;
		params.bMustHaveTarget = bMustHaveTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetClosestActiveCivilian
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMustHaveTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ACivilianCharacter* UBpGameplayHelperLib::GetClosestActiveCivilian(const struct FCoreUObject_FVector& Location, float Distance, bool bMustHaveTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetClosestActiveCivilian");
		
		UBpGameplayHelperLib_GetClosestActiveCivilian_Params params {};
		params.Location = Location;
		params.Distance = Distance;
		params.bMustHaveTarget = bMustHaveTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetCharacterLookOverrideDataTable
	 * 		Flags  -> ()
	 */
	class UDataTable* UBpGameplayHelperLib::GetCharacterLookOverrideDataTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetCharacterLookOverrideDataTable");
		
		UBpGameplayHelperLib_GetCharacterLookOverrideDataTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetBuildTime
	 * 		Flags  -> ()
	 */
	class FString UBpGameplayHelperLib::GetBuildTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetBuildTime");
		
		UBpGameplayHelperLib_GetBuildTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetBuildDate
	 * 		Flags  -> ()
	 */
	class FString UBpGameplayHelperLib::GetBuildDate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetBuildDate");
		
		UBpGameplayHelperLib_GetBuildDate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetBounceLightEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bBounceLightEnabled                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::GetBounceLightEnabled(bool* bBounceLightEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetBounceLightEnabled");
		
		UBpGameplayHelperLib_GetBounceLightEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bBounceLightEnabled != nullptr)
			*bBounceLightEnabled = params.bBounceLightEnabled;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetAttachmentPointsRemaining
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSavedLoadout                               Loadout                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	int32_t UBpGameplayHelperLib::GetAttachmentPointsRemaining(const struct FSavedLoadout& Loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetAttachmentPointsRemaining");
		
		UBpGameplayHelperLib_GetAttachmentPointsRemaining_Params params {};
		params.Loadout = Loadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetAnimatedIconLookupDataTable
	 * 		Flags  -> ()
	 */
	class UDataTable* UBpGameplayHelperLib::GetAnimatedIconLookupDataTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetAnimatedIconLookupDataTable");
		
		UBpGameplayHelperLib_GetAnimatedIconLookupDataTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetAnimatedIconFromTable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        RowName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccess                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FAnimatedIcon UBpGameplayHelperLib::GetAnimatedIconFromTable(const class FName& RowName, bool* bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetAnimatedIconFromTable");
		
		UBpGameplayHelperLib_GetAnimatedIconFromTable_Params params {};
		params.RowName = RowName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bSuccess != nullptr)
			*bSuccess = params.bSuccess;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetAmmoLookupDataTable
	 * 		Flags  -> ()
	 */
	class UDataTable* UBpGameplayHelperLib::GetAmmoLookupDataTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetAmmoLookupDataTable");
		
		UBpGameplayHelperLib_GetAmmoLookupDataTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetAILookupDataTable
	 * 		Flags  -> ()
	 */
	class UDataTable* UBpGameplayHelperLib::GetAILookupDataTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetAILookupDataTable");
		
		UBpGameplayHelperLib_GetAILookupDataTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.GetAdditionalBugReportInformation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UBpGameplayHelperLib::GetAdditionalBugReportInformation(class APlayerController* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.GetAdditionalBugReportInformation");
		
		UBpGameplayHelperLib_GetAdditionalBugReportInformation_Params params {};
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.FindClosestDeadGuyInRadius
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Causer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeUnconscious                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APlayerCharacter* UBpGameplayHelperLib::FindClosestDeadGuyInRadius(const struct FCoreUObject_FVector& Origin, class AActor* Causer, float Radius, bool bIncludeUnconscious)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.FindClosestDeadGuyInRadius");
		
		UBpGameplayHelperLib_FindClosestDeadGuyInRadius_Params params {};
		params.Origin = Origin;
		params.Causer = Causer;
		params.Radius = Radius;
		params.bIncludeUnconscious = bIncludeUnconscious;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.EquipLoadoutOnPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSavedLoadout                               Loadout                                                    (Parm, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        EquipPlayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLoadoutEquipOptions                        LoadoutEquipOptions                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::EquipLoadoutOnPlayer(const struct FSavedLoadout& Loadout, class AReadyOrNotCharacter* EquipPlayer, const struct FLoadoutEquipOptions& LoadoutEquipOptions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.EquipLoadoutOnPlayer");
		
		UBpGameplayHelperLib_EquipLoadoutOnPlayer_Params params {};
		params.Loadout = Loadout;
		params.EquipPlayer = EquipPlayer;
		params.LoadoutEquipOptions = LoadoutEquipOptions;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.EnableInteractionForController
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InInteractableActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           InPlayerCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::EnableInteractionForController(class AActor* InInteractableActor, class APlayerController* InPlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.EnableInteractionForController");
		
		UBpGameplayHelperLib_EnableInteractionForController_Params params {};
		params.InInteractableActor = InInteractableActor;
		params.InPlayerCharacter = InPlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.EnableInteractionFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InInteractableActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            InPlayerCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::EnableInteractionFor(class AActor* InInteractableActor, class APlayerCharacter* InPlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.EnableInteractionFor");
		
		UBpGameplayHelperLib_EnableInteractionFor_Params params {};
		params.InInteractableActor = InInteractableActor;
		params.InPlayerCharacter = InPlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.EnableInteractionCompForController
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInteractableComponent*                      InteractableComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           InPlayerController                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::EnableInteractionCompForController(class UInteractableComponent* InteractableComponent, class APlayerController* InPlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.EnableInteractionCompForController");
		
		UBpGameplayHelperLib_EnableInteractionCompForController_Params params {};
		params.InteractableComponent = InteractableComponent;
		params.InPlayerController = InPlayerController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.DisableInteractionForController
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InInteractableActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           InPlayerCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::DisableInteractionForController(class AActor* InInteractableActor, class APlayerController* InPlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.DisableInteractionForController");
		
		UBpGameplayHelperLib_DisableInteractionForController_Params params {};
		params.InInteractableActor = InInteractableActor;
		params.InPlayerCharacter = InPlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.DisableInteractionFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InInteractableActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            InPlayerCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::DisableInteractionFor(class AActor* InInteractableActor, class APlayerCharacter* InPlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.DisableInteractionFor");
		
		UBpGameplayHelperLib_DisableInteractionFor_Params params {};
		params.InInteractableActor = InInteractableActor;
		params.InPlayerCharacter = InPlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.DisableInteractionCompForController
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInteractableComponent*                      InteractableComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           InPlayerController                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::DisableInteractionCompForController(class UInteractableComponent* InteractableComponent, class APlayerController* InPlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.DisableInteractionCompForController");
		
		UBpGameplayHelperLib_DisableInteractionCompForController_Params params {};
		params.InteractableComponent = InteractableComponent;
		params.InPlayerController = InPlayerController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.DeleteLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      LoadoutName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::DeleteLoadout(const class FString& LoadoutName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.DeleteLoadout");
		
		UBpGameplayHelperLib_DeleteLoadout_Params params {};
		params.LoadoutName = LoadoutName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.ConvertWeaponTypeToItemType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EWeaponType                                        WeaponType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EItemType UBpGameplayHelperLib::ConvertWeaponTypeToItemType(EWeaponType WeaponType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.ConvertWeaponTypeToItemType");
		
		UBpGameplayHelperLib_ConvertWeaponTypeToItemType_Params params {};
		params.WeaponType = WeaponType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.ConvertSquareVectorToCircle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector2D                      SquareVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D UBpGameplayHelperLib::ConvertSquareVectorToCircle(const struct FCoreUObject_FVector2D& SquareVector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.ConvertSquareVectorToCircle");
		
		UBpGameplayHelperLib_ConvertSquareVectorToCircle_Params params {};
		params.SquareVector = SquareVector;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.ConvertItemTypeToWeaponType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemType                                          ItemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EWeaponType UBpGameplayHelperLib::ConvertItemTypeToWeaponType(EItemType ItemType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.ConvertItemTypeToWeaponType");
		
		UBpGameplayHelperLib_ConvertItemTypeToWeaponType_Params params {};
		params.ItemType = ItemType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.ConvertFloatToStringMinutes_Detail
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UBpGameplayHelperLib::ConvertFloatToStringMinutes_Detail(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.ConvertFloatToStringMinutes_Detail");
		
		UBpGameplayHelperLib_ConvertFloatToStringMinutes_Detail_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.ConvertFloatToStringMinutes
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UBpGameplayHelperLib::ConvertFloatToStringMinutes(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.ConvertFloatToStringMinutes");
		
		UBpGameplayHelperLib_ConvertFloatToStringMinutes_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.ConvertDegreeIntoLetter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Degrees                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UBpGameplayHelperLib::ConvertDegreeIntoLetter(float Degrees)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.ConvertDegreeIntoLetter");
		
		UBpGameplayHelperLib_ConvertDegreeIntoLetter_Params params {};
		params.Degrees = Degrees;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.CompareLevelDataLookupBP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLevelDataLookupTable                       A                                                          (Parm, NativeAccessSpecifierPublic)
	 * 		struct FLevelDataLookupTable                       B                                                          (Parm, NativeAccessSpecifierPublic)
	 */
	bool UBpGameplayHelperLib::CompareLevelDataLookupBP(const struct FLevelDataLookupTable& A, const struct FLevelDataLookupTable& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.CompareLevelDataLookupBP");
		
		UBpGameplayHelperLib_CompareLevelDataLookupBP_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.ChangeLocalization
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Target                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::ChangeLocalization(const class FString& Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.ChangeLocalization");
		
		UBpGameplayHelperLib_ChangeLocalization_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.CastToRadialDamageEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageEvent                                DamageEvent                                                (Parm, NativeAccessSpecifierPublic)
	 * 		EStructureCastPathway                              Branches                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRadialDamageEvent UBpGameplayHelperLib::CastToRadialDamageEvent(const struct FDamageEvent& DamageEvent, EStructureCastPathway* Branches)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.CastToRadialDamageEvent");
		
		UBpGameplayHelperLib_CastToRadialDamageEvent_Params params {};
		params.DamageEvent = DamageEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Branches != nullptr)
			*Branches = params.Branches;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.CastToPointDamageEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageEvent                                DamageEvent                                                (Parm, NativeAccessSpecifierPublic)
	 * 		EStructureCastPathway                              Branches                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FPointDamageEvent UBpGameplayHelperLib::CastToPointDamageEvent(const struct FDamageEvent& DamageEvent, EStructureCastPathway* Branches)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.CastToPointDamageEvent");
		
		UBpGameplayHelperLib_CastToPointDamageEvent_Params params {};
		params.DamageEvent = DamageEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Branches != nullptr)
			*Branches = params.Branches;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.CanSwatKillPlayer
	 * 		Flags  -> ()
	 */
	bool UBpGameplayHelperLib::CanSwatKillPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.CanSwatKillPlayer");
		
		UBpGameplayHelperLib_CanSwatKillPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.AttachMagazinesToWeapon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      WeaponClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseMagazineWeapon*                         Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::AttachMagazinesToWeapon(class UClass* WeaponClass, class ABaseMagazineWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.AttachMagazinesToWeapon");
		
		UBpGameplayHelperLib_AttachMagazinesToWeapon_Params params {};
		params.WeaponClass = WeaponClass;
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpGameplayHelperLib.AddDefaultItemsToPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpGameplayHelperLib::AddDefaultItemsToPlayer(class AReadyOrNotCharacter* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpGameplayHelperLib.AddDefaultItemsToPlayer");
		
		UBpGameplayHelperLib_AddDefaultItemsToPlayer_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBpGameplayHelperLib.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBpGameplayHelperLib::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BpGameplayHelperLib");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotSaveGame.CreateDefaultSavegame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      LoadSlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UReadyOrNotSaveGame* UReadyOrNotSaveGame::CreateDefaultSavegame(const class FString& LoadSlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotSaveGame.CreateDefaultSavegame");
		
		UReadyOrNotSaveGame_CreateDefaultSavegame_Params params {};
		params.LoadSlotName = LoadSlotName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotSaveGame.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotSaveGame::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotSaveGame");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotSessionData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotSessionData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotSessionData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotModData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotModData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotModData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpKeybindsLib.SaveKeybinds
	 * 		Flags  -> ()
	 */
	bool UBpKeybindsLib::SaveKeybinds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpKeybindsLib.SaveKeybinds");
		
		UBpKeybindsLib_SaveKeybinds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBpKeybindsLib.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBpKeybindsLib::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BpKeybindsLib");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SupportsRayTracing
	 * 		Flags  -> ()
	 */
	bool UBpVideoSettingsLib::SupportsRayTracing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SupportsRayTracing");
		
		UBpVideoSettingsLib_SupportsRayTracing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetWorldDecalEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FadeDistance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Density                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetWorldDecalEnabled(bool bEnabled, float FadeDistance, float Density)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetWorldDecalEnabled");
		
		UBpVideoSettingsLib_SetWorldDecalEnabled_Params params {};
		params.bEnabled = bEnabled;
		params.FadeDistance = FadeDistance;
		params.Density = Density;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetVSyncEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetVSyncEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetVSyncEnabled");
		
		UBpVideoSettingsLib_SetVSyncEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetVideoQualitySettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            AntiAliasing                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Effects                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PostProcess                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ResolutionScaling                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Shadow                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Texture                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ViewDistance                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetVideoQualitySettings(int32_t AntiAliasing, int32_t Effects, int32_t PostProcess, float ResolutionScaling, int32_t Shadow, int32_t Texture, int32_t ViewDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetVideoQualitySettings");
		
		UBpVideoSettingsLib_SetVideoQualitySettings_Params params {};
		params.AntiAliasing = AntiAliasing;
		params.Effects = Effects;
		params.PostProcess = PostProcess;
		params.ResolutionScaling = ResolutionScaling;
		params.Shadow = Shadow;
		params.Texture = Texture;
		params.ViewDistance = ViewDistance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetScreenResolution
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Width                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Height                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EWindowMode                                        NewWindowMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetScreenResolution(int32_t Width, int32_t Height, EWindowMode NewWindowMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetScreenResolution");
		
		UBpVideoSettingsLib_SetScreenResolution_Params params {};
		params.Width = Width;
		params.Height = Height;
		params.NewWindowMode = NewWindowMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetReflexLatencyOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bGameToRenderLatencyEnabled                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGameLatencyEnabled                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRenderLatencyEnabled                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetReflexLatencyOptions(bool bGameToRenderLatencyEnabled, bool bGameLatencyEnabled, bool bRenderLatencyEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetReflexLatencyOptions");
		
		UBpVideoSettingsLib_SetReflexLatencyOptions_Params params {};
		params.bGameToRenderLatencyEnabled = bGameToRenderLatencyEnabled;
		params.bGameLatencyEnabled = bGameLatencyEnabled;
		params.bRenderLatencyEnabled = bRenderLatencyEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetReflexEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		unsigned char                                      ReflexMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFlashIndicatorEnabled                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetReflexEnabled(unsigned char ReflexMode, bool bFlashIndicatorEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetReflexEnabled");
		
		UBpVideoSettingsLib_SetReflexEnabled_Params params {};
		params.ReflexMode = ReflexMode;
		params.bFlashIndicatorEnabled = bFlashIndicatorEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetRaytracingSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bRTXEnabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRTXReflectionsEnabled                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRTXShadowsEnabled                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRTXAmbientOcclusionEnabled                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRTXGlobalIllumination                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRTXTranslucency                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetRaytracingSettings(bool bRTXEnabled, bool bRTXReflectionsEnabled, bool bRTXShadowsEnabled, bool bRTXAmbientOcclusionEnabled, bool bRTXGlobalIllumination, bool bRTXTranslucency)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetRaytracingSettings");
		
		UBpVideoSettingsLib_SetRaytracingSettings_Params params {};
		params.bRTXEnabled = bRTXEnabled;
		params.bRTXReflectionsEnabled = bRTXReflectionsEnabled;
		params.bRTXShadowsEnabled = bRTXShadowsEnabled;
		params.bRTXAmbientOcclusionEnabled = bRTXAmbientOcclusionEnabled;
		params.bRTXGlobalIllumination = bRTXGlobalIllumination;
		params.bRTXTranslucency = bRTXTranslucency;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetOverallVideoQuality
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Quality                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetOverallVideoQuality(int32_t Quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetOverallVideoQuality");
		
		UBpVideoSettingsLib_SetOverallVideoQuality_Params params {};
		params.Quality = Quality;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetMotionBlurStrength
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetMotionBlurStrength(float Strength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetMotionBlurStrength");
		
		UBpVideoSettingsLib_SetMotionBlurStrength_Params params {};
		params.Strength = Strength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetMotionBlurEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetMotionBlurEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetMotionBlurEnabled");
		
		UBpVideoSettingsLib_SetMotionBlurEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetGraphicsPresetIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            GraphicsPresetIndex                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetGraphicsPresetIndex(int32_t GraphicsPresetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetGraphicsPresetIndex");
		
		UBpVideoSettingsLib_SetGraphicsPresetIndex_Params params {};
		params.GraphicsPresetIndex = GraphicsPresetIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetFSRQuality
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Quality                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetFSRQuality(int32_t Quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetFSRQuality");
		
		UBpVideoSettingsLib_SetFSRQuality_Params params {};
		params.Quality = Quality;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetFrameRateLimit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            FrameRateLimit                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetFrameRateLimit(int32_t FrameRateLimit, bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetFrameRateLimit");
		
		UBpVideoSettingsLib_SetFrameRateLimit_Params params {};
		params.FrameRateLimit = FrameRateLimit;
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetDlssQuality
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Quality                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetDlssQuality(int32_t Quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetDlssQuality");
		
		UBpVideoSettingsLib_SetDlssQuality_Params params {};
		params.Quality = Quality;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SetDepthofFieldSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bDoFEnabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::SetDepthofFieldSetting(bool bDoFEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SetDepthofFieldSetting");
		
		UBpVideoSettingsLib_SetDepthofFieldSetting_Params params {};
		params.bDoFEnabled = bDoFEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.SaveVideoModeAndQuality
	 * 		Flags  -> ()
	 */
	bool UBpVideoSettingsLib::SaveVideoModeAndQuality()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.SaveVideoModeAndQuality");
		
		UBpVideoSettingsLib_SaveVideoModeAndQuality_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.IsNvidiaReflexEnabled
	 * 		Flags  -> ()
	 */
	bool UBpVideoSettingsLib::IsNvidiaReflexEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.IsNvidiaReflexEnabled");
		
		UBpVideoSettingsLib_IsNvidiaReflexEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetWorldDecalsEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FadeDistance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Density                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetWorldDecalsEnabled(bool* bEnabled, float* FadeDistance, float* Density)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetWorldDecalsEnabled");
		
		UBpVideoSettingsLib_GetWorldDecalsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bEnabled != nullptr)
			*bEnabled = params.bEnabled;
		if (FadeDistance != nullptr)
			*FadeDistance = params.FadeDistance;
		if (Density != nullptr)
			*Density = params.Density;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetVSyncEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetVSyncEnabled(bool* bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetVSyncEnabled");
		
		UBpVideoSettingsLib_GetVSyncEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bEnabled != nullptr)
			*bEnabled = params.bEnabled;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetVideoQualitySettingsAsString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        OverallSetting                                             (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        AntiAliasing                                               (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        Effects                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        PostProcess                                                (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        Shadow                                                     (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        Texture                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        ViewDistance                                               (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetVideoQualitySettingsAsString(class FText* OverallSetting, class FText* AntiAliasing, class FText* Effects, class FText* PostProcess, class FText* Shadow, class FText* Texture, class FText* ViewDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetVideoQualitySettingsAsString");
		
		UBpVideoSettingsLib_GetVideoQualitySettingsAsString_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OverallSetting != nullptr)
			*OverallSetting = params.OverallSetting;
		if (AntiAliasing != nullptr)
			*AntiAliasing = params.AntiAliasing;
		if (Effects != nullptr)
			*Effects = params.Effects;
		if (PostProcess != nullptr)
			*PostProcess = params.PostProcess;
		if (Shadow != nullptr)
			*Shadow = params.Shadow;
		if (Texture != nullptr)
			*Texture = params.Texture;
		if (ViewDistance != nullptr)
			*ViewDistance = params.ViewDistance;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetVideoQualitySettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            AntiAliasing                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Effects                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PostProcess                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ResolutionScaling                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Shadow                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Texture                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ViewDistance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetVideoQualitySettings(int32_t* AntiAliasing, int32_t* Effects, int32_t* PostProcess, float* ResolutionScaling, int32_t* Shadow, int32_t* Texture, int32_t* ViewDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetVideoQualitySettings");
		
		UBpVideoSettingsLib_GetVideoQualitySettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (AntiAliasing != nullptr)
			*AntiAliasing = params.AntiAliasing;
		if (Effects != nullptr)
			*Effects = params.Effects;
		if (PostProcess != nullptr)
			*PostProcess = params.PostProcess;
		if (ResolutionScaling != nullptr)
			*ResolutionScaling = params.ResolutionScaling;
		if (Shadow != nullptr)
			*Shadow = params.Shadow;
		if (Texture != nullptr)
			*Texture = params.Texture;
		if (ViewDistance != nullptr)
			*ViewDistance = params.ViewDistance;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetSupportedScreenResolutions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FString>                              Resolutions                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetSupportedScreenResolutions(TArray<class FString>* Resolutions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetSupportedScreenResolutions");
		
		UBpVideoSettingsLib_GetSupportedScreenResolutions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Resolutions != nullptr)
			*Resolutions = params.Resolutions;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetReflexLatencyOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bGameToRenderLatencyEnabled                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGameLatencyEnabled                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRenderLatencyEnabled                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetReflexLatencyOptions(bool* bGameToRenderLatencyEnabled, bool* bGameLatencyEnabled, bool* bRenderLatencyEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetReflexLatencyOptions");
		
		UBpVideoSettingsLib_GetReflexLatencyOptions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bGameToRenderLatencyEnabled != nullptr)
			*bGameToRenderLatencyEnabled = params.bGameToRenderLatencyEnabled;
		if (bGameLatencyEnabled != nullptr)
			*bGameLatencyEnabled = params.bGameLatencyEnabled;
		if (bRenderLatencyEnabled != nullptr)
			*bRenderLatencyEnabled = params.bRenderLatencyEnabled;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetReflexLatency
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bGameToRenderLatencyEnabled                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              GametoRenderLatency                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGameLatencyEnabled                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              GameLatencyInMS                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRenderLatencyEnabled                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RenderLatencyInMS                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpVideoSettingsLib::GetReflexLatency(bool* bGameToRenderLatencyEnabled, float* GametoRenderLatency, bool* bGameLatencyEnabled, float* GameLatencyInMS, bool* bRenderLatencyEnabled, float* RenderLatencyInMS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetReflexLatency");
		
		UBpVideoSettingsLib_GetReflexLatency_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bGameToRenderLatencyEnabled != nullptr)
			*bGameToRenderLatencyEnabled = params.bGameToRenderLatencyEnabled;
		if (GametoRenderLatency != nullptr)
			*GametoRenderLatency = params.GametoRenderLatency;
		if (bGameLatencyEnabled != nullptr)
			*bGameLatencyEnabled = params.bGameLatencyEnabled;
		if (GameLatencyInMS != nullptr)
			*GameLatencyInMS = params.GameLatencyInMS;
		if (bRenderLatencyEnabled != nullptr)
			*bRenderLatencyEnabled = params.bRenderLatencyEnabled;
		if (RenderLatencyInMS != nullptr)
			*RenderLatencyInMS = params.RenderLatencyInMS;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetReflexEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		unsigned char                                      ReflexMode                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFlashIndicatorEnabled                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetReflexEnabled(unsigned char* ReflexMode, bool* bFlashIndicatorEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetReflexEnabled");
		
		UBpVideoSettingsLib_GetReflexEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ReflexMode != nullptr)
			*ReflexMode = params.ReflexMode;
		if (bFlashIndicatorEnabled != nullptr)
			*bFlashIndicatorEnabled = params.bFlashIndicatorEnabled;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetRaytracingSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bRTXEnabled                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRTXReflectionsEnabled                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRTXShadowsEnabled                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRTXAmbientOcclusionEnabled                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRTXGlobalIllumination                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRTXTranslucency                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetRaytracingSettings(bool* bRTXEnabled, bool* bRTXReflectionsEnabled, bool* bRTXShadowsEnabled, bool* bRTXAmbientOcclusionEnabled, bool* bRTXGlobalIllumination, bool* bRTXTranslucency)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetRaytracingSettings");
		
		UBpVideoSettingsLib_GetRaytracingSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bRTXEnabled != nullptr)
			*bRTXEnabled = params.bRTXEnabled;
		if (bRTXReflectionsEnabled != nullptr)
			*bRTXReflectionsEnabled = params.bRTXReflectionsEnabled;
		if (bRTXShadowsEnabled != nullptr)
			*bRTXShadowsEnabled = params.bRTXShadowsEnabled;
		if (bRTXAmbientOcclusionEnabled != nullptr)
			*bRTXAmbientOcclusionEnabled = params.bRTXAmbientOcclusionEnabled;
		if (bRTXGlobalIllumination != nullptr)
			*bRTXGlobalIllumination = params.bRTXGlobalIllumination;
		if (bRTXTranslucency != nullptr)
			*bRTXTranslucency = params.bRTXTranslucency;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetOverallVideoQuality
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Quality                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetOverallVideoQuality(int32_t* Quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetOverallVideoQuality");
		
		UBpVideoSettingsLib_GetOverallVideoQuality_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Quality != nullptr)
			*Quality = params.Quality;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetMotionBlurStrength
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Strength                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetMotionBlurStrength(float* Strength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetMotionBlurStrength");
		
		UBpVideoSettingsLib_GetMotionBlurStrength_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Strength != nullptr)
			*Strength = params.Strength;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetMotionBlurEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetMotionBlurEnabled(bool* bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetMotionBlurEnabled");
		
		UBpVideoSettingsLib_GetMotionBlurEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bEnabled != nullptr)
			*bEnabled = params.bEnabled;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetGraphicsPresetIndex
	 * 		Flags  -> ()
	 */
	int32_t UBpVideoSettingsLib::GetGraphicsPresetIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetGraphicsPresetIndex");
		
		UBpVideoSettingsLib_GetGraphicsPresetIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetFSRQuality
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Quality                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetFSRQuality(int32_t* Quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetFSRQuality");
		
		UBpVideoSettingsLib_GetFSRQuality_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Quality != nullptr)
			*Quality = params.Quality;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetFrameRateLimit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            FrameRateLimit                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetFrameRateLimit(int32_t* FrameRateLimit, bool* bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetFrameRateLimit");
		
		UBpVideoSettingsLib_GetFrameRateLimit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (FrameRateLimit != nullptr)
			*FrameRateLimit = params.FrameRateLimit;
		if (bEnabled != nullptr)
			*bEnabled = params.bEnabled;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetDlssQuality
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Quality                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetDlssQuality(int32_t* Quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetDlssQuality");
		
		UBpVideoSettingsLib_GetDlssQuality_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Quality != nullptr)
			*Quality = params.Quality;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetDepthOfFieldSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bDoFEnabled                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::GetDepthOfFieldSetting(bool* bDoFEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetDepthOfFieldSetting");
		
		UBpVideoSettingsLib_GetDepthOfFieldSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bDoFEnabled != nullptr)
			*bDoFEnabled = params.bDoFEnabled;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetCurrentScreenResolution
	 * 		Flags  -> ()
	 */
	class FString UBpVideoSettingsLib::GetCurrentScreenResolution()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetCurrentScreenResolution");
		
		UBpVideoSettingsLib_GetCurrentScreenResolution_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GetCurrentScreenMode
	 * 		Flags  -> ()
	 */
	EWindowMode UBpVideoSettingsLib::GetCurrentScreenMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GetCurrentScreenMode");
		
		UBpVideoSettingsLib_GetCurrentScreenMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GenerateQualityString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Quality                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UBpVideoSettingsLib::GenerateQualityString(int32_t Quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GenerateQualityString");
		
		UBpVideoSettingsLib_GenerateQualityString_Params params {};
		params.Quality = Quality;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GenerateFSRQualityString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Quality                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UBpVideoSettingsLib::GenerateFSRQualityString(int32_t Quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GenerateFSRQualityString");
		
		UBpVideoSettingsLib_GenerateFSRQualityString_Params params {};
		params.Quality = Quality;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.GenerateDlssQualityString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Quality                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UBpVideoSettingsLib::GenerateDlssQualityString(int32_t Quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.GenerateDlssQualityString");
		
		UBpVideoSettingsLib_GenerateDlssQualityString_Params params {};
		params.Quality = Quality;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.ForceReloadSettings
	 * 		Flags  -> ()
	 */
	void UBpVideoSettingsLib::ForceReloadSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.ForceReloadSettings");
		
		UBpVideoSettingsLib_ForceReloadSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpVideoSettingsLib.ChangeScreenResolution
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Width                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Height                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EWindowMode                                        NewWindowMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpVideoSettingsLib::ChangeScreenResolution(int32_t Width, int32_t Height, EWindowMode NewWindowMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpVideoSettingsLib.ChangeScreenResolution");
		
		UBpVideoSettingsLib_ChangeScreenResolution_Params params {};
		params.Width = Width;
		params.Height = Height;
		params.NewWindowMode = NewWindowMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBpVideoSettingsLib.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBpVideoSettingsLib::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BpVideoSettingsLib");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpWidgetLib.PostBugReport
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Summary                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Description                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Category                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBpWidgetLib::PostBugReport(const class FString& Summary, const class FString& Description, const class FString& Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpWidgetLib.PostBugReport");
		
		UBpWidgetLib_PostBugReport_Params params {};
		params.Summary = Summary;
		params.Description = Description;
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpWidgetLib.DrawLineWithThickness
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPaintContext                               Context                                                    (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      PositionA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      PositionB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                Tint                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAntiAlias                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpWidgetLib::DrawLineWithThickness(struct FPaintContext* Context, const struct FCoreUObject_FVector2D& PositionA, const struct FCoreUObject_FVector2D& PositionB, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness, const struct FCoreUObject_FVector2D& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpWidgetLib.DrawLineWithThickness");
		
		UBpWidgetLib_DrawLineWithThickness_Params params {};
		params.PositionA = PositionA;
		params.PositionB = PositionB;
		params.Tint = Tint;
		params.bAntiAlias = bAntiAlias;
		params.Thickness = Thickness;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Context != nullptr)
			*Context = params.Context;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpWidgetLib.DrawLineWithCenteredOffset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPaintContext                               Context                                                    (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      PositionA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      PositionB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                Tint                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAntiAlias                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      Center                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpWidgetLib::DrawLineWithCenteredOffset(struct FPaintContext* Context, const struct FCoreUObject_FVector2D& PositionA, const struct FCoreUObject_FVector2D& PositionB, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness, const struct FCoreUObject_FVector2D& Offset, const struct FCoreUObject_FVector2D& Center, float Scale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpWidgetLib.DrawLineWithCenteredOffset");
		
		UBpWidgetLib_DrawLineWithCenteredOffset_Params params {};
		params.PositionA = PositionA;
		params.PositionB = PositionB;
		params.Tint = Tint;
		params.bAntiAlias = bAntiAlias;
		params.Thickness = Thickness;
		params.Offset = Offset;
		params.Center = Center;
		params.Scale = Scale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Context != nullptr)
			*Context = params.Context;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpWidgetLib.DrawLinesWithThickness
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPaintContext                               Context                                                    (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<struct FCoreUObject_FVector2D>              Points                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                Tint                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAntiAlias                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpWidgetLib::DrawLinesWithThickness(struct FPaintContext* Context, TArray<struct FCoreUObject_FVector2D> Points, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness, const struct FCoreUObject_FVector2D& Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpWidgetLib.DrawLinesWithThickness");
		
		UBpWidgetLib_DrawLinesWithThickness_Params params {};
		params.Points = Points;
		params.Tint = Tint;
		params.bAntiAlias = bAntiAlias;
		params.Thickness = Thickness;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Context != nullptr)
			*Context = params.Context;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpWidgetLib.DrawLinesWithCenteredOffset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPaintContext                               Context                                                    (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<struct FCoreUObject_FVector2D>              Points                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                Tint                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAntiAlias                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      Center                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBpWidgetLib::DrawLinesWithCenteredOffset(struct FPaintContext* Context, TArray<struct FCoreUObject_FVector2D> Points, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness, const struct FCoreUObject_FVector2D& Offset, const struct FCoreUObject_FVector2D& Center, float Scale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpWidgetLib.DrawLinesWithCenteredOffset");
		
		UBpWidgetLib_DrawLinesWithCenteredOffset_Params params {};
		params.Points = Points;
		params.Tint = Tint;
		params.bAntiAlias = bAntiAlias;
		params.Thickness = Thickness;
		params.Offset = Offset;
		params.Center = Center;
		params.Scale = Scale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Context != nullptr)
			*Context = params.Context;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BpWidgetLib.ChangeStringTableTextKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Target                                                     (ConstParm, Parm, NativeAccessSpecifierPublic)
	 * 		class FString                                      NewKey                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UBpWidgetLib::ChangeStringTableTextKey(const class FText& Target, const class FString& NewKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BpWidgetLib.ChangeStringTableTextKey");
		
		UBpWidgetLib_ChangeStringTableTextKey_Params params {};
		params.Target = Target;
		params.NewKey = NewKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBpWidgetLib.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBpWidgetLib::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BpWidgetLib");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Shotgun.RefreshEntireShellRack
	 * 		Flags  -> ()
	 */
	void AShotgun::RefreshEntireShellRack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Shotgun.RefreshEntireShellRack");
		
		AShotgun_RefreshEntireShellRack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Shotgun.PlayReloadLoop
	 * 		Flags  -> ()
	 */
	void AShotgun::PlayReloadLoop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Shotgun.PlayReloadLoop");
		
		AShotgun_PlayReloadLoop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Shotgun.OnRep_ShellsReplicated
	 * 		Flags  -> ()
	 */
	void AShotgun::OnRep_ShellsReplicated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Shotgun.OnRep_ShellsReplicated");
		
		AShotgun_OnRep_ShellsReplicated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Shotgun.LoadNextShellInRack
	 * 		Flags  -> ()
	 */
	void AShotgun::LoadNextShellInRack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Shotgun.LoadNextShellInRack");
		
		AShotgun_LoadNextShellInRack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Shotgun.FinishedLoadingShellFromRack
	 * 		Flags  -> ()
	 */
	void AShotgun::FinishedLoadingShellFromRack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Shotgun.FinishedLoadingShellFromRack");
		
		AShotgun_FinishedLoadingShellFromRack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Shotgun.CheckReloadSettings
	 * 		Flags  -> ()
	 */
	void AShotgun::CheckReloadSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Shotgun.CheckReloadSettings");
		
		AShotgun_CheckReloadSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AShotgun.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AShotgun::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Shotgun");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABreachingShotgun.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABreachingShotgun::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BreachingShotgun");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BreakableGlass.Multicast_DestructibleHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector_NetQuantize                         Location                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABreakableGlass::Multicast_DestructibleHit(const struct FVector_NetQuantize& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BreakableGlass.Multicast_DestructibleHit");
		
		ABreakableGlass_Multicast_DestructibleHit_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BreakableGlass.Multicast_ConvertHitAndExecute
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            FirstPositionBox                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TextureX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TextureY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize                         HitPosition                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize                         Direction                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABreakableGlass::Multicast_ConvertHitAndExecute(int32_t FirstPositionBox, int32_t TextureX, int32_t TextureY, const struct FVector_NetQuantize& HitPosition, const struct FVector_NetQuantize& Direction, float Damage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BreakableGlass.Multicast_ConvertHitAndExecute");
		
		ABreakableGlass_Multicast_ConvertHitAndExecute_Params params {};
		params.FirstPositionBox = FirstPositionBox;
		params.TextureX = TextureX;
		params.TextureY = TextureY;
		params.HitPosition = HitPosition;
		params.Direction = Direction;
		params.Damage = Damage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BreakableGlass.FirstHitPositionObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            FirstPositionBox                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TextureY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TextureX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        HitPosition                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        ObjectiveDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DamageRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstHitCanBreakIt                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CharacterVelocityToBreak                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABreakableGlass::FirstHitPositionObject(int32_t FirstPositionBox, int32_t TextureY, int32_t TextureX, const struct FCoreUObject_FVector& HitPosition, const struct FCoreUObject_FVector& ObjectiveDirection, float DamageRadius, bool bFirstHitCanBreakIt, float CharacterVelocityToBreak)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BreakableGlass.FirstHitPositionObject");
		
		ABreakableGlass_FirstHitPositionObject_Params params {};
		params.FirstPositionBox = FirstPositionBox;
		params.TextureY = TextureY;
		params.TextureX = TextureX;
		params.HitPosition = HitPosition;
		params.ObjectiveDirection = ObjectiveDirection;
		params.DamageRadius = DamageRadius;
		params.bFirstHitCanBreakIt = bFirstHitCanBreakIt;
		params.CharacterVelocityToBreak = CharacterVelocityToBreak;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BreakableGlass.DestructibleHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABreakableGlass::DestructibleHit(const struct FCoreUObject_FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BreakableGlass.DestructibleHit");
		
		ABreakableGlass_DestructibleHit_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BreakableGlass.ConvertHitAndExecute
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABreakableGlass::ConvertHitAndExecute(const struct FHitResult& Hit, float Damage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BreakableGlass.ConvertHitAndExecute");
		
		ABreakableGlass_ConvertHitAndExecute_Params params {};
		params.Hit = Hit;
		params.Damage = Damage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABreakableGlass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABreakableGlass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BreakableGlass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BriefingWidget.PlayMissionAudio
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      AudioName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBriefingWidget::PlayMissionAudio(const class FString& AudioName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BriefingWidget.PlayMissionAudio");
		
		UBriefingWidget_PlayMissionAudio_Params params {};
		params.AudioName = AudioName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BriefingWidget.MoveCameraToMouseCursor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPointerEvent                               PointerEvent                                               (Parm, NativeAccessSpecifierPublic)
	 */
	void UBriefingWidget::MoveCameraToMouseCursor(const struct FPointerEvent& PointerEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BriefingWidget.MoveCameraToMouseCursor");
		
		UBriefingWidget_MoveCameraToMouseCursor_Params params {};
		params.PointerEvent = PointerEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BriefingWidget.GetWhiteboardTimelineAsString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      OutString                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBriefingWidget::GetWhiteboardTimelineAsString(class FString* OutString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BriefingWidget.GetWhiteboardTimelineAsString");
		
		UBriefingWidget_GetWhiteboardTimelineAsString_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutString != nullptr)
			*OutString = params.OutString;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BriefingWidget.GetWhiteboardObjectiveText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      OutString                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBriefingWidget::GetWhiteboardObjectiveText(class FString* OutString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BriefingWidget.GetWhiteboardObjectiveText");
		
		UBriefingWidget_GetWhiteboardObjectiveText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutString != nullptr)
			*OutString = params.OutString;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BriefingWidget.GetLevelNickname
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      OutNickname                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBriefingWidget::GetLevelNickname(class FString* OutNickname)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BriefingWidget.GetLevelNickname");
		
		UBriefingWidget_GetLevelNickname_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutNickname != nullptr)
			*OutNickname = params.OutNickname;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BriefingWidget.GetBriefing
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FMissionAudio                               OutBriefing                                                (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UBriefingWidget::GetBriefing(struct FMissionAudio* OutBriefing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BriefingWidget.GetBriefing");
		
		UBriefingWidget_GetBriefing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutBriefing != nullptr)
			*OutBriefing = params.OutBriefing;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BriefingWidget.GetBios
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EBioType                                           BioType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FCharacterBio>                       OutBios                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UBriefingWidget::GetBios(EBioType BioType, TArray<struct FCharacterBio>* OutBios)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BriefingWidget.GetBios");
		
		UBriefingWidget_GetBios_Params params {};
		params.BioType = BioType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutBios != nullptr)
			*OutBios = params.OutBios;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BriefingWidget.GetBioDetails
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCharacterBio                               Bio                                                        (Parm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FCriminalRecord>                     RapSheet                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  ProfileImage                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OutDescription                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OutBioText                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBriefingWidget::GetBioDetails(const struct FCharacterBio& Bio, TArray<struct FCriminalRecord>* RapSheet, class UTexture2D** ProfileImage, class FString* OutDescription, class FString* OutBioText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BriefingWidget.GetBioDetails");
		
		UBriefingWidget_GetBioDetails_Params params {};
		params.Bio = Bio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (RapSheet != nullptr)
			*RapSheet = params.RapSheet;
		if (ProfileImage != nullptr)
			*ProfileImage = params.ProfileImage;
		if (OutDescription != nullptr)
			*OutDescription = params.OutDescription;
		if (OutBioText != nullptr)
			*OutBioText = params.OutBioText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BriefingWidget.DoesLevelHaveMissionAudio
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      AudioName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHasMissionAudio                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBriefingWidget::DoesLevelHaveMissionAudio(const class FString& AudioName, bool* bHasMissionAudio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BriefingWidget.DoesLevelHaveMissionAudio");
		
		UBriefingWidget_DoesLevelHaveMissionAudio_Params params {};
		params.AudioName = AudioName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bHasMissionAudio != nullptr)
			*bHasMissionAudio = params.bHasMissionAudio;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBriefingWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBriefingWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BriefingWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABringOrderToChaos.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABringOrderToChaos::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BringOrderToChaos");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BuildingTrigger.OnBuildingExit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuildingTrigger::OnBuildingExit(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BuildingTrigger.OnBuildingExit");
		
		ABuildingTrigger_OnBuildingExit_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BuildingTrigger.OnBuildingEnter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABuildingTrigger::OnBuildingEnter(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BuildingTrigger.OnBuildingEnter");
		
		ABuildingTrigger_OnBuildingEnter_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BuildingTrigger.IsActorOnFloor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            FloorNumber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ABuildingTrigger::IsActorOnFloor(class AActor* Actor, int32_t FloorNumber)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BuildingTrigger.IsActorOnFloor");
		
		ABuildingTrigger_IsActorOnFloor_Params params {};
		params.Actor = Actor;
		params.FloorNumber = FloorNumber;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BuildingTrigger.GetFloorNumberFromActorLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ABuildingTrigger::GetFloorNumberFromActorLocation(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BuildingTrigger.GetFloorNumberFromActorLocation");
		
		ABuildingTrigger_GetFloorNumberFromActorLocation_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BuildingTrigger.GetFloorLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            FloorNumber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector ABuildingTrigger::GetFloorLocation(int32_t FloorNumber)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BuildingTrigger.GetFloorLocation");
		
		ABuildingTrigger_GetFloorLocation_Params params {};
		params.FloorNumber = FloorNumber;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BuildingTrigger.GenerateFloors
	 * 		Flags  -> ()
	 */
	void ABuildingTrigger::GenerateFloors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BuildingTrigger.GenerateFloors");
		
		ABuildingTrigger_GenerateFloors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABuildingTrigger.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABuildingTrigger::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BuildingTrigger");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABuildingTrigger_Incrimination.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABuildingTrigger_Incrimination::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BuildingTrigger_Incrimination");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBulletDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBulletDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BulletDamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Projectile.OnHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AProjectile::OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Projectile.OnHit");
		
		AProjectile_OnHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Projectile.Multicast_SpawnImpactEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      EffectsClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DecalScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bExitImpact                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bArmorImpact                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectile::Multicast_SpawnImpactEffects(const struct FHitResult& Hit, class UClass* EffectsClass, float DecalScale, bool bExitImpact, bool bArmorImpact)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Projectile.Multicast_SpawnImpactEffects");
		
		AProjectile_Multicast_SpawnImpactEffects_Params params {};
		params.Hit = Hit;
		params.EffectsClass = EffectsClass;
		params.DecalScale = DecalScale;
		params.bExitImpact = bExitImpact;
		params.bArmorImpact = bArmorImpact;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Projectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADamageProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADamageProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DamageProjectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BulletProjectile.OnRespawnProjectile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        RespawnLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FRotator                       RespawnRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              NewSpeed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewDamage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EProjectileReaction                                ProjectileReaction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABulletProjectile::OnRespawnProjectile(const struct FCoreUObject_FVector& RespawnLocation, const struct FCoreUObject_FRotator& RespawnRotation, float NewSpeed, float NewDamage, EProjectileReaction ProjectileReaction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BulletProjectile.OnRespawnProjectile");
		
		ABulletProjectile_OnRespawnProjectile_Params params {};
		params.RespawnLocation = RespawnLocation;
		params.RespawnRotation = RespawnRotation;
		params.NewSpeed = NewSpeed;
		params.NewDamage = NewDamage;
		params.ProjectileReaction = ProjectileReaction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BulletProjectile.OnRep_UpdateMesh
	 * 		Flags  -> ()
	 */
	void ABulletProjectile::OnRep_UpdateMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BulletProjectile.OnRep_UpdateMesh");
		
		ABulletProjectile_OnRep_UpdateMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BulletProjectile.OnMeshHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ABulletProjectile::OnMeshHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BulletProjectile.OnMeshHit");
		
		ABulletProjectile_OnMeshHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BulletProjectile.OnDeflect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  DeflectionHit                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ABulletProjectile::OnDeflect(const struct FHitResult& DeflectionHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BulletProjectile.OnDeflect");
		
		ABulletProjectile_OnDeflect_Params params {};
		params.DeflectionHit = DeflectionHit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BulletProjectile.Multicast_SimulatePhysics
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSimulate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABulletProjectile::Multicast_SimulatePhysics(bool bSimulate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BulletProjectile.Multicast_SimulatePhysics");
		
		ABulletProjectile_Multicast_SimulatePhysics_Params params {};
		params.bSimulate = bSimulate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BulletProjectile.Multicast_OnRespawnProjectile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector_NetQuantize100                      RespawnLocation                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize100                      RespawnRotation                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewSpeed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewDamage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EProjectileReaction                                ProjectileReaction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABulletProjectile::Multicast_OnRespawnProjectile(const struct FVector_NetQuantize100& RespawnLocation, const struct FVector_NetQuantize100& RespawnRotation, float NewSpeed, float NewDamage, EProjectileReaction ProjectileReaction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BulletProjectile.Multicast_OnRespawnProjectile");
		
		ABulletProjectile_Multicast_OnRespawnProjectile_Params params {};
		params.RespawnLocation = RespawnLocation;
		params.RespawnRotation = RespawnRotation;
		params.NewSpeed = NewSpeed;
		params.NewDamage = NewDamage;
		params.ProjectileReaction = ProjectileReaction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BulletProjectile.Multicast_AttachToComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABulletProjectile::Multicast_AttachToComponent(const struct FCoreUObject_FVector& NewLocation, class USceneComponent* Component, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BulletProjectile.Multicast_AttachToComponent");
		
		ABulletProjectile_Multicast_AttachToComponent_Params params {};
		params.NewLocation = NewLocation;
		params.Component = Component;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.BulletProjectile.Multicast_ApplyForceToHitObjects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Velocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABulletProjectile::Multicast_ApplyForceToHitObjects(const struct FHitResult& Hit, const struct FCoreUObject_FVector& Velocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.BulletProjectile.Multicast_ApplyForceToHitObjects");
		
		ABulletProjectile_Multicast_ApplyForceToHitObjects_Params params {};
		params.Hit = Hit;
		params.Velocity = Velocity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABulletProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABulletProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BulletProjectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABulletTracer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABulletTracer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.BulletTracer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.C2Explosive.Server_StartC2Placement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AC2Explosive::Server_StartC2Placement(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.C2Explosive.Server_StartC2Placement");
		
		AC2Explosive_Server_StartC2Placement_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.C2Explosive.Server_FinishC2Placement
	 * 		Flags  -> ()
	 */
	void AC2Explosive::Server_FinishC2Placement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.C2Explosive.Server_FinishC2Placement");
		
		AC2Explosive_Server_FinishC2Placement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.C2Explosive.OnRep_LastPlacedC2Explosive
	 * 		Flags  -> ()
	 */
	void AC2Explosive::OnRep_LastPlacedC2Explosive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.C2Explosive.OnRep_LastPlacedC2Explosive");
		
		AC2Explosive_OnRep_LastPlacedC2Explosive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.C2Explosive.Multicast_StartPlaceC2Explosive
	 * 		Flags  -> ()
	 */
	void AC2Explosive::Multicast_StartPlaceC2Explosive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.C2Explosive.Multicast_StartPlaceC2Explosive");
		
		AC2Explosive_Multicast_StartPlaceC2Explosive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.C2Explosive.EquipDetonator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFromExplosives                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AC2Explosive::EquipDetonator(bool bFromExplosives)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.C2Explosive.EquipDetonator");
		
		AC2Explosive_EquipDetonator_Params params {};
		params.bFromExplosives = bFromExplosives;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.C2Explosive.Client_C2PlacementFinished
	 * 		Flags  -> ()
	 */
	void AC2Explosive::Client_C2PlacementFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.C2Explosive.Client_C2PlacementFinished");
		
		AC2Explosive_Client_C2PlacementFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AC2Explosive.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AC2Explosive::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.C2Explosive");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CachedAnimDataLibrary.StateMachine_IsStateRelevant
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimInstance*                               InAnimInstance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCachedAnimStateData                        CachedAnimStateData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UCachedAnimDataLibrary::StateMachine_IsStateRelevant(class UAnimInstance* InAnimInstance, const struct FCachedAnimStateData& CachedAnimStateData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CachedAnimDataLibrary.StateMachine_IsStateRelevant");
		
		UCachedAnimDataLibrary_StateMachine_IsStateRelevant_Params params {};
		params.InAnimInstance = InAnimInstance;
		params.CachedAnimStateData = CachedAnimStateData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CachedAnimDataLibrary.StateMachine_GetLocalWeight
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimInstance*                               InAnimInstance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCachedAnimStateData                        CachedAnimStateData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	float UCachedAnimDataLibrary::StateMachine_GetLocalWeight(class UAnimInstance* InAnimInstance, const struct FCachedAnimStateData& CachedAnimStateData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CachedAnimDataLibrary.StateMachine_GetLocalWeight");
		
		UCachedAnimDataLibrary_StateMachine_GetLocalWeight_Params params {};
		params.InAnimInstance = InAnimInstance;
		params.CachedAnimStateData = CachedAnimStateData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CachedAnimDataLibrary.StateMachine_GetGlobalWeight
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimInstance*                               InAnimInstance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCachedAnimStateData                        CachedAnimStateData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	float UCachedAnimDataLibrary::StateMachine_GetGlobalWeight(class UAnimInstance* InAnimInstance, const struct FCachedAnimStateData& CachedAnimStateData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CachedAnimDataLibrary.StateMachine_GetGlobalWeight");
		
		UCachedAnimDataLibrary_StateMachine_GetGlobalWeight_Params params {};
		params.InAnimInstance = InAnimInstance;
		params.CachedAnimStateData = CachedAnimStateData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCachedAnimDataLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCachedAnimDataLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CachedAnimDataLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanBreachWithShotgun.OnShotgunBreached
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UCanBreachWithShotgun::OnShotgunBreached(float DamageAmount, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanBreachWithShotgun.OnShotgunBreached");
		
		UCanBreachWithShotgun_OnShotgunBreached_Params params {};
		params.DamageAmount = DamageAmount;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanBreachWithShotgun.IsBreachableWithShotgun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFront                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCanBreachWithShotgun::IsBreachableWithShotgun(bool bFront)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanBreachWithShotgun.IsBreachableWithShotgun");
		
		UCanBreachWithShotgun_IsBreachableWithShotgun_Params params {};
		params.bFront = bFront;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanBreachWithShotgun.CanBreachWithShotgunNow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ShotgunOwner                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseItem*                                   Shotgun                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  TraceHit                                                   (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UCanBreachWithShotgun::CanBreachWithShotgunNow(class AReadyOrNotCharacter* ShotgunOwner, class ABaseItem* Shotgun, float DamageAmount, const struct FHitResult& TraceHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanBreachWithShotgun.CanBreachWithShotgunNow");
		
		UCanBreachWithShotgun_CanBreachWithShotgunNow_Params params {};
		params.ShotgunOwner = ShotgunOwner;
		params.Shotgun = Shotgun;
		params.DamageAmount = DamageAmount;
		params.TraceHit = TraceHit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCanBreachWithShotgun.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCanBreachWithShotgun::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CanBreachWithShotgun");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanIssueCommandOn.GetCommandActor
	 * 		Flags  -> ()
	 */
	class AActor* UCanIssueCommandOn::GetCommandActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanIssueCommandOn.GetCommandActor");
		
		UCanIssueCommandOn_GetCommandActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanIssueCommandOn.CanIssueCommand
	 * 		Flags  -> ()
	 */
	bool UCanIssueCommandOn::CanIssueCommand()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanIssueCommandOn.CanIssueCommand");
		
		UCanIssueCommandOn_CanIssueCommand_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCanIssueCommandOn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCanIssueCommandOn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CanIssueCommandOn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanPlaceC2On.OnC2Removed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlacedC2Explosive*                          C2                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCanPlaceC2On::OnC2Removed(class APlacedC2Explosive* C2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanPlaceC2On.OnC2Removed");
		
		UCanPlaceC2On_OnC2Removed_Params params {};
		params.C2 = C2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanPlaceC2On.OnC2Detonated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlacedC2Explosive*                          C2                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCanPlaceC2On::OnC2Detonated(class APlacedC2Explosive* C2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanPlaceC2On.OnC2Detonated");
		
		UCanPlaceC2On_OnC2Detonated_Params params {};
		params.C2 = C2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanPlaceC2On.GetPlacementRotation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  TraceHit                                                   (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FRotator UCanPlaceC2On::GetPlacementRotation(const struct FHitResult& TraceHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanPlaceC2On.GetPlacementRotation");
		
		UCanPlaceC2On_GetPlacementRotation_Params params {};
		params.TraceHit = TraceHit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanPlaceC2On.GetPlacementLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  TraceHit                                                   (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector UCanPlaceC2On::GetPlacementLocation(const struct FHitResult& TraceHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanPlaceC2On.GetPlacementLocation");
		
		UCanPlaceC2On_GetPlacementLocation_Params params {};
		params.TraceHit = TraceHit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanPlaceC2On.CanPlaceC2OnNow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            C2Owner                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AC2Explosive*                                C2                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UCanPlaceC2On::CanPlaceC2OnNow(class APlayerCharacter* C2Owner, class AC2Explosive* C2, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanPlaceC2On.CanPlaceC2OnNow");
		
		UCanPlaceC2On_CanPlaceC2OnNow_Params params {};
		params.C2Owner = C2Owner;
		params.C2 = C2;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanPlaceC2On.C2StopPlacement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AC2Explosive*                                C2                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCanPlaceC2On::C2StopPlacement(class AC2Explosive* C2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanPlaceC2On.C2StopPlacement");
		
		UCanPlaceC2On_C2StopPlacement_Params params {};
		params.C2 = C2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanPlaceC2On.C2StartPlacement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AC2Explosive*                                C2                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCanPlaceC2On::C2StartPlacement(class AC2Explosive* C2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanPlaceC2On.C2StartPlacement");
		
		UCanPlaceC2On_C2StartPlacement_Params params {};
		params.C2 = C2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCanPlaceC2On.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCanPlaceC2On::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CanPlaceC2On");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUse.UsesHoldButtonPrompt
	 * 		Flags  -> ()
	 */
	bool UCanUse::UsesHoldButtonPrompt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUse.UsesHoldButtonPrompt");
		
		UCanUse_UsesHoldButtonPrompt_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUse.StartUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCanUse::StartUse(class APlayerCharacter* User)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUse.StartUse");
		
		UCanUse_StartUse_Params params {};
		params.User = User;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUse.PlaysUseIconComplete
	 * 		Flags  -> ()
	 */
	bool UCanUse::PlaysUseIconComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUse.PlaysUseIconComplete");
		
		UCanUse_PlaysUseIconComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUse.OverridesUseButtonPromptText
	 * 		Flags  -> ()
	 */
	bool UCanUse::OverridesUseButtonPromptText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUse.OverridesUseButtonPromptText");
		
		UCanUse_OverridesUseButtonPromptText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUse.IsAvailableForUse
	 * 		Flags  -> ()
	 */
	bool UCanUse::IsAvailableForUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUse.IsAvailableForUse");
		
		UCanUse_IsAvailableForUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUse.GetUseViewComponents
	 * 		Flags  -> ()
	 */
	TArray<class USceneComponent*> UCanUse::GetUseViewComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUse.GetUseViewComponents");
		
		UCanUse_GetUseViewComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUse.GetUseIconBoltComponent
	 * 		Flags  -> ()
	 */
	class USceneComponent* UCanUse::GetUseIconBoltComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUse.GetUseIconBoltComponent");
		
		UCanUse_GetUseIconBoltComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUse.GetUseButtonPromptText
	 * 		Flags  -> ()
	 */
	class FText UCanUse::GetUseButtonPromptText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUse.GetUseButtonPromptText");
		
		UCanUse_GetUseButtonPromptText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUse.EndUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCanUse::EndUse(class APlayerCharacter* User)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUse.EndUse");
		
		UCanUse_EndUse_Params params {};
		params.User = User;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUse.CanUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCanUse::CanUse(class APlayerCharacter* User)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUse.CanUse");
		
		UCanUse_CanUse_Params params {};
		params.User = User;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCanUse.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCanUse::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CanUse");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUseMultitoolOn.ShouldOperate
	 * 		Flags  -> ()
	 */
	bool UCanUseMultitoolOn::ShouldOperate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUseMultitoolOn.ShouldOperate");
		
		UCanUseMultitoolOn_ShouldOperate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUseMultitoolOn.Server_FinishedUsingMultitool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ToolOwner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCanUseMultitoolOn::Server_FinishedUsingMultitool(class AReadyOrNotCharacter* ToolOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUseMultitoolOn.Server_FinishedUsingMultitool");
		
		UCanUseMultitoolOn_Server_FinishedUsingMultitool_Params params {};
		params.ToolOwner = ToolOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUseMultitoolOn.GetMultitoolUseType
	 * 		Flags  -> ()
	 */
	EMultitoolFunctions UCanUseMultitoolOn::GetMultitoolUseType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUseMultitoolOn.GetMultitoolUseType");
		
		UCanUseMultitoolOn_GetMultitoolUseType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUseMultitoolOn.GetMultitoolUseTime
	 * 		Flags  -> ()
	 */
	float UCanUseMultitoolOn::GetMultitoolUseTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUseMultitoolOn.GetMultitoolUseTime");
		
		UCanUseMultitoolOn_GetMultitoolUseTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUseMultitoolOn.Client_FinishedUsingMultitool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ToolOwner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCanUseMultitoolOn::Client_FinishedUsingMultitool(class AReadyOrNotCharacter* ToolOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUseMultitoolOn.Client_FinishedUsingMultitool");
		
		UCanUseMultitoolOn_Client_FinishedUsingMultitool_Params params {};
		params.ToolOwner = ToolOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUseMultitoolOn.CanUseMultitoolNow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ToolOwner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AMultitool*                                  Tool                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  TraceHit                                                   (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UCanUseMultitoolOn::CanUseMultitoolNow(class AReadyOrNotCharacter* ToolOwner, class AMultitool* Tool, const struct FHitResult& TraceHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUseMultitoolOn.CanUseMultitoolNow");
		
		UCanUseMultitoolOn_CanUseMultitoolNow_Params params {};
		params.ToolOwner = ToolOwner;
		params.Tool = Tool;
		params.TraceHit = TraceHit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CanUseMultitoolOn.CanCancelMultitoolAction
	 * 		Flags  -> ()
	 */
	bool UCanUseMultitoolOn::CanCancelMultitoolAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CanUseMultitoolOn.CanCancelMultitoolAction");
		
		UCanUseMultitoolOn_CanCancelMultitoolAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCanUseMultitoolOn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCanUseMultitoolOn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CanUseMultitoolOn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CaptureTheFlagGM.OnFlagDroppedSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            DroppedByCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          DroppedByTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACaptureTheFlagGM::OnFlagDroppedSignature__DelegateSignature(class APlayerCharacter* DroppedByCharacter, ETeamType DroppedByTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CaptureTheFlagGM.OnFlagDroppedSignature__DelegateSignature");
		
		ACaptureTheFlagGM_OnFlagDroppedSignature__DelegateSignature_Params params {};
		params.DroppedByCharacter = DroppedByCharacter;
		params.DroppedByTeam = DroppedByTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CaptureTheFlagGM.OnFlagCapturedSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            CapturedByCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          CpaturedByTeam                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACaptureTheFlagGM::OnFlagCapturedSignature__DelegateSignature(class APlayerCharacter* CapturedByCharacter, ETeamType CpaturedByTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CaptureTheFlagGM.OnFlagCapturedSignature__DelegateSignature");
		
		ACaptureTheFlagGM_OnFlagCapturedSignature__DelegateSignature_Params params {};
		params.CapturedByCharacter = CapturedByCharacter;
		params.CpaturedByTeam = CpaturedByTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CaptureTheFlagGM.OnFlagBearerKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACaptureTheFlagGM::OnFlagBearerKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CaptureTheFlagGM.OnFlagBearerKilled");
		
		ACaptureTheFlagGM_OnFlagBearerKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CaptureTheFlagGM.DropFlag
	 * 		Flags  -> ()
	 */
	void ACaptureTheFlagGM::DropFlag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CaptureTheFlagGM.DropFlag");
		
		ACaptureTheFlagGM_DropFlag_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CaptureTheFlagGM.ChooseFlagSpawnPoint
	 * 		Flags  -> ()
	 */
	class ACTF_FlagSpawnPoint* ACaptureTheFlagGM::ChooseFlagSpawnPoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CaptureTheFlagGM.ChooseFlagSpawnPoint");
		
		ACaptureTheFlagGM_ChooseFlagSpawnPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CaptureTheFlagGM.CaptureFlag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACTF_Flag*                                   CapturedFlag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            NewFlagBearer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACaptureTheFlagGM::CaptureFlag(class ACTF_Flag* CapturedFlag, class APlayerCharacter* NewFlagBearer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CaptureTheFlagGM.CaptureFlag");
		
		ACaptureTheFlagGM_CaptureFlag_Params params {};
		params.CapturedFlag = CapturedFlag;
		params.NewFlagBearer = NewFlagBearer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACaptureTheFlagGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACaptureTheFlagGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CaptureTheFlagGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CaptureTheFlagGS.OnRep_FlagStatus
	 * 		Flags  -> ()
	 */
	void ACaptureTheFlagGS::OnRep_FlagStatus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CaptureTheFlagGS.OnRep_FlagStatus");
		
		ACaptureTheFlagGS_OnRep_FlagStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACaptureTheFlagGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACaptureTheFlagGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CaptureTheFlagGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Challenge.UpdateFromProfile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UReadyOrNotProfile*                          Profile                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallenge::UpdateFromProfile(class UReadyOrNotProfile* Profile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Challenge.UpdateFromProfile");
		
		UChallenge_UpdateFromProfile_Params params {};
		params.Profile = Profile;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Challenge.ResetChallengeProgress
	 * 		Flags  -> ()
	 */
	void UChallenge::ResetChallengeProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Challenge.ResetChallengeProgress");
		
		UChallenge_ResetChallengeProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Challenge.OnChallengeInit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotGameState*                        gs                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallenge::OnChallengeInit(class AReadyOrNotGameState* gs)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Challenge.OnChallengeInit");
		
		UChallenge_OnChallengeInit_Params params {};
		params.gs = gs;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Challenge.OnChallengeAchieved
	 * 		Flags  -> ()
	 */
	void UChallenge::OnChallengeAchieved()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Challenge.OnChallengeAchieved");
		
		UChallenge_OnChallengeAchieved_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Challenge.IncrementChallengeProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            IncrementBy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallenge::IncrementChallengeProgress(int32_t IncrementBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Challenge.IncrementChallengeProgress");
		
		UChallenge_IncrementChallengeProgress_Params params {};
		params.IncrementBy = IncrementBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Challenge.DecrementChallengeProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            DecrementBy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallenge::DecrementChallengeProgress(int32_t DecrementBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Challenge.DecrementChallengeProgress");
		
		UChallenge_DecrementChallengeProgress_Params params {};
		params.DecrementBy = DecrementBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChallenge.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChallenge::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Challenge");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ChallengeManager.SaveChallenges
	 * 		Flags  -> ()
	 */
	void UChallengeManager::SaveChallenges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ChallengeManager.SaveChallenges");
		
		UChallengeManager_SaveChallenges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ChallengeManager.InitChallenges
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotGameState*                        GameState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLevelDataLookupTable                       LevelData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UChallengeManager::InitChallenges(class AReadyOrNotGameState* GameState, const struct FLevelDataLookupTable& LevelData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ChallengeManager.InitChallenges");
		
		UChallengeManager_InitChallenges_Params params {};
		params.GameState = GameState;
		params.LevelData = LevelData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChallengeManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChallengeManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ChallengeManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterCustomizationPortal.UpdateCharacterLookOverride
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Head                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Body                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACharacterCustomizationPortal::UpdateCharacterLookOverride(const class FName& Head, const class FName& Body)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterCustomizationPortal.UpdateCharacterLookOverride");
		
		ACharacterCustomizationPortal_UpdateCharacterLookOverride_Params params {};
		params.Head = Head;
		params.Body = Body;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterCustomizationPortal.SaveCharacterLookOverride
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        InHead                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        InBody                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACharacterCustomizationPortal::SaveCharacterLookOverride(const class FName& InHead, const class FName& InBody)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterCustomizationPortal.SaveCharacterLookOverride");
		
		ACharacterCustomizationPortal_SaveCharacterLookOverride_Params params {};
		params.InHead = InHead;
		params.InBody = InBody;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterCustomizationPortal.IsDLCLocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCharacterPersonalizationData               Data                                                       (Parm, NativeAccessSpecifierPublic)
	 */
	bool ACharacterCustomizationPortal::IsDLCLocked(const struct FCharacterPersonalizationData& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterCustomizationPortal.IsDLCLocked");
		
		ACharacterCustomizationPortal_IsDLCLocked_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterCustomizationPortal.GetCustomizationEntries
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FCharacterPersonalizationData>       OutHeads                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		TArray<struct FCharacterPersonalizationData>       OutBodys                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ACharacterCustomizationPortal::GetCustomizationEntries(TArray<struct FCharacterPersonalizationData>* OutHeads, TArray<struct FCharacterPersonalizationData>* OutBodys)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterCustomizationPortal.GetCustomizationEntries");
		
		ACharacterCustomizationPortal_GetCustomizationEntries_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHeads != nullptr)
			*OutHeads = params.OutHeads;
		if (OutBodys != nullptr)
			*OutBodys = params.OutBodys;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterCustomizationPortal.GetCurrentCharacterLookOverride
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        OutHead                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        OutBody                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACharacterCustomizationPortal::GetCurrentCharacterLookOverride(class FName* OutHead, class FName* OutBody)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterCustomizationPortal.GetCurrentCharacterLookOverride");
		
		ACharacterCustomizationPortal_GetCurrentCharacterLookOverride_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHead != nullptr)
			*OutHead = params.OutHead;
		if (OutBody != nullptr)
			*OutBody = params.OutBody;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterCustomizationPortal.GetCharacterLookOverride
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Head                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Body                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCharacterLookOverride                      OutCharacterLookOverride                                   (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool ACharacterCustomizationPortal::GetCharacterLookOverride(const class FName& Head, const class FName& Body, struct FCharacterLookOverride* OutCharacterLookOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterCustomizationPortal.GetCharacterLookOverride");
		
		ACharacterCustomizationPortal_GetCharacterLookOverride_Params params {};
		params.Head = Head;
		params.Body = Body;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutCharacterLookOverride != nullptr)
			*OutCharacterLookOverride = params.OutCharacterLookOverride;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterCustomizationPortal.GetAllCompatibleHeads
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        InBody                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                OutHeads                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ACharacterCustomizationPortal::GetAllCompatibleHeads(const class FName& InBody, TArray<class FName>* OutHeads)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterCustomizationPortal.GetAllCompatibleHeads");
		
		ACharacterCustomizationPortal_GetAllCompatibleHeads_Params params {};
		params.InBody = InBody;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHeads != nullptr)
			*OutHeads = params.OutHeads;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterCustomizationPortal.GetAllCompatibleBodies
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        InHead                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                OutBodies                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ACharacterCustomizationPortal::GetAllCompatibleBodies(const class FName& InHead, TArray<class FName>* OutBodies)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterCustomizationPortal.GetAllCompatibleBodies");
		
		ACharacterCustomizationPortal_GetAllCompatibleBodies_Params params {};
		params.InHead = InHead;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutBodies != nullptr)
			*OutBodies = params.OutBodies;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACharacterCustomizationPortal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACharacterCustomizationPortal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CharacterCustomizationPortal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHealthComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHealthComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HealthComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.UseAllLimbTickets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::UseAllLimbTickets(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.UseAllLimbTickets");
		
		UCharacterHealthComponent_UseAllLimbTickets_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.UpdatePreviousLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::UpdatePreviousLimbHealth(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.UpdatePreviousLimbHealth");
		
		UCharacterHealthComponent_UpdatePreviousLimbHealth_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.SetReviveHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewReviveHealth                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::SetReviveHealth(float NewReviveHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.SetReviveHealth");
		
		UCharacterHealthComponent_SetReviveHealth_Params params {};
		params.NewReviveHealth = NewReviveHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.SetRemainingRevives
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewRemainingRevives                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::SetRemainingRevives(int32_t NewRemainingRevives)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.SetRemainingRevives");
		
		UCharacterHealthComponent_SetRemainingRevives_Params params {};
		params.NewRemainingRevives = NewRemainingRevives;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.SetMaxLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewMaxHealth                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::SetMaxLimbHealth(ELimbType Limb, float NewMaxHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.SetMaxLimbHealth");
		
		UCharacterHealthComponent_SetMaxLimbHealth_Params params {};
		params.Limb = Limb;
		params.NewMaxHealth = NewMaxHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.SetLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewHealthAmount                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::SetLimbHealth(ELimbType Limb, float NewHealthAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.SetLimbHealth");
		
		UCharacterHealthComponent_SetLimbHealth_Params params {};
		params.Limb = Limb;
		params.NewHealthAmount = NewHealthAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.SetHealthStatus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerHealthStatus                                NewHealthStatus                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::SetHealthStatus(EPlayerHealthStatus NewHealthStatus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.SetHealthStatus");
		
		UCharacterHealthComponent_SetHealthStatus_Params params {};
		params.NewHealthStatus = NewHealthStatus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.SetCurrentLimbHealthToMax
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::SetCurrentLimbHealthToMax(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.SetCurrentLimbHealthToMax");
		
		UCharacterHealthComponent_SetCurrentLimbHealthToMax_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_UseAllRemainingLimbTickets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_UseAllRemainingLimbTickets(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_UseAllRemainingLimbTickets");
		
		UCharacterHealthComponent_Server_UseAllRemainingLimbTickets_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_UpdatePreviousLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_UpdatePreviousLimbHealth(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_UpdatePreviousLimbHealth");
		
		UCharacterHealthComponent_Server_UpdatePreviousLimbHealth_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_SetReviveHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewReviveHealth                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_SetReviveHealth(float NewReviveHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_SetReviveHealth");
		
		UCharacterHealthComponent_Server_SetReviveHealth_Params params {};
		params.NewReviveHealth = NewReviveHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_SetRemainingRevives
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewRemainingRevives                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_SetRemainingRevives(int32_t NewRemainingRevives)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_SetRemainingRevives");
		
		UCharacterHealthComponent_Server_SetRemainingRevives_Params params {};
		params.NewRemainingRevives = NewRemainingRevives;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_SetMaxLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewMaxHealth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_SetMaxLimbHealth(ELimbType Limb, float NewMaxHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_SetMaxLimbHealth");
		
		UCharacterHealthComponent_Server_SetMaxLimbHealth_Params params {};
		params.Limb = Limb;
		params.NewMaxHealth = NewMaxHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_SetLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewHealthAmount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_SetLimbHealth(ELimbType Limb, float NewHealthAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_SetLimbHealth");
		
		UCharacterHealthComponent_Server_SetLimbHealth_Params params {};
		params.Limb = Limb;
		params.NewHealthAmount = NewHealthAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_SetHealthStatus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerHealthStatus                                NewHealthStatus                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_SetHealthStatus(EPlayerHealthStatus NewHealthStatus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_SetHealthStatus");
		
		UCharacterHealthComponent_Server_SetHealthStatus_Params params {};
		params.NewHealthStatus = NewHealthStatus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_SetCurrentLimbHealthToMax
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_SetCurrentLimbHealthToMax(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_SetCurrentLimbHealthToMax");
		
		UCharacterHealthComponent_Server_SetCurrentLimbHealthToMax_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_ResetRevives
	 * 		Flags  -> ()
	 */
	void UCharacterHealthComponent::Server_ResetRevives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_ResetRevives");
		
		UCharacterHealthComponent_Server_ResetRevives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_ResetReviveHealth
	 * 		Flags  -> ()
	 */
	void UCharacterHealthComponent::Server_ResetReviveHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_ResetReviveHealth");
		
		UCharacterHealthComponent_Server_ResetReviveHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_ResetLimbTickets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_ResetLimbTickets(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_ResetLimbTickets");
		
		UCharacterHealthComponent_Server_ResetLimbTickets_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_ResetLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_ResetLimbHealth(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_ResetLimbHealth");
		
		UCharacterHealthComponent_Server_ResetLimbHealth_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_ResetAllLimbTickets
	 * 		Flags  -> ()
	 */
	void UCharacterHealthComponent::Server_ResetAllLimbTickets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_ResetAllLimbTickets");
		
		UCharacterHealthComponent_Server_ResetAllLimbTickets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_ResetAllLimbHealth
	 * 		Flags  -> ()
	 */
	void UCharacterHealthComponent::Server_ResetAllLimbHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_ResetAllLimbHealth");
		
		UCharacterHealthComponent_Server_ResetAllLimbHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_IncreaseReviveHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_IncreaseReviveHealth(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_IncreaseReviveHealth");
		
		UCharacterHealthComponent_Server_IncreaseReviveHealth_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_IncreaseRevive
	 * 		Flags  -> ()
	 */
	void UCharacterHealthComponent::Server_IncreaseRevive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_IncreaseRevive");
		
		UCharacterHealthComponent_Server_IncreaseRevive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_IncreaseLimbTickets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_IncreaseLimbTickets(ELimbType Limb, int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_IncreaseLimbTickets");
		
		UCharacterHealthComponent_Server_IncreaseLimbTickets_Params params {};
		params.Limb = Limb;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_IncreaseLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_IncreaseLimbHealth(ELimbType Limb, float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_IncreaseLimbHealth");
		
		UCharacterHealthComponent_Server_IncreaseLimbHealth_Params params {};
		params.Limb = Limb;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_HalfMaxLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_HalfMaxLimbHealth(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_HalfMaxLimbHealth");
		
		UCharacterHealthComponent_Server_HalfMaxLimbHealth_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_DecreaseReviveHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_DecreaseReviveHealth(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_DecreaseReviveHealth");
		
		UCharacterHealthComponent_Server_DecreaseReviveHealth_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_DecreaseRevive
	 * 		Flags  -> ()
	 */
	void UCharacterHealthComponent::Server_DecreaseRevive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_DecreaseRevive");
		
		UCharacterHealthComponent_Server_DecreaseRevive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_DecreaseLimbTickets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_DecreaseLimbTickets(ELimbType Limb, int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_DecreaseLimbTickets");
		
		UCharacterHealthComponent_Server_DecreaseLimbTickets_Params params {};
		params.Limb = Limb;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.Server_DecreaseLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::Server_DecreaseLimbHealth(ELimbType Limb, float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.Server_DecreaseLimbHealth");
		
		UCharacterHealthComponent_Server_DecreaseLimbHealth_Params params {};
		params.Limb = Limb;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.ResetRevives
	 * 		Flags  -> ()
	 */
	void UCharacterHealthComponent::ResetRevives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.ResetRevives");
		
		UCharacterHealthComponent_ResetRevives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.ResetReviveHealth
	 * 		Flags  -> ()
	 */
	void UCharacterHealthComponent::ResetReviveHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.ResetReviveHealth");
		
		UCharacterHealthComponent_ResetReviveHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.ResetLimbTickets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::ResetLimbTickets(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.ResetLimbTickets");
		
		UCharacterHealthComponent_ResetLimbTickets_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.ResetLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::ResetLimbHealth(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.ResetLimbHealth");
		
		UCharacterHealthComponent_ResetLimbHealth_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.ResetAllLimbTickets
	 * 		Flags  -> ()
	 */
	void UCharacterHealthComponent::ResetAllLimbTickets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.ResetAllLimbTickets");
		
		UCharacterHealthComponent_ResetAllLimbTickets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.ResetAllLimbHealth
	 * 		Flags  -> ()
	 */
	void UCharacterHealthComponent::ResetAllLimbHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.ResetAllLimbHealth");
		
		UCharacterHealthComponent_ResetAllLimbHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CharacterHealthComponent.OnLimbNoTicketsRemainingSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::OnLimbNoTicketsRemainingSignature__DelegateSignature(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CharacterHealthComponent.OnLimbNoTicketsRemainingSignature__DelegateSignature");
		
		UCharacterHealthComponent_OnLimbNoTicketsRemainingSignature__DelegateSignature_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CharacterHealthComponent.OnLimbNoHealthSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::OnLimbNoHealthSignature__DelegateSignature(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CharacterHealthComponent.OnLimbNoHealthSignature__DelegateSignature");
		
		UCharacterHealthComponent_OnLimbNoHealthSignature__DelegateSignature_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CharacterHealthComponent.OnLimbLowHealthSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          AffectedLimb                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LimbHealth                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::OnLimbLowHealthSignature__DelegateSignature(ELimbType AffectedLimb, float LimbHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CharacterHealthComponent.OnLimbLowHealthSignature__DelegateSignature");
		
		UCharacterHealthComponent_OnLimbLowHealthSignature__DelegateSignature_Params params {};
		params.AffectedLimb = AffectedLimb;
		params.LimbHealth = LimbHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CharacterHealthComponent.OnLimbFullTicketsSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::OnLimbFullTicketsSignature__DelegateSignature(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CharacterHealthComponent.OnLimbFullTicketsSignature__DelegateSignature");
		
		UCharacterHealthComponent_OnLimbFullTicketsSignature__DelegateSignature_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CharacterHealthComponent.OnLimbFullHealthSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::OnLimbFullHealthSignature__DelegateSignature(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CharacterHealthComponent.OnLimbFullHealthSignature__DelegateSignature");
		
		UCharacterHealthComponent_OnLimbFullHealthSignature__DelegateSignature_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CharacterHealthComponent.OnLimbBrokenSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::OnLimbBrokenSignature__DelegateSignature(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CharacterHealthComponent.OnLimbBrokenSignature__DelegateSignature");
		
		UCharacterHealthComponent_OnLimbBrokenSignature__DelegateSignature_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsUsingUnlimitedRevives
	 * 		Flags  -> ()
	 */
	bool UCharacterHealthComponent::IsUsingUnlimitedRevives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsUsingUnlimitedRevives");
		
		UCharacterHealthComponent_IsUsingUnlimitedRevives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsReviveHealthDepleted
	 * 		Flags  -> ()
	 */
	bool UCharacterHealthComponent::IsReviveHealthDepleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsReviveHealthDepleted");
		
		UCharacterHealthComponent_IsReviveHealthDepleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsLimbNoHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::IsLimbNoHealth(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsLimbNoHealth");
		
		UCharacterHealthComponent_IsLimbNoHealth_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsLimbLowHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::IsLimbLowHealth(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsLimbLowHealth");
		
		UCharacterHealthComponent_IsLimbLowHealth_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsLimbHealthBelow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::IsLimbHealthBelow(ELimbType Limb, float HealthValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsLimbHealthBelow");
		
		UCharacterHealthComponent_IsLimbHealthBelow_Params params {};
		params.Limb = Limb;
		params.HealthValue = HealthValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsLimbHealthAtOrBelow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::IsLimbHealthAtOrBelow(ELimbType Limb, float HealthValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsLimbHealthAtOrBelow");
		
		UCharacterHealthComponent_IsLimbHealthAtOrBelow_Params params {};
		params.Limb = Limb;
		params.HealthValue = HealthValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsLimbHealthAtOrAbove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::IsLimbHealthAtOrAbove(ELimbType Limb, float HealthValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsLimbHealthAtOrAbove");
		
		UCharacterHealthComponent_IsLimbHealthAtOrAbove_Params params {};
		params.Limb = Limb;
		params.HealthValue = HealthValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsLimbHealthAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::IsLimbHealthAt(ELimbType Limb, float HealthValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsLimbHealthAt");
		
		UCharacterHealthComponent_IsLimbHealthAt_Params params {};
		params.Limb = Limb;
		params.HealthValue = HealthValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsLimbHealthAbove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::IsLimbHealthAbove(ELimbType Limb, float HealthValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsLimbHealthAbove");
		
		UCharacterHealthComponent_IsLimbHealthAbove_Params params {};
		params.Limb = Limb;
		params.HealthValue = HealthValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsLimbFullHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::IsLimbFullHealth(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsLimbFullHealth");
		
		UCharacterHealthComponent_IsLimbFullHealth_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsLimbEqualTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLimbHealthData                             InLimbHealthData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FLimbHealthData                             OtherLimbHealthData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::IsLimbEqualTo(const struct FLimbHealthData& InLimbHealthData, const struct FLimbHealthData& OtherLimbHealthData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsLimbEqualTo");
		
		UCharacterHealthComponent_IsLimbEqualTo_Params params {};
		params.InLimbHealthData = InLimbHealthData;
		params.OtherLimbHealthData = OtherLimbHealthData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsLimbBroken
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::IsLimbBroken(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsLimbBroken");
		
		UCharacterHealthComponent_IsLimbBroken_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsIncapacitationEnabled
	 * 		Flags  -> ()
	 */
	bool UCharacterHealthComponent::IsIncapacitationEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsIncapacitationEnabled");
		
		UCharacterHealthComponent_IsIncapacitationEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsIncapacitated
	 * 		Flags  -> ()
	 */
	bool UCharacterHealthComponent::IsIncapacitated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsIncapacitated");
		
		UCharacterHealthComponent_IsIncapacitated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsAnyLimbBroken
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          OutLimbType                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::IsAnyLimbBroken(ELimbType* OutLimbType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsAnyLimbBroken");
		
		UCharacterHealthComponent_IsAnyLimbBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLimbType != nullptr)
			*OutLimbType = params.OutLimbType;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsAnyLimbBelowFullHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          OutLimbType                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::IsAnyLimbBelowFullHealth(ELimbType* OutLimbType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsAnyLimbBelowFullHealth");
		
		UCharacterHealthComponent_IsAnyLimbBelowFullHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLimbType != nullptr)
			*OutLimbType = params.OutLimbType;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IsAnyLimbAtNoHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          OutLimbType                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::IsAnyLimbAtNoHealth(ELimbType* OutLimbType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IsAnyLimbAtNoHealth");
		
		UCharacterHealthComponent_IsAnyLimbAtNoHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLimbType != nullptr)
			*OutLimbType = params.OutLimbType;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IncreaseReviveHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::IncreaseReviveHealth(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IncreaseReviveHealth");
		
		UCharacterHealthComponent_IncreaseReviveHealth_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IncreaseRevive
	 * 		Flags  -> ()
	 */
	void UCharacterHealthComponent::IncreaseRevive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IncreaseRevive");
		
		UCharacterHealthComponent_IncreaseRevive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IncreaseLimbTickets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::IncreaseLimbTickets(ELimbType Limb, int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IncreaseLimbTickets");
		
		UCharacterHealthComponent_IncreaseLimbTickets_Params params {};
		params.Limb = Limb;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.IncreaseLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Amount                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::IncreaseLimbHealth(ELimbType Limb, float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.IncreaseLimbHealth");
		
		UCharacterHealthComponent_IncreaseLimbHealth_Params params {};
		params.Limb = Limb;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.HalfMaxLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterHealthComponent::HalfMaxLimbHealth(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.HalfMaxLimbHealth");
		
		UCharacterHealthComponent_HalfMaxLimbHealth_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetRightLegHealth_Copy
	 * 		Flags  -> ()
	 */
	struct FLimbHealthData UCharacterHealthComponent::GetRightLegHealth_Copy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetRightLegHealth_Copy");
		
		UCharacterHealthComponent_GetRightLegHealth_Copy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetRightArmHealth_Copy
	 * 		Flags  -> ()
	 */
	struct FLimbHealthData UCharacterHealthComponent::GetRightArmHealth_Copy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetRightArmHealth_Copy");
		
		UCharacterHealthComponent_GetRightArmHealth_Copy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetReviveOperatingTime
	 * 		Flags  -> ()
	 */
	float UCharacterHealthComponent::GetReviveOperatingTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetReviveOperatingTime");
		
		UCharacterHealthComponent_GetReviveOperatingTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetRemainingReviveTime
	 * 		Flags  -> ()
	 */
	float UCharacterHealthComponent::GetRemainingReviveTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetRemainingReviveTime");
		
		UCharacterHealthComponent_GetRemainingReviveTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetRemainingRevives
	 * 		Flags  -> ()
	 */
	int32_t UCharacterHealthComponent::GetRemainingRevives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetRemainingRevives");
		
		UCharacterHealthComponent_GetRemainingRevives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetRemainingReviveHealth
	 * 		Flags  -> ()
	 */
	float UCharacterHealthComponent::GetRemainingReviveHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetRemainingReviveHealth");
		
		UCharacterHealthComponent_GetRemainingReviveHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetMaxRevives
	 * 		Flags  -> ()
	 */
	int32_t UCharacterHealthComponent::GetMaxRevives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetMaxRevives");
		
		UCharacterHealthComponent_GetMaxRevives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetMaxReviveHealth
	 * 		Flags  -> ()
	 */
	float UCharacterHealthComponent::GetMaxReviveHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetMaxReviveHealth");
		
		UCharacterHealthComponent_GetMaxReviveHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetLimb_Copy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLimbHealthData UCharacterHealthComponent::GetLimb_Copy(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetLimb_Copy");
		
		UCharacterHealthComponent_GetLimb_Copy_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetLeftLegHealth_Copy
	 * 		Flags  -> ()
	 */
	struct FLimbHealthData UCharacterHealthComponent::GetLeftLegHealth_Copy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetLeftLegHealth_Copy");
		
		UCharacterHealthComponent_GetLeftLegHealth_Copy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetLeftArmHealth_Copy
	 * 		Flags  -> ()
	 */
	struct FLimbHealthData UCharacterHealthComponent::GetLeftArmHealth_Copy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetLeftArmHealth_Copy");
		
		UCharacterHealthComponent_GetLeftArmHealth_Copy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetHealthStatus
	 * 		Flags  -> ()
	 */
	EPlayerHealthStatus UCharacterHealthComponent::GetHealthStatus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetHealthStatus");
		
		UCharacterHealthComponent_GetHealthStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetHeadHealth_Copy
	 * 		Flags  -> ()
	 */
	struct FLimbHealthData UCharacterHealthComponent::GetHeadHealth_Copy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetHeadHealth_Copy");
		
		UCharacterHealthComponent_GetHeadHealth_Copy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.GetBrokenLimbs
	 * 		Flags  -> ()
	 */
	TArray<ELimbType> UCharacterHealthComponent::GetBrokenLimbs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.GetBrokenLimbs");
		
		UCharacterHealthComponent_GetBrokenLimbs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.DecreaseReviveHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::DecreaseReviveHealth(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.DecreaseReviveHealth");
		
		UCharacterHealthComponent_DecreaseReviveHealth_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.DecreaseRevive
	 * 		Flags  -> ()
	 */
	void UCharacterHealthComponent::DecreaseRevive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.DecreaseRevive");
		
		UCharacterHealthComponent_DecreaseRevive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.DecreaseLimbTickets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::DecreaseLimbTickets(ELimbType Limb, int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.DecreaseLimbTickets");
		
		UCharacterHealthComponent_DecreaseLimbTickets_Params params {};
		params.Limb = Limb;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.DecreaseLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Amount                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterHealthComponent::DecreaseLimbHealth(ELimbType Limb, float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.DecreaseLimbHealth");
		
		UCharacterHealthComponent_DecreaseLimbHealth_Params params {};
		params.Limb = Limb;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CharacterHealthComponent.CanUseReviveSystem
	 * 		Flags  -> ()
	 */
	bool UCharacterHealthComponent::CanUseReviveSystem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CharacterHealthComponent.CanUseReviveSystem");
		
		UCharacterHealthComponent_CanUseReviveSystem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterHealthComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterHealthComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CharacterHealthComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChargeCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChargeCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ChargeCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCheckDoorQuestNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCheckDoorQuestNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CheckDoorQuestNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Chemlight.SetFPMeshHidden
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFPMeshHidden                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AChemlight::SetFPMeshHidden(bool bFPMeshHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Chemlight.SetFPMeshHidden");
		
		AChemlight_SetFPMeshHidden_Params params {};
		params.bFPMeshHidden = bFPMeshHidden;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Chemlight.Server_SpawnThrownChemlight
	 * 		Flags  -> ()
	 */
	void AChemlight::Server_SpawnThrownChemlight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Chemlight.Server_SpawnThrownChemlight");
		
		AChemlight_Server_SpawnThrownChemlight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Chemlight.QuickThrow
	 * 		Flags  -> ()
	 */
	void AChemlight::QuickThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Chemlight.QuickThrow");
		
		AChemlight_QuickThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Chemlight.OnChemlightThrown
	 * 		Flags  -> ()
	 */
	void AChemlight::OnChemlightThrown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Chemlight.OnChemlightThrown");
		
		AChemlight_OnChemlightThrown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Chemlight.NormalThrow
	 * 		Flags  -> ()
	 */
	void AChemlight::NormalThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Chemlight.NormalThrow");
		
		AChemlight_NormalThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Chemlight.Multicast_SpawnThrownChemlight
	 * 		Flags  -> ()
	 */
	void AChemlight::Multicast_SpawnThrownChemlight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Chemlight.Multicast_SpawnThrownChemlight");
		
		AChemlight_Multicast_SpawnThrownChemlight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Chemlight.IsPlayingChemlightThrowAnimations
	 * 		Flags  -> ()
	 */
	bool AChemlight::IsPlayingChemlightThrowAnimations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Chemlight.IsPlayingChemlightThrowAnimations");
		
		AChemlight_IsPlayingChemlightThrowAnimations_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Chemlight.GetRemainingAmmo
	 * 		Flags  -> ()
	 */
	int32_t AChemlight::GetRemainingAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Chemlight.GetRemainingAmmo");
		
		AChemlight_GetRemainingAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Chemlight.CanThrow
	 * 		Flags  -> ()
	 */
	bool AChemlight::CanThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Chemlight.CanThrow");
		
		AChemlight_CanThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Chemlight.CancelThrow
	 * 		Flags  -> ()
	 */
	void AChemlight::CancelThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Chemlight.CancelThrow");
		
		AChemlight_CancelThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Chemlight.AICanThrowChemlightAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AChemlight::AICanThrowChemlightAtLocation(const struct FCoreUObject_FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Chemlight.AICanThrowChemlightAtLocation");
		
		AChemlight_AICanThrowChemlightAtLocation_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AChemlight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AChemlight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Chemlight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.UsingReviveSystem
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::UsingReviveSystem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.UsingReviveSystem");
		
		AReadyOrNotCharacter_UsingReviveSystem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.UpdateOverridesFromCharacterLookOverrideDataTable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      LookOverride                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::UpdateOverridesFromCharacterLookOverrideDataTable(const class FString& LookOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.UpdateOverridesFromCharacterLookOverrideDataTable");
		
		AReadyOrNotCharacter_UpdateOverridesFromCharacterLookOverrideDataTable_Params params {};
		params.LookOverride = LookOverride;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.UnlockMovementAndActions
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::UnlockMovementAndActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.UnlockMovementAndActions");
		
		AReadyOrNotCharacter_UnlockMovementAndActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.UnlockMovement
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::UnlockMovement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.UnlockMovement");
		
		AReadyOrNotCharacter_UnlockMovement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.UnlockAllActions
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::UnlockAllActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.UnlockAllActions");
		
		AReadyOrNotCharacter_UnlockAllActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.UnlockAim
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::UnlockAim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.UnlockAim");
		
		AReadyOrNotCharacter_UnlockAim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.TestPhysicalAnimationComponent
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::TestPhysicalAnimationComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.TestPhysicalAnimationComponent");
		
		AReadyOrNotCharacter_TestPhysicalAnimationComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.StopTPMontageFromTable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendoutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::StopTPMontageFromTable(const class FString& Animation, float BlendoutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.StopTPMontageFromTable");
		
		AReadyOrNotCharacter_StopTPMontageFromTable_Params params {};
		params.Animation = Animation;
		params.BlendoutTime = BlendoutTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.StopTPMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendoutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::StopTPMontage(class UAnimMontage* AnimMontage, float BlendoutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.StopTPMontage");
		
		AReadyOrNotCharacter_StopTPMontage_Params params {};
		params.AnimMontage = AnimMontage;
		params.BlendoutTime = BlendoutTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.StopTPAnimMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::StopTPAnimMontage(class UAnimMontage* AnimMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.StopTPAnimMontage");
		
		AReadyOrNotCharacter_StopTPAnimMontage_Params params {};
		params.AnimMontage = AnimMontage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.StopFPAnimMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendoutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::StopFPAnimMontage(class UAnimMontage* AnimMontage, float BlendoutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.StopFPAnimMontage");
		
		AReadyOrNotCharacter_StopFPAnimMontage_Params params {};
		params.AnimMontage = AnimMontage;
		params.BlendoutTime = BlendoutTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.StartStun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      StunCauser                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::StartStun(EStunType StunType, class AActor* StunCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.StartStun");
		
		AReadyOrNotCharacter_StartStun_Params params {};
		params.StunType = StunType;
		params.StunCauser = StunCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.StartPepperSprayed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class APepperspray*                                PeppersprayUsed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::StartPepperSprayed(const struct FHitResult& Hit, class APepperspray* PeppersprayUsed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.StartPepperSprayed");
		
		AReadyOrNotCharacter_StartPepperSprayed_Params params {};
		params.Hit = Hit;
		params.PeppersprayUsed = PeppersprayUsed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.StartBeingTasered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              PingStunDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATaser*                                      WeaponUsed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::StartBeingTasered(float PingStunDuration, class ATaser* WeaponUsed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.StartBeingTasered");
		
		AReadyOrNotCharacter_StartBeingTasered_Params params {};
		params.PingStunDuration = PingStunDuration;
		params.WeaponUsed = WeaponUsed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.SpawnFootstepEffect
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::SpawnFootstepEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.SpawnFootstepEffect");
		
		AReadyOrNotCharacter_SpawnFootstepEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.SpawnEvidenceCollectionBag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                     SpawnTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class ACollectedEvidenceActor* AReadyOrNotCharacter::SpawnEvidenceCollectionBag(const struct FTransform& SpawnTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.SpawnEvidenceCollectionBag");
		
		AReadyOrNotCharacter_SpawnEvidenceCollectionBag_Params params {};
		params.SpawnTransform = SpawnTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.SpawnBloodPool
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::SpawnBloodPool()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.SpawnBloodPool");
		
		AReadyOrNotCharacter_SpawnBloodPool_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_Yell
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::Server_Yell()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_Yell");
		
		AReadyOrNotCharacter_Server_Yell_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_ThrowArrestedTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ArrestedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_ThrowArrestedTarget(class AReadyOrNotCharacter* ArrestedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_ThrowArrestedTarget");
		
		AReadyOrNotCharacter_Server_ThrowArrestedTarget_Params params {};
		params.ArrestedCharacter = ArrestedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_StartStun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      StunCauser                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_StartStun(EStunType StunType, class AActor* StunCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_StartStun");
		
		AReadyOrNotCharacter_Server_StartStun_Params params {};
		params.StunType = StunType;
		params.StunCauser = StunCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_ReportToTOC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayAnimation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_ReportToTOC(class AActor* Actor, bool bPlayAnimation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_ReportToTOC");
		
		AReadyOrNotCharacter_Server_ReportToTOC_Params params {};
		params.Actor = Actor;
		params.bPlayAnimation = bPlayAnimation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_ReportTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_ReportTarget(class AActor* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_ReportTarget");
		
		AReadyOrNotCharacter_Server_ReportTarget_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_PlayTOCConversation
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::Server_PlayTOCConversation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_PlayTOCConversation");
		
		AReadyOrNotCharacter_Server_PlayTOCConversation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_PlayNonLocal3PMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                NewMontage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_PlayNonLocal3PMontage(class UAnimMontage* NewMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_PlayNonLocal3PMontage");
		
		AReadyOrNotCharacter_Server_PlayNonLocal3PMontage_Params params {};
		params.NewMontage = NewMontage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_Play3PMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                NewMontage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_Play3PMontage(class UAnimMontage* NewMontage, float StartTime, float PlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_Play3PMontage");
		
		AReadyOrNotCharacter_Server_Play3PMontage_Params params {};
		params.NewMontage = NewMontage;
		params.StartTime = StartTime;
		params.PlayRate = PlayRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_MeleeInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_MeleeInteract(class UObject* Interactable, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_MeleeInteract");
		
		AReadyOrNotCharacter_Server_MeleeInteract_Params params {};
		params.Interactable = Interactable;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_Kill
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::Server_Kill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_Kill");
		
		AReadyOrNotCharacter_Server_Kill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_KickQueuedDoor
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::Server_KickQueuedDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_KickQueuedDoor");
		
		AReadyOrNotCharacter_Server_KickQueuedDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_KickFailQueuedDoor
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::Server_KickFailQueuedDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_KickFailQueuedDoor");
		
		AReadyOrNotCharacter_Server_KickFailQueuedDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_KickBreakQueuedDoor
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::Server_KickBreakQueuedDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_KickBreakQueuedDoor");
		
		AReadyOrNotCharacter_Server_KickBreakQueuedDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_Interact_PrimaryUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_Interact_PrimaryUse(class UObject* Interactable, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_Interact_PrimaryUse");
		
		AReadyOrNotCharacter_Server_Interact_PrimaryUse_Params params {};
		params.Interactable = Interactable;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_Interact
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_Interact(class UObject* Interactable, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_Interact");
		
		AReadyOrNotCharacter_Server_Interact_Params params {};
		params.Interactable = Interactable;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_EndInteract_PrimaryUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_EndInteract_PrimaryUse(class UObject* Interactable, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_EndInteract_PrimaryUse");
		
		AReadyOrNotCharacter_Server_EndInteract_PrimaryUse_Params params {};
		params.Interactable = Interactable;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_EndInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_EndInteract(class UObject* Interactable, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_EndInteract");
		
		AReadyOrNotCharacter_Server_EndInteract_Params params {};
		params.Interactable = Interactable;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_DropArrestedTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ArrestedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_DropArrestedTarget(class AReadyOrNotCharacter* ArrestedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_DropArrestedTarget");
		
		AReadyOrNotCharacter_Server_DropArrestedTarget_Params params {};
		params.ArrestedCharacter = ArrestedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_DoubleTapInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_DoubleTapInteract(class UObject* Interactable, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_DoubleTapInteract");
		
		AReadyOrNotCharacter_Server_DoubleTapInteract_Params params {};
		params.Interactable = Interactable;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_DoMelee
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::Server_DoMelee()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_DoMelee");
		
		AReadyOrNotCharacter_Server_DoMelee_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_CollectEvidenceActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AEvidenceActor*                              InEvidenceActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_CollectEvidenceActor(class AEvidenceActor* InEvidenceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_CollectEvidenceActor");
		
		AReadyOrNotCharacter_Server_CollectEvidenceActor_Params params {};
		params.InEvidenceActor = InEvidenceActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_CollectEvidence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_CollectEvidence(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_CollectEvidence");
		
		AReadyOrNotCharacter_Server_CollectEvidence_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_ChangeTPMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMesh*                               Body                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMesh*                               Face                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_ChangeTPMesh(class USkeletalMesh* Body, class USkeletalMesh* Face)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_ChangeTPMesh");
		
		AReadyOrNotCharacter_Server_ChangeTPMesh_Params params {};
		params.Body = Body;
		params.Face = Face;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_CarryArrestedTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ArrestedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_CarryArrestedTarget(class AReadyOrNotCharacter* ArrestedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_CarryArrestedTarget");
		
		AReadyOrNotCharacter_Server_CarryArrestedTarget_Params params {};
		params.ArrestedCharacter = ArrestedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Server_ApplyPointDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        HitFromDirection                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Server_ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, const struct FCoreUObject_FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, class UClass* DamageTypeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Server_ApplyPointDamage");
		
		AReadyOrNotCharacter_Server_ApplyPointDamage_Params params {};
		params.DamagedActor = DamagedActor;
		params.BaseDamage = BaseDamage;
		params.HitFromDirection = HitFromDirection;
		params.HitInfo = HitInfo;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageTypeClass = DamageTypeClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.ResetPhysicsAsset
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::ResetPhysicsAsset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.ResetPhysicsAsset");
		
		AReadyOrNotCharacter_ResetPhysicsAsset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.ResetHealth
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::ResetHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.ResetHealth");
		
		AReadyOrNotCharacter_ResetHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.RagdollArrestTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        RagdollCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::RagdollArrestTarget(class AReadyOrNotCharacter* RagdollCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.RagdollArrestTarget");
		
		AReadyOrNotCharacter_RagdollArrestTarget_Params params {};
		params.RagdollCharacter = RagdollCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.PlayTOCResponse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Line                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNetworked                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETOCPriority                                       Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanPrefix                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::PlayTOCResponse(const class FString& Line, bool bIsNetworked, ETOCPriority Priority, bool bCanPrefix, float Delay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.PlayTOCResponse");
		
		AReadyOrNotCharacter_PlayTOCResponse_Params params {};
		params.Line = Line;
		params.bIsNetworked = bIsNetworked;
		params.Priority = Priority;
		params.bCanPrefix = bCanPrefix;
		params.Delay = Delay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.PlaySpecificDebugVoiceLine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filename                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::PlaySpecificDebugVoiceLine(const class FString& Filename)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.PlaySpecificDebugVoiceLine");
		
		AReadyOrNotCharacter_PlaySpecificDebugVoiceLine_Params params {};
		params.Filename = Filename;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.PlayROEViolateTOCResponse
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::PlayROEViolateTOCResponse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.PlayROEViolateTOCResponse");
		
		AReadyOrNotCharacter_PlayROEViolateTOCResponse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.PlayRawVOWithCooldown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      VoiceLine                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Cooldown                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OverrideSpeakerName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::PlayRawVOWithCooldown(const class FString& VoiceLine, float Cooldown, const class FString& OverrideSpeakerName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.PlayRawVOWithCooldown");
		
		AReadyOrNotCharacter_PlayRawVOWithCooldown_Params params {};
		params.VoiceLine = VoiceLine;
		params.Cooldown = Cooldown;
		params.OverrideSpeakerName = OverrideSpeakerName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.PlayRawVO
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      VoiceLine                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OverrideSpeakerName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreIfAlreadyPlaying                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::PlayRawVO(const class FString& VoiceLine, const class FString& OverrideSpeakerName, bool bIgnoreIfAlreadyPlaying)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.PlayRawVO");
		
		AReadyOrNotCharacter_PlayRawVO_Params params {};
		params.VoiceLine = VoiceLine;
		params.OverrideSpeakerName = OverrideSpeakerName;
		params.bIgnoreIfAlreadyPlaying = bIgnoreIfAlreadyPlaying;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.PlayRandomDebugVoiceLine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Line                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::PlayRandomDebugVoiceLine(const class FString& Line)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.PlayRandomDebugVoiceLine");
		
		AReadyOrNotCharacter_PlayRandomDebugVoiceLine_Params params {};
		params.Line = Line;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.PlayRandomDebugConversation
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::PlayRandomDebugConversation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.PlayRandomDebugConversation");
		
		AReadyOrNotCharacter_PlayRandomDebugConversation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.PlayPairedInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInteractionsData*                           InteractionData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Driver                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Slave                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseItem*                                   OptionalItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APairedInteractionDriver* AReadyOrNotCharacter::PlayPairedInteraction(class UInteractionsData* InteractionData, class AActor* Driver, class AActor* Slave, class ABaseItem* OptionalItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.PlayPairedInteraction");
		
		AReadyOrNotCharacter_PlayPairedInteraction_Params params {};
		params.InteractionData = InteractionData;
		params.Driver = Driver;
		params.Slave = Slave;
		params.OptionalItem = OptionalItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.PlayMontageFromTableWithIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimMontage* AReadyOrNotCharacter::PlayMontageFromTableWithIndex(const class FString& Animation, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.PlayMontageFromTableWithIndex");
		
		AReadyOrNotCharacter_PlayMontageFromTableWithIndex_Params params {};
		params.Animation = Animation;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.PlayMontageFromTable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimMontage* AReadyOrNotCharacter::PlayMontageFromTable(const class FString& Animation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.PlayMontageFromTable");
		
		AReadyOrNotCharacter_PlayMontageFromTable_Params params {};
		params.Animation = Animation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Play3PMontageDeferred
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      AnimationName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Play3PMontageDeferred(class UAnimMontage* Montage, const class FString& AnimationName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Play3PMontageDeferred");
		
		AReadyOrNotCharacter_Play3PMontageDeferred_Params params {};
		params.Montage = Montage;
		params.AnimationName = AnimationName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Play3PMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                NewMontage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Play3PMontage(class UAnimMontage* NewMontage, float StartTime, float PlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Play3PMontage");
		
		AReadyOrNotCharacter_Play3PMontage_Params params {};
		params.NewMontage = NewMontage;
		params.StartTime = StartTime;
		params.PlayRate = PlayRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Play1PMontageDeferred
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      AnimationName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Play1PMontageDeferred(class UAnimMontage* Montage, const class FString& AnimationName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Play1PMontageDeferred");
		
		AReadyOrNotCharacter_Play1PMontageDeferred_Params params {};
		params.Montage = Montage;
		params.AnimationName = AnimationName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Play1PMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                NewMontage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Play1PMontage(class UAnimMontage* NewMontage, float PlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Play1PMontage");
		
		AReadyOrNotCharacter_Play1PMontage_Params params {};
		params.NewMontage = NewMontage;
		params.PlayRate = PlayRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.PickupEvidence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InEvidence                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::PickupEvidence(class AActor* InEvidence)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.PickupEvidence");
		
		AReadyOrNotCharacter_PickupEvidence_Params params {};
		params.InEvidence = InEvidence;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OpenDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOpenDoor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::OpenDoor(class ADoor* Door, bool bOpenDoor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OpenDoor");
		
		AReadyOrNotCharacter_OpenDoor_Params params {};
		params.Door = Door;
		params.bOpenDoor = bOpenDoor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnYellExecute
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnYellExecute()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnYellExecute");
		
		AReadyOrNotCharacter_OnYellExecute_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnWeaponFire__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseMagazineWeapon*                         Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        fireDirection                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnWeaponFire__DelegateSignature(class AReadyOrNotCharacter* Character, class ABaseMagazineWeapon* Weapon, const struct FCoreUObject_FVector& fireDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnWeaponFire__DelegateSignature");
		
		AReadyOrNotCharacter_OnWeaponFire__DelegateSignature_Params params {};
		params.Character = Character;
		params.Weapon = Weapon;
		params.fireDirection = fireDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnVoiceAudioStopped
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnVoiceAudioStopped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnVoiceAudioStopped");
		
		AReadyOrNotCharacter_OnVoiceAudioStopped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnStunnedPlaySound__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsImmune                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnStunnedPlaySound__DelegateSignature(EStunType StunType, bool bIsImmune)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnStunnedPlaySound__DelegateSignature");
		
		AReadyOrNotCharacter_OnStunnedPlaySound__DelegateSignature_Params params {};
		params.StunType = StunType;
		params.bIsImmune = bIsImmune;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnStunnedEnded__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnStunnedEnded__DelegateSignature(EStunType StunType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnStunnedEnded__DelegateSignature");
		
		AReadyOrNotCharacter_OnStunnedEnded__DelegateSignature_Params params {};
		params.StunType = StunType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnStunned__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnStunned__DelegateSignature(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnStunned__DelegateSignature");
		
		AReadyOrNotCharacter_OnStunned__DelegateSignature_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnStunDamage__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Causer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  HitCharacter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStunDamage*                                 DamageEvent                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnStunDamage__DelegateSignature(float Damage, class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* HitCharacter, class UStunDamage* DamageEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnStunDamage__DelegateSignature");
		
		AReadyOrNotCharacter_OnStunDamage__DelegateSignature_Params params {};
		params.Damage = Damage;
		params.Causer = Causer;
		params.InstigatorCharacter = InstigatorCharacter;
		params.HitCharacter = HitCharacter;
		params.DamageEvent = DamageEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnRep_Surrendered
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnRep_Surrendered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnRep_Surrendered");
		
		AReadyOrNotCharacter_OnRep_Surrendered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnRep_ReplicatedAcceleration
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnRep_ReplicatedAcceleration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnRep_ReplicatedAcceleration");
		
		AReadyOrNotCharacter_OnRep_ReplicatedAcceleration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnRep_MeshReplicated
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnRep_MeshReplicated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnRep_MeshReplicated");
		
		AReadyOrNotCharacter_OnRep_MeshReplicated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnRep_CurrentRagdollArrestCharacterChanged
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnRep_CurrentRagdollArrestCharacterChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnRep_CurrentRagdollArrestCharacterChanged");
		
		AReadyOrNotCharacter_OnRep_CurrentRagdollArrestCharacterChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnRep_CurrentCarryCharacterChanged
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnRep_CurrentCarryCharacterChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnRep_CurrentCarryCharacterChanged");
		
		AReadyOrNotCharacter_OnRep_CurrentCarryCharacterChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnRep_ControlRotation
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnRep_ControlRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnRep_ControlRotation");
		
		AReadyOrNotCharacter_OnRep_ControlRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnRep_CharacterLookOverride
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnRep_CharacterLookOverride()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnRep_CharacterLookOverride");
		
		AReadyOrNotCharacter_OnRep_CharacterLookOverride_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnRep_ActiveRagdollPhysAsset
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnRep_ActiveRagdollPhysAsset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnRep_ActiveRagdollPhysAsset");
		
		AReadyOrNotCharacter_OnRep_ActiveRagdollPhysAsset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnQuickthrowStart__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   LastItemBeforeQuickThrow                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseItem*                                   QuickThrowGrenade                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnQuickthrowStart__DelegateSignature(class ABaseItem* LastItemBeforeQuickThrow, class ABaseItem* QuickThrowGrenade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnQuickthrowStart__DelegateSignature");
		
		AReadyOrNotCharacter_OnQuickthrowStart__DelegateSignature_Params params {};
		params.LastItemBeforeQuickThrow = LastItemBeforeQuickThrow;
		params.QuickThrowGrenade = QuickThrowGrenade;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnQuickthrowEnd__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   QuickThrowGrenade                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnQuickthrowEnd__DelegateSignature(class ABaseItem* QuickThrowGrenade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnQuickthrowEnd__DelegateSignature");
		
		AReadyOrNotCharacter_OnQuickthrowEnd__DelegateSignature_Params params {};
		params.QuickThrowGrenade = QuickThrowGrenade;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnPointDamage__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Causer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  HitCharacter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBulletDamageType*                           DamageEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnPointDamage__DelegateSignature(float Damage, class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* HitCharacter, class UBulletDamageType* DamageEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnPointDamage__DelegateSignature");
		
		AReadyOrNotCharacter_OnPointDamage__DelegateSignature_Params params {};
		params.Damage = Damage;
		params.Causer = Causer;
		params.InstigatorCharacter = InstigatorCharacter;
		params.HitCharacter = HitCharacter;
		params.DamageEvent = DamageEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnPlayerHitEvent__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        HitBone                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnPlayerHitEvent__DelegateSignature(float Damage, const class FName& HitBone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnPlayerHitEvent__DelegateSignature");
		
		AReadyOrNotCharacter_OnPlayerHitEvent__DelegateSignature_Params params {};
		params.Damage = Damage;
		params.HitBone = HitBone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnPickupItemNotifyEvent__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnPickupItemNotifyEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnPickupItemNotifyEvent__DelegateSignature");
		
		AReadyOrNotCharacter_OnPickupItemNotifyEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnMirrorDoorNotifyEvent__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnMirrorDoorNotifyEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnMirrorDoorNotifyEvent__DelegateSignature");
		
		AReadyOrNotCharacter_OnMirrorDoorNotifyEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnMeshHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnMeshHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnMeshHit");
		
		AReadyOrNotCharacter_OnMeshHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnMeleeHitTaken__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnMeleeHitTaken__DelegateSignature(class AReadyOrNotCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnMeleeHitTaken__DelegateSignature");
		
		AReadyOrNotCharacter_OnMeleeHitTaken__DelegateSignature_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnKilled(class AReadyOrNotCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnKilled");
		
		AReadyOrNotCharacter_OnKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnItemThrownNotifyEvent__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   InThrownItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnItemThrownNotifyEvent__DelegateSignature(class ABaseItem* InThrownItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnItemThrownNotifyEvent__DelegateSignature");
		
		AReadyOrNotCharacter_OnItemThrownNotifyEvent__DelegateSignature_Params params {};
		params.InThrownItem = InThrownItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnItemHolstered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   HolsteredItem                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnItemHolstered(class ABaseItem* HolsteredItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnItemHolstered");
		
		AReadyOrNotCharacter_OnItemHolstered_Params params {};
		params.HolsteredItem = HolsteredItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnItemEquipped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   NewEquippedItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnItemEquipped(class ABaseItem* NewEquippedItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnItemEquipped");
		
		AReadyOrNotCharacter_OnItemEquipped_Params params {};
		params.NewEquippedItem = NewEquippedItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnIncapacitated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnIncapacitated(class AReadyOrNotCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnIncapacitated");
		
		AReadyOrNotCharacter_OnIncapacitated_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnHealthDepleted
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnHealthDepleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnHealthDepleted");
		
		AReadyOrNotCharacter_OnHealthDepleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnGetupComplete__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnGetupComplete__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnGetupComplete__DelegateSignature");
		
		AReadyOrNotCharacter_OnGetupComplete__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnFreed__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACharacter*                                  Freed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  Freer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnFreed__DelegateSignature(class ACharacter* Freed, class ACharacter* Freer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnFreed__DelegateSignature");
		
		AReadyOrNotCharacter_OnFreed__DelegateSignature_Params params {};
		params.Freed = Freed;
		params.Freer = Freer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnFootstep__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnFootstep__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnFootstep__DelegateSignature");
		
		AReadyOrNotCharacter_OnFootstep__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnEquippedWeaponMagCheck
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseMagazineWeapon*                         Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnEquippedWeaponMagCheck(class ABaseMagazineWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnEquippedWeaponMagCheck");
		
		AReadyOrNotCharacter_OnEquippedWeaponMagCheck_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnEquippedWeaponFire
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseMagazineWeapon*                         Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bServer                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnEquippedWeaponFire(class ABaseMagazineWeapon* Weapon, bool bServer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnEquippedWeaponFire");
		
		AReadyOrNotCharacter_OnEquippedWeaponFire_Params params {};
		params.Weapon = Weapon;
		params.bServer = bServer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnEquippedWeaponDryFire
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseMagazineWeapon*                         Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bServer                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnEquippedWeaponDryFire(class ABaseMagazineWeapon* Weapon, bool bServer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnEquippedWeaponDryFire");
		
		AReadyOrNotCharacter_OnEquippedWeaponDryFire_Params params {};
		params.Weapon = Weapon;
		params.bServer = bServer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnDowned__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DownedCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnDowned__DelegateSignature(class AReadyOrNotCharacter* DownedCharacter, class AReadyOrNotCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnDowned__DelegateSignature");
		
		AReadyOrNotCharacter_OnDowned__DelegateSignature_Params params {};
		params.DownedCharacter = DownedCharacter;
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnDoorWedgePlacedNotifyEvent__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnDoorWedgePlacedNotifyEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnDoorWedgePlacedNotifyEvent__DelegateSignature");
		
		AReadyOrNotCharacter_OnDoorWedgePlacedNotifyEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnDoorLockPickNotifyEvent__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnDoorLockPickNotifyEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnDoorLockPickNotifyEvent__DelegateSignature");
		
		AReadyOrNotCharacter_OnDoorLockPickNotifyEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnDoorCheckedNotifyEvent__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnDoorCheckedNotifyEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnDoorCheckedNotifyEvent__DelegateSignature");
		
		AReadyOrNotCharacter_OnDoorCheckedNotifyEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnDismembermentParticleCollision
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        EventName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              EmitterTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ParticleTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Velocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Normal                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPhysicalMaterial*                           PhysMat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnDismembermentParticleCollision(const class FName& EventName, float EmitterTime, int32_t ParticleTime, const struct FCoreUObject_FVector& Location, const struct FCoreUObject_FVector& Velocity, const struct FCoreUObject_FVector& Direction, const struct FCoreUObject_FVector& Normal, const class FName& BoneName, class UPhysicalMaterial* PhysMat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnDismembermentParticleCollision");
		
		AReadyOrNotCharacter_OnDismembermentParticleCollision_Params params {};
		params.EventName = EventName;
		params.EmitterTime = EmitterTime;
		params.ParticleTime = ParticleTime;
		params.Location = Location;
		params.Velocity = Velocity;
		params.Direction = Direction;
		params.Normal = Normal;
		params.BoneName = BoneName;
		params.PhysMat = PhysMat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnDisarmTrapNotifyEvent__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnDisarmTrapNotifyEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnDisarmTrapNotifyEvent__DelegateSignature");
		
		AReadyOrNotCharacter_OnDisarmTrapNotifyEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnDeadHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnDeadHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnDeadHit");
		
		AReadyOrNotCharacter_OnDeadHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnCharacterTakeDamage__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnCharacterTakeDamage__DelegateSignature(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnCharacterTakeDamage__DelegateSignature");
		
		AReadyOrNotCharacter_OnCharacterTakeDamage__DelegateSignature_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnCharacterKilled__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnCharacterKilled__DelegateSignature(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnCharacterKilled__DelegateSignature");
		
		AReadyOrNotCharacter_OnCharacterKilled__DelegateSignature_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnCharacterIncapacitated__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        IncapacitatedCharacter                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnCharacterIncapacitated__DelegateSignature(class AReadyOrNotCharacter* IncapacitatedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnCharacterIncapacitated__DelegateSignature");
		
		AReadyOrNotCharacter_OnCharacterIncapacitated__DelegateSignature_Params params {};
		params.IncapacitatedCharacter = IncapacitatedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnCarryThrowComplete_Slave
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Slave                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnCarryThrowComplete_Slave(class AActor* Slave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnCarryThrowComplete_Slave");
		
		AReadyOrNotCharacter_OnCarryThrowComplete_Slave_Params params {};
		params.Slave = Slave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnCarryThrowComplete_Driver
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Driver                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnCarryThrowComplete_Driver(class AActor* Driver)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnCarryThrowComplete_Driver");
		
		AReadyOrNotCharacter_OnCarryThrowComplete_Driver_Params params {};
		params.Driver = Driver;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnCarryThrowComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Driver                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Slave                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnCarryThrowComplete(class AActor* Driver, class AActor* Slave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnCarryThrowComplete");
		
		AReadyOrNotCharacter_OnCarryThrowComplete_Params params {};
		params.Driver = Driver;
		params.Slave = Slave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnCarryPickupComplete_Slave
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Slave                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnCarryPickupComplete_Slave(class AActor* Slave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnCarryPickupComplete_Slave");
		
		AReadyOrNotCharacter_OnCarryPickupComplete_Slave_Params params {};
		params.Slave = Slave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnCarryPickupComplete_Driver
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Driver                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnCarryPickupComplete_Driver(class AActor* Driver)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnCarryPickupComplete_Driver");
		
		AReadyOrNotCharacter_OnCarryPickupComplete_Driver_Params params {};
		params.Driver = Driver;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnCarryPickupComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Driver                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Slave                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnCarryPickupComplete(class AActor* Driver, class AActor* Slave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnCarryPickupComplete");
		
		AReadyOrNotCharacter_OnCarryPickupComplete_Params params {};
		params.Driver = Driver;
		params.Slave = Slave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnCarryDropComplete_Slave
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Slave                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnCarryDropComplete_Slave(class AActor* Slave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnCarryDropComplete_Slave");
		
		AReadyOrNotCharacter_OnCarryDropComplete_Slave_Params params {};
		params.Slave = Slave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnCarryDropComplete_Driver
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Driver                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnCarryDropComplete_Driver(class AActor* Driver)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnCarryDropComplete_Driver");
		
		AReadyOrNotCharacter_OnCarryDropComplete_Driver_Params params {};
		params.Driver = Driver;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnCarryDropComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Driver                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Slave                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnCarryDropComplete(class AActor* Driver, class AActor* Slave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnCarryDropComplete");
		
		AReadyOrNotCharacter_OnCarryDropComplete_Params params {};
		params.Driver = Driver;
		params.Slave = Slave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnC2NotifyEvent__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::OnC2NotifyEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnC2NotifyEvent__DelegateSignature");
		
		AReadyOrNotCharacter_OnC2NotifyEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnBoneDamaged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        BoneHit                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnBoneDamaged__DelegateSignature(const class FName& BoneHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnBoneDamaged__DelegateSignature");
		
		AReadyOrNotCharacter_OnBoneDamaged__DelegateSignature_Params params {};
		params.BoneHit = BoneHit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnBodyPartDamaged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHeadDamaged                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBodyDamaged                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeftArmDamaged                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRightArmDamaged                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeftLegDamaged                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRightLegDamaged                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeftFootDamaged                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRightFootDamaged                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnBodyPartDamaged__DelegateSignature(bool bHeadDamaged, bool bBodyDamaged, bool bLeftArmDamaged, bool bRightArmDamaged, bool bLeftLegDamaged, bool bRightLegDamaged, bool bLeftFootDamaged, bool bRightFootDamaged)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnBodyPartDamaged__DelegateSignature");
		
		AReadyOrNotCharacter_OnBodyPartDamaged__DelegateSignature_Params params {};
		params.bHeadDamaged = bHeadDamaged;
		params.bBodyDamaged = bBodyDamaged;
		params.bLeftArmDamaged = bLeftArmDamaged;
		params.bRightArmDamaged = bRightArmDamaged;
		params.bLeftLegDamaged = bLeftLegDamaged;
		params.bRightLegDamaged = bRightLegDamaged;
		params.bLeftFootDamaged = bLeftFootDamaged;
		params.bRightFootDamaged = bRightFootDamaged;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnArteryBleedParticleCollision
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        EventName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              EmitterTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ParticleTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Velocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Normal                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPhysicalMaterial*                           PhysMat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnArteryBleedParticleCollision(const class FName& EventName, float EmitterTime, int32_t ParticleTime, const struct FCoreUObject_FVector& Location, const struct FCoreUObject_FVector& Velocity, const struct FCoreUObject_FVector& Direction, const struct FCoreUObject_FVector& Normal, const class FName& BoneName, class UPhysicalMaterial* PhysMat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnArteryBleedParticleCollision");
		
		AReadyOrNotCharacter_OnArteryBleedParticleCollision_Params params {};
		params.EventName = EventName;
		params.EmitterTime = EmitterTime;
		params.ParticleTime = ParticleTime;
		params.Location = Location;
		params.Velocity = Velocity;
		params.Direction = Direction;
		params.Normal = Normal;
		params.BoneName = BoneName;
		params.PhysMat = PhysMat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnArrest__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ArrestedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnArrest__DelegateSignature(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotCharacter.OnArrest__DelegateSignature");
		
		AReadyOrNotCharacter_OnArrest__DelegateSignature_Params params {};
		params.ArrestedCharacter = ArrestedCharacter;
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.OnActorSpawned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::OnActorSpawned(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.OnActorSpawned");
		
		AReadyOrNotCharacter_OnActorSpawned_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_TakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_TakeDamage(float Damage, const struct FDamageEvent& DamageEvent, class AReadyOrNotCharacter* InstigatorCharacter, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_TakeDamage");
		
		AReadyOrNotCharacter_Multicast_TakeDamage_Params params {};
		params.Damage = Damage;
		params.DamageEvent = DamageEvent;
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_Stop3PMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendoutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_Stop3PMontage(class UAnimMontage* Montage, float BlendoutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_Stop3PMontage");
		
		AReadyOrNotCharacter_Multicast_Stop3PMontage_Params params {};
		params.Montage = Montage;
		params.BlendoutTime = BlendoutTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_Stop1PMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendoutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_Stop1PMontage(class UAnimMontage* Montage, float BlendoutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_Stop1PMontage");
		
		AReadyOrNotCharacter_Multicast_Stop1PMontage_Params params {};
		params.Montage = Montage;
		params.BlendoutTime = BlendoutTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_SpawnDismembermentEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGibAreas                                          GibArea                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_SpawnDismembermentEffects(EGibAreas GibArea, const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_SpawnDismembermentEffects");
		
		AReadyOrNotCharacter_Multicast_SpawnDismembermentEffects_Params params {};
		params.GibArea = GibArea;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_SpawnBloodEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              WoundSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_SpawnBloodEffects(const struct FHitResult& Hit, float WoundSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_SpawnBloodEffects");
		
		AReadyOrNotCharacter_Multicast_SpawnBloodEffects_Params params {};
		params.Hit = Hit;
		params.WoundSize = WoundSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_SpawnArterialBloodEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  HitResult                                                  (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class FName                                        Artery                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_SpawnArterialBloodEffects(const struct FHitResult& HitResult, const class FName& Artery)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_SpawnArterialBloodEffects");
		
		AReadyOrNotCharacter_Multicast_SpawnArterialBloodEffects_Params params {};
		params.HitResult = HitResult;
		params.Artery = Artery;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_SavePoseSnapshot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        SnapshotName                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_SavePoseSnapshot(const class FName& SnapshotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_SavePoseSnapshot");
		
		AReadyOrNotCharacter_Multicast_SavePoseSnapshot_Params params {};
		params.SnapshotName = SnapshotName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_PlayRawVO
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SpecificFileName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OverrideSpeakerName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreIfAlreadyPlaying                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_PlayRawVO(const class FString& SpecificFileName, const class FString& OverrideSpeakerName, bool bIgnoreIfAlreadyPlaying)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_PlayRawVO");
		
		AReadyOrNotCharacter_Multicast_PlayRawVO_Params params {};
		params.SpecificFileName = SpecificFileName;
		params.OverrideSpeakerName = OverrideSpeakerName;
		params.bIgnoreIfAlreadyPlaying = bIgnoreIfAlreadyPlaying;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_PlayNonLocal3PMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                NewMontage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_PlayNonLocal3PMontage(class UAnimMontage* NewMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_PlayNonLocal3PMontage");
		
		AReadyOrNotCharacter_Multicast_PlayNonLocal3PMontage_Params params {};
		params.NewMontage = NewMontage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_PlayMeleeImpactEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFMODEvent*                                  ImpactSound                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UParticleSystem*                             ImpactParticle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_PlayMeleeImpactEffects(class UFMODEvent* ImpactSound, class UParticleSystem* ImpactParticle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_PlayMeleeImpactEffects");
		
		AReadyOrNotCharacter_Multicast_PlayMeleeImpactEffects_Params params {};
		params.ImpactSound = ImpactSound;
		params.ImpactParticle = ImpactParticle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_PlayDeathAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_PlayDeathAnimation(class UAnimMontage* Montage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_PlayDeathAnimation");
		
		AReadyOrNotCharacter_Multicast_PlayDeathAnimation_Params params {};
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_Play3PMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                NewMontage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_Play3PMontage(class UAnimMontage* NewMontage, float StartTime, float PlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_Play3PMontage");
		
		AReadyOrNotCharacter_Multicast_Play3PMontage_Params params {};
		params.NewMontage = NewMontage;
		params.StartTime = StartTime;
		params.PlayRate = PlayRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_PauseAllAnims
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bPaused                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_PauseAllAnims(bool bPaused)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_PauseAllAnims");
		
		AReadyOrNotCharacter_Multicast_PauseAllAnims_Params params {};
		params.bPaused = bPaused;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_OnTargetReported
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::Multicast_OnTargetReported()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_OnTargetReported");
		
		AReadyOrNotCharacter_Multicast_OnTargetReported_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_OnKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        LastBoneHit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_OnKilled(const class FName& LastBoneHit, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_OnKilled");
		
		AReadyOrNotCharacter_Multicast_OnKilled_Params params {};
		params.LastBoneHit = LastBoneHit;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_OnIncapacitated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        LastBone                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_OnIncapacitated(const class FName& LastBone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_OnIncapacitated");
		
		AReadyOrNotCharacter_Multicast_OnIncapacitated_Params params {};
		params.LastBone = LastBone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_OnExplosiveVestDetonation
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::Multicast_OnExplosiveVestDetonation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_OnExplosiveVestDetonation");
		
		AReadyOrNotCharacter_Multicast_OnExplosiveVestDetonation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_InflictSuppression
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      CameraShake                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLessLethal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_InflictSuppression(float Strength, class UClass* CameraShake, bool bLessLethal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_InflictSuppression");
		
		AReadyOrNotCharacter_Multicast_InflictSuppression_Params params {};
		params.Strength = Strength;
		params.CameraShake = CameraShake;
		params.bLessLethal = bLessLethal;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_EnableRagdollBlendIn
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::Multicast_EnableRagdollBlendIn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_EnableRagdollBlendIn");
		
		AReadyOrNotCharacter_Multicast_EnableRagdollBlendIn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_EnableRagdoll
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_EnableRagdoll(float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_EnableRagdoll");
		
		AReadyOrNotCharacter_Multicast_EnableRagdoll_Params params {};
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_DisableRagdoll
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::Multicast_DisableRagdoll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_DisableRagdoll");
		
		AReadyOrNotCharacter_Multicast_DisableRagdoll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_ChangeFaceEmotion
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECharacterEmotion                                  NewEmotion                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OverrideTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Blend                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendDecay                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_ChangeFaceEmotion(ECharacterEmotion NewEmotion, float OverrideTime, float Blend, float BlendDecay, int32_t Priority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_ChangeFaceEmotion");
		
		AReadyOrNotCharacter_Multicast_ChangeFaceEmotion_Params params {};
		params.NewEmotion = NewEmotion;
		params.OverrideTime = OverrideTime;
		params.Blend = Blend;
		params.BlendDecay = BlendDecay;
		params.Priority = Priority;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Multicast_AddMoveIgnoreActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        MoveIgnoreCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAdd                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Multicast_AddMoveIgnoreActor(class AReadyOrNotCharacter* MoveIgnoreCharacter, bool bAdd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Multicast_AddMoveIgnoreActor");
		
		AReadyOrNotCharacter_Multicast_AddMoveIgnoreActor_Params params {};
		params.MoveIgnoreCharacter = MoveIgnoreCharacter;
		params.bAdd = bAdd;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.MeshMerge
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::MeshMerge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.MeshMerge");
		
		AReadyOrNotCharacter_MeshMerge_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.LockMovementAndActions
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::LockMovementAndActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.LockMovementAndActions");
		
		AReadyOrNotCharacter_LockMovementAndActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.LockMovement
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::LockMovement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.LockMovement");
		
		AReadyOrNotCharacter_LockMovement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.LockAllActions
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::LockAllActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.LockAllActions");
		
		AReadyOrNotCharacter_LockAllActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.LockAim
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::LockAim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.LockAim");
		
		AReadyOrNotCharacter_LockAim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Kill
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::Kill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Kill");
		
		AReadyOrNotCharacter_Kill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.KickDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::KickDoor(class ADoor* Door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.KickDoor");
		
		AReadyOrNotCharacter_KickDoor_Params params {};
		params.Door = Door;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsUpperBodyMontagePlaying
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsUpperBodyMontagePlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsUpperBodyMontagePlaying");
		
		AReadyOrNotCharacter_IsUpperBodyMontagePlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsUnconsciousNotDead
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsUnconsciousNotDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsUnconsciousNotDead");
		
		AReadyOrNotCharacter_IsUnconsciousNotDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsTableMontagePlayingWithTimeRemaining
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              TimeRemaining                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsTableMontagePlayingWithTimeRemaining(const class FString& Animation, float* TimeRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsTableMontagePlayingWithTimeRemaining");
		
		AReadyOrNotCharacter_IsTableMontagePlayingWithTimeRemaining_Params params {};
		params.Animation = Animation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TimeRemaining != nullptr)
			*TimeRemaining = params.TimeRemaining;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsTableMontagePlaying
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsTableMontagePlaying(const class FString& Animation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsTableMontagePlaying");
		
		AReadyOrNotCharacter_IsTableMontagePlaying_Params params {};
		params.Animation = Animation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsTableMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsTableMontage(class UAnimMontage* Montage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsTableMontage");
		
		AReadyOrNotCharacter_IsTableMontage_Params params {};
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsSuspect
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsSuspect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsSuspect");
		
		AReadyOrNotCharacter_IsSuspect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsSurrenderedFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Seconds                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsSurrenderedFor(float Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsSurrenderedFor");
		
		AReadyOrNotCharacter_IsSurrenderedFor_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsSurrendered
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsSurrendered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsSurrendered");
		
		AReadyOrNotCharacter_IsSurrendered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsSurrenderComplete
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsSurrenderComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsSurrenderComplete");
		
		AReadyOrNotCharacter_IsSurrenderComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsStunnedWith
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsStunnedWith(EStunType StunType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsStunnedWith");
		
		AReadyOrNotCharacter_IsStunnedWith_Params params {};
		params.StunType = StunType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsStunned
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsStunned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsStunned");
		
		AReadyOrNotCharacter_IsStunned_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsStartling
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsStartling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsStartling");
		
		AReadyOrNotCharacter_IsStartling_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsSpeechTimerActive
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsSpeechTimerActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsSpeechTimerActive");
		
		AReadyOrNotCharacter_IsSpeechTimerActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsReviveHealthDepleted
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsReviveHealthDepleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsReviveHealthDepleted");
		
		AReadyOrNotCharacter_IsReviveHealthDepleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsRelevant
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsRelevant()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsRelevant");
		
		AReadyOrNotCharacter_IsRelevant_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsRagdollBlending
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsRagdollBlending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsRagdollBlending");
		
		AReadyOrNotCharacter_IsRagdollBlending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsPlayingRootMotionFromMontage
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsPlayingRootMotionFromMontage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsPlayingRootMotionFromMontage");
		
		AReadyOrNotCharacter_IsPlayingRootMotionFromMontage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsPlayingNonInterruptibleMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MontageNameTryingToBePlayed                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsPlayingNonInterruptibleMontage(const class FString& MontageNameTryingToBePlayed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsPlayingNonInterruptibleMontage");
		
		AReadyOrNotCharacter_IsPlayingNonInterruptibleMontage_Params params {};
		params.MontageNameTryingToBePlayed = MontageNameTryingToBePlayed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsPlayingCarryAnims
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsPlayingCarryAnims()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsPlayingCarryAnims");
		
		AReadyOrNotCharacter_IsPlayingCarryAnims_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsOutside
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsOutside()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsOutside");
		
		AReadyOrNotCharacter_IsOutside_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsOutlineEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActorOutlineType                                  OutlineType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsOutlineEnabled(EActorOutlineType OutlineType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsOutlineEnabled");
		
		AReadyOrNotCharacter_IsOutlineEnabled_Params params {};
		params.OutlineType = OutlineType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsOnSWATTeam
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsOnSWATTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsOnSWATTeam");
		
		AReadyOrNotCharacter_IsOnSWATTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsOnSameTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsOnSameTeam(class AReadyOrNotCharacter* A, class AReadyOrNotCharacter* B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsOnSameTeam");
		
		AReadyOrNotCharacter_IsOnSameTeam_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsMontageSlotPlaying
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        SlotName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsMontageSlotPlaying(const class FName& SlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsMontageSlotPlaying");
		
		AReadyOrNotCharacter_IsMontageSlotPlaying_Params params {};
		params.SlotName = SlotName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsLowHealth
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsLowHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsLowHealth");
		
		AReadyOrNotCharacter_IsLowHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsLocalPlayer
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsLocalPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsLocalPlayer");
		
		AReadyOrNotCharacter_IsLocalPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsLoadingTableMontage
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsLoadingTableMontage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsLoadingTableMontage");
		
		AReadyOrNotCharacter_IsLoadingTableMontage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsLimbHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsLimbHit(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsLimbHit");
		
		AReadyOrNotCharacter_IsLimbHit_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsLimbBroken
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsLimbBroken(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsLimbBroken");
		
		AReadyOrNotCharacter_IsLimbBroken_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsInRagdoll
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsInRagdoll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsInRagdoll");
		
		AReadyOrNotCharacter_IsInRagdoll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsInjured
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsInjured()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsInjured");
		
		AReadyOrNotCharacter_IsInjured_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsIncapacitated
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsIncapacitated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsIncapacitated");
		
		AReadyOrNotCharacter_IsIncapacitated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsHealthDepleted
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsHealthDepleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsHealthDepleted");
		
		AReadyOrNotCharacter_IsHealthDepleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsHalfHealth
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsHalfHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsHalfHealth");
		
		AReadyOrNotCharacter_IsHalfHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsGettingUp
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsGettingUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsGettingUp");
		
		AReadyOrNotCharacter_IsGettingUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsFullHealth
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsFullHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsFullHealth");
		
		AReadyOrNotCharacter_IsFullHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsFullBodyMontagePlaying
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsFullBodyMontagePlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsFullBodyMontagePlaying");
		
		AReadyOrNotCharacter_IsFullBodyMontagePlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsDropping
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsDropping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsDropping");
		
		AReadyOrNotCharacter_IsDropping_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsDowned
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsDowned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsDowned");
		
		AReadyOrNotCharacter_IsDowned_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsDeadOrUnconscious
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsDeadOrUnconscious()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsDeadOrUnconscious");
		
		AReadyOrNotCharacter_IsDeadOrUnconscious_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsDeadNotUnconscious
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsDeadNotUnconscious()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsDeadNotUnconscious");
		
		AReadyOrNotCharacter_IsDeadNotUnconscious_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsCurrentlyTased
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsCurrentlyTased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsCurrentlyTased");
		
		AReadyOrNotCharacter_IsCurrentlyTased_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsCurrentlyStung
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsCurrentlyStung()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsCurrentlyStung");
		
		AReadyOrNotCharacter_IsCurrentlyStung_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsCurrentlySprayed
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsCurrentlySprayed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsCurrentlySprayed");
		
		AReadyOrNotCharacter_IsCurrentlySprayed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsCurrentlyGassed
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsCurrentlyGassed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsCurrentlyGassed");
		
		AReadyOrNotCharacter_IsCurrentlyGassed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsCurrentlyFlashed
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsCurrentlyFlashed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsCurrentlyFlashed");
		
		AReadyOrNotCharacter_IsCurrentlyFlashed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsCivilian
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsCivilian()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsCivilian");
		
		AReadyOrNotCharacter_IsCivilian_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsCarrying
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsCarrying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsCarrying");
		
		AReadyOrNotCharacter_IsCarrying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsCarried
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsCarried()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsCarried");
		
		AReadyOrNotCharacter_IsCarried_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsBeingThrown
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsBeingThrown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsBeingThrown");
		
		AReadyOrNotCharacter_IsBeingThrown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsBeingCarried
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsBeingCarried()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsBeingCarried");
		
		AReadyOrNotCharacter_IsBeingCarried_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsBeingArrested
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsBeingArrested()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsBeingArrested");
		
		AReadyOrNotCharacter_IsBeingArrested_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsArrestedOrSurrendered
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsArrestedOrSurrendered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsArrestedOrSurrendered");
		
		AReadyOrNotCharacter_IsArrestedOrSurrendered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsArrestedAndDead
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsArrestedAndDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsArrestedAndDead");
		
		AReadyOrNotCharacter_IsArrestedAndDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsArrested
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsArrested()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsArrested");
		
		AReadyOrNotCharacter_IsArrested_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsAnyTableMontagePlaying
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      OutMontage                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsAnyTableMontagePlaying(class FString* OutMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsAnyTableMontagePlaying");
		
		AReadyOrNotCharacter_IsAnyTableMontagePlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutMontage != nullptr)
			*OutMontage = params.OutMontage;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsAnyLimbHit
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsAnyLimbHit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsAnyLimbHit");
		
		AReadyOrNotCharacter_IsAnyLimbHit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsAnimationBlocking
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsAnimationBlocking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsAnimationBlocking");
		
		AReadyOrNotCharacter_IsAnimationBlocking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsAffectedByDamageTypeClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      DamageType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsAffectedByDamageTypeClass(class UClass* DamageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsAffectedByDamageTypeClass");
		
		AReadyOrNotCharacter_IsAffectedByDamageTypeClass_Params params {};
		params.DamageType = DamageType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsAffectedByDamageType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::IsAffectedByDamageType(class UDamageType* DamageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsAffectedByDamageType");
		
		AReadyOrNotCharacter_IsAffectedByDamageType_Params params {};
		params.DamageType = DamageType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsActiveForMovement
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsActiveForMovement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsActiveForMovement");
		
		AReadyOrNotCharacter_IsActiveForMovement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IsActive
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::IsActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IsActive");
		
		AReadyOrNotCharacter_IsActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Is3PMontagePlaying
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::Is3PMontagePlaying(class UAnimMontage* Montage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Is3PMontagePlaying");
		
		AReadyOrNotCharacter_Is3PMontagePlaying_Params params {};
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.IncreaseHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::IncreaseHealth(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.IncreaseHealth");
		
		AReadyOrNotCharacter_IncreaseHealth_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.HasRecentlyTakenStunDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Tolerance                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::HasRecentlyTakenStunDamage(float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.HasRecentlyTakenStunDamage");
		
		AReadyOrNotCharacter_HasRecentlyTakenStunDamage_Params params {};
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.HasRecentlyTakenDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Tolerance                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::HasRecentlyTakenDamage(float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.HasRecentlyTakenDamage");
		
		AReadyOrNotCharacter_HasRecentlyTakenDamage_Params params {};
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.HasLineOfSightTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::HasLineOfSightTo(const struct FCoreUObject_FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.HasLineOfSightTo");
		
		AReadyOrNotCharacter_HasLineOfSightTo_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.HasEverBeenStunned
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::HasEverBeenStunned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.HasEverBeenStunned");
		
		AReadyOrNotCharacter_HasEverBeenStunned_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.HasBeenSpottedBySwat
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::HasBeenSpottedBySwat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.HasBeenSpottedBySwat");
		
		AReadyOrNotCharacter_HasBeenSpottedBySwat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.HasBeenReported
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::HasBeenReported()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.HasBeenReported");
		
		AReadyOrNotCharacter_HasBeenReported_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetTimeSinceLastStun
	 * 		Flags  -> ()
	 */
	float AReadyOrNotCharacter::GetTimeSinceLastStun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetTimeSinceLastStun");
		
		AReadyOrNotCharacter_GetTimeSinceLastStun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetTimeSinceLastBulletDamage
	 * 		Flags  -> ()
	 */
	float AReadyOrNotCharacter::GetTimeSinceLastBulletDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetTimeSinceLastBulletDamage");
		
		AReadyOrNotCharacter_GetTimeSinceLastBulletDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetTeam
	 * 		Flags  -> ()
	 */
	ETeamType AReadyOrNotCharacter::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetTeam");
		
		AReadyOrNotCharacter_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetTableMontageQueue
	 * 		Flags  -> ()
	 */
	TArray<class FString> AReadyOrNotCharacter::GetTableMontageQueue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetTableMontageQueue");
		
		AReadyOrNotCharacter_GetTableMontageQueue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetSpeechCharacterName
	 * 		Flags  -> ()
	 */
	class FString AReadyOrNotCharacter::GetSpeechCharacterName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetSpeechCharacterName");
		
		AReadyOrNotCharacter_GetSpeechCharacterName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetSpeakCooldown
	 * 		Flags  -> ()
	 */
	float AReadyOrNotCharacter::GetSpeakCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetSpeakCooldown");
		
		AReadyOrNotCharacter_GetSpeakCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetRemovedItems
	 * 		Flags  -> ()
	 */
	TArray<class ABaseItem*> AReadyOrNotCharacter::GetRemovedItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetRemovedItems");
		
		AReadyOrNotCharacter_GetRemovedItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetMontageFromTableWithIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimMontage* AReadyOrNotCharacter::GetMontageFromTableWithIndex(const class FString& Animation, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetMontageFromTableWithIndex");
		
		AReadyOrNotCharacter_GetMontageFromTableWithIndex_Params params {};
		params.Animation = Animation;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetMontageFromTable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimMontage* AReadyOrNotCharacter::GetMontageFromTable(const class FString& Animation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetMontageFromTable");
		
		AReadyOrNotCharacter_GetMontageFromTable_Params params {};
		params.Animation = Animation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetMontageAnimCountFromTable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AReadyOrNotCharacter::GetMontageAnimCountFromTable(const class FString& Animation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetMontageAnimCountFromTable");
		
		AReadyOrNotCharacter_GetMontageAnimCountFromTable_Params params {};
		params.Animation = Animation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetMaxHealth
	 * 		Flags  -> ()
	 */
	float AReadyOrNotCharacter::GetMaxHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetMaxHealth");
		
		AReadyOrNotCharacter_GetMaxHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetLimbHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELimbType                                          Limb                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLimbHealthData AReadyOrNotCharacter::GetLimbHealth(ELimbType Limb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetLimbHealth");
		
		AReadyOrNotCharacter_GetLimbHealth_Params params {};
		params.Limb = Limb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetLastTableMontagePlayed
	 * 		Flags  -> ()
	 */
	class FString AReadyOrNotCharacter::GetLastTableMontagePlayed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetLastTableMontagePlayed");
		
		AReadyOrNotCharacter_GetLastTableMontagePlayed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetHealthStatus
	 * 		Flags  -> ()
	 */
	EPlayerHealthStatus AReadyOrNotCharacter::GetHealthStatus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetHealthStatus");
		
		AReadyOrNotCharacter_GetHealthStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetHealthComponent
	 * 		Flags  -> ()
	 */
	class UCharacterHealthComponent* AReadyOrNotCharacter::GetHealthComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetHealthComponent");
		
		AReadyOrNotCharacter_GetHealthComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetFMODFootstepParameters
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Stance                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Speed                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Surface                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::GetFMODFootstepParameters(int32_t* Stance, int32_t* Speed, int32_t* Surface)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetFMODFootstepParameters");
		
		AReadyOrNotCharacter_GetFMODFootstepParameters_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Stance != nullptr)
			*Stance = params.Stance;
		if (Speed != nullptr)
			*Speed = params.Speed;
		if (Surface != nullptr)
			*Surface = params.Surface;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetEquippedItem
	 * 		Flags  -> ()
	 */
	class ABaseItem* AReadyOrNotCharacter::GetEquippedItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetEquippedItem");
		
		AReadyOrNotCharacter_GetEquippedItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetDeltaRotationToCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AReadyOrNotCharacter::GetDeltaRotationToCharacter(class AReadyOrNotCharacter* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetDeltaRotationToCharacter");
		
		AReadyOrNotCharacter_GetDeltaRotationToCharacter_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetCurrentWeaponAnimType
	 * 		Flags  -> ()
	 */
	EAnimWeaponType AReadyOrNotCharacter::GetCurrentWeaponAnimType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetCurrentWeaponAnimType");
		
		AReadyOrNotCharacter_GetCurrentWeaponAnimType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetCurrentStunTime
	 * 		Flags  -> ()
	 */
	float AReadyOrNotCharacter::GetCurrentStunTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetCurrentStunTime");
		
		AReadyOrNotCharacter_GetCurrentStunTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetCurrentStunDuration
	 * 		Flags  -> ()
	 */
	float AReadyOrNotCharacter::GetCurrentStunDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetCurrentStunDuration");
		
		AReadyOrNotCharacter_GetCurrentStunDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetCurrentReviveTime
	 * 		Flags  -> ()
	 */
	float AReadyOrNotCharacter::GetCurrentReviveTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetCurrentReviveTime");
		
		AReadyOrNotCharacter_GetCurrentReviveTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetCurrentReviveHealth
	 * 		Flags  -> ()
	 */
	float AReadyOrNotCharacter::GetCurrentReviveHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetCurrentReviveHealth");
		
		AReadyOrNotCharacter_GetCurrentReviveHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetCurrentHealth
	 * 		Flags  -> ()
	 */
	float AReadyOrNotCharacter::GetCurrentHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetCurrentHealth");
		
		AReadyOrNotCharacter_GetCurrentHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetCollisionIgnoredComponents
	 * 		Flags  -> ()
	 */
	TArray<class UPrimitiveComponent*> AReadyOrNotCharacter::GetCollisionIgnoredComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetCollisionIgnoredComponents");
		
		AReadyOrNotCharacter_GetCollisionIgnoredComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.GetCollisionIgnoredActors
	 * 		Flags  -> ()
	 */
	TArray<class AActor*> AReadyOrNotCharacter::GetCollisionIgnoredActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.GetCollisionIgnoredActors");
		
		AReadyOrNotCharacter_GetCollisionIgnoredActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.ForceMeshUsingOverride
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMesh*                               InFPMesh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMesh*                               InTPMesh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMesh*                               InFaceMesh                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::ForceMeshUsingOverride(class USkeletalMesh* InFPMesh, class USkeletalMesh* InTPMesh, class USkeletalMesh* InFaceMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.ForceMeshUsingOverride");
		
		AReadyOrNotCharacter_ForceMeshUsingOverride_Params params {};
		params.InFPMesh = InFPMesh;
		params.InTPMesh = InTPMesh;
		params.InFaceMesh = InFaceMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.EndStun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::EndStun(EStunType StunType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.EndStun");
		
		AReadyOrNotCharacter_EndStun_Params params {};
		params.StunType = StunType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.EndEvidenceCollection_COOP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UInteractableComponent*                      CollectionInteractableComp                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::EndEvidenceCollection_COOP(class UInteractableComponent* CollectionInteractableComp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.EndEvidenceCollection_COOP");
		
		AReadyOrNotCharacter_EndEvidenceCollection_COOP_Params params {};
		params.CollectionInteractableComp = CollectionInteractableComp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.EnableRagdoll
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::EnableRagdoll(float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.EnableRagdoll");
		
		AReadyOrNotCharacter_EnableRagdoll_Params params {};
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.EnableOutline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActorOutlineType                                  OutlineType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::EnableOutline(EActorOutlineType OutlineType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.EnableOutline");
		
		AReadyOrNotCharacter_EnableOutline_Params params {};
		params.OutlineType = OutlineType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.DoesMontageFromTableExist
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::DoesMontageFromTableExist(const class FString& Animation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.DoesMontageFromTableExist");
		
		AReadyOrNotCharacter_DoesMontageFromTableExist_Params params {};
		params.Animation = Animation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.DisableRagdoll
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::DisableRagdoll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.DisableRagdoll");
		
		AReadyOrNotCharacter_DisableRagdoll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.DisableOutline
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::DisableOutline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.DisableOutline");
		
		AReadyOrNotCharacter_DisableOutline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.DepleteHealth
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::DepleteHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.DepleteHealth");
		
		AReadyOrNotCharacter_DepleteHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.DecreaseHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::DecreaseHealth(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.DecreaseHealth");
		
		AReadyOrNotCharacter_DecreaseHealth_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.DamageHitHead
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPointDamageEvent                           DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::DamageHitHead(const struct FPointDamageEvent& DamageEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.DamageHitHead");
		
		AReadyOrNotCharacter_DamageHitHead_Params params {};
		params.DamageEvent = DamageEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.CompleteEvidenceCollection_COOP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InEvidenceActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::CompleteEvidenceCollection_COOP(class AActor* InEvidenceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.CompleteEvidenceCollection_COOP");
		
		AReadyOrNotCharacter_CompleteEvidenceCollection_COOP_Params params {};
		params.InEvidenceActor = InEvidenceActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.CollectPendingEvidence
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::CollectPendingEvidence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.CollectPendingEvidence");
		
		AReadyOrNotCharacter_CollectPendingEvidence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Client_SetControlRotation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FRotator                       NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Client_SetControlRotation(const struct FCoreUObject_FRotator& NewRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Client_SetControlRotation");
		
		AReadyOrNotCharacter_Client_SetControlRotation_Params params {};
		params.NewRotation = NewRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Client_PlayScreenShake
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      CameraShake                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Client_PlayScreenShake(class UClass* CameraShake)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Client_PlayScreenShake");
		
		AReadyOrNotCharacter_Client_PlayScreenShake_Params params {};
		params.CameraShake = CameraShake;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Client_PlayMeleeImpactEffects
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::Client_PlayMeleeImpactEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Client_PlayMeleeImpactEffects");
		
		AReadyOrNotCharacter_Client_PlayMeleeImpactEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Client_PlayFMODEvent2D
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFMODEvent*                                  Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Client_PlayFMODEvent2D(class UFMODEvent* Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Client_PlayFMODEvent2D");
		
		AReadyOrNotCharacter_Client_PlayFMODEvent2D_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Client_Play1PMontage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                NewMontage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Client_Play1PMontage(class UAnimMontage* NewMontage, float PlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Client_Play1PMontage");
		
		AReadyOrNotCharacter_Client_Play1PMontage_Params params {};
		params.NewMontage = NewMontage;
		params.PlayRate = PlayRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Client_OnBoneDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        BoneHit                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Client_OnBoneDamaged(const class FName& BoneHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Client_OnBoneDamaged");
		
		AReadyOrNotCharacter_Client_OnBoneDamaged_Params params {};
		params.BoneHit = BoneHit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Client_OnBodyPartDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInHeadHit                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInBodyHit                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInLeftArmHit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInRightArmHit                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInLeftLegHit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInRightLegHit                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInLeftFootHit                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInRightFootHit                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Client_OnBodyPartDamaged(bool bInHeadHit, bool bInBodyHit, bool bInLeftArmHit, bool bInRightArmHit, bool bInLeftLegHit, bool bInRightLegHit, bool bInLeftFootHit, bool bInRightFootHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Client_OnBodyPartDamaged");
		
		AReadyOrNotCharacter_Client_OnBodyPartDamaged_Params params {};
		params.bInHeadHit = bInHeadHit;
		params.bInBodyHit = bInBodyHit;
		params.bInLeftArmHit = bInLeftArmHit;
		params.bInRightArmHit = bInRightArmHit;
		params.bInLeftLegHit = bInLeftLegHit;
		params.bInRightLegHit = bInRightLegHit;
		params.bInLeftFootHit = bInLeftFootHit;
		params.bInRightFootHit = bInRightFootHit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.CanYell
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::CanYell()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.CanYell");
		
		AReadyOrNotCharacter_CanYell_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.CanMelee
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::CanMelee()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.CanMelee");
		
		AReadyOrNotCharacter_CanMelee_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.CanDropCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        CharacterToDrop                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::CanDropCharacter(class AReadyOrNotCharacter* CharacterToDrop)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.CanDropCharacter");
		
		AReadyOrNotCharacter_CanDropCharacter_Params params {};
		params.CharacterToDrop = CharacterToDrop;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.CancelArrest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerMakingArrest                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::CancelArrest(class AReadyOrNotCharacter* PlayerMakingArrest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.CancelArrest");
		
		AReadyOrNotCharacter_CancelArrest_Params params {};
		params.PlayerMakingArrest = PlayerMakingArrest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.CanCarryCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        CharacterToPickup                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotCharacter::CanCarryCharacter(class AReadyOrNotCharacter* CharacterToPickup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.CanCarryCharacter");
		
		AReadyOrNotCharacter_CanCarryCharacter_Params params {};
		params.CharacterToPickup = CharacterToPickup;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.CanBePickedUp
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::CanBePickedUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.CanBePickedUp");
		
		AReadyOrNotCharacter_CanBePickedUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.CanArrestRagdoll
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::CanArrestRagdoll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.CanArrestRagdoll");
		
		AReadyOrNotCharacter_CanArrestRagdoll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.CanArrest
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::CanArrest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.CanArrest");
		
		AReadyOrNotCharacter_CanArrest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.CacheIsOutside
	 * 		Flags  -> ()
	 */
	void AReadyOrNotCharacter::CacheIsOutside()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.CacheIsOutside");
		
		AReadyOrNotCharacter_CacheIsOutside_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.BeginEvidenceCollection_COOP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InEvidenceActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      CollectionInteractableComp                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CollectionTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::BeginEvidenceCollection_COOP(class AActor* InEvidenceActor, class UInteractableComponent* CollectionInteractableComp, float CollectionTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.BeginEvidenceCollection_COOP");
		
		AReadyOrNotCharacter_BeginEvidenceCollection_COOP_Params params {};
		params.InEvidenceActor = InEvidenceActor;
		params.CollectionInteractableComp = CollectionInteractableComp;
		params.CollectionTime = CollectionTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.ArrestComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerMakingArrest                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AZipcuffs*                                   Zipcuffs                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::ArrestComplete(class AReadyOrNotCharacter* PlayerMakingArrest, class AZipcuffs* Zipcuffs)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.ArrestComplete");
		
		AReadyOrNotCharacter_ArrestComplete_Params params {};
		params.PlayerMakingArrest = PlayerMakingArrest;
		params.Zipcuffs = Zipcuffs;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.Arrest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerMakingArrest                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::Arrest(class AReadyOrNotCharacter* PlayerMakingArrest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.Arrest");
		
		AReadyOrNotCharacter_Arrest_Params params {};
		params.PlayerMakingArrest = PlayerMakingArrest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.ApplyDamageToBone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        HitBone                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPointDamageEvent                           DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotCharacter::ApplyDamageToBone(float* Damage, const class FName& HitBone, const struct FPointDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.ApplyDamageToBone");
		
		AReadyOrNotCharacter_ApplyDamageToBone_Params params {};
		params.HitBone = HitBone;
		params.DamageEvent = DamageEvent;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Damage != nullptr)
			*Damage = params.Damage;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotCharacter.AnyBodyPartHit
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotCharacter::AnyBodyPartHit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotCharacter.AnyBodyPartHit");
		
		AReadyOrNotCharacter_AnyBodyPartHit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.WasRecentlyYelledAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Seconds                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticCharacter::WasRecentlyYelledAt(float Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.WasRecentlyYelledAt");
		
		ACyberneticCharacter_WasRecentlyYelledAt_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.UpdateDefaultMoveStyle
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::UpdateDefaultMoveStyle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.UpdateDefaultMoveStyle");
		
		ACyberneticCharacter_UpdateDefaultMoveStyle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.SurrenderExit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESurrenderExitType                                 ExitType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        FocalPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticCharacter::SurrenderExit(ESurrenderExitType ExitType, const struct FCoreUObject_FVector& FocalPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.SurrenderExit");
		
		ACyberneticCharacter_SurrenderExit_Params params {};
		params.ExitType = ExitType;
		params.FocalPoint = FocalPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.Surrender
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::Surrender()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.Surrender");
		
		ACyberneticCharacter_Surrender_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.StopPlayingDead
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::StopPlayingDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.StopPlayingDead");
		
		ACyberneticCharacter_StopPlayingDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.PlayShootingWeaponConversation
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::PlayShootingWeaponConversation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.PlayShootingWeaponConversation");
		
		ACyberneticCharacter_PlayShootingWeaponConversation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.PlayMontageWithFocalPoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        FocalPoint                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticCharacter::PlayMontageWithFocalPoint(class UAnimMontage* Montage, const struct FCoreUObject_FVector& FocalPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.PlayMontageWithFocalPoint");
		
		ACyberneticCharacter_PlayMontageWithFocalPoint_Params params {};
		params.Montage = Montage;
		params.FocalPoint = FocalPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.PlayMontageFromTableWithIndexWithFocalPoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        FocalPoint                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimMontage* ACyberneticCharacter::PlayMontageFromTableWithIndexWithFocalPoint(const class FString& Animation, int32_t Index, const struct FCoreUObject_FVector& FocalPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.PlayMontageFromTableWithIndexWithFocalPoint");
		
		ACyberneticCharacter_PlayMontageFromTableWithIndexWithFocalPoint_Params params {};
		params.Animation = Animation;
		params.Index = Index;
		params.FocalPoint = FocalPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.PlayMontageFromTableWithFocalPoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        FocalPoint                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimMontage* ACyberneticCharacter::PlayMontageFromTableWithFocalPoint(const class FString& Animation, const struct FCoreUObject_FVector& FocalPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.PlayMontageFromTableWithFocalPoint");
		
		ACyberneticCharacter_PlayMontageFromTableWithFocalPoint_Params params {};
		params.Animation = Animation;
		params.FocalPoint = FocalPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.PlayDead
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayVO                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::PlayDead(float Duration, bool bPlayVO)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.PlayDead");
		
		ACyberneticCharacter_PlayDead_Params params {};
		params.Duration = Duration;
		params.bPlayVO = bPlayVO;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.PlayBarkOrStartConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SpeechRow                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHasSharedCooldown                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Cooldown                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::PlayBarkOrStartConversation(const class FString& SpeechRow, bool bHasSharedCooldown, float Cooldown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.PlayBarkOrStartConversation");
		
		ACyberneticCharacter_PlayBarkOrStartConversation_Params params {};
		params.SpeechRow = SpeechRow;
		params.bHasSharedCooldown = bHasSharedCooldown;
		params.Cooldown = Cooldown;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticCharacter.OnWeaponForceFireNotifyEvent__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::OnWeaponForceFireNotifyEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticCharacter.OnWeaponForceFireNotifyEvent__DelegateSignature");
		
		ACyberneticCharacter_OnWeaponForceFireNotifyEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticCharacter.OnSpottedCharacter__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        Spotter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::OnSpottedCharacter__DelegateSignature(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticCharacter.OnSpottedCharacter__DelegateSignature");
		
		ACyberneticCharacter_OnSpottedCharacter__DelegateSignature_Params params {};
		params.Spotter = Spotter;
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticCharacter.OnSensedCharacter__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::OnSensedCharacter__DelegateSignature(class AReadyOrNotCharacter* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticCharacter.OnSensedCharacter__DelegateSignature");
		
		ACyberneticCharacter_OnSensedCharacter__DelegateSignature_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticCharacter.OnSensedActor__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::OnSensedActor__DelegateSignature(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticCharacter.OnSensedActor__DelegateSignature");
		
		ACyberneticCharacter_OnSensedActor__DelegateSignature_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.OnRep_SimulatingAttachedStaticMeshes
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::OnRep_SimulatingAttachedStaticMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.OnRep_SimulatingAttachedStaticMeshes");
		
		ACyberneticCharacter_OnRep_SimulatingAttachedStaticMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.OnRep_CharacterMeshData
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::OnRep_CharacterMeshData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.OnRep_CharacterMeshData");
		
		ACyberneticCharacter_OnRep_CharacterMeshData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.OnRep_AttachedSkeletalMeshData
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::OnRep_AttachedSkeletalMeshData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.OnRep_AttachedSkeletalMeshData");
		
		ACyberneticCharacter_OnRep_AttachedSkeletalMeshData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.OnRep_AttachedMeshData
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::OnRep_AttachedMeshData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.OnRep_AttachedMeshData");
		
		ACyberneticCharacter_OnRep_AttachedMeshData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.OnOfficerShouted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Shouter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLOS                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::OnOfficerShouted(class AReadyOrNotCharacter* Shouter, bool bLOS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.OnOfficerShouted");
		
		ACyberneticCharacter_OnOfficerShouted_Params params {};
		params.Shouter = Shouter;
		params.bLOS = bLOS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticCharacter.OnHeardOfficerYellSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Shouter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLOS                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::OnHeardOfficerYellSignature__DelegateSignature(class AReadyOrNotCharacter* Shouter, bool bLOS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticCharacter.OnHeardOfficerYellSignature__DelegateSignature");
		
		ACyberneticCharacter_OnHeardOfficerYellSignature__DelegateSignature_Params params {};
		params.Shouter = Shouter;
		params.bLOS = bLOS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.OnGetupAfterRagdollComplete
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::OnGetupAfterRagdollComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.OnGetupAfterRagdollComplete");
		
		ACyberneticCharacter_OnGetupAfterRagdollComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticCharacter.OnExitedSurrender__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESurrenderExitType                                 ExitType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::OnExitedSurrender__DelegateSignature(ESurrenderExitType ExitType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticCharacter.OnExitedSurrender__DelegateSignature");
		
		ACyberneticCharacter_OnExitedSurrender__DelegateSignature_Params params {};
		params.ExitType = ExitType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticCharacter.OnDoorBreachNotifyEvent__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::OnDoorBreachNotifyEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticCharacter.OnDoorBreachNotifyEvent__DelegateSignature");
		
		ACyberneticCharacter_OnDoorBreachNotifyEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticCharacter.OnCollectPendingEvidenceNotify__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::OnCollectPendingEvidenceNotify__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticCharacter.OnCollectPendingEvidenceNotify__DelegateSignature");
		
		ACyberneticCharacter_OnCollectPendingEvidenceNotify__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticCharacter.OnAimedAt__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::OnAimedAt__DelegateSignature(class ACyberneticCharacter* Character, class AReadyOrNotCharacter* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticCharacter.OnAimedAt__DelegateSignature");
		
		ACyberneticCharacter_OnAimedAt__DelegateSignature_Params params {};
		params.Character = Character;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticCharacter.OnAIFire__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        AICharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseMagazineWeapon*                         MagazineWeapon                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        fireDirection                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::OnAIFire__DelegateSignature(class ACyberneticCharacter* AICharacter, class ABaseMagazineWeapon* MagazineWeapon, const struct FCoreUObject_FVector& fireDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticCharacter.OnAIFire__DelegateSignature");
		
		ACyberneticCharacter_OnAIFire__DelegateSignature_Params params {};
		params.AICharacter = AICharacter;
		params.MagazineWeapon = MagazineWeapon;
		params.fireDirection = fireDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.Multicast_SendCharacterMeshData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCharacterMesh                              RPC_CharacterMeshData                                      (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::Multicast_SendCharacterMeshData(const struct FCharacterMesh& RPC_CharacterMeshData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.Multicast_SendCharacterMeshData");
		
		ACyberneticCharacter_Multicast_SendCharacterMeshData_Params params {};
		params.RPC_CharacterMeshData = RPC_CharacterMeshData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.Multicast_PlayArmourHitEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseArmour*                                 Armour                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::Multicast_PlayArmourHitEffects(class ABaseArmour* Armour, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.Multicast_PlayArmourHitEffects");
		
		ACyberneticCharacter_Multicast_PlayArmourHitEffects_Params params {};
		params.Armour = Armour;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.Knockout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayVO                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::Knockout(float Duration, bool bPlayVO)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.Knockout");
		
		ACyberneticCharacter_Knockout_Params params {};
		params.Duration = Duration;
		params.bPlayVO = bPlayVO;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsWearingHeadArmor
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsWearingHeadArmor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsWearingHeadArmor");
		
		ACyberneticCharacter_IsWearingHeadArmor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsWearingExplosiveVest
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsWearingExplosiveVest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsWearingExplosiveVest");
		
		ACyberneticCharacter_IsWearingExplosiveVest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsUnjustifiedUseOfForce
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Aggressor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseItem*                                   ForceWeapon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDamageType*                                 ForceUsed                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticCharacter::IsUnjustifiedUseOfForce(class AReadyOrNotCharacter* Aggressor, class ABaseItem* ForceWeapon, class UDamageType* ForceUsed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsUnjustifiedUseOfForce");
		
		ACyberneticCharacter_IsUnjustifiedUseOfForce_Params params {};
		params.Aggressor = Aggressor;
		params.ForceWeapon = ForceWeapon;
		params.ForceUsed = ForceUsed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsTakingHostage
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsTakingHostage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsTakingHostage");
		
		ACyberneticCharacter_IsTakingHostage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsTakingCoverAtLandmark
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsTakingCoverAtLandmark()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsTakingCoverAtLandmark");
		
		ACyberneticCharacter_IsTakingCoverAtLandmark_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsTakingCover
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsTakingCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsTakingCover");
		
		ACyberneticCharacter_IsTakingCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsRaisingWeapon
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsRaisingWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsRaisingWeapon");
		
		ACyberneticCharacter_IsRaisingWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsPlayingStunAnimation
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsPlayingStunAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsPlayingStunAnimation");
		
		ACyberneticCharacter_IsPlayingStunAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsPlayingDead
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsPlayingDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsPlayingDead");
		
		ACyberneticCharacter_IsPlayingDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsMovingToLandmarkCover
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsMovingToLandmarkCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsMovingToLandmarkCover");
		
		ACyberneticCharacter_IsMovingToLandmarkCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsMovingToCover
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsMovingToCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsMovingToCover");
		
		ACyberneticCharacter_IsMovingToCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsLoweringWeapon
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsLoweringWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsLoweringWeapon");
		
		ACyberneticCharacter_IsLoweringWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsHesitatingFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Seconds                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticCharacter::IsHesitatingFor(float Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsHesitatingFor");
		
		ACyberneticCharacter_IsHesitatingFor_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsHesitating
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsHesitating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsHesitating");
		
		ACyberneticCharacter_IsHesitating_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsFiringFromCover
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsFiringFromCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsFiringFromCover");
		
		ACyberneticCharacter_IsFiringFromCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsExitingSurrender
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsExitingSurrender()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsExitingSurrender");
		
		ACyberneticCharacter_IsExitingSurrender_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsEndingHostageTake
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsEndingHostageTake()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsEndingHostageTake");
		
		ACyberneticCharacter_IsEndingHostageTake_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsDamagedByLethal
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsDamagedByLethal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsDamagedByLethal");
		
		ACyberneticCharacter_IsDamagedByLethal_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsDamagedByLessLethal
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsDamagedByLessLethal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsDamagedByLessLethal");
		
		ACyberneticCharacter_IsDamagedByLessLethal_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsBeingTakenHostage
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsBeingTakenHostage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsBeingTakenHostage");
		
		ACyberneticCharacter_IsBeingTakenHostage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsBeginningHostageTake
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsBeginningHostageTake()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsBeginningHostageTake");
		
		ACyberneticCharacter_IsBeginningHostageTake_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsArrestCapable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticCharacter::IsArrestCapable(class APlayerCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsArrestCapable");
		
		ACyberneticCharacter_IsArrestCapable_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IsActiveForCombat
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::IsActiveForCombat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IsActiveForCombat");
		
		ACyberneticCharacter_IsActiveForCombat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.IncreaseStress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::IncreaseStress(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.IncreaseStress");
		
		ACyberneticCharacter_IncreaseStress_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.HasDamagedSWAT
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::HasDamagedSWAT()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.HasDamagedSWAT");
		
		ACyberneticCharacter_HasDamagedSWAT_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.GetVisibleSWATPercentage
	 * 		Flags  -> ()
	 */
	float ACyberneticCharacter::GetVisibleSWATPercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.GetVisibleSWATPercentage");
		
		ACyberneticCharacter_GetVisibleSWATPercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.GetHesitationTime
	 * 		Flags  -> ()
	 */
	float ACyberneticCharacter::GetHesitationTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.GetHesitationTime");
		
		ACyberneticCharacter_GetHesitationTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.GetFocalPoint
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector ACyberneticCharacter::GetFocalPoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.GetFocalPoint");
		
		ACyberneticCharacter_GetFocalPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.GetEquippedWeapon
	 * 		Flags  -> ()
	 */
	class ABaseMagazineWeapon* ACyberneticCharacter::GetEquippedWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.GetEquippedWeapon");
		
		ACyberneticCharacter_GetEquippedWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.GetDebugInfoOnROE
	 * 		Flags  -> ()
	 */
	TArray<struct FDebugData> ACyberneticCharacter::GetDebugInfoOnROE()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.GetDebugInfoOnROE");
		
		ACyberneticCharacter_GetDebugInfoOnROE_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.GetCyberneticsController
	 * 		Flags  -> ()
	 */
	class ACyberneticController* ACyberneticCharacter::GetCyberneticsController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.GetCyberneticsController");
		
		ACyberneticCharacter_GetCyberneticsController_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.GetArmour
	 * 		Flags  -> ()
	 */
	class ABaseArmour* ACyberneticCharacter::GetArmour()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.GetArmour");
		
		ACyberneticCharacter_GetArmour_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.GetAIArchetype
	 * 		Flags  -> ()
	 */
	class UAIArchetypeData* ACyberneticCharacter::GetAIArchetype()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.GetAIArchetype");
		
		ACyberneticCharacter_GetAIArchetype_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.ForceFireGun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Chance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::ForceFireGun(float Chance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.ForceFireGun");
		
		ACyberneticCharacter_ForceFireGun_Params params {};
		params.Chance = Chance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.FakeSurrender
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::FakeSurrender()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.FakeSurrender");
		
		ACyberneticCharacter_FakeSurrender_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.DrawWeapon
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::DrawWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.DrawWeapon");
		
		ACyberneticCharacter_DrawWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.DetermineSurrenderExitType
	 * 		Flags  -> ()
	 */
	ESurrenderExitType ACyberneticCharacter::DetermineSurrenderExitType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.DetermineSurrenderExitType");
		
		ACyberneticCharacter_DetermineSurrenderExitType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.DecreaseStress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticCharacter::DecreaseStress(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.DecreaseStress");
		
		ACyberneticCharacter_DecreaseStress_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.CanExitSurrender
	 * 		Flags  -> ()
	 */
	bool ACyberneticCharacter::CanExitSurrender()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.CanExitSurrender");
		
		ACyberneticCharacter_CanExitSurrender_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticCharacter.CalculateGetupPosition
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector ACyberneticCharacter::CalculateGetupPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticCharacter.CalculateGetupPosition");
		
		ACyberneticCharacter_CalculateGetupPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticCharacter.AIFinishedSpawningDelegate__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ACyberneticCharacter::AIFinishedSpawningDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticCharacter.AIFinishedSpawningDelegate__DelegateSignature");
		
		ACyberneticCharacter_AIFinishedSpawningDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACyberneticCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACyberneticCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CyberneticCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACivilianCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACivilianCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CivilianCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCivilianCombatActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCivilianCombatActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CivilianCombatActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.SenseStuff
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              TestActors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::SenseStuff(TArray<class AActor*> TestActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.SenseStuff");
		
		ACyberneticController_SenseStuff_Params params {};
		params.TestActors = TestActors;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.RequestMoveAsync
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bProjectToNavigation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ACyberneticController::RequestMoveAsync(const struct FCoreUObject_FVector& Location, bool bProjectToNavigation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.RequestMoveAsync");
		
		ACyberneticController_RequestMoveAsync_Params params {};
		params.Location = Location;
		params.bProjectToNavigation = bProjectToNavigation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.RemoveAllActivitiesExcept
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ActivityType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::RemoveAllActivitiesExcept(class UClass* ActivityType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.RemoveAllActivitiesExcept");
		
		ACyberneticController_RemoveAllActivitiesExcept_Params params {};
		params.ActivityType = ActivityType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.RemoveActivitiesOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ActivityType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bClearCurrent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::RemoveActivitiesOfType(class UClass* ActivityType, bool bClearCurrent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.RemoveActivitiesOfType");
		
		ACyberneticController_RemoveActivitiesOfType_Params params {};
		params.ActivityType = ActivityType;
		params.bClearCurrent = bClearCurrent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.PerformWorldBuildingActivities
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::PerformWorldBuildingActivities(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.PerformWorldBuildingActivities");
		
		ACyberneticController_PerformWorldBuildingActivities_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnPerceptionUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              TestActors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnPerceptionUpdated(TArray<class AActor*> TestActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnPerceptionUpdated");
		
		ACyberneticController_OnPerceptionUpdated_Params params {};
		params.TestActors = TestActors;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownNeutralTakeDamage_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownNeutralTakeDamage_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownNeutralTakeDamage_Blueprint");
		
		ACyberneticController_OnKnownNeutralTakeDamage_Blueprint_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownNeutralTakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownNeutralTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownNeutralTakeDamage");
		
		ACyberneticController_OnKnownNeutralTakeDamage_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownNeutralStunned_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownNeutralStunned_Blueprint(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownNeutralStunned_Blueprint");
		
		ACyberneticController_OnKnownNeutralStunned_Blueprint_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownNeutralStunned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownNeutralStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownNeutralStunned");
		
		ACyberneticController_OnKnownNeutralStunned_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownNeutralKilled_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownNeutralKilled_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownNeutralKilled_Blueprint");
		
		ACyberneticController_OnKnownNeutralKilled_Blueprint_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownNeutralKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownNeutralKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownNeutralKilled");
		
		ACyberneticController_OnKnownNeutralKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownNeutralIncapacitated_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        IncapacitatedCharacter                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownNeutralIncapacitated_Blueprint(class AReadyOrNotCharacter* IncapacitatedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownNeutralIncapacitated_Blueprint");
		
		ACyberneticController_OnKnownNeutralIncapacitated_Blueprint_Params params {};
		params.IncapacitatedCharacter = IncapacitatedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownNeutralIncapacitated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        IncapacitatedCharacter                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownNeutralIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownNeutralIncapacitated");
		
		ACyberneticController_OnKnownNeutralIncapacitated_Params params {};
		params.IncapacitatedCharacter = IncapacitatedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownFriendlyTakeDamage_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownFriendlyTakeDamage_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownFriendlyTakeDamage_Blueprint");
		
		ACyberneticController_OnKnownFriendlyTakeDamage_Blueprint_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownFriendlyTakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownFriendlyTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownFriendlyTakeDamage");
		
		ACyberneticController_OnKnownFriendlyTakeDamage_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownFriendlyStunned_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownFriendlyStunned_Blueprint(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownFriendlyStunned_Blueprint");
		
		ACyberneticController_OnKnownFriendlyStunned_Blueprint_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownFriendlyStunned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownFriendlyStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownFriendlyStunned");
		
		ACyberneticController_OnKnownFriendlyStunned_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownFriendlyKilled_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownFriendlyKilled_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownFriendlyKilled_Blueprint");
		
		ACyberneticController_OnKnownFriendlyKilled_Blueprint_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownFriendlyKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownFriendlyKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownFriendlyKilled");
		
		ACyberneticController_OnKnownFriendlyKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownFriendlyIncapacitated_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        IncapacitatedCharacter                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownFriendlyIncapacitated_Blueprint(class AReadyOrNotCharacter* IncapacitatedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownFriendlyIncapacitated_Blueprint");
		
		ACyberneticController_OnKnownFriendlyIncapacitated_Blueprint_Params params {};
		params.IncapacitatedCharacter = IncapacitatedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownFriendlyIncapacitated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        IncapacitatedCharacter                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownFriendlyIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownFriendlyIncapacitated");
		
		ACyberneticController_OnKnownFriendlyIncapacitated_Params params {};
		params.IncapacitatedCharacter = IncapacitatedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownEnemyTakeDamage_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownEnemyTakeDamage_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownEnemyTakeDamage_Blueprint");
		
		ACyberneticController_OnKnownEnemyTakeDamage_Blueprint_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownEnemyTakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownEnemyTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownEnemyTakeDamage");
		
		ACyberneticController_OnKnownEnemyTakeDamage_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownEnemyStunned_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownEnemyStunned_Blueprint(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownEnemyStunned_Blueprint");
		
		ACyberneticController_OnKnownEnemyStunned_Blueprint_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownEnemyStunned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownEnemyStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownEnemyStunned");
		
		ACyberneticController_OnKnownEnemyStunned_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownEnemyKilled_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownEnemyKilled_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownEnemyKilled_Blueprint");
		
		ACyberneticController_OnKnownEnemyKilled_Blueprint_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownEnemyKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownEnemyKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownEnemyKilled");
		
		ACyberneticController_OnKnownEnemyKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownEnemyIncapacitated_Blueprint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        IncapacitatedCharacter                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownEnemyIncapacitated_Blueprint(class AReadyOrNotCharacter* IncapacitatedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownEnemyIncapacitated_Blueprint");
		
		ACyberneticController_OnKnownEnemyIncapacitated_Blueprint_Params params {};
		params.IncapacitatedCharacter = IncapacitatedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnKnownEnemyIncapacitated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        IncapacitatedCharacter                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnKnownEnemyIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnKnownEnemyIncapacitated");
		
		ACyberneticController_OnKnownEnemyIncapacitated_Params params {};
		params.IncapacitatedCharacter = IncapacitatedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnDoorKicked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnDoorKicked(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter, bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnDoorKicked");
		
		ACyberneticController_OnDoorKicked_Params params {};
		params.Door = Door;
		params.InstigatorCharacter = InstigatorCharacter;
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnDoorExploded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnDoorExploded(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnDoorExploded");
		
		ACyberneticController_OnDoorExploded_Params params {};
		params.Door = Door;
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticController.OnAIMoveCompleted__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AAIController*                               Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            RequestID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnAIMoveCompleted__DelegateSignature(class AAIController* Controller, int32_t RequestID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticController.OnAIMoveCompleted__DelegateSignature");
		
		ACyberneticController_OnAIMoveCompleted__DelegateSignature_Params params {};
		params.Controller = Controller;
		params.RequestID = RequestID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.OnAIFinishSpawning
	 * 		Flags  -> ()
	 */
	void ACyberneticController::OnAIFinishSpawning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.OnAIFinishSpawning");
		
		ACyberneticController_OnAIFinishSpawning_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticController.OnActivityComplete__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               CompletedActivity                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBaseActivity*                               NextActivity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccessfullyCompleted                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::OnActivityComplete__DelegateSignature(class UBaseActivity* CompletedActivity, class UBaseActivity* NextActivity, bool bSuccessfullyCompleted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticController.OnActivityComplete__DelegateSignature");
		
		ACyberneticController_OnActivityComplete__DelegateSignature_Params params {};
		params.CompletedActivity = CompletedActivity;
		params.NextActivity = NextActivity;
		params.bSuccessfullyCompleted = bSuccessfullyCompleted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsTagInvestigativeNoise
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Tag                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::IsTagInvestigativeNoise(const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsTagInvestigativeNoise");
		
		ACyberneticController_IsTagInvestigativeNoise_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsTagAggressiveNoise
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Tag                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::IsTagAggressiveNoise(const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsTagAggressiveNoise");
		
		ACyberneticController_IsTagAggressiveNoise_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsSWAT
	 * 		Flags  -> ()
	 */
	bool ACyberneticController::IsSWAT()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsSWAT");
		
		ACyberneticController_IsSWAT_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsSuspect
	 * 		Flags  -> ()
	 */
	bool ACyberneticController::IsSuspect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsSuspect");
		
		ACyberneticController_IsSuspect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsPlayerAKnownEnemy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::IsPlayerAKnownEnemy(class APlayerCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsPlayerAKnownEnemy");
		
		ACyberneticController_IsPlayerAKnownEnemy_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsMovingForRequests
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FAIRequestID>                        Requests                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::IsMovingForRequests(TArray<struct FAIRequestID> Requests)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsMovingForRequests");
		
		ACyberneticController_IsMovingForRequests_Params params {};
		params.Requests = Requests;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsMovingForRequest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RequestID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::IsMovingForRequest(int32_t RequestID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsMovingForRequest");
		
		ACyberneticController_IsMovingForRequest_Params params {};
		params.RequestID = RequestID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsMoving
	 * 		Flags  -> ()
	 */
	bool ACyberneticController::IsMoving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsMoving");
		
		ACyberneticController_IsMoving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsLastAlive
	 * 		Flags  -> ()
	 */
	bool ACyberneticController::IsLastAlive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsLastAlive");
		
		ACyberneticController_IsLastAlive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsFindingPath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PathId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::IsFindingPath(int32_t PathId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsFindingPath");
		
		ACyberneticController_IsFindingPath_Params params {};
		params.PathId = PathId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsFindingAnyPath
	 * 		Flags  -> ()
	 */
	bool ACyberneticController::IsFindingAnyPath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsFindingAnyPath");
		
		ACyberneticController_IsFindingAnyPath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsCivilian
	 * 		Flags  -> ()
	 */
	bool ACyberneticController::IsCivilian()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsCivilian");
		
		ACyberneticController_IsCivilian_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsCharacterNeutral
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::IsCharacterNeutral(class AReadyOrNotCharacter* InCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsCharacterNeutral");
		
		ACyberneticController_IsCharacterNeutral_Params params {};
		params.InCharacter = InCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsCharacterFriendly
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::IsCharacterFriendly(class AReadyOrNotCharacter* InCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsCharacterFriendly");
		
		ACyberneticController_IsCharacterFriendly_Params params {};
		params.InCharacter = InCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsCharacterEnemy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::IsCharacterEnemy(class AReadyOrNotCharacter* InCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsCharacterEnemy");
		
		ACyberneticController_IsCharacterEnemy_Params params {};
		params.InCharacter = InCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.IsActivelyMovingOnPath
	 * 		Flags  -> ()
	 */
	bool ACyberneticController::IsActivelyMovingOnPath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.IsActivelyMovingOnPath");
		
		ACyberneticController_IsActivelyMovingOnPath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.HasRecentlySeenSwat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::HasRecentlySeenSwat(struct FCoreUObject_FVector* OutLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.HasRecentlySeenSwat");
		
		ACyberneticController_HasRecentlySeenSwat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.HasRecentlySeenSuspect
	 * 		Flags  -> ()
	 */
	bool ACyberneticController::HasRecentlySeenSuspect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.HasRecentlySeenSuspect");
		
		ACyberneticController_HasRecentlySeenSuspect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.HasRecentlySeenCivilian
	 * 		Flags  -> ()
	 */
	bool ACyberneticController::HasRecentlySeenCivilian()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.HasRecentlySeenCivilian");
		
		ACyberneticController_HasRecentlySeenCivilian_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.HasBeenExposedToAggressiveNoise_Tag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        OutTag                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SinceSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxDistance                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeFriendly                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::HasBeenExposedToAggressiveNoise_Tag(class FName* OutTag, float SinceSeconds, float MaxDistance, bool bIncludeFriendly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.HasBeenExposedToAggressiveNoise_Tag");
		
		ACyberneticController_HasBeenExposedToAggressiveNoise_Tag_Params params {};
		params.SinceSeconds = SinceSeconds;
		params.MaxDistance = MaxDistance;
		params.bIncludeFriendly = bIncludeFriendly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTag != nullptr)
			*OutTag = params.OutTag;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.HasBeenExposedToAggressiveNoise
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              SinceSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxDistance                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeFriendly                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::HasBeenExposedToAggressiveNoise(float SinceSeconds, float MaxDistance, bool bIncludeFriendly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.HasBeenExposedToAggressiveNoise");
		
		ACyberneticController_HasBeenExposedToAggressiveNoise_Params params {};
		params.SinceSeconds = SinceSeconds;
		params.MaxDistance = MaxDistance;
		params.bIncludeFriendly = bIncludeFriendly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.HasActivityType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ActivityType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::HasActivityType(class UClass* ActivityType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.HasActivityType");
		
		ACyberneticController_HasActivityType_Params params {};
		params.ActivityType = ActivityType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.GetTrackedTarget
	 * 		Flags  -> ()
	 */
	class AReadyOrNotCharacter* ACyberneticController::GetTrackedTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.GetTrackedTarget");
		
		ACyberneticController_GetTrackedTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.GetTimeSinceLastMove
	 * 		Flags  -> ()
	 */
	float ACyberneticController::GetTimeSinceLastMove()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.GetTimeSinceLastMove");
		
		ACyberneticController_GetTimeSinceLastMove_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.GetTeam
	 * 		Flags  -> ()
	 */
	ETeamType ACyberneticController::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.GetTeam");
		
		ACyberneticController_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.GetNavQueryFilter
	 * 		Flags  -> ()
	 */
	class UClass* ACyberneticController::GetNavQueryFilter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.GetNavQueryFilter");
		
		ACyberneticController_GetNavQueryFilter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.GetLatestStimulus
	 * 		Flags  -> ()
	 */
	struct FAIStimulus ACyberneticController::GetLatestStimulus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.GetLatestStimulus");
		
		ACyberneticController_GetLatestStimulus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.GetHeardActorInstigator
	 * 		Flags  -> ()
	 */
	class AReadyOrNotCharacter* ACyberneticController::GetHeardActorInstigator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.GetHeardActorInstigator");
		
		ACyberneticController_GetHeardActorInstigator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.GetCombatActivity
	 * 		Flags  -> ()
	 */
	class UBaseCombatActivity* ACyberneticController::GetCombatActivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.GetCombatActivity");
		
		ACyberneticController_GetCombatActivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.GetCharacter
	 * 		Flags  -> ()
	 */
	class ACyberneticCharacter* ACyberneticController::GetCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.GetCharacter");
		
		ACyberneticController_GetCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.GetAwarenessState
	 * 		Flags  -> ()
	 */
	EAIAwarenessState ACyberneticController::GetAwarenessState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.GetAwarenessState");
		
		ACyberneticController_GetAwarenessState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.GetActivityQueueCount
	 * 		Flags  -> ()
	 */
	int32_t ACyberneticController::GetActivityQueueCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.GetActivityQueueCount");
		
		ACyberneticController_GetActivityQueueCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.GetActivityQueueAsString
	 * 		Flags  -> ()
	 */
	class FString ACyberneticController::GetActivityQueueAsString()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.GetActivityQueueAsString");
		
		ACyberneticController_GetActivityQueueAsString_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.GetActivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ActivityType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseActivity* ACyberneticController::GetActivity(class UClass* ActivityType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.GetActivity");
		
		ACyberneticController_GetActivity_Params params {};
		params.ActivityType = ActivityType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.FinishActivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               Activity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::FinishActivity(class UBaseActivity* Activity, bool bSuccess, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.FinishActivity");
		
		ACyberneticController_FinishActivity_Params params {};
		params.Activity = Activity;
		params.bSuccess = bSuccess;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.DoesPathGoThroughDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::DoesPathGoThroughDoor(class ADoor** Door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.DoesPathGoThroughDoor");
		
		ACyberneticController_DoesPathGoThroughDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Door != nullptr)
			*Door = params.Door;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CyberneticController.AsyncPathFoundDelegate__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PathId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERonNavigationQueryResult                          Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::AsyncPathFoundDelegate__DelegateSignature(int32_t PathId, ERonNavigationQueryResult Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CyberneticController.AsyncPathFoundDelegate__DelegateSignature");
		
		ACyberneticController_AsyncPathFoundDelegate__DelegateSignature_Params params {};
		params.PathId = PathId;
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.AddExposedToStimulusTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Tag                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        StimulusLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFriendly                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        StimulusInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACyberneticController::AddExposedToStimulusTag(const class FName& Tag, const struct FCoreUObject_FVector& StimulusLocation, bool bFriendly, class AReadyOrNotCharacter* StimulusInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.AddExposedToStimulusTag");
		
		ACyberneticController_AddExposedToStimulusTag_Params params {};
		params.Tag = Tag;
		params.StimulusLocation = StimulusLocation;
		params.bFriendly = bFriendly;
		params.StimulusInstigator = StimulusInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.AddActivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               Activity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOverrideCurrentActivity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACyberneticController::AddActivity(class UBaseActivity* Activity, bool bOverrideCurrentActivity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.AddActivity");
		
		ACyberneticController_AddActivity_Params params {};
		params.Activity = Activity;
		params.bOverrideCurrentActivity = bOverrideCurrentActivity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.AbortMove
	 * 		Flags  -> ()
	 */
	void ACyberneticController::AbortMove()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.AbortMove");
		
		ACyberneticController_AbortMove_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.AbortCoverLandmark
	 * 		Flags  -> ()
	 */
	void ACyberneticController::AbortCoverLandmark()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.AbortCoverLandmark");
		
		ACyberneticController_AbortCoverLandmark_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CyberneticController.AbortCover
	 * 		Flags  -> ()
	 */
	void ACyberneticController::AbortCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CyberneticController.AbortCover");
		
		ACyberneticController_AbortCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACyberneticController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACyberneticController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CyberneticController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACivilianController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACivilianController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CivilianController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCivilianFleeCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCivilianFleeCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CivilianFleeCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AClearPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AClearPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ClearPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClearWeaponAnimNotify.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClearWeaponAnimNotify::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ClearWeaponAnimNotify");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CollectedEvidenceActor.Server_PlaySpawnSound
	 * 		Flags  -> ()
	 */
	void ACollectedEvidenceActor::Server_PlaySpawnSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CollectedEvidenceActor.Server_PlaySpawnSound");
		
		ACollectedEvidenceActor_Server_PlaySpawnSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CollectedEvidenceActor.PlaySpawnSound
	 * 		Flags  -> ()
	 */
	void ACollectedEvidenceActor::PlaySpawnSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CollectedEvidenceActor.PlaySpawnSound");
		
		ACollectedEvidenceActor_PlaySpawnSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CollectedEvidenceActor.Multicast_PlaySpawnSound
	 * 		Flags  -> ()
	 */
	void ACollectedEvidenceActor::Multicast_PlaySpawnSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CollectedEvidenceActor.Multicast_PlaySpawnSound");
		
		ACollectedEvidenceActor_Multicast_PlaySpawnSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACollectedEvidenceActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACollectedEvidenceActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CollectedEvidenceActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CollectEvidenceActivity.OnEvidenceCollected
	 * 		Flags  -> ()
	 */
	void UCollectEvidenceActivity::OnEvidenceCollected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CollectEvidenceActivity.OnEvidenceCollected");
		
		UCollectEvidenceActivity_OnEvidenceCollected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CollectEvidenceActivity.OnCollectEvidenceEnd
	 * 		Flags  -> ()
	 */
	void UCollectEvidenceActivity::OnCollectEvidenceEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CollectEvidenceActivity.OnCollectEvidenceEnd");
		
		UCollectEvidenceActivity_OnCollectEvidenceEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CollectEvidenceActivity.OnCollectEvidenceBegin
	 * 		Flags  -> ()
	 */
	void UCollectEvidenceActivity::OnCollectEvidenceBegin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CollectEvidenceActivity.OnCollectEvidenceBegin");
		
		UCollectEvidenceActivity_OnCollectEvidenceBegin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CollectEvidenceActivity.EnterMoveToStage
	 * 		Flags  -> ()
	 */
	void UCollectEvidenceActivity::EnterMoveToStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CollectEvidenceActivity.EnterMoveToStage");
		
		UCollectEvidenceActivity_EnterMoveToStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CollectEvidenceActivity.EnterCollectStage
	 * 		Flags  -> ()
	 */
	void UCollectEvidenceActivity::EnterCollectStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CollectEvidenceActivity.EnterCollectStage");
		
		UCollectEvidenceActivity_EnterCollectStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CollectEvidenceActivity.CanCollectEvidence
	 * 		Flags  -> ()
	 */
	bool UCollectEvidenceActivity::CanCollectEvidence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CollectEvidenceActivity.CanCollectEvidence");
		
		UCollectEvidenceActivity_CanCollectEvidence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCollectEvidenceActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCollectEvidenceActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CollectEvidenceActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CombinedCombatActivity.OnExitedSurrender
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESurrenderExitType                                 ExitType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCombinedCombatActivity::OnExitedSurrender(ESurrenderExitType ExitType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CombinedCombatActivity.OnExitedSurrender");
		
		UCombinedCombatActivity_OnExitedSurrender_Params params {};
		params.ExitType = ExitType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CombinedCombatActivity.GoToState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECombatState                                       NewCombatState                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCombinedCombatActivity::GoToState(ECombatState NewCombatState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CombinedCombatActivity.GoToState");
		
		UCombinedCombatActivity_GoToState_Params params {};
		params.NewCombatState = NewCombatState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCombinedCombatActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCombinedCombatActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CombinedCombatActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CommandDecal.TrackTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        TargetLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        MarkerLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      CommandDecalSize                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACommandDecal::TrackTarget(const struct FCoreUObject_FVector& TargetLocation, const struct FCoreUObject_FVector& MarkerLocation, const struct FCoreUObject_FVector2D& CommandDecalSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CommandDecal.TrackTarget");
		
		ACommandDecal_TrackTarget_Params params {};
		params.TargetLocation = TargetLocation;
		params.MarkerLocation = MarkerLocation;
		params.CommandDecalSize = CommandDecalSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CommandDecal.SetCommandTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          NewCommandTeam                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACommandDecal::SetCommandTeam(ETeamType NewCommandTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CommandDecal.SetCommandTeam");
		
		ACommandDecal_SetCommandTeam_Params params {};
		params.NewCommandTeam = NewCommandTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CommandDecal.SetCommandParticle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UParticleSystem*                             NewCommandParticle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACommandDecal::SetCommandParticle(class UParticleSystem* NewCommandParticle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CommandDecal.SetCommandParticle");
		
		ACommandDecal_SetCommandParticle_Params params {};
		params.NewCommandParticle = NewCommandParticle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CommandDecal.SetCommandIconColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLinearColor                                NewCommandIconColor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACommandDecal::SetCommandIconColor(const struct FLinearColor& NewCommandIconColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CommandDecal.SetCommandIconColor");
		
		ACommandDecal_SetCommandIconColor_Params params {};
		params.NewCommandIconColor = NewCommandIconColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CommandDecal.SetCommandDecalString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      NewCommandName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACommandDecal::SetCommandDecalString(const class FString& NewCommandName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CommandDecal.SetCommandDecalString");
		
		ACommandDecal_SetCommandDecalString_Params params {};
		params.NewCommandName = NewCommandName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CommandDecal.SetCommandDecalColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLinearColor                                NewCommandDecalColor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACommandDecal::SetCommandDecalColor(const struct FLinearColor& NewCommandDecalColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CommandDecal.SetCommandDecalColor");
		
		ACommandDecal_SetCommandDecalColor_Params params {};
		params.NewCommandDecalColor = NewCommandDecalColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CommandDecal.GetCommandTeam
	 * 		Flags  -> ()
	 */
	ETeamType ACommandDecal::GetCommandTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CommandDecal.GetCommandTeam");
		
		ACommandDecal_GetCommandTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CommandDecal.DeactivateCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHideDecalWhenNoSquadPositionIsVisible                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        SpecificPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACommandDecal::DeactivateCommand(bool bHideDecalWhenNoSquadPositionIsVisible, class AReadyOrNotCharacter* SpecificPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CommandDecal.DeactivateCommand");
		
		ACommandDecal_DeactivateCommand_Params params {};
		params.bHideDecalWhenNoSquadPositionIsVisible = bHideDecalWhenNoSquadPositionIsVisible;
		params.SpecificPlayer = SpecificPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CommandDecal.ActivateCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      CommandName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        MarkerLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TMap<class AReadyOrNotCharacter*, struct FCoreUObject_FVector> SquadPositionsMap                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool ACommandDecal::ActivateCommand(const class FString& CommandName, const struct FCoreUObject_FVector& CommandLocation, const struct FCoreUObject_FVector& MarkerLocation, TMap<class AReadyOrNotCharacter*, struct FCoreUObject_FVector> SquadPositionsMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CommandDecal.ActivateCommand");
		
		ACommandDecal_ActivateCommand_Params params {};
		params.CommandName = CommandName;
		params.CommandLocation = CommandLocation;
		params.MarkerLocation = MarkerLocation;
		params.SquadPositionsMap = SquadPositionsMap;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACommandDecal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACommandDecal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CommandDecal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CommitSuicideActivity.SuicideActivityDelegate__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UCommitSuicideActivity::SuicideActivityDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CommitSuicideActivity.SuicideActivityDelegate__DelegateSignature");
		
		UCommitSuicideActivity_SuicideActivityDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CommitSuicideActivity.OnStunned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCommitSuicideActivity::OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CommitSuicideActivity.OnStunned");
		
		UCommitSuicideActivity_OnStunned_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CommitSuicideActivity.OnMeleeHitTaken
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCommitSuicideActivity::OnMeleeHitTaken(class AReadyOrNotCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CommitSuicideActivity.OnMeleeHitTaken");
		
		UCommitSuicideActivity_OnMeleeHitTaken_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CommitSuicideActivity.OnHeardYell
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Shouter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLOS                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCommitSuicideActivity::OnHeardYell(class AReadyOrNotCharacter* Shouter, bool bLOS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CommitSuicideActivity.OnHeardYell");
		
		UCommitSuicideActivity_OnHeardYell_Params params {};
		params.Shouter = Shouter;
		params.bLOS = bLOS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CommitSuicideActivity.OnDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCommitSuicideActivity::OnDamaged(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CommitSuicideActivity.OnDamaged");
		
		UCommitSuicideActivity_OnDamaged_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCommitSuicideActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCommitSuicideActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CommitSuicideActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCompetitionHelperLib.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCompetitionHelperLib::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CompetitionHelperLib");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Conditional.CheckPassCondition
	 * 		Flags  -> ()
	 */
	bool UConditional::CheckPassCondition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Conditional.CheckPassCondition");
		
		UConditional_CheckPassCondition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConditional.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConditional::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Conditional");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ControllableByTablet.HideActorsForTabletView
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneCaptureComponent2D*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControllableByTablet::HideActorsForTabletView(class USceneCaptureComponent2D* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ControllableByTablet.HideActorsForTabletView");
		
		UControllableByTablet_HideActorsForTabletView_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ControllableByTablet.GetTabletViewTeamColor
	 * 		Flags  -> ()
	 */
	ETeamType UControllableByTablet::GetTabletViewTeamColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ControllableByTablet.GetTabletViewTeamColor");
		
		UControllableByTablet_GetTabletViewTeamColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ControllableByTablet.GetTabletViewSocket
	 * 		Flags  -> ()
	 */
	class FName UControllableByTablet::GetTabletViewSocket()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ControllableByTablet.GetTabletViewSocket");
		
		UControllableByTablet_GetTabletViewSocket_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ControllableByTablet.GetTabletViewComponent
	 * 		Flags  -> ()
	 */
	class USceneComponent* UControllableByTablet::GetTabletViewComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ControllableByTablet.GetTabletViewComponent");
		
		UControllableByTablet_GetTabletViewComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ControllableByTablet.GetTabletNameText
	 * 		Flags  -> ()
	 */
	class FText UControllableByTablet::GetTabletNameText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ControllableByTablet.GetTabletNameText");
		
		UControllableByTablet_GetTabletNameText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ControllableByTablet.CanTabletViewMe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            TabletOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotGameState*                        GameState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UControllableByTablet::CanTabletViewMe(class APlayerCharacter* TabletOwner, class AReadyOrNotGameState* GameState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ControllableByTablet.CanTabletViewMe");
		
		UControllableByTablet_CanTabletViewMe_Params params {};
		params.TabletOwner = TabletOwner;
		params.GameState = GameState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ControllableByTablet.CanControlWithTablet
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            TabletOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UControllableByTablet::CanControlWithTablet(class APlayerCharacter* TabletOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ControllableByTablet.CanControlWithTablet");
		
		UControllableByTablet_CanControlWithTablet_Params params {};
		params.TabletOwner = TabletOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ControllableByTablet.AssumeTabletControl
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            TabletOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControllableByTablet::AssumeTabletControl(class APlayerCharacter* TabletOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ControllableByTablet.AssumeTabletControl");
		
		UControllableByTablet_AssumeTabletControl_Params params {};
		params.TabletOwner = TabletOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UControllableByTablet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UControllableByTablet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ControllableByTablet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Conversation.TryGetSpeakers
	 * 		Flags  -> ()
	 */
	void UConversation::TryGetSpeakers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Conversation.TryGetSpeakers");
		
		UConversation_TryGetSpeakers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Conversation.RequirementsMet
	 * 		Flags  -> ()
	 */
	bool UConversation::RequirementsMet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Conversation.RequirementsMet");
		
		UConversation_RequirementsMet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Conversation.ReplyToConversation
	 * 		Flags  -> ()
	 */
	void UConversation::ReplyToConversation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Conversation.ReplyToConversation");
		
		UConversation_ReplyToConversation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.Conversation.OnEndConversation__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UConversation::OnEndConversation__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.Conversation.OnEndConversation__DelegateSignature");
		
		UConversation_OnEndConversation__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.Conversation.OnConversationContinuing__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Idx                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversation::OnConversationContinuing__DelegateSignature(int32_t Idx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.Conversation.OnConversationContinuing__DelegateSignature");
		
		UConversation_OnConversationContinuing__DelegateSignature_Params params {};
		params.Idx = Idx;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Conversation.GoToSpecificConversationIdAndContinueConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Idx                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversation::GoToSpecificConversationIdAndContinueConversation(int32_t Idx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Conversation.GoToSpecificConversationIdAndContinueConversation");
		
		UConversation_GoToSpecificConversationIdAndContinueConversation_Params params {};
		params.Idx = Idx;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Conversation.GiveWorldBuildingActivityByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        SpeakerId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversation::GiveWorldBuildingActivityByTag(const class FName& SpeakerId, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Conversation.GiveWorldBuildingActivityByTag");
		
		UConversation_GiveWorldBuildingActivityByTag_Params params {};
		params.SpeakerId = SpeakerId;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Conversation.GetSpeakerForId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ACyberneticCharacter* UConversation::GetSpeakerForId(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Conversation.GetSpeakerForId");
		
		UConversation_GetSpeakerForId_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Conversation.GetSpeakerForConversationIdx
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Idx                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ACyberneticCharacter* UConversation::GetSpeakerForConversationIdx(int32_t Idx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Conversation.GetSpeakerForConversationIdx");
		
		UConversation_GetSpeakerForConversationIdx_Params params {};
		params.Idx = Idx;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Conversation.GetConversationData
	 * 		Flags  -> ()
	 */
	struct FConversationData UConversation::GetConversationData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Conversation.GetConversationData");
		
		UConversation_GetConversationData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Conversation.ContinueConversation
	 * 		Flags  -> ()
	 */
	void UConversation::ContinueConversation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Conversation.ContinueConversation");
		
		UConversation_ContinueConversation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Conversation.BuildConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversation::BuildConversation(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Conversation.BuildConversation");
		
		UConversation_BuildConversation_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Conversation.BeginConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        ConversationStarter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UConversation::BeginConversation(class ACyberneticCharacter* ConversationStarter, const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Conversation.BeginConversation");
		
		UConversation_BeginConversation_Params params {};
		params.ConversationStarter = ConversationStarter;
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConversation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConversation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Conversation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ConversationManager.TryPlayConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ConversationId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticCharacter*                        ConversationStarter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UConversation* AConversationManager::TryPlayConversation(const class FName& ConversationId, class ACyberneticCharacter* ConversationStarter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ConversationManager.TryPlayConversation");
		
		AConversationManager_TryPlayConversation_Params params {};
		params.ConversationId = ConversationId;
		params.ConversationStarter = ConversationStarter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ConversationManager.PlayPrebuiltConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Conversation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticCharacter*                        ConversationStarter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ConversationId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UConversation* AConversationManager::PlayPrebuiltConversation(class UClass* Conversation, class ACyberneticCharacter* ConversationStarter, const class FName& ConversationId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ConversationManager.PlayPrebuiltConversation");
		
		AConversationManager_PlayPrebuiltConversation_Params params {};
		params.Conversation = Conversation;
		params.ConversationStarter = ConversationStarter;
		params.ConversationId = ConversationId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ConversationManager.PlayConversationInst
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UConversation*                               Conversation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticCharacter*                        ConversationStarter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AConversationManager::PlayConversationInst(class UConversation* Conversation, class ACyberneticCharacter* ConversationStarter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ConversationManager.PlayConversationInst");
		
		AConversationManager_PlayConversationInst_Params params {};
		params.Conversation = Conversation;
		params.ConversationStarter = ConversationStarter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AConversationManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AConversationManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ConversationManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.StartMissionEndTimer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bWon                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGM::StartMissionEndTimer(bool bWon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.StartMissionEndTimer");
		
		ACoopGM_StartMissionEndTimer_Params params {};
		params.bWon = bWon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.SpawnSuspectsAndHostages
	 * 		Flags  -> ()
	 */
	void ACoopGM::SpawnSuspectsAndHostages()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.SpawnSuspectsAndHostages");
		
		ACoopGM_SpawnSuspectsAndHostages_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.SpawnPolice
	 * 		Flags  -> ()
	 */
	void ACoopGM::SpawnPolice()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.SpawnPolice");
		
		ACoopGM_SpawnPolice_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.SpawnDeployables
	 * 		Flags  -> ()
	 */
	void ACoopGM::SpawnDeployables()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.SpawnDeployables");
		
		ACoopGM_SpawnDeployables_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.Server_SoftClearVoteCheck
	 * 		Flags  -> ()
	 */
	void ACoopGM::Server_SoftClearVoteCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.Server_SoftClearVoteCheck");
		
		ACoopGM_Server_SoftClearVoteCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.RemoveAllSpawnedAI
	 * 		Flags  -> ()
	 */
	void ACoopGM::RemoveAllSpawnedAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.RemoveAllSpawnedAI");
		
		ACoopGM_RemoveAllSpawnedAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.Personnel_SpawnVentilation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PersonnelNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MapPointNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGM::Personnel_SpawnVentilation(int32_t PersonnelNum, int32_t MapPointNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.Personnel_SpawnVentilation");
		
		ACoopGM_Personnel_SpawnVentilation_Params params {};
		params.PersonnelNum = PersonnelNum;
		params.MapPointNum = MapPointNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.Personnel_SpawnTruckDriver
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PersonnelNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MapPointNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGM::Personnel_SpawnTruckDriver(int32_t PersonnelNum, int32_t MapPointNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.Personnel_SpawnTruckDriver");
		
		ACoopGM_Personnel_SpawnTruckDriver_Params params {};
		params.PersonnelNum = PersonnelNum;
		params.MapPointNum = MapPointNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.Personnel_SpawnPowerCrew
	 * 		Flags  -> ()
	 */
	void ACoopGM::Personnel_SpawnPowerCrew()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.Personnel_SpawnPowerCrew");
		
		ACoopGM_Personnel_SpawnPowerCrew_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.Personnel_SpawnOperator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PersonnelNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MapPointNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNoisemaker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGM::Personnel_SpawnOperator(int32_t PersonnelNum, int32_t MapPointNum, bool bNoisemaker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.Personnel_SpawnOperator");
		
		ACoopGM_Personnel_SpawnOperator_Params params {};
		params.PersonnelNum = PersonnelNum;
		params.MapPointNum = MapPointNum;
		params.bNoisemaker = bNoisemaker;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.Personnel_SpawnNegotiator
	 * 		Flags  -> ()
	 */
	void ACoopGM::Personnel_SpawnNegotiator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.Personnel_SpawnNegotiator");
		
		ACoopGM_Personnel_SpawnNegotiator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.Personnel_SpawnHighground
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PersonnelNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MapPointNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSpotter                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMarksman                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSniper                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGM::Personnel_SpawnHighground(int32_t PersonnelNum, int32_t MapPointNum, bool bSpotter, bool bMarksman, bool bSniper)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.Personnel_SpawnHighground");
		
		ACoopGM_Personnel_SpawnHighground_Params params {};
		params.PersonnelNum = PersonnelNum;
		params.MapPointNum = MapPointNum;
		params.bSpotter = bSpotter;
		params.bMarksman = bMarksman;
		params.bSniper = bSniper;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CoopGM.OnMissionEnded__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bMissionSucceded                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGM::OnMissionEnded__DelegateSignature(bool bMissionSucceded)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CoopGM.OnMissionEnded__DelegateSignature");
		
		ACoopGM_OnMissionEnded__DelegateSignature_Params params {};
		params.bMissionSucceded = bMissionSucceded;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.MissionEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGM::MissionEnd(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.MissionEnd");
		
		ACoopGM_MissionEnd_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.GetSWATManager
	 * 		Flags  -> ()
	 */
	class ASWATManager* ACoopGM::GetSWATManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.GetSWATManager");
		
		ACoopGM_GetSWATManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.GetCOOPMode
	 * 		Flags  -> ()
	 */
	ECOOPMode ACoopGM::GetCOOPMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.GetCOOPMode");
		
		ACoopGM_GetCOOPMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.FriendlyAIKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGM::FriendlyAIKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.FriendlyAIKilled");
		
		ACoopGM_FriendlyAIKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.FindSpotUpgradeSWAT
	 * 		Flags  -> ()
	 */
	void ACoopGM::FindSpotUpgradeSWAT()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.FindSpotUpgradeSWAT");
		
		ACoopGM_FindSpotUpgradeSWAT_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.FindPlayerStartForTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APlayerStart* ACoopGM::FindPlayerStartForTeam(ETeamType Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.FindPlayerStartForTeam");
		
		ACoopGM_FindPlayerStartForTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.EnemyAIKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGM::EnemyAIKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.EnemyAIKilled");
		
		ACoopGM_EnemyAIKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.EnemyAIBulletHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Causer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  HitCharacter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBulletDamageType*                           DamageEvent                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGM::EnemyAIBulletHit(float Damage, class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* HitCharacter, class UBulletDamageType* DamageEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.EnemyAIBulletHit");
		
		ACoopGM_EnemyAIBulletHit_Params params {};
		params.Damage = Damage;
		params.Causer = Causer;
		params.InstigatorCharacter = InstigatorCharacter;
		params.HitCharacter = HitCharacter;
		params.DamageEvent = DamageEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.EnemyAIArrested
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ArrestedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGM::EnemyAIArrested(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.EnemyAIArrested");
		
		ACoopGM_EnemyAIArrested_Params params {};
		params.ArrestedCharacter = ArrestedCharacter;
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGM.CheckSpawners
	 * 		Flags  -> ()
	 */
	void ACoopGM::CheckSpawners()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGM.CheckSpawners");
		
		ACoopGM_CheckSpawners_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.CoopGM.AllAISpawnedDelegate__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ACoopGM::AllAISpawnedDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.CoopGM.AllAISpawnedDelegate__DelegateSignature");
		
		ACoopGM_AllAISpawnedDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACoopGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACoopGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CoopGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.UpdateVotes
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Yes                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            No                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGS::UpdateVotes(int32_t Yes, int32_t No)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.UpdateVotes");
		
		ACoopGS_UpdateVotes_Params params {};
		params.Yes = Yes;
		params.No = No;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.StartTOCBriefing
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      TOCLine                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGS::StartTOCBriefing(const class FString& TOCLine)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.StartTOCBriefing");
		
		ACoopGS_StartTOCBriefing_Params params {};
		params.TOCLine = TOCLine;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.Server_SetDeployableDepot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotPlayerController*                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewDepotNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGS::Server_SetDeployableDepot(class AReadyOrNotPlayerController* Controller, int32_t NewDepotNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.Server_SetDeployableDepot");
		
		ACoopGS_Server_SetDeployableDepot_Params params {};
		params.Controller = Controller;
		params.NewDepotNum = NewDepotNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.OnRep_MapElement
	 * 		Flags  -> ()
	 */
	void ACoopGS::OnRep_MapElement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.OnRep_MapElement");
		
		ACoopGS_OnRep_MapElement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.OnRep_COOPMode
	 * 		Flags  -> ()
	 */
	void ACoopGS::OnRep_COOPMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.OnRep_COOPMode");
		
		ACoopGS_OnRep_COOPMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.Multicast_OnMissionEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGS::Multicast_OnMissionEnd(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.Multicast_OnMissionEnd");
		
		ACoopGS_Multicast_OnMissionEnd_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.Multicast_BroadcastNewSquadLeader
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            NewLeader                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoopGS::Multicast_BroadcastNewSquadLeader(class APlayerCharacter* NewLeader)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.Multicast_BroadcastNewSquadLeader");
		
		ACoopGS_Multicast_BroadcastNewSquadLeader_Params params {};
		params.NewLeader = NewLeader;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.IsPersonnelEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PersonnelNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACoopGS::IsPersonnelEnabled(int32_t PersonnelNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.IsPersonnelEnabled");
		
		ACoopGS_IsPersonnelEnabled_Params params {};
		params.PersonnelNum = PersonnelNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.IsDeployableEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            DeployableNumber                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACoopGS::IsDeployableEnabled(int32_t DeployableNumber)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.IsDeployableEnabled");
		
		ACoopGS_IsDeployableEnabled_Params params {};
		params.DeployableNumber = DeployableNumber;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.GetUsedPersonnelPoints
	 * 		Flags  -> ()
	 */
	TArray<int32_t> ACoopGS::GetUsedPersonnelPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.GetUsedPersonnelPoints");
		
		ACoopGS_GetUsedPersonnelPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.GetUnenabledPersonnel
	 * 		Flags  -> ()
	 */
	TArray<int32_t> ACoopGS::GetUnenabledPersonnel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.GetUnenabledPersonnel");
		
		ACoopGS_GetUnenabledPersonnel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.GetUnenabledDeployables
	 * 		Flags  -> ()
	 */
	TArray<int32_t> ACoopGS::GetUnenabledDeployables()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.GetUnenabledDeployables");
		
		ACoopGS_GetUnenabledDeployables_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.GetPersonnelForMapNum
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            MapPointNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ACoopGS::GetPersonnelForMapNum(int32_t MapPointNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.GetPersonnelForMapNum");
		
		ACoopGS_GetPersonnelForMapNum_Params params {};
		params.MapPointNum = MapPointNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.GetEnabledPersonnel
	 * 		Flags  -> ()
	 */
	TArray<int32_t> ACoopGS::GetEnabledPersonnel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.GetEnabledPersonnel");
		
		ACoopGS_GetEnabledPersonnel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.GetEnabledDeployablesShortNames
	 * 		Flags  -> ()
	 */
	TArray<class FText> ACoopGS::GetEnabledDeployablesShortNames()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.GetEnabledDeployablesShortNames");
		
		ACoopGS_GetEnabledDeployablesShortNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.GetEnabledDeployables
	 * 		Flags  -> ()
	 */
	TArray<int32_t> ACoopGS::GetEnabledDeployables()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.GetEnabledDeployables");
		
		ACoopGS_GetEnabledDeployables_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoopGS.CanChangeSpawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bBlueTeam                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESelectedSpawn                                     NewSpawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACoopGS::CanChangeSpawn(bool bBlueTeam, ESelectedSpawn NewSpawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoopGS.CanChangeSpawn");
		
		ACoopGS_CanChangeSpawn_Params params {};
		params.bBlueTeam = bBlueTeam;
		params.NewSpawn = NewSpawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACoopGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACoopGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CoopGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.COOPScorePopUp.PlayRewardSound
	 * 		Flags  -> ()
	 */
	void UCOOPScorePopUp::PlayRewardSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.COOPScorePopUp.PlayRewardSound");
		
		UCOOPScorePopUp_PlayRewardSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCOOPScorePopUp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCOOPScorePopUp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.COOPScorePopUp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCoverDoorActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCoverDoorActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CoverDoorActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACoverFinderPreview.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACoverFinderPreview::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CoverFinderPreview");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCoverFinderRenderingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCoverFinderRenderingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CoverFinderRenderingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverFireVolume.OnActorSpawned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoverFireVolume::OnActorSpawned(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverFireVolume.OnActorSpawned");
		
		ACoverFireVolume_OnActorSpawned_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverFireVolume.HasFreeFirePoint
	 * 		Flags  -> ()
	 */
	bool ACoverFireVolume::HasFreeFirePoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverFireVolume.HasFreeFirePoint");
		
		ACoverFireVolume_HasFreeFirePoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverFireVolume.GetNextPushUpPoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AFirePointActor*                             CurrentFirePoint                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        EnemyLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AFirePointActor* ACoverFireVolume::GetNextPushUpPoint(class AFirePointActor* CurrentFirePoint, const struct FCoreUObject_FVector& Location, const struct FCoreUObject_FVector& EnemyLocation, class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverFireVolume.GetNextPushUpPoint");
		
		ACoverFireVolume_GetNextPushUpPoint_Params params {};
		params.CurrentFirePoint = CurrentFirePoint;
		params.Location = Location;
		params.EnemyLocation = EnemyLocation;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverFireVolume.GetNearestSuspects
	 * 		Flags  -> ()
	 */
	TArray<class ASuspectCharacter*> ACoverFireVolume::GetNearestSuspects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverFireVolume.GetNearestSuspects");
		
		ACoverFireVolume_GetNearestSuspects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverFireVolume.GetNearestFirePoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AFirePointActor* ACoverFireVolume::GetNearestFirePoint(const struct FCoreUObject_FVector& Location, class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverFireVolume.GetNearestFirePoint");
		
		ACoverFireVolume_GetNearestFirePoint_Params params {};
		params.Location = Location;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverFireVolume.GetFurtherestFirePoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AFirePointActor* ACoverFireVolume::GetFurtherestFirePoint(const struct FCoreUObject_FVector& Location, class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverFireVolume.GetFurtherestFirePoint");
		
		ACoverFireVolume_GetFurtherestFirePoint_Params params {};
		params.Location = Location;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACoverFireVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACoverFireVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CoverFireVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverLandmark.ToggleLandmarkEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoverLandmark::ToggleLandmarkEnabled(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverLandmark.ToggleLandmarkEnabled");
		
		ACoverLandmark_ToggleLandmarkEnabled_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverLandmark.PreviewIdleAnim
	 * 		Flags  -> ()
	 */
	void ACoverLandmark::PreviewIdleAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverLandmark.PreviewIdleAnim");
		
		ACoverLandmark_PreviewIdleAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverLandmark.PreviewExitAnim
	 * 		Flags  -> ()
	 */
	void ACoverLandmark::PreviewExitAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverLandmark.PreviewExitAnim");
		
		ACoverLandmark_PreviewExitAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverLandmark.PreviewEntryAnim
	 * 		Flags  -> ()
	 */
	void ACoverLandmark::PreviewEntryAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverLandmark.PreviewEntryAnim");
		
		ACoverLandmark_PreviewEntryAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverLandmark.IsCooldownActiveFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AController*                                 InController                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ACoverLandmark::IsCooldownActiveFor(class AController* InController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverLandmark.IsCooldownActiveFor");
		
		ACoverLandmark_IsCooldownActiveFor_Params params {};
		params.InController = InController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverLandmark.EnableLandmark
	 * 		Flags  -> ()
	 */
	void ACoverLandmark::EnableLandmark()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverLandmark.EnableLandmark");
		
		ACoverLandmark_EnableLandmark_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverLandmark.DisableLandmark
	 * 		Flags  -> ()
	 */
	void ACoverLandmark::DisableLandmark()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverLandmark.DisableLandmark");
		
		ACoverLandmark_DisableLandmark_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverLandmark.AddCooldownFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AController*                                 InController                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InCooldownTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoverLandmark::AddCooldownFor(class AController* InController, float InCooldownTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverLandmark.AddCooldownFor");
		
		ACoverLandmark_AddCooldownFor_Params params {};
		params.InController = InController;
		params.InCooldownTime = InCooldownTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACoverLandmark.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACoverLandmark::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CoverLandmark");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverLandmarkProxy.OnProxyUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsActive                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoverLandmarkProxy::OnProxyUse(bool bIsActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverLandmarkProxy.OnProxyUse");
		
		ACoverLandmarkProxy_OnProxyUse_Params params {};
		params.bIsActive = bIsActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CoverLandmarkProxy.OnProxyEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACoverLandmarkProxy::OnProxyEnd(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CoverLandmarkProxy.OnProxyEnd");
		
		ACoverLandmarkProxy_OnProxyEnd_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACoverLandmarkProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACoverLandmarkProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CoverLandmarkProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCoverQueryResultInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCoverQueryResultInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CoverQueryResultInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCSGasDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCSGasDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CSGasDamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CTF_Flag.ResetFlagTransforms
	 * 		Flags  -> ()
	 */
	void ACTF_Flag::ResetFlagTransforms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CTF_Flag.ResetFlagTransforms");
		
		ACTF_Flag_ResetFlagTransforms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CTF_Flag.OnFlagBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ACTF_Flag::OnFlagBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CTF_Flag.OnFlagBeginOverlap");
		
		ACTF_Flag_OnFlagBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CTF_Flag.GetBoneToAttachName
	 * 		Flags  -> ()
	 */
	class FName ACTF_Flag::GetBoneToAttachName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CTF_Flag.GetBoneToAttachName");
		
		ACTF_Flag_GetBoneToAttachName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACTF_Flag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACTF_Flag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CTF_Flag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACTF_FlagSpawnPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACTF_FlagSpawnPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CTF_FlagSpawnPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CTFTriggerBox.OnBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACTFTriggerBox::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CTFTriggerBox.OnBeginOverlap");
		
		ACTFTriggerBox_OnBeginOverlap_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CTFTriggerBox.FulfillsRequirements
	 * 		Flags  -> ()
	 */
	bool ACTFTriggerBox::FulfillsRequirements()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CTFTriggerBox.FulfillsRequirements");
		
		ACTFTriggerBox_FulfillsRequirements_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACTFTriggerBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACTFTriggerBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CTFTriggerBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCurrentMatchRoundWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCurrentMatchRoundWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CurrentMatchRoundWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCursorWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCursorWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CursorWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCurveFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCurveFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CurveFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCustomizationWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCustomizationWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CustomizationWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCustomPhysicalMaterial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCustomPhysicalMaterial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CustomPhysicalMaterial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CuttableCableActor.Server_PullCable
	 * 		Flags  -> ()
	 */
	void ACuttableCableActor::Server_PullCable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CuttableCableActor.Server_PullCable");
		
		ACuttableCableActor_Server_PullCable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CuttableCableActor.Server_CutCableAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        CutOrigin                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACuttableCableActor::Server_CutCableAt(const struct FCoreUObject_FVector& CutOrigin)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CuttableCableActor.Server_CutCableAt");
		
		ACuttableCableActor_Server_CutCableAt_Params params {};
		params.CutOrigin = CutOrigin;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CuttableCableActor.OnCablePulled_Server
	 * 		Flags  -> ()
	 */
	void ACuttableCableActor::OnCablePulled_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CuttableCableActor.OnCablePulled_Server");
		
		ACuttableCableActor_OnCablePulled_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CuttableCableActor.OnCablePulled_Multicast
	 * 		Flags  -> ()
	 */
	void ACuttableCableActor::OnCablePulled_Multicast()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CuttableCableActor.OnCablePulled_Multicast");
		
		ACuttableCableActor_OnCablePulled_Multicast_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CuttableCableActor.OnCableCut_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        SplitOrigin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACuttableCableActor::OnCableCut_Server(const struct FCoreUObject_FVector& SplitOrigin)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CuttableCableActor.OnCableCut_Server");
		
		ACuttableCableActor_OnCableCut_Server_Params params {};
		params.SplitOrigin = SplitOrigin;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CuttableCableActor.OnCableCut_Multicast
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        SplitOrigin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACuttableCableActor::OnCableCut_Multicast(const struct FCoreUObject_FVector& SplitOrigin)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CuttableCableActor.OnCableCut_Multicast");
		
		ACuttableCableActor_OnCableCut_Multicast_Params params {};
		params.SplitOrigin = SplitOrigin;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CuttableCableActor.Multicast_OnCablePulled
	 * 		Flags  -> ()
	 */
	void ACuttableCableActor::Multicast_OnCablePulled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CuttableCableActor.Multicast_OnCablePulled");
		
		ACuttableCableActor_Multicast_OnCablePulled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CuttableCableActor.Multicast_OnCableCutAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        SplitOrigin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACuttableCableActor::Multicast_OnCableCutAt(const struct FCoreUObject_FVector& SplitOrigin)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CuttableCableActor.Multicast_OnCableCutAt");
		
		ACuttableCableActor_Multicast_OnCableCutAt_Params params {};
		params.SplitOrigin = SplitOrigin;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CuttableCableActor.GetCablePoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FCoreUObject_FVector>                OutPoints                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ACuttableCableActor::GetCablePoints(TArray<struct FCoreUObject_FVector>* OutPoints)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CuttableCableActor.GetCablePoints");
		
		ACuttableCableActor_GetCablePoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPoints != nullptr)
			*OutPoints = params.OutPoints;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACuttableCableActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACuttableCableActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CuttableCableActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DataSingleton.UnloadLevels
	 * 		Flags  -> ()
	 */
	void UDataSingleton::UnloadLevels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DataSingleton.UnloadLevels");
		
		UDataSingleton_UnloadLevels_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DataSingleton.RefreshInputKeyTable
	 * 		Flags  -> ()
	 */
	void UDataSingleton::RefreshInputKeyTable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DataSingleton.RefreshInputKeyTable");
		
		UDataSingleton_RefreshInputKeyTable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DataSingleton.LoadLevels
	 * 		Flags  -> ()
	 */
	void UDataSingleton::LoadLevels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DataSingleton.LoadLevels");
		
		UDataSingleton_LoadLevels_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDataSingleton.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDataSingleton::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DataSingleton");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DebugDisplayActor.SetWidgetClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      NewWidgetClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADebugDisplayActor::SetWidgetClass(class UClass* NewWidgetClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DebugDisplayActor.SetWidgetClass");
		
		ADebugDisplayActor_SetWidgetClass_Params params {};
		params.NewWidgetClass = NewWidgetClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DebugDisplayActor.SetTitle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      TextTitle                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADebugDisplayActor::SetTitle(const class FString& TextTitle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DebugDisplayActor.SetTitle");
		
		ADebugDisplayActor_SetTitle_Params params {};
		params.TextTitle = TextTitle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DebugDisplayActor.SetText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            TextLine                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADebugDisplayActor::SetText(int32_t TextLine, const class FString& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DebugDisplayActor.SetText");
		
		ADebugDisplayActor_SetText_Params params {};
		params.TextLine = TextLine;
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DebugDisplayActor.AddText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ADebugDisplayActor::AddText(const class FString& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DebugDisplayActor.AddText");
		
		ADebugDisplayActor_AddText_Params params {};
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADebugDisplayActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADebugDisplayActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DebugDisplayActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DebugDisplayWidget.SetDebugTitle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      NewTitle                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDebugDisplayWidget::SetDebugTitle(const class FString& NewTitle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DebugDisplayWidget.SetDebugTitle");
		
		UDebugDisplayWidget_SetDebugTitle_Params params {};
		params.NewTitle = NewTitle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DebugDisplayWidget.SetDebugText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      NewText                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDebugDisplayWidget::SetDebugText(int32_t ID, const class FString& NewText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DebugDisplayWidget.SetDebugText");
		
		UDebugDisplayWidget_SetDebugText_Params params {};
		params.ID = ID;
		params.NewText = NewText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DebugDisplayWidget.AddDebugText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      NewText                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UDebugDisplayWidget::AddDebugText(const class FString& NewText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DebugDisplayWidget.AddDebugText");
		
		UDebugDisplayWidget_AddDebugText_Params params {};
		params.NewText = NewText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDebugDisplayWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDebugDisplayWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DebugDisplayWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADefusalGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADefusalGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DefusalGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADefusalGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADefusalGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DefusalGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DefuseBombThreats.OnBombDefused
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABombActor*                                  DefusedBomb                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADefuseBombThreats::OnBombDefused(class ABombActor* DefusedBomb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DefuseBombThreats.OnBombDefused");
		
		ADefuseBombThreats_OnBombDefused_Params params {};
		params.DefusedBomb = DefusedBomb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADefuseBombThreats.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADefuseBombThreats::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DefuseBombThreats");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployableBag.Server_StartBagPlacement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  TraceHit                                                   (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADeployableBag::Server_StartBagPlacement(const struct FHitResult& TraceHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployableBag.Server_StartBagPlacement");
		
		ADeployableBag_Server_StartBagPlacement_Params params {};
		params.TraceHit = TraceHit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployableBag.OnBagSpawned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlacedBag*                                  SpawnedBag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADeployableBag::OnBagSpawned(class APlacedBag* SpawnedBag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployableBag.OnBagSpawned");
		
		ADeployableBag_OnBagSpawned_Params params {};
		params.SpawnedBag = SpawnedBag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADeployableBag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADeployableBag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DeployableBag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDeployableData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDeployableData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DeployableData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployableDepot.OnSuccessfulSpawn
	 * 		Flags  -> ()
	 */
	void ADeployableDepot::OnSuccessfulSpawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployableDepot.OnSuccessfulSpawn");
		
		ADeployableDepot_OnSuccessfulSpawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployableDepot.OnGameStarted
	 * 		Flags  -> ()
	 */
	void ADeployableDepot::OnGameStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployableDepot.OnGameStarted");
		
		ADeployableDepot_OnGameStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployableDepot.Multicast_OnSuccessfulSpawn
	 * 		Flags  -> ()
	 */
	void ADeployableDepot::Multicast_OnSuccessfulSpawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployableDepot.Multicast_OnSuccessfulSpawn");
		
		ADeployableDepot_Multicast_OnSuccessfulSpawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADeployableDepot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADeployableDepot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DeployableDepot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployableSpawnComponent.TrySpawnComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               ShouldSpawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDeployableSpawnComponent::TrySpawnComponent(bool ShouldSpawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployableSpawnComponent.TrySpawnComponent");
		
		UDeployableSpawnComponent_TrySpawnComponent_Params params {};
		params.ShouldSpawn = ShouldSpawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployableSpawnComponent.MutateSpawnedDeployable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      SpawnedDeployable                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDeployableSpawnComponent::MutateSpawnedDeployable(class AActor* SpawnedDeployable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployableSpawnComponent.MutateSpawnedDeployable");
		
		UDeployableSpawnComponent_MutateSpawnedDeployable_Params params {};
		params.SpawnedDeployable = SpawnedDeployable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDeployableSpawnComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDeployableSpawnComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DeployableSpawnComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDeployAtLocationCommand.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDeployAtLocationCommand::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DeployAtLocationCommand");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployItemAtLocationActivity.TickMoveToStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDeployItemAtLocationActivity::TickMoveToStage(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployItemAtLocationActivity.TickMoveToStage");
		
		UDeployItemAtLocationActivity_TickMoveToStage_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployItemAtLocationActivity.TickDeployStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDeployItemAtLocationActivity::TickDeployStage(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployItemAtLocationActivity.TickDeployStage");
		
		UDeployItemAtLocationActivity_TickDeployStage_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployItemAtLocationActivity.ExitMoveToStage
	 * 		Flags  -> ()
	 */
	void UDeployItemAtLocationActivity::ExitMoveToStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployItemAtLocationActivity.ExitMoveToStage");
		
		UDeployItemAtLocationActivity_ExitMoveToStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployItemAtLocationActivity.ExitDeployStage
	 * 		Flags  -> ()
	 */
	void UDeployItemAtLocationActivity::ExitDeployStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployItemAtLocationActivity.ExitDeployStage");
		
		UDeployItemAtLocationActivity_ExitDeployStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployItemAtLocationActivity.EnterMoveToStage
	 * 		Flags  -> ()
	 */
	void UDeployItemAtLocationActivity::EnterMoveToStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployItemAtLocationActivity.EnterMoveToStage");
		
		UDeployItemAtLocationActivity_EnterMoveToStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployItemAtLocationActivity.EnterDeployStage
	 * 		Flags  -> ()
	 */
	void UDeployItemAtLocationActivity::EnterDeployStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployItemAtLocationActivity.EnterDeployStage");
		
		UDeployItemAtLocationActivity_EnterDeployStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployItemAtLocationActivity.CanDeploy
	 * 		Flags  -> ()
	 */
	bool UDeployItemAtLocationActivity::CanDeploy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployItemAtLocationActivity.CanDeploy");
		
		UDeployItemAtLocationActivity_CanDeploy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployItemAtLocationActivity.Blueprint_TickDeployStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDeployItemAtLocationActivity::Blueprint_TickDeployStage(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployItemAtLocationActivity.Blueprint_TickDeployStage");
		
		UDeployItemAtLocationActivity_Blueprint_TickDeployStage_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployItemAtLocationActivity.Blueprint_ExitDeployStage
	 * 		Flags  -> ()
	 */
	void UDeployItemAtLocationActivity::Blueprint_ExitDeployStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployItemAtLocationActivity.Blueprint_ExitDeployStage");
		
		UDeployItemAtLocationActivity_Blueprint_ExitDeployStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployItemAtLocationActivity.Blueprint_EnterDeployStage
	 * 		Flags  -> ()
	 */
	void UDeployItemAtLocationActivity::Blueprint_EnterDeployStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployItemAtLocationActivity.Blueprint_EnterDeployStage");
		
		UDeployItemAtLocationActivity_Blueprint_EnterDeployStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDeployItemAtLocationActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDeployItemAtLocationActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DeployItemAtLocationActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DeployChemlightActivity.OnChemlightThrown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDeployChemlightActivity::OnChemlightThrown(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DeployChemlightActivity.OnChemlightThrown");
		
		UDeployChemlightActivity_OnChemlightThrown_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDeployChemlightActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDeployChemlightActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DeployChemlightActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDeployGrenadeAtLocationActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDeployGrenadeAtLocationActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DeployGrenadeAtLocationActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorInteractionActivity.ShouldGetInPosition
	 * 		Flags  -> ()
	 */
	bool UDoorInteractionActivity::ShouldGetInPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorInteractionActivity.ShouldGetInPosition");
		
		UDoorInteractionActivity_ShouldGetInPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorInteractionActivity.PerformInteractStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDoorInteractionActivity::PerformInteractStage(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorInteractionActivity.PerformInteractStage");
		
		UDoorInteractionActivity_PerformInteractStage_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorInteractionActivity.PerformGetInPositionStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDoorInteractionActivity::PerformGetInPositionStage(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorInteractionActivity.PerformGetInPositionStage");
		
		UDoorInteractionActivity_PerformGetInPositionStage_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorInteractionActivity.OnInteractionEnd
	 * 		Flags  -> ()
	 */
	void UDoorInteractionActivity::OnInteractionEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorInteractionActivity.OnInteractionEnd");
		
		UDoorInteractionActivity_OnInteractionEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorInteractionActivity.OnInteractionBegin
	 * 		Flags  -> ()
	 */
	void UDoorInteractionActivity::OnInteractionBegin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorInteractionActivity.OnInteractionBegin");
		
		UDoorInteractionActivity_OnInteractionBegin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorInteractionActivity.OnDoorOpened
	 * 		Flags  -> ()
	 */
	void UDoorInteractionActivity::OnDoorOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorInteractionActivity.OnDoorOpened");
		
		UDoorInteractionActivity_OnDoorOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorInteractionActivity.OnDoorClosed
	 * 		Flags  -> ()
	 */
	void UDoorInteractionActivity::OnDoorClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorInteractionActivity.OnDoorClosed");
		
		UDoorInteractionActivity_OnDoorClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorInteractionActivity.OnDoorBroken
	 * 		Flags  -> ()
	 */
	void UDoorInteractionActivity::OnDoorBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorInteractionActivity.OnDoorBroken");
		
		UDoorInteractionActivity_OnDoorBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorInteractionActivity.ExitInteractStage
	 * 		Flags  -> ()
	 */
	void UDoorInteractionActivity::ExitInteractStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorInteractionActivity.ExitInteractStage");
		
		UDoorInteractionActivity_ExitInteractStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorInteractionActivity.ExitGetInPositionStage
	 * 		Flags  -> ()
	 */
	void UDoorInteractionActivity::ExitGetInPositionStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorInteractionActivity.ExitGetInPositionStage");
		
		UDoorInteractionActivity_ExitGetInPositionStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorInteractionActivity.EnterInteractStage
	 * 		Flags  -> ()
	 */
	void UDoorInteractionActivity::EnterInteractStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorInteractionActivity.EnterInteractStage");
		
		UDoorInteractionActivity_EnterInteractStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorInteractionActivity.EnterGetInPositionStage
	 * 		Flags  -> ()
	 */
	void UDoorInteractionActivity::EnterGetInPositionStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorInteractionActivity.EnterGetInPositionStage");
		
		UDoorInteractionActivity_EnterGetInPositionStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorInteractionActivity.CanInteract
	 * 		Flags  -> ()
	 */
	bool UDoorInteractionActivity::CanInteract()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorInteractionActivity.CanInteract");
		
		UDoorInteractionActivity_CanInteract_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDoorInteractionActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDoorInteractionActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DoorInteractionActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDeployWedgeActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDeployWedgeActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DeployWedgeActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDestructibleDoorChunkComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDestructibleDoorChunkComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DestructibleDoorChunkComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DestructibleVehicle.StopCarAlarm
	 * 		Flags  -> ()
	 */
	void ADestructibleVehicle::StopCarAlarm()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DestructibleVehicle.StopCarAlarm");
		
		ADestructibleVehicle_StopCarAlarm_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DestructibleVehicle.Multicast_PlayTireDestroyedEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMeshComponent*                        TireMesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADestructibleVehicle::Multicast_PlayTireDestroyedEffects(class UStaticMeshComponent* TireMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DestructibleVehicle.Multicast_PlayTireDestroyedEffects");
		
		ADestructibleVehicle_Multicast_PlayTireDestroyedEffects_Params params {};
		params.TireMesh = TireMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DestructibleVehicle.Multicast_PlayAudioEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFMODEvent*                                  Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize                         Location                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADestructibleVehicle::Multicast_PlayAudioEvent(class UFMODEvent* Event, const struct FVector_NetQuantize& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DestructibleVehicle.Multicast_PlayAudioEvent");
		
		ADestructibleVehicle_Multicast_PlayAudioEvent_Params params {};
		params.Event = Event;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DestructibleVehicle.Multicast_DeployCarFeatures
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bAirbag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCarAlarm                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisableLeftLight                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisableRightLight                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSimulateRearVisionMirror                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSimulateLeftWingMirror                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSimulateRightWingMirror                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADestructibleVehicle::Multicast_DeployCarFeatures(bool bAirbag, bool bCarAlarm, bool bDisableLeftLight, bool bDisableRightLight, bool bSimulateRearVisionMirror, bool bSimulateLeftWingMirror, bool bSimulateRightWingMirror)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DestructibleVehicle.Multicast_DeployCarFeatures");
		
		ADestructibleVehicle_Multicast_DeployCarFeatures_Params params {};
		params.bAirbag = bAirbag;
		params.bCarAlarm = bCarAlarm;
		params.bDisableLeftLight = bDisableLeftLight;
		params.bDisableRightLight = bDisableRightLight;
		params.bSimulateRearVisionMirror = bSimulateRearVisionMirror;
		params.bSimulateLeftWingMirror = bSimulateLeftWingMirror;
		params.bSimulateRightWingMirror = bSimulateRightWingMirror;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DestructibleVehicle.Multicast_ApplyWindowShatterEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UDestructibleComponent*                      Destructible                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADestructibleVehicle::Multicast_ApplyWindowShatterEffects(class UDestructibleComponent* Destructible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DestructibleVehicle.Multicast_ApplyWindowShatterEffects");
		
		ADestructibleVehicle_Multicast_ApplyWindowShatterEffects_Params params {};
		params.Destructible = Destructible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DestructibleVehicle.Multicast_ApplyRadialDamageToWindow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UDestructibleComponent*                      Destructible                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize                         DamageOrigin                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DamageRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ImpulseStrength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADestructibleVehicle::Multicast_ApplyRadialDamageToWindow(class UDestructibleComponent* Destructible, const struct FVector_NetQuantize& DamageOrigin, float DamageRadius, float ImpulseStrength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DestructibleVehicle.Multicast_ApplyRadialDamageToWindow");
		
		ADestructibleVehicle_Multicast_ApplyRadialDamageToWindow_Params params {};
		params.Destructible = Destructible;
		params.DamageOrigin = DamageOrigin;
		params.DamageRadius = DamageRadius;
		params.ImpulseStrength = ImpulseStrength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DestructibleVehicle.FlashHeadLights
	 * 		Flags  -> ()
	 */
	void ADestructibleVehicle::FlashHeadLights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DestructibleVehicle.FlashHeadLights");
		
		ADestructibleVehicle_FlashHeadLights_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADestructibleVehicle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADestructibleVehicle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DestructibleVehicle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Detonator.Tick
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADetonator::Tick(float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Detonator.Tick");
		
		ADetonator_Tick_Params params {};
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Detonator.Server_DetonateC2
	 * 		Flags  -> ()
	 */
	void ADetonator::Server_DetonateC2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Detonator.Server_DetonateC2");
		
		ADetonator_Server_DetonateC2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADetonator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADetonator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Detonator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDisarmC2Activity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDisarmC2Activity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DisarmC2Activity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DisarmDoorTrapActivity.OnTrapTriggered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ATrapActor*                                  Trap                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        TriggeredBy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDisarmDoorTrapActivity::OnTrapTriggered(class ATrapActor* Trap, class AReadyOrNotCharacter* TriggeredBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DisarmDoorTrapActivity.OnTrapTriggered");
		
		UDisarmDoorTrapActivity_OnTrapTriggered_Params params {};
		params.Trap = Trap;
		params.TriggeredBy = TriggeredBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDisarmDoorTrapActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDisarmDoorTrapActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DisarmDoorTrapActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DisarmStandaloneTrapActivity.OnTrapTriggered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ATrapActor*                                  Trap                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        TriggeredBy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDisarmStandaloneTrapActivity::OnTrapTriggered(class ATrapActor* Trap, class AReadyOrNotCharacter* TriggeredBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DisarmStandaloneTrapActivity.OnTrapTriggered");
		
		UDisarmStandaloneTrapActivity_OnTrapTriggered_Params params {};
		params.Trap = Trap;
		params.TriggeredBy = TriggeredBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DisarmStandaloneTrapActivity.OnTrapDisarmed
	 * 		Flags  -> ()
	 */
	void UDisarmStandaloneTrapActivity::OnTrapDisarmed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DisarmStandaloneTrapActivity.OnTrapDisarmed");
		
		UDisarmStandaloneTrapActivity_OnTrapDisarmed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DisarmStandaloneTrapActivity.EnterGetInPositionStage
	 * 		Flags  -> ()
	 */
	void UDisarmStandaloneTrapActivity::EnterGetInPositionStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DisarmStandaloneTrapActivity.EnterGetInPositionStage");
		
		UDisarmStandaloneTrapActivity_EnterGetInPositionStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DisarmStandaloneTrapActivity.EnterDisarmStage
	 * 		Flags  -> ()
	 */
	void UDisarmStandaloneTrapActivity::EnterDisarmStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DisarmStandaloneTrapActivity.EnterDisarmStage");
		
		UDisarmStandaloneTrapActivity_EnterDisarmStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DisarmStandaloneTrapActivity.CanPerformDisarm
	 * 		Flags  -> ()
	 */
	bool UDisarmStandaloneTrapActivity::CanPerformDisarm()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DisarmStandaloneTrapActivity.CanPerformDisarm");
		
		UDisarmStandaloneTrapActivity_CanPerformDisarm_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDisarmStandaloneTrapActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDisarmStandaloneTrapActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DisarmStandaloneTrapActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADontDie.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADontDie::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DontDie");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.IsPointInFrontOfDoorway
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Vector                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoorwayWithoutDoor::IsPointInFrontOfDoorway(const struct FCoreUObject_FVector& Vector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.IsPointInFrontOfDoorway");
		
		ADoorwayWithoutDoor_IsPointInFrontOfDoorway_Params params {};
		params.Vector = Vector;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetFrontStackupPoints
	 * 		Flags  -> ()
	 */
	TArray<class UDoorPointComponent*> ADoorwayWithoutDoor::GetFrontStackupPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetFrontStackupPoints");
		
		ADoorwayWithoutDoor_GetFrontStackupPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetFrontPIEMidLocation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector ADoorwayWithoutDoor::GetFrontPIEMidLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetFrontPIEMidLocation");
		
		ADoorwayWithoutDoor_GetFrontPIEMidLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetFrontPIEEndLocation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector ADoorwayWithoutDoor::GetFrontPIEEndLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetFrontPIEEndLocation");
		
		ADoorwayWithoutDoor_GetFrontPIEEndLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetFrontMidpoint
	 * 		Flags  -> ()
	 */
	class UDoorPointComponent* ADoorwayWithoutDoor::GetFrontMidpoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetFrontMidpoint");
		
		ADoorwayWithoutDoor_GetFrontMidpoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetFrontGrenadeThrowPoint
	 * 		Flags  -> ()
	 */
	class UDoorPointComponent* ADoorwayWithoutDoor::GetFrontGrenadeThrowPoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetFrontGrenadeThrowPoint");
		
		ADoorwayWithoutDoor_GetFrontGrenadeThrowPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetFrontGrenadeLaunchPoint
	 * 		Flags  -> ()
	 */
	class UDoorPointComponent* ADoorwayWithoutDoor::GetFrontGrenadeLaunchPoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetFrontGrenadeLaunchPoint");
		
		ADoorwayWithoutDoor_GetFrontGrenadeLaunchPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetFrontDoorInteractionPoint
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector ADoorwayWithoutDoor::GetFrontDoorInteractionPoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetFrontDoorInteractionPoint");
		
		ADoorwayWithoutDoor_GetFrontDoorInteractionPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetFrontClearPoints
	 * 		Flags  -> ()
	 */
	TArray<class UDoorPointComponent*> ADoorwayWithoutDoor::GetFrontClearPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetFrontClearPoints");
		
		ADoorwayWithoutDoor_GetFrontClearPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetBackStackupPoints
	 * 		Flags  -> ()
	 */
	TArray<class UDoorPointComponent*> ADoorwayWithoutDoor::GetBackStackupPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetBackStackupPoints");
		
		ADoorwayWithoutDoor_GetBackStackupPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetBackPIEMidLocation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector ADoorwayWithoutDoor::GetBackPIEMidLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetBackPIEMidLocation");
		
		ADoorwayWithoutDoor_GetBackPIEMidLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetBackPIEEndLocation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector ADoorwayWithoutDoor::GetBackPIEEndLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetBackPIEEndLocation");
		
		ADoorwayWithoutDoor_GetBackPIEEndLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetBackMidpoint
	 * 		Flags  -> ()
	 */
	class UDoorPointComponent* ADoorwayWithoutDoor::GetBackMidpoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetBackMidpoint");
		
		ADoorwayWithoutDoor_GetBackMidpoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetBackGrenadeThrowPoint
	 * 		Flags  -> ()
	 */
	class UDoorPointComponent* ADoorwayWithoutDoor::GetBackGrenadeThrowPoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetBackGrenadeThrowPoint");
		
		ADoorwayWithoutDoor_GetBackGrenadeThrowPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetBackGrenadeLaunchPoint
	 * 		Flags  -> ()
	 */
	class UDoorPointComponent* ADoorwayWithoutDoor::GetBackGrenadeLaunchPoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetBackGrenadeLaunchPoint");
		
		ADoorwayWithoutDoor_GetBackGrenadeLaunchPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetBackDoorInteractionPoint
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector ADoorwayWithoutDoor::GetBackDoorInteractionPoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetBackDoorInteractionPoint");
		
		ADoorwayWithoutDoor_GetBackDoorInteractionPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.GetBackClearPoints
	 * 		Flags  -> ()
	 */
	TArray<class UDoorPointComponent*> ADoorwayWithoutDoor::GetBackClearPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.GetBackClearPoints");
		
		ADoorwayWithoutDoor_GetBackClearPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorwayWithoutDoor.CanIssueMoveAndClear
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  TraceHit                                                   (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool ADoorwayWithoutDoor::CanIssueMoveAndClear(const struct FHitResult& TraceHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorwayWithoutDoor.CanIssueMoveAndClear");
		
		ADoorwayWithoutDoor_CanIssueMoveAndClear_Params params {};
		params.TraceHit = TraceHit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADoorwayWithoutDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADoorwayWithoutDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DoorwayWithoutDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.UpdateDoorTickRate
	 * 		Flags  -> ()
	 */
	void ADoor::UpdateDoorTickRate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.UpdateDoorTickRate");
		
		ADoor_UpdateDoorTickRate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.UnlockDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bUnlockSubDoor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::UnlockDoor(bool bUnlockSubDoor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.UnlockDoor");
		
		ADoor_UnlockDoor_Params params {};
		params.bUnlockSubDoor = bUnlockSubDoor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.TryPlayAISuspectResponseToDoorBroken
	 * 		Flags  -> ()
	 */
	void ADoor::TryPlayAISuspectResponseToDoorBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.TryPlayAISuspectResponseToDoorBroken");
		
		ADoor_TryPlayAISuspectResponseToDoorBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.ToggleLightBlocker
	 * 		Flags  -> ()
	 */
	void ADoor::ToggleLightBlocker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.ToggleLightBlocker");
		
		ADoor_ToggleLightBlocker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Tick_DoorRam
	 * 		Flags  -> ()
	 */
	void ADoor::Tick_DoorRam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Tick_DoorRam");
		
		ADoor_Tick_DoorRam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Tick_DoorPush
	 * 		Flags  -> ()
	 */
	void ADoor::Tick_DoorPush()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Tick_DoorPush");
		
		ADoor_Tick_DoorPush_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Tick_DoorOpenClose
	 * 		Flags  -> ()
	 */
	void ADoor::Tick_DoorOpenClose()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Tick_DoorOpenClose");
		
		ADoor_Tick_DoorOpenClose_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Tick_DoorLocked
	 * 		Flags  -> ()
	 */
	void ADoor::Tick_DoorLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Tick_DoorLocked");
		
		ADoor_Tick_DoorLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Tick_DoorKick_Success
	 * 		Flags  -> ()
	 */
	void ADoor::Tick_DoorKick_Success()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Tick_DoorKick_Success");
		
		ADoor_Tick_DoorKick_Success_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Tick_DoorKick_Fail
	 * 		Flags  -> ()
	 */
	void ADoor::Tick_DoorKick_Fail()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Tick_DoorKick_Fail");
		
		ADoor_Tick_DoorKick_Fail_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Tick_DoorHandleLocked
	 * 		Flags  -> ()
	 */
	void ADoor::Tick_DoorHandleLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Tick_DoorHandleLocked");
		
		ADoor_Tick_DoorHandleLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Tick_DoorHandle_Push
	 * 		Flags  -> ()
	 */
	void ADoor::Tick_DoorHandle_Push()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Tick_DoorHandle_Push");
		
		ADoor_Tick_DoorHandle_Push_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Tick_DoorHandle_Open
	 * 		Flags  -> ()
	 */
	void ADoor::Tick_DoorHandle_Open()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Tick_DoorHandle_Open");
		
		ADoor_Tick_DoorHandle_Open_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Tick_DoorExplode
	 * 		Flags  -> ()
	 */
	void ADoor::Tick_DoorExplode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Tick_DoorExplode");
		
		ADoor_Tick_DoorExplode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Tick_DoorBreach
	 * 		Flags  -> ()
	 */
	void ADoor::Tick_DoorBreach()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Tick_DoorBreach");
		
		ADoor_Tick_DoorBreach_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.TeamKnowsDoorTrapState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuspectTeam                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::TeamKnowsDoorTrapState(bool bSuspectTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.TeamKnowsDoorTrapState");
		
		ADoor_TeamKnowsDoorTrapState_Params params {};
		params.bSuspectTeam = bSuspectTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.TeamKnowsDoorLockState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuspectTeam                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::TeamKnowsDoorLockState(bool bSuspectTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.TeamKnowsDoorLockState");
		
		ADoor_TeamKnowsDoorLockState_Params params {};
		params.bSuspectTeam = bSuspectTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.SubDoor_CanOpenDoors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::SubDoor_CanOpenDoors(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.SubDoor_CanOpenDoors");
		
		ADoor_SubDoor_CanOpenDoors_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.SubDoor_CanCloseDoors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::SubDoor_CanCloseDoors(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.SubDoor_CanCloseDoors");
		
		ADoor_SubDoor_CanCloseDoors_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.SpawnDoorBlocker
	 * 		Flags  -> ()
	 */
	void ADoor::SpawnDoorBlocker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.SpawnDoorBlocker");
		
		ADoor_SpawnDoorBlocker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.SkippedBreachAction
	 * 		Flags  -> ()
	 */
	void ADoor::SkippedBreachAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.SkippedBreachAction");
		
		ADoor_SkippedBreachAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.SetupTrap
	 * 		Flags  -> ()
	 */
	void ADoor::SetupTrap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.SetupTrap");
		
		ADoor_SetupTrap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Setup
	 * 		Flags  -> ()
	 */
	void ADoor::Setup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Setup");
		
		ADoor_Setup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.SetSWATHasAllKeycards
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::SetSWATHasAllKeycards(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.SetSWATHasAllKeycards");
		
		ADoor_SetSWATHasAllKeycards_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.SetLocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewLocked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::SetLocked(bool bNewLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.SetLocked");
		
		ADoor_SetLocked_Params params {};
		params.bNewLocked = bNewLocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.SetDoorTrapKnowledge
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuspectTeam                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bKnowledge                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::SetDoorTrapKnowledge(bool bSuspectTeam, bool bKnowledge)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.SetDoorTrapKnowledge");
		
		ADoor_SetDoorTrapKnowledge_Params params {};
		params.bSuspectTeam = bSuspectTeam;
		params.bKnowledge = bKnowledge;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.SetDoorLockKnowledge
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuspectTeam                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bKnowledge                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::SetDoorLockKnowledge(bool bSuspectTeam, bool bKnowledge)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.SetDoorLockKnowledge");
		
		ADoor_SetDoorLockKnowledge_Params params {};
		params.bSuspectTeam = bSuspectTeam;
		params.bKnowledge = bKnowledge;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.SetAllElectronicLocks
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Blocked                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::SetAllElectronicLocks(class UObject* WorldContextObject, bool Blocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.SetAllElectronicLocks");
		
		ADoor_SetAllElectronicLocks_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Blocked = Blocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Server_SetTrapKnowledgeState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuspectTeam                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNewKnowledgeState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::Server_SetTrapKnowledgeState(bool bSuspectTeam, bool bNewKnowledgeState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Server_SetTrapKnowledgeState");
		
		ADoor_Server_SetTrapKnowledgeState_Params params {};
		params.bSuspectTeam = bSuspectTeam;
		params.bNewKnowledgeState = bNewKnowledgeState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Server_SetLockKnowledgeState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuspectTeam                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNewKnowledgeState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::Server_SetLockKnowledgeState(bool bSuspectTeam, bool bNewKnowledgeState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Server_SetLockKnowledgeState");
		
		ADoor_Server_SetLockKnowledgeState_Params params {};
		params.bSuspectTeam = bSuspectTeam;
		params.bNewKnowledgeState = bNewKnowledgeState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Restore
	 * 		Flags  -> ()
	 */
	void ADoor::Restore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Restore");
		
		ADoor_Restore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.ResetDoorTrapKnowledge
	 * 		Flags  -> ()
	 */
	void ADoor::ResetDoorTrapKnowledge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.ResetDoorTrapKnowledge");
		
		ADoor_ResetDoorTrapKnowledge_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.ResetDoorLockKnowledge
	 * 		Flags  -> ()
	 */
	void ADoor::ResetDoorLockKnowledge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.ResetDoorLockKnowledge");
		
		ADoor_ResetDoorLockKnowledge_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.RemoveWedges
	 * 		Flags  -> ()
	 */
	void ADoor::RemoveWedges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.RemoveWedges");
		
		ADoor_RemoveWedges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.RemoveDoorBlocker
	 * 		Flags  -> ()
	 */
	void ADoor::RemoveDoorBlocker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.RemoveDoorBlocker");
		
		ADoor_RemoveDoorBlocker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.RamDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorRamCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ADoor::RamDoor(class AReadyOrNotCharacter* DoorRamCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.RamDoor");
		
		ADoor_RamDoor_Params params {};
		params.DoorRamCharacter = DoorRamCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.PushDoor_SpecificAngle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorPusherCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CustomTargetAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimateDoorHandle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::PushDoor_SpecificAngle(class AReadyOrNotCharacter* DoorPusherCharacter, float CustomTargetAngle, bool bAnimateDoorHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.PushDoor_SpecificAngle");
		
		ADoor_PushDoor_SpecificAngle_Params params {};
		params.DoorPusherCharacter = DoorPusherCharacter;
		params.CustomTargetAngle = CustomTargetAngle;
		params.bAnimateDoorHandle = bAnimateDoorHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.PushDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorPusherCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InIncrementAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimateDoorHandle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlaySound                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ADoor::PushDoor(class AReadyOrNotCharacter* DoorPusherCharacter, float InIncrementAngle, bool bAnimateDoorHandle, bool bPlaySound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.PushDoor");
		
		ADoor_PushDoor_Params params {};
		params.DoorPusherCharacter = DoorPusherCharacter;
		params.InIncrementAngle = InIncrementAngle;
		params.bAnimateDoorHandle = bAnimateDoorHandle;
		params.bPlaySound = bPlaySound;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.PlayDoorSound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDoorInteraction                                   DoorInteraction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DoorInteractionInstigator                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FMODParam>                           Params                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADoor::PlayDoorSound(EDoorInteraction DoorInteraction, class AReadyOrNotCharacter* DoorInteractionInstigator, TArray<struct FMODParam> Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.PlayDoorSound");
		
		ADoor_PlayDoorSound_Params params {};
		params.DoorInteraction = DoorInteraction;
		params.DoorInteractionInstigator = DoorInteractionInstigator;
		params.Params = Params;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.PlayDoorKickSound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Kicker                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::PlayDoorKickSound(class AReadyOrNotCharacter* Kicker, float Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.PlayDoorKickSound");
		
		ADoor_PlayDoorKickSound_Params params {};
		params.Kicker = Kicker;
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.PlayDoorDamageSound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDoorDamageType                                    DoorDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FMODParam>                           Params                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADoor::PlayDoorDamageSound(EDoorDamageType DoorDamage, TArray<struct FMODParam> Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.PlayDoorDamageSound");
		
		ADoor_PlayDoorDamageSound_Params params {};
		params.DoorDamage = DoorDamage;
		params.Params = Params;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.PeekDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorPeekerCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InIncrementAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimateDoorHandle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ADoor::PeekDoor(class AReadyOrNotCharacter* DoorPeekerCharacter, float InIncrementAngle, bool bAnimateDoorHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.PeekDoor");
		
		ADoor_PeekDoor_Params params {};
		params.DoorPeekerCharacter = DoorPeekerCharacter;
		params.InIncrementAngle = InIncrementAngle;
		params.bAnimateDoorHandle = bAnimateDoorHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.OpenSubDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorOpenCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimateDoorHandle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::OpenSubDoor(class AReadyOrNotCharacter* DoorOpenCharacter, bool bInstant, bool bAnimateDoorHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.OpenSubDoor");
		
		ADoor_OpenSubDoor_Params params {};
		params.DoorOpenCharacter = DoorOpenCharacter;
		params.bInstant = bInstant;
		params.bAnimateDoorHandle = bAnimateDoorHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.OpenDoor_SpecificAngle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorOpenCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CustomTargetAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimateDoorHandle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::OpenDoor_SpecificAngle(class AReadyOrNotCharacter* DoorOpenCharacter, float CustomTargetAngle, bool bInstant, bool bAnimateDoorHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.OpenDoor_SpecificAngle");
		
		ADoor_OpenDoor_SpecificAngle_Params params {};
		params.DoorOpenCharacter = DoorOpenCharacter;
		params.CustomTargetAngle = CustomTargetAngle;
		params.bInstant = bInstant;
		params.bAnimateDoorHandle = bAnimateDoorHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.OpenDoor_Debug
	 * 		Flags  -> ()
	 */
	void ADoor::OpenDoor_Debug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.OpenDoor_Debug");
		
		ADoor_OpenDoor_Debug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.OpenDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorOpenCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimateDoorHandle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNoCloseThreshold                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ADoor::OpenDoor(class AReadyOrNotCharacter* DoorOpenCharacter, bool bInstant, bool bAnimateDoorHandle, bool bNoCloseThreshold)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.OpenDoor");
		
		ADoor_OpenDoor_Params params {};
		params.DoorOpenCharacter = DoorOpenCharacter;
		params.bInstant = bInstant;
		params.bAnimateDoorHandle = bAnimateDoorHandle;
		params.bNoCloseThreshold = bNoCloseThreshold;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.OnRep_TrapDataUpdated
	 * 		Flags  -> ()
	 */
	void ADoor::OnRep_TrapDataUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.OnRep_TrapDataUpdated");
		
		ADoor_OnRep_TrapDataUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.OnRep_DoorHandlesBroken
	 * 		Flags  -> ()
	 */
	void ADoor::OnRep_DoorHandlesBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.OnRep_DoorHandlesBroken");
		
		ADoor_OnRep_DoorHandlesBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.OnRep_DoorDataUpdated
	 * 		Flags  -> ()
	 */
	void ADoor::OnRep_DoorDataUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.OnRep_DoorDataUpdated");
		
		ADoor_OnRep_DoorDataUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.OnRep_DestroyedChunkIdxChanged
	 * 		Flags  -> ()
	 */
	void ADoor::OnRep_DestroyedChunkIdxChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.OnRep_DestroyedChunkIdxChanged");
		
		ADoor_OnRep_DestroyedChunkIdxChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.OnRep_ClientResetDoor
	 * 		Flags  -> ()
	 */
	void ADoor::OnRep_ClientResetDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.OnRep_ClientResetDoor");
		
		ADoor_OnRep_ClientResetDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.Door.OnDoorOpened__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ADoor::OnDoorOpened__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.Door.OnDoorOpened__DelegateSignature");
		
		ADoor_OnDoorOpened__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.Door.OnDoorKick__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::OnDoorKick__DelegateSignature(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter, bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.Door.OnDoorKick__DelegateSignature");
		
		ADoor_OnDoorKick__DelegateSignature_Params params {};
		params.Door = Door;
		params.InstigatorCharacter = InstigatorCharacter;
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.Door.OnDoorExplode__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::OnDoorExplode__DelegateSignature(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.Door.OnDoorExplode__DelegateSignature");
		
		ADoor_OnDoorExplode__DelegateSignature_Params params {};
		params.Door = Door;
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.Door.OnDoorClosed__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ADoor::OnDoorClosed__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.Door.OnDoorClosed__DelegateSignature");
		
		ADoor_OnDoorClosed__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.Door.OnDoorBroken__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ADoor::OnDoorBroken__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.Door.OnDoorBroken__DelegateSignature");
		
		ADoor_OnDoorBroken__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.NonMainSubDoor_CanShowOpenDoorPrompt
	 * 		Flags  -> ()
	 */
	bool ADoor::NonMainSubDoor_CanShowOpenDoorPrompt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.NonMainSubDoor_CanShowOpenDoorPrompt");
		
		ADoor_NonMainSubDoor_CanShowOpenDoorPrompt_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Multicast_SetLocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldLocked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::Multicast_SetLocked(bool bShouldLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Multicast_SetLocked");
		
		ADoor_Multicast_SetLocked_Params params {};
		params.bShouldLocked = bShouldLocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Multicast_PlayElectronicDoorSound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFMODEvent*                                  Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::Multicast_PlayElectronicDoorSound(class UFMODEvent* Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Multicast_PlayElectronicDoorSound");
		
		ADoor_Multicast_PlayElectronicDoorSound_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Multicast_PlayDoorSound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDoorInteraction                                   DoorDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DoorInteractionInstigator                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FMODParam>                           Params                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADoor::Multicast_PlayDoorSound(EDoorInteraction DoorDamage, class AReadyOrNotCharacter* DoorInteractionInstigator, TArray<struct FMODParam> Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Multicast_PlayDoorSound");
		
		ADoor_Multicast_PlayDoorSound_Params params {};
		params.DoorDamage = DoorDamage;
		params.DoorInteractionInstigator = DoorInteractionInstigator;
		params.Params = Params;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Multicast_PlayDoorDamageSound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDoorDamageType                                    DoorDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FMODParam>                           Params                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADoor::Multicast_PlayDoorDamageSound(EDoorDamageType DoorDamage, TArray<struct FMODParam> Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Multicast_PlayDoorDamageSound");
		
		ADoor_Multicast_PlayDoorDamageSound_Params params {};
		params.DoorDamage = DoorDamage;
		params.Params = Params;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Multicast_ExplodeDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorBreacherCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ExplosionCauser                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bKeepHinges                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::Multicast_ExplodeDoor(class AReadyOrNotCharacter* DoorBreacherCharacter, class AActor* ExplosionCauser, bool bKeepHinges)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Multicast_ExplodeDoor");
		
		ADoor_Multicast_ExplodeDoor_Params params {};
		params.DoorBreacherCharacter = DoorBreacherCharacter;
		params.ExplosionCauser = ExplosionCauser;
		params.bKeepHinges = bKeepHinges;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Multicast_CheckSupports
	 * 		Flags  -> ()
	 */
	void ADoor::Multicast_CheckSupports()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Multicast_CheckSupports");
		
		ADoor_Multicast_CheckSupports_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.MainSubDoor_CanShowOpenDoorPrompt
	 * 		Flags  -> ()
	 */
	bool ADoor::MainSubDoor_CanShowOpenDoorPrompt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.MainSubDoor_CanShowOpenDoorPrompt");
		
		ADoor_MainSubDoor_CanShowOpenDoorPrompt_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.LockDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bLockSubDoor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::LockDoor(bool bLockSubDoor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.LockDoor");
		
		ADoor_LockDoor_Params params {};
		params.bLockSubDoor = bLockSubDoor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.KickSubDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorKickCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::KickSubDoor(class AReadyOrNotCharacter* DoorKickCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.KickSubDoor");
		
		ADoor_KickSubDoor_Params params {};
		params.DoorKickCharacter = DoorKickCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.KickDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorKickCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bKickSubDoor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::KickDoor(class AReadyOrNotCharacter* DoorKickCharacter, bool bKickSubDoor, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.KickDoor");
		
		ADoor_KickDoor_Params params {};
		params.DoorKickCharacter = DoorKickCharacter;
		params.bKickSubDoor = bKickSubDoor;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsTrapLive
	 * 		Flags  -> ()
	 */
	bool ADoor::IsTrapLive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsTrapLive");
		
		ADoor_IsTrapLive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsTooFarForKick
	 * 		Flags  -> ()
	 */
	bool ADoor::IsTooFarForKick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsTooFarForKick");
		
		ADoor_IsTooFarForKick_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsSubDoorOpen
	 * 		Flags  -> ()
	 */
	bool ADoor::IsSubDoorOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsSubDoorOpen");
		
		ADoor_IsSubDoorOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsStackUpDisabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsStackUpDisabled(const struct FCoreUObject_FVector& CommandLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsStackUpDisabled");
		
		ADoor_IsStackUpDisabled_Params params {};
		params.CommandLocation = CommandLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsPointRightOfDoorway
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Vector                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsPointRightOfDoorway(const struct FCoreUObject_FVector& Vector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsPointRightOfDoorway");
		
		ADoor_IsPointRightOfDoorway_Params params {};
		params.Vector = Vector;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsPointInFrontOfDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Vector                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsPointInFrontOfDoor(const struct FCoreUObject_FVector& Vector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsPointInFrontOfDoor");
		
		ADoor_IsPointInFrontOfDoor_Params params {};
		params.Vector = Vector;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsPendingSubDoorKick
	 * 		Flags  -> ()
	 */
	bool ADoor::IsPendingSubDoorKick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsPendingSubDoorKick");
		
		ADoor_IsPendingSubDoorKick_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOutlineEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActorOutlineType                                  OutlineType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsOutlineEnabled(EActorOutlineType OutlineType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOutlineEnabled");
		
		ADoor_IsOutlineEnabled_Params params {};
		params.OutlineType = OutlineType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOutlineDisabled
	 * 		Flags  -> ()
	 */
	bool ADoor::IsOutlineDisabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOutlineDisabled");
		
		ADoor_IsOutlineDisabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOpening
	 * 		Flags  -> ()
	 */
	bool ADoor::IsOpening()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOpening");
		
		ADoor_IsOpening_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOpenBy_Angle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsOpenBy_Angle(float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOpenBy_Angle");
		
		ADoor_IsOpenBy_Angle_Params params {};
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOpenBy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Percentage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsOpenBy(float Percentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOpenBy");
		
		ADoor_IsOpenBy_Params params {};
		params.Percentage = Percentage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOpenBeyondIncrementThreshold
	 * 		Flags  -> ()
	 */
	bool ADoor::IsOpenBeyondIncrementThreshold()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOpenBeyondIncrementThreshold");
		
		ADoor_IsOpenBeyondIncrementThreshold_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOpenBeyondCloseThreshold
	 * 		Flags  -> ()
	 */
	bool ADoor::IsOpenBeyondCloseThreshold()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOpenBeyondCloseThreshold");
		
		ADoor_IsOpenBeyondCloseThreshold_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOpenBeyond_Angle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsOpenBeyond_Angle(float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOpenBeyond_Angle");
		
		ADoor_IsOpenBeyond_Angle_Params params {};
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOpenBeyond
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Percentage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsOpenBeyond(float Percentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOpenBeyond");
		
		ADoor_IsOpenBeyond_Params params {};
		params.Percentage = Percentage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOpenAtOrBeyond_Angle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsOpenAtOrBeyond_Angle(float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOpenAtOrBeyond_Angle");
		
		ADoor_IsOpenAtOrBeyond_Angle_Params params {};
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOpenAtOrBeyond
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Percentage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsOpenAtOrBeyond(float Percentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOpenAtOrBeyond");
		
		ADoor_IsOpenAtOrBeyond_Params params {};
		params.Percentage = Percentage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOpen_Forward
	 * 		Flags  -> ()
	 */
	bool ADoor::IsOpen_Forward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOpen_Forward");
		
		ADoor_IsOpen_Forward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOpen_Backward
	 * 		Flags  -> ()
	 */
	bool ADoor::IsOpen_Backward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOpen_Backward");
		
		ADoor_IsOpen_Backward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsOpen
	 * 		Flags  -> ()
	 */
	bool ADoor::IsOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsOpen");
		
		ADoor_IsOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsNonMainSubdoor
	 * 		Flags  -> ()
	 */
	bool ADoor::IsNonMainSubdoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsNonMainSubdoor");
		
		ADoor_IsNonMainSubdoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsNonDoorInteractionPlaying
	 * 		Flags  -> ()
	 */
	bool ADoor::IsNonDoorInteractionPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsNonDoorInteractionPlaying");
		
		ADoor_IsNonDoorInteractionPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsMirrorBlocked
	 * 		Flags  -> ()
	 */
	bool ADoor::IsMirrorBlocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsMirrorBlocked");
		
		ADoor_IsMirrorBlocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsMiddleChunkBroken
	 * 		Flags  -> ()
	 */
	bool ADoor::IsMiddleChunkBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsMiddleChunkBroken");
		
		ADoor_IsMiddleChunkBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsMainSubdoor
	 * 		Flags  -> ()
	 */
	bool ADoor::IsMainSubdoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsMainSubdoor");
		
		ADoor_IsMainSubdoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsLocked
	 * 		Flags  -> ()
	 */
	bool ADoor::IsLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsLocked");
		
		ADoor_IsLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsLockChanceOverriden
	 * 		Flags  -> ()
	 */
	bool ADoor::IsLockChanceOverriden()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsLockChanceOverriden");
		
		ADoor_IsLockChanceOverriden_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsLockable
	 * 		Flags  -> ()
	 */
	bool ADoor::IsLockable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsLockable");
		
		ADoor_IsLockable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsLocationSameSideAsTrap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        InLocation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsLocationSameSideAsTrap(const struct FCoreUObject_FVector& InLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsLocationSameSideAsTrap");
		
		ADoor_IsLocationSameSideAsTrap_Params params {};
		params.InLocation = InLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsJammed
	 * 		Flags  -> ()
	 */
	bool ADoor::IsJammed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsJammed");
		
		ADoor_IsJammed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsIgnoredForFlee
	 * 		Flags  -> ()
	 */
	bool ADoor::IsIgnoredForFlee()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsIgnoredForFlee");
		
		ADoor_IsIgnoredForFlee_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsHalfwayOpen
	 * 		Flags  -> ()
	 */
	bool ADoor::IsHalfwayOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsHalfwayOpen");
		
		ADoor_IsHalfwayOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsFullyOpen_Forward
	 * 		Flags  -> ()
	 */
	bool ADoor::IsFullyOpen_Forward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsFullyOpen_Forward");
		
		ADoor_IsFullyOpen_Forward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsFullyOpen_Backward
	 * 		Flags  -> ()
	 */
	bool ADoor::IsFullyOpen_Backward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsFullyOpen_Backward");
		
		ADoor_IsFullyOpen_Backward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsFullyOpen
	 * 		Flags  -> ()
	 */
	bool ADoor::IsFullyOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsFullyOpen");
		
		ADoor_IsFullyOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsElectronicDoor
	 * 		Flags  -> ()
	 */
	bool ADoor::IsElectronicDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsElectronicDoor");
		
		ADoor_IsElectronicDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsDoorwayOnly
	 * 		Flags  -> ()
	 */
	bool ADoor::IsDoorwayOnly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsDoorwayOnly");
		
		ADoor_IsDoorwayOnly_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsDoorInteractionPlaying
	 * 		Flags  -> ()
	 */
	bool ADoor::IsDoorInteractionPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsDoorInteractionPlaying");
		
		ADoor_IsDoorInteractionPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsDoorChunkDestroyed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UDestructibleDoorChunkComponent*             InChunkComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsDoorChunkDestroyed(class UDestructibleDoorChunkComponent* InChunkComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsDoorChunkDestroyed");
		
		ADoor_IsDoorChunkDestroyed_Params params {};
		params.InChunkComponent = InChunkComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsDoorBroken
	 * 		Flags  -> ()
	 */
	bool ADoor::IsDoorBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsDoorBroken");
		
		ADoor_IsDoorBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsDestructible
	 * 		Flags  -> ()
	 */
	bool ADoor::IsDestructible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsDestructible");
		
		ADoor_IsDestructible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsClosing
	 * 		Flags  -> ()
	 */
	bool ADoor::IsClosing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsClosing");
		
		ADoor_IsClosing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsClosed
	 * 		Flags  -> ()
	 */
	bool ADoor::IsClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsClosed");
		
		ADoor_IsClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsC2Placed
	 * 		Flags  -> ()
	 */
	bool ADoor::IsC2Placed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsC2Placed");
		
		ADoor_IsC2Placed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsAttachedToRoot
	 * 		Flags  -> ()
	 */
	bool ADoor::IsAttachedToRoot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsAttachedToRoot");
		
		ADoor_IsAttachedToRoot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsAnyInteractionPlaying
	 * 		Flags  -> ()
	 */
	bool ADoor::IsAnyInteractionPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsAnyInteractionPlaying");
		
		ADoor_IsAnyInteractionPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsAnyAIOpening
	 * 		Flags  -> ()
	 */
	bool ADoor::IsAnyAIOpening()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsAnyAIOpening");
		
		ADoor_IsAnyAIOpening_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsAnyAIClosing
	 * 		Flags  -> ()
	 */
	bool ADoor::IsAnyAIClosing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsAnyAIClosing");
		
		ADoor_IsAnyAIClosing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsActorSameSideAsTrap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsActorSameSideAsTrap(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsActorSameSideAsTrap");
		
		ADoor_IsActorSameSideAsTrap_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsActorRightOfDoorway
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsActorRightOfDoorway(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsActorRightOfDoorway");
		
		ADoor_IsActorRightOfDoorway_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsActorInFrontOfDoorway
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsActorInFrontOfDoorway(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsActorInFrontOfDoorway");
		
		ADoor_IsActorInFrontOfDoorway_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsActorInFrontOfDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsActorInFrontOfDoor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsActorInFrontOfDoor");
		
		ADoor_IsActorInFrontOfDoor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.IsActorBehindDoor_Relative
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::IsActorBehindDoor_Relative(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.IsActorBehindDoor_Relative");
		
		ADoor_IsActorBehindDoor_Relative_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.HasTrapAndSWATKnowsTrap
	 * 		Flags  -> ()
	 */
	bool ADoor::HasTrapAndSWATKnowsTrap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.HasTrapAndSWATKnowsTrap");
		
		ADoor_HasTrapAndSWATKnowsTrap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.HasTrapAndSuspectKnowsTrap
	 * 		Flags  -> ()
	 */
	bool ADoor::HasTrapAndSuspectKnowsTrap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.HasTrapAndSuspectKnowsTrap");
		
		ADoor_HasTrapAndSuspectKnowsTrap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.HasEverBeenOpened
	 * 		Flags  -> ()
	 */
	bool ADoor::HasEverBeenOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.HasEverBeenOpened");
		
		ADoor_HasEverBeenOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetWedgeLocation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector ADoor::GetWedgeLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetWedgeLocation");
		
		ADoor_GetWedgeLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetTypeOfDoorTrap
	 * 		Flags  -> ()
	 */
	class FName ADoor::GetTypeOfDoorTrap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetTypeOfDoorTrap");
		
		ADoor_GetTypeOfDoorTrap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetTypeOfDoorRow
	 * 		Flags  -> ()
	 */
	class FName ADoor::GetTypeOfDoorRow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetTypeOfDoorRow");
		
		ADoor_GetTypeOfDoorRow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetTargetAngle
	 * 		Flags  -> ()
	 */
	float ADoor::GetTargetAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetTargetAngle");
		
		ADoor_GetTargetAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetSWATKnowsLockState
	 * 		Flags  -> ()
	 */
	bool ADoor::GetSWATKnowsLockState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetSWATKnowsLockState");
		
		ADoor_GetSWATKnowsLockState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetSuspectKnowsLockState
	 * 		Flags  -> ()
	 */
	bool ADoor::GetSuspectKnowsLockState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetSuspectKnowsLockState");
		
		ADoor_GetSuspectKnowsLockState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetSubDoor
	 * 		Flags  -> ()
	 */
	class ADoor* ADoor::GetSubDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetSubDoor");
		
		ADoor_GetSubDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetStartingOpenAngle
	 * 		Flags  -> ()
	 */
	float ADoor::GetStartingOpenAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetStartingOpenAngle");
		
		ADoor_GetStartingOpenAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetStackupsForArea
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStackupGenArea                                    StackupArea                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class AStackUpActor*> ADoor::GetStackupsForArea(EStackupGenArea StackupArea)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetStackupsForArea");
		
		ADoor_GetStackupsForArea_Params params {};
		params.StackupArea = StackupArea;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetPseudoVelocity
	 * 		Flags  -> ()
	 */
	float ADoor::GetPseudoVelocity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetPseudoVelocity");
		
		ADoor_GetPseudoVelocity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetPlacedC2
	 * 		Flags  -> ()
	 */
	class APlacedC2Explosive* ADoor::GetPlacedC2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetPlacedC2");
		
		ADoor_GetPlacedC2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetOpenThreshold
	 * 		Flags  -> ()
	 */
	float ADoor::GetOpenThreshold()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetOpenThreshold");
		
		ADoor_GetOpenThreshold_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetOpenAmountAsPercentage
	 * 		Flags  -> ()
	 */
	float ADoor::GetOpenAmountAsPercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetOpenAmountAsPercentage");
		
		ADoor_GetOpenAmountAsPercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetOpenAmount
	 * 		Flags  -> ()
	 */
	float ADoor::GetOpenAmount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetOpenAmount");
		
		ADoor_GetOpenAmount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetMaxOpenAmount
	 * 		Flags  -> ()
	 */
	float ADoor::GetMaxOpenAmount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetMaxOpenAmount");
		
		ADoor_GetMaxOpenAmount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetLastDoorUser
	 * 		Flags  -> ()
	 */
	class AReadyOrNotCharacter* ADoor::GetLastDoorUser()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetLastDoorUser");
		
		ADoor_GetLastDoorUser_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetIncrementAngle
	 * 		Flags  -> ()
	 */
	float ADoor::GetIncrementAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetIncrementAngle");
		
		ADoor_GetIncrementAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetDoorStunDistance
	 * 		Flags  -> ()
	 */
	TMap<EDoorDamageType, float> ADoor::GetDoorStunDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetDoorStunDistance");
		
		ADoor_GetDoorStunDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetDoorMidLocation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector ADoor::GetDoorMidLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetDoorMidLocation");
		
		ADoor_GetDoorMidLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetDoorKillDistance
	 * 		Flags  -> ()
	 */
	TMap<EDoorDamageType, float> ADoor::GetDoorKillDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetDoorKillDistance");
		
		ADoor_GetDoorKillDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetBestDoorInteraction_FromStackUpArea
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStackupGenArea                                    InStackUpArea                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDoorwayBased                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector ADoor::GetBestDoorInteraction_FromStackUpArea(EStackupGenArea InStackUpArea, bool bDoorwayBased)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetBestDoorInteraction_FromStackUpArea");
		
		ADoor_GetBestDoorInteraction_FromStackUpArea_Params params {};
		params.InStackUpArea = InStackUpArea;
		params.bDoorwayBased = bDoorwayBased;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetBestDoorInteraction_FromLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        InInteractionLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDoorwayBased                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector ADoor::GetBestDoorInteraction_FromLocation(const struct FCoreUObject_FVector& InInteractionLocation, bool bDoorwayBased)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetBestDoorInteraction_FromLocation");
		
		ADoor_GetBestDoorInteraction_FromLocation_Params params {};
		params.InInteractionLocation = InInteractionLocation;
		params.bDoorwayBased = bDoorwayBased;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetAttachedWedge
	 * 		Flags  -> ()
	 */
	class ADoorJam* ADoor::GetAttachedWedge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetAttachedWedge");
		
		ADoor_GetAttachedWedge_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GetAttachedTrap
	 * 		Flags  -> ()
	 */
	class ATrapActorAttachedToDoor* ADoor::GetAttachedTrap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GetAttachedTrap");
		
		ADoor_GetAttachedTrap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.GenerateClearPoints
	 * 		Flags  -> ()
	 */
	void ADoor::GenerateClearPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.GenerateClearPoints");
		
		ADoor_GenerateClearPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.FlipStackUpArea
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStackupGenArea                                    OutStackUpArea                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHorizontalFlip                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bVerticalFlip                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::FlipStackUpArea(EStackupGenArea* OutStackUpArea, bool bHorizontalFlip, bool bVerticalFlip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.FlipStackUpArea");
		
		ADoor_FlipStackUpArea_Params params {};
		params.bHorizontalFlip = bHorizontalFlip;
		params.bVerticalFlip = bVerticalFlip;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutStackUpArea != nullptr)
			*OutStackUpArea = params.OutStackUpArea;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Finished_DoorRam
	 * 		Flags  -> ()
	 */
	void ADoor::Finished_DoorRam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Finished_DoorRam");
		
		ADoor_Finished_DoorRam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Finished_DoorKick_Success
	 * 		Flags  -> ()
	 */
	void ADoor::Finished_DoorKick_Success()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Finished_DoorKick_Success");
		
		ADoor_Finished_DoorKick_Success_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.Finished_DoorExplode
	 * 		Flags  -> ()
	 */
	void ADoor::Finished_DoorExplode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.Finished_DoorExplode");
		
		ADoor_Finished_DoorExplode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.FindStackUpAreaFromLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        InInteractionLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EStackupGenArea ADoor::FindStackUpAreaFromLocation(const struct FCoreUObject_FVector& InInteractionLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.FindStackUpAreaFromLocation");
		
		ADoor_FindStackUpAreaFromLocation_Params params {};
		params.InInteractionLocation = InInteractionLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.ExplodeDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorBreacherCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ExplosionCauser                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bKeepHinges                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::ExplodeDoor(class AReadyOrNotCharacter* DoorBreacherCharacter, class AActor* ExplosionCauser, bool bKeepHinges)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.ExplodeDoor");
		
		ADoor_ExplodeDoor_Params params {};
		params.DoorBreacherCharacter = DoorBreacherCharacter;
		params.ExplosionCauser = ExplosionCauser;
		params.bKeepHinges = bKeepHinges;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.EnableOutline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActorOutlineType                                  OutlineType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::EnableOutline(EActorOutlineType OutlineType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.EnableOutline");
		
		ADoor_EnableOutline_Params params {};
		params.OutlineType = OutlineType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.EnableNavLink
	 * 		Flags  -> ()
	 */
	void ADoor::EnableNavLink()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.EnableNavLink");
		
		ADoor_EnableNavLink_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.EnableAllInteractables
	 * 		Flags  -> ()
	 */
	void ADoor::EnableAllInteractables()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.EnableAllInteractables");
		
		ADoor_EnableAllInteractables_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.DoesSWATKnowTrapState
	 * 		Flags  -> ()
	 */
	bool ADoor::DoesSWATKnowTrapState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.DoesSWATKnowTrapState");
		
		ADoor_DoesSWATKnowTrapState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.DoesSuspectKnowTrapState
	 * 		Flags  -> ()
	 */
	bool ADoor::DoesSuspectKnowTrapState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.DoesSuspectKnowTrapState");
		
		ADoor_DoesSuspectKnowTrapState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.DisableStackupsOnErroringSide
	 * 		Flags  -> ()
	 */
	void ADoor::DisableStackupsOnErroringSide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.DisableStackupsOnErroringSide");
		
		ADoor_DisableStackupsOnErroringSide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.DisableOutline
	 * 		Flags  -> ()
	 */
	void ADoor::DisableOutline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.DisableOutline");
		
		ADoor_DisableOutline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.DisableNavLink
	 * 		Flags  -> ()
	 */
	void ADoor::DisableNavLink()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.DisableNavLink");
		
		ADoor_DisableNavLink_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.DisableAllInteractables
	 * 		Flags  -> ()
	 */
	void ADoor::DisableAllInteractables()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.DisableAllInteractables");
		
		ADoor_DisableAllInteractables_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.DestroyNavLink
	 * 		Flags  -> ()
	 */
	void ADoor::DestroyNavLink()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.DestroyNavLink");
		
		ADoor_DestroyNavLink_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.DestroyChunk_Index
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ChunkIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Impulse                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ImpulseStrength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::DestroyChunk_Index(int32_t ChunkIndex, const struct FCoreUObject_FVector& Impulse, float ImpulseStrength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.DestroyChunk_Index");
		
		ADoor_DestroyChunk_Index_Params params {};
		params.ChunkIndex = ChunkIndex;
		params.Impulse = Impulse;
		params.ImpulseStrength = ImpulseStrength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.DestroyChunk
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UDestructibleDoorChunkComponent*             InChunk                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Impulse                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ImpulseStrength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::DestroyChunk(class UDestructibleDoorChunkComponent* InChunk, const struct FCoreUObject_FVector& Impulse, float ImpulseStrength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.DestroyChunk");
		
		ADoor_DestroyChunk_Params params {};
		params.InChunk = InChunk;
		params.Impulse = Impulse;
		params.ImpulseStrength = ImpulseStrength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.DestroyAllChunks
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Impulse                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ImpulseStrength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bKeepHinges                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::DestroyAllChunks(const struct FCoreUObject_FVector& Impulse, float ImpulseStrength, bool bKeepHinges)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.DestroyAllChunks");
		
		ADoor_DestroyAllChunks_Params params {};
		params.Impulse = Impulse;
		params.ImpulseStrength = ImpulseStrength;
		params.bKeepHinges = bKeepHinges;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.DecreaseNumKicksToBreakDown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorKickCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShouldOpenDoor                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanBreakLock                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              KickChanceOffset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::DecreaseNumKicksToBreakDown(class AReadyOrNotCharacter* DoorKickCharacter, bool* bShouldOpenDoor, bool* bCanBreakLock, float KickChanceOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.DecreaseNumKicksToBreakDown");
		
		ADoor_DecreaseNumKicksToBreakDown_Params params {};
		params.DoorKickCharacter = DoorKickCharacter;
		params.KickChanceOffset = KickChanceOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bShouldOpenDoor != nullptr)
			*bShouldOpenDoor = params.bShouldOpenDoor;
		if (bCanBreakLock != nullptr)
			*bCanBreakLock = params.bCanBreakLock;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CollapseDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorBreacherCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        BreachLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::CollapseDoor(class AReadyOrNotCharacter* DoorBreacherCharacter, const struct FCoreUObject_FVector& BreachLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CollapseDoor");
		
		ADoor_CollapseDoor_Params params {};
		params.DoorBreacherCharacter = DoorBreacherCharacter;
		params.BreachLocation = BreachLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CloseSubDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorCloseCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimateDoorHandle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::CloseSubDoor(class AReadyOrNotCharacter* DoorCloseCharacter, bool bInstant, bool bAnimateDoorHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CloseSubDoor");
		
		ADoor_CloseSubDoor_Params params {};
		params.DoorCloseCharacter = DoorCloseCharacter;
		params.bInstant = bInstant;
		params.bAnimateDoorHandle = bAnimateDoorHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CloseDoor_Debug
	 * 		Flags  -> ()
	 */
	void ADoor::CloseDoor_Debug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CloseDoor_Debug");
		
		ADoor_CloseDoor_Debug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CloseDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorCloserCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimateDoorHandle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::CloseDoor(class AReadyOrNotCharacter* DoorCloserCharacter, bool bInstant, bool bAnimateDoorHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CloseDoor");
		
		ADoor_CloseDoor_Params params {};
		params.DoorCloserCharacter = DoorCloserCharacter;
		params.bInstant = bInstant;
		params.bAnimateDoorHandle = bAnimateDoorHandle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanTakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanTakeDamage(float Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanTakeDamage");
		
		ADoor_CanTakeDamage_Params params {};
		params.Damage = Damage;
		params.DamageEvent = DamageEvent;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanSpawnTrap
	 * 		Flags  -> ()
	 */
	bool ADoor::CanSpawnTrap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanSpawnTrap");
		
		ADoor_CanSpawnTrap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanRamDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanRamDoor(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanRamDoor");
		
		ADoor_CanRamDoor_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanPushDoorWhileBroken
	 * 		Flags  -> ()
	 */
	bool ADoor::CanPushDoorWhileBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanPushDoorWhileBroken");
		
		ADoor_CanPushDoorWhileBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanPushDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanPushDoor(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanPushDoor");
		
		ADoor_CanPushDoor_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanPullDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanPullDoor(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanPullDoor");
		
		ADoor_CanPullDoor_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanPlaceC2Explosive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanPlaceC2Explosive(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanPlaceC2Explosive");
		
		ADoor_CanPlaceC2Explosive_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanPeekDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanPeekDoor(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanPeekDoor");
		
		ADoor_CanPeekDoor_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanOpenDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanOpenDoor(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanOpenDoor");
		
		ADoor_CanOpenDoor_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanMirrorUnderDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanMirrorUnderDoor(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanMirrorUnderDoor");
		
		ADoor_CanMirrorUnderDoor_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanLockpickDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanLockpickDoor(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanLockpickDoor");
		
		ADoor_CanLockpickDoor_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanKickDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanKickDoor(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanKickDoor");
		
		ADoor_CanKickDoor_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanIssueOrdersHere
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  TraceResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanIssueOrdersHere(const struct FHitResult& TraceResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanIssueOrdersHere");
		
		ADoor_CanIssueOrdersHere_Params params {};
		params.TraceResult = TraceResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanEquipWedge
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanEquipWedge(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanEquipWedge");
		
		ADoor_CanEquipWedge_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanEquipOptiwand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanEquipOptiwand(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanEquipOptiwand");
		
		ADoor_CanEquipOptiwand_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanEquipMultitool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanEquipMultitool(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanEquipMultitool");
		
		ADoor_CanEquipMultitool_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanEquipC2Explosive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanEquipC2Explosive(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanEquipC2Explosive");
		
		ADoor_CanEquipC2Explosive_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanEquipBreachingShotgun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanEquipBreachingShotgun(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanEquipBreachingShotgun");
		
		ADoor_CanEquipBreachingShotgun_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanEquipBatteringRam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanEquipBatteringRam(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanEquipBatteringRam");
		
		ADoor_CanEquipBatteringRam_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanDeployWedge
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanDeployWedge(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanDeployWedge");
		
		ADoor_CanDeployWedge_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.CanCloseDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADoor::CanCloseDoor(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.CanCloseDoor");
		
		ADoor_CanCloseDoor_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.BreakDoorHandles
	 * 		Flags  -> ()
	 */
	void ADoor::BreakDoorHandles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.BreakDoorHandles");
		
		ADoor_BreakDoorHandles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.BreakDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bDestroyAllChunks                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DoorBreakerCharacter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::BreakDoor(bool bDestroyAllChunks, class AReadyOrNotCharacter* DoorBreakerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.BreakDoor");
		
		ADoor_BreakDoor_Params params {};
		params.bDestroyAllChunks = bDestroyAllChunks;
		params.DoorBreakerCharacter = DoorBreakerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.BreachDoorFromPoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorBreacherCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        BreachPoint                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InIncrementAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::BreachDoorFromPoint(class AReadyOrNotCharacter* DoorBreacherCharacter, const struct FCoreUObject_FVector& BreachPoint, float InIncrementAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.BreachDoorFromPoint");
		
		ADoor_BreachDoorFromPoint_Params params {};
		params.DoorBreacherCharacter = DoorBreacherCharacter;
		params.BreachPoint = BreachPoint;
		params.InIncrementAngle = InIncrementAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.BreachDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DoorBreacherCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InIncrementAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::BreachDoor(class AReadyOrNotCharacter* DoorBreacherCharacter, float InIncrementAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.BreachDoor");
		
		ADoor_BreachDoor_Params params {};
		params.DoorBreacherCharacter = DoorBreacherCharacter;
		params.InIncrementAngle = InIncrementAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.AttachWedge
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoorJam*                                    NewWedge                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::AttachWedge(class ADoorJam* NewWedge)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.AttachWedge");
		
		ADoor_AttachWedge_Params params {};
		params.NewWedge = NewWedge;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.AttachTrap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ATrapActorAttachedToDoor*                    NewTrap                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAttachToDoor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::AttachTrap(class ATrapActorAttachedToDoor* NewTrap, bool bAttachToDoor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.AttachTrap");
		
		ADoor_AttachTrap_Params params {};
		params.NewTrap = NewTrap;
		params.bAttachToDoor = bAttachToDoor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.ApplyRandomDamageToChunks
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              MinDamage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxDamage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::ApplyRandomDamageToChunks(float MinDamage, float MaxDamage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.ApplyRandomDamageToChunks");
		
		ADoor_ApplyRandomDamageToChunks_Params params {};
		params.MinDamage = MinDamage;
		params.MaxDamage = MaxDamage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.ApplyDoorDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDoorDamageType                                    InDoorDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::ApplyDoorDamage(EDoorDamageType InDoorDamage, class AReadyOrNotCharacter* Victim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.ApplyDoorDamage");
		
		ADoor_ApplyDoorDamage_Params params {};
		params.InDoorDamage = InDoorDamage;
		params.Victim = Victim;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.AnyTopDoorChunksBroken
	 * 		Flags  -> ()
	 */
	bool ADoor::AnyTopDoorChunksBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.AnyTopDoorChunksBroken");
		
		ADoor_AnyTopDoorChunksBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.AnyMiddleDoorChunksBroken
	 * 		Flags  -> ()
	 */
	bool ADoor::AnyMiddleDoorChunksBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.AnyMiddleDoorChunksBroken");
		
		ADoor_AnyMiddleDoorChunksBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.AnyHingesLeft
	 * 		Flags  -> ()
	 */
	bool ADoor::AnyHingesLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.AnyHingesLeft");
		
		ADoor_AnyHingesLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.AnyChunksDestroyed
	 * 		Flags  -> ()
	 */
	bool ADoor::AnyChunksDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.AnyChunksDestroyed");
		
		ADoor_AnyChunksDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.AnyBottomDoorChunksBroken
	 * 		Flags  -> ()
	 */
	bool ADoor::AnyBottomDoorChunksBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.AnyBottomDoorChunksBroken");
		
		ADoor_AnyBottomDoorChunksBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.AllTopDoorChunksBroken
	 * 		Flags  -> ()
	 */
	bool ADoor::AllTopDoorChunksBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.AllTopDoorChunksBroken");
		
		ADoor_AllTopDoorChunksBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.AllMiddleDoorChunksBroken
	 * 		Flags  -> ()
	 */
	bool ADoor::AllMiddleDoorChunksBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.AllMiddleDoorChunksBroken");
		
		ADoor_AllMiddleDoorChunksBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.AllMajorDoorChunksDestroyed
	 * 		Flags  -> ()
	 */
	bool ADoor::AllMajorDoorChunksDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.AllMajorDoorChunksDestroyed");
		
		ADoor_AllMajorDoorChunksDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Door.AllBottomDoorChunksBroken
	 * 		Flags  -> ()
	 */
	bool ADoor::AllBottomDoorChunksBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Door.AllBottomDoorChunksBroken");
		
		ADoor_AllBottomDoorChunksBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Door");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorBreachActivity.OnBreacherKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDoorBreachActivity::OnBreacherKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorBreachActivity.OnBreacherKilled");
		
		UDoorBreachActivity_OnBreacherKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorBreachActivity.FinishDoorBreach
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDoorBreachActivity::FinishDoorBreach(bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorBreachActivity.FinishDoorBreach");
		
		UDoorBreachActivity_FinishDoorBreach_Params params {};
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDoorBreachActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDoorBreachActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DoorBreachActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.KickDoorActivity.OnDoorKicked
	 * 		Flags  -> ()
	 */
	void UKickDoorActivity::OnDoorKicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.KickDoorActivity.OnDoorKicked");
		
		UKickDoorActivity_OnDoorKicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKickDoorActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKickDoorActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.KickDoorActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.C2DoorActivity.OnC2Placed
	 * 		Flags  -> ()
	 */
	void UC2DoorActivity::OnC2Placed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.C2DoorActivity.OnC2Placed");
		
		UC2DoorActivity_OnC2Placed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.C2DoorActivity.OnC2Detonate
	 * 		Flags  -> ()
	 */
	void UC2DoorActivity::OnC2Detonate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.C2DoorActivity.OnC2Detonate");
		
		UC2DoorActivity_OnC2Detonate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.C2DoorActivity.EnterDetonateC2Stage
	 * 		Flags  -> ()
	 */
	void UC2DoorActivity::EnterDetonateC2Stage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.C2DoorActivity.EnterDetonateC2Stage");
		
		UC2DoorActivity_EnterDetonateC2Stage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.C2DoorActivity.CanDetonateC2
	 * 		Flags  -> ()
	 */
	bool UC2DoorActivity::CanDetonateC2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.C2DoorActivity.CanDetonateC2");
		
		UC2DoorActivity_CanDetonateC2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UC2DoorActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UC2DoorActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.C2DoorActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ShotgunDoorActivity.OnDoorShotgunned
	 * 		Flags  -> ()
	 */
	void UShotgunDoorActivity::OnDoorShotgunned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ShotgunDoorActivity.OnDoorShotgunned");
		
		UShotgunDoorActivity_OnDoorShotgunned_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ShotgunDoorActivity.OnDoorKicked
	 * 		Flags  -> ()
	 */
	void UShotgunDoorActivity::OnDoorKicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ShotgunDoorActivity.OnDoorKicked");
		
		UShotgunDoorActivity_OnDoorKicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ShotgunDoorActivity.OnDoorBreached
	 * 		Flags  -> ()
	 */
	void UShotgunDoorActivity::OnDoorBreached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ShotgunDoorActivity.OnDoorBreached");
		
		UShotgunDoorActivity_OnDoorBreached_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ShotgunDoorActivity.IsShotgunBreachFinished
	 * 		Flags  -> ()
	 */
	bool UShotgunDoorActivity::IsShotgunBreachFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ShotgunDoorActivity.IsShotgunBreachFinished");
		
		UShotgunDoorActivity_IsShotgunBreachFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UShotgunDoorActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UShotgunDoorActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ShotgunDoorActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URamDoorActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URamDoorActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RamDoorActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ThrowItemThroughDoorActivity.OnThrowReady__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UThrowItemThroughDoorActivity::OnThrowReady__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ThrowItemThroughDoorActivity.OnThrowReady__DelegateSignature");
		
		UThrowItemThroughDoorActivity_OnThrowReady__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ThrowItemThroughDoorActivity.OnPerformingThrow__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UThrowItemThroughDoorActivity::OnPerformingThrow__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ThrowItemThroughDoorActivity.OnPerformingThrow__DelegateSignature");
		
		UThrowItemThroughDoorActivity_OnPerformingThrow__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThrowItemThroughDoorActivity.OnDoorBreached
	 * 		Flags  -> ()
	 */
	void UThrowItemThroughDoorActivity::OnDoorBreached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThrowItemThroughDoorActivity.OnDoorBreached");
		
		UThrowItemThroughDoorActivity_OnDoorBreached_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThrowItemThroughDoorActivity.IsItemThrown
	 * 		Flags  -> ()
	 */
	bool UThrowItemThroughDoorActivity::IsItemThrown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThrowItemThroughDoorActivity.IsItemThrown");
		
		UThrowItemThroughDoorActivity_IsItemThrown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UThrowItemThroughDoorActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UThrowItemThroughDoorActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ThrowItemThroughDoorActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UThrowGrenadeThroughDoorActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UThrowGrenadeThroughDoorActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ThrowGrenadeThroughDoorActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.CustomDoorBreachActivity.TickBreachDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCustomDoorBreachActivity::TickBreachDoor(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.CustomDoorBreachActivity.TickBreachDoor");
		
		UCustomDoorBreachActivity_TickBreachDoor_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCustomDoorBreachActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCustomDoorBreachActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.CustomDoorBreachActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorJam.Server_StartDoorjamPlacement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       PendingDoor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoorJam::Server_StartDoorjamPlacement(class ADoor* PendingDoor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorJam.Server_StartDoorjamPlacement");
		
		ADoorJam_Server_StartDoorjamPlacement_Params params {};
		params.PendingDoor = PendingDoor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorJam.Server_FinishDoorjamPlacement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       PendingDoor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoorJam::Server_FinishDoorjamPlacement(class ADoor* PendingDoor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorJam.Server_FinishDoorjamPlacement");
		
		ADoorJam_Server_FinishDoorjamPlacement_Params params {};
		params.PendingDoor = PendingDoor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorJam.OnRep_DoorjamSet
	 * 		Flags  -> ()
	 */
	void ADoorJam::OnRep_DoorjamSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorJam.OnRep_DoorjamSet");
		
		ADoorJam_OnRep_DoorjamSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorJam.Multicast_StartPlacement
	 * 		Flags  -> ()
	 */
	void ADoorJam::Multicast_StartPlacement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorJam.Multicast_StartPlacement");
		
		ADoorJam_Multicast_StartPlacement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorJam.JamDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoorJam::JamDoor(class ADoor* Door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorJam.JamDoor");
		
		ADoorJam_JamDoor_Params params {};
		params.Door = Door;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADoorJam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADoorJam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DoorJam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDoorNavLink.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDoorNavLink::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DoorNavLink");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDoorPointComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDoorPointComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DoorPointComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorRam.TryGetHitPosition
	 * 		Flags  -> ()
	 */
	struct FHitResult ADoorRam::TryGetHitPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorRam.TryGetHitPosition");
		
		ADoorRam_TryGetHitPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorRam.Server_StrikePlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            TargetPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoorRam::Server_StrikePlayer(class APlayerCharacter* TargetPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorRam.Server_StrikePlayer");
		
		ADoorRam_Server_StrikePlayer_Params params {};
		params.TargetPlayer = TargetPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorRam.Server_StrikeDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       TargetDoor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoorRam::Server_StrikeDoor(class ADoor* TargetDoor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorRam.Server_StrikeDoor");
		
		ADoorRam_Server_StrikeDoor_Params params {};
		params.TargetDoor = TargetDoor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorRam.OnBatteringRamHit
	 * 		Flags  -> ()
	 */
	void ADoorRam::OnBatteringRamHit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorRam.OnBatteringRamHit");
		
		ADoorRam_OnBatteringRamHit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DoorRam.CanHitActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  TestHit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool ADoorRam::CanHitActor(const struct FHitResult& TestHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DoorRam.CanHitActor");
		
		ADoorRam_CanHitActor_Params params {};
		params.TestHit = TestHit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADoorRam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADoorRam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DoorRam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDoorwayComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDoorwayComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DoorwayComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.TakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AUnmannedVehicle::TakeDamage(float Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.TakeDamage");
		
		AUnmannedVehicle_TakeDamage_Params params {};
		params.Damage = Damage;
		params.DamageEvent = DamageEvent;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.Server_StopPiloting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotPlayerController*                 CallingController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AUnmannedVehicle::Server_StopPiloting(class AReadyOrNotPlayerController* CallingController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.Server_StopPiloting");
		
		AUnmannedVehicle_Server_StopPiloting_Params params {};
		params.CallingController = CallingController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.Server_StartPiloting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotPlayerController*                 NewController                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AUnmannedVehicle::Server_StartPiloting(class AReadyOrNotPlayerController* NewController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.Server_StartPiloting");
		
		AUnmannedVehicle_Server_StartPiloting_Params params {};
		params.NewController = NewController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.OnDeath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AUnmannedVehicle::OnDeath(class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.OnDeath");
		
		AUnmannedVehicle_OnDeath_Params params {};
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.IsAlive
	 * 		Flags  -> ()
	 */
	bool AUnmannedVehicle::IsAlive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.IsAlive");
		
		AUnmannedVehicle_IsAlive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.HideActorsForTabletView
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneCaptureComponent2D*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AUnmannedVehicle::HideActorsForTabletView(class USceneCaptureComponent2D* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.HideActorsForTabletView");
		
		AUnmannedVehicle_HideActorsForTabletView_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.GetTabletViewTeamColor
	 * 		Flags  -> ()
	 */
	ETeamType AUnmannedVehicle::GetTabletViewTeamColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.GetTabletViewTeamColor");
		
		AUnmannedVehicle_GetTabletViewTeamColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.GetTabletViewComponent
	 * 		Flags  -> ()
	 */
	class USceneComponent* AUnmannedVehicle::GetTabletViewComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.GetTabletViewComponent");
		
		AUnmannedVehicle_GetTabletViewComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.GetTabletNameText
	 * 		Flags  -> ()
	 */
	class FText AUnmannedVehicle::GetTabletNameText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.GetTabletNameText");
		
		AUnmannedVehicle_GetTabletNameText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.GetPilot
	 * 		Flags  -> ()
	 */
	class APlayerCharacter* AUnmannedVehicle::GetPilot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.GetPilot");
		
		AUnmannedVehicle_GetPilot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.GetHealth
	 * 		Flags  -> ()
	 */
	float AUnmannedVehicle::GetHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.GetHealth");
		
		AUnmannedVehicle_GetHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.Die
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AUnmannedVehicle::Die(class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.Die");
		
		AUnmannedVehicle_Die_Params params {};
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.CanTabletViewMe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            TabletOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotGameState*                        GameState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AUnmannedVehicle::CanTabletViewMe(class APlayerCharacter* TabletOwner, class AReadyOrNotGameState* GameState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.CanTabletViewMe");
		
		AUnmannedVehicle_CanTabletViewMe_Params params {};
		params.TabletOwner = TabletOwner;
		params.GameState = GameState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.CanControlWithTablet
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            TabletOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AUnmannedVehicle::CanControlWithTablet(class APlayerCharacter* TabletOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.CanControlWithTablet");
		
		AUnmannedVehicle_CanControlWithTablet_Params params {};
		params.TabletOwner = TabletOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UnmannedVehicle.AssumeTabletControl
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            TabletOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AUnmannedVehicle::AssumeTabletControl(class APlayerCharacter* TabletOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UnmannedVehicle.AssumeTabletControl");
		
		AUnmannedVehicle_AssumeTabletControl_Params params {};
		params.TabletOwner = TabletOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AUnmannedVehicle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AUnmannedVehicle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.UnmannedVehicle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.UpdatePilotingInfo
	 * 		Flags  -> ()
	 */
	void ADrone::UpdatePilotingInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.UpdatePilotingInfo");
		
		ADrone_UpdatePilotingInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.ToggleThirdPerson
	 * 		Flags  -> ()
	 */
	void ADrone::ToggleThirdPerson()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.ToggleThirdPerson");
		
		ADrone_ToggleThirdPerson_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.Tick_CameraReset
	 * 		Flags  -> ()
	 */
	void ADrone::Tick_CameraReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.Tick_CameraReset");
		
		ADrone_Tick_CameraReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.Tick_CameraDamage
	 * 		Flags  -> ()
	 */
	void ADrone::Tick_CameraDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.Tick_CameraDamage");
		
		ADrone_Tick_CameraDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.SteadyDrone
	 * 		Flags  -> ()
	 */
	void ADrone::SteadyDrone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.SteadyDrone");
		
		ADrone_SteadyDrone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.Server_UpdateDrone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                     NewTransform                                               (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              InRPM                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADrone::Server_UpdateDrone(const struct FTransform& NewTransform, float InRPM)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.Server_UpdateDrone");
		
		ADrone_Server_UpdateDrone_Params params {};
		params.NewTransform = NewTransform;
		params.InRPM = InRPM;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.RetrieveLastHitDamageInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDroneDamageSpeed                                  InDroneDamageSpeed                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InDamageAmount                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADrone::RetrieveLastHitDamageInfo(EDroneDamageSpeed* InDroneDamageSpeed, float* InDamageAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.RetrieveLastHitDamageInfo");
		
		ADrone_RetrieveLastHitDamageInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InDroneDamageSpeed != nullptr)
			*InDroneDamageSpeed = params.InDroneDamageSpeed;
		if (InDamageAmount != nullptr)
			*InDamageAmount = params.InDamageAmount;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.QuickTurn
	 * 		Flags  -> ()
	 */
	void ADrone::QuickTurn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.QuickTurn");
		
		ADrone_QuickTurn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.OnDroneHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADrone::OnDroneHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.OnDroneHit");
		
		ADrone_OnDroneHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.OnDetectionSphereOverlapped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADrone::OnDetectionSphereOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.OnDetectionSphereOverlapped");
		
		ADrone_OnDetectionSphereOverlapped_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.IsStabilized
	 * 		Flags  -> ()
	 */
	bool ADrone::IsStabilized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.IsStabilized");
		
		ADrone_IsStabilized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.IsSpeedThresholdMet
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InSpeedAsPercentage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADrone::IsSpeedThresholdMet(float InSpeedAsPercentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.IsSpeedThresholdMet");
		
		ADrone_IsSpeedThresholdMet_Params params {};
		params.InSpeedAsPercentage = InSpeedAsPercentage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.IsMovingRight
	 * 		Flags  -> ()
	 */
	bool ADrone::IsMovingRight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.IsMovingRight");
		
		ADrone_IsMovingRight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.IsMovingLeft
	 * 		Flags  -> ()
	 */
	bool ADrone::IsMovingLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.IsMovingLeft");
		
		ADrone_IsMovingLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.IsMovingForward
	 * 		Flags  -> ()
	 */
	bool ADrone::IsMovingForward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.IsMovingForward");
		
		ADrone_IsMovingForward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.IsMovingBackward
	 * 		Flags  -> ()
	 */
	bool ADrone::IsMovingBackward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.IsMovingBackward");
		
		ADrone_IsMovingBackward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.IsMoving
	 * 		Flags  -> ()
	 */
	bool ADrone::IsMoving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.IsMoving");
		
		ADrone_IsMoving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.IsInvincible
	 * 		Flags  -> ()
	 */
	bool ADrone::IsInvincible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.IsInvincible");
		
		ADrone_IsInvincible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.IsInThirdPersonMode
	 * 		Flags  -> ()
	 */
	bool ADrone::IsInThirdPersonMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.IsInThirdPersonMode");
		
		ADrone_IsInThirdPersonMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.IsApplyingInput
	 * 		Flags  -> ()
	 */
	bool ADrone::IsApplyingInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.IsApplyingInput");
		
		ADrone_IsApplyingInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.IncrementSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADrone::IncrementSpeed(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.IncrementSpeed");
		
		ADrone_IncrementSpeed_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.HasPilot
	 * 		Flags  -> ()
	 */
	bool ADrone::HasPilot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.HasPilot");
		
		ADrone_HasPilot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.GetMinSpeed
	 * 		Flags  -> ()
	 */
	float ADrone::GetMinSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.GetMinSpeed");
		
		ADrone_GetMinSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.GetMaxSpeed
	 * 		Flags  -> ()
	 */
	float ADrone::GetMaxSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.GetMaxSpeed");
		
		ADrone_GetMaxSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.GetMaxRPM
	 * 		Flags  -> ()
	 */
	float ADrone::GetMaxRPM()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.GetMaxRPM");
		
		ADrone_GetMaxRPM_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.GetIdleRPM
	 * 		Flags  -> ()
	 */
	float ADrone::GetIdleRPM()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.GetIdleRPM");
		
		ADrone_GetIdleRPM_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.GetDroneController
	 * 		Flags  -> ()
	 */
	class AReadyOrNotPlayerController* ADrone::GetDroneController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.GetDroneController");
		
		ADrone_GetDroneController_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.GetDistanceToPilot
	 * 		Flags  -> ()
	 */
	float ADrone::GetDistanceToPilot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.GetDistanceToPilot");
		
		ADrone_GetDistanceToPilot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.GetCurrentSpeedAsPercentage
	 * 		Flags  -> ()
	 */
	float ADrone::GetCurrentSpeedAsPercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.GetCurrentSpeedAsPercentage");
		
		ADrone_GetCurrentSpeedAsPercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.GetCurrentRPM
	 * 		Flags  -> ()
	 */
	float ADrone::GetCurrentRPM()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.GetCurrentRPM");
		
		ADrone_GetCurrentRPM_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.GetCurrentMovementDirection
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector ADrone::GetCurrentMovementDirection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.GetCurrentMovementDirection");
		
		ADrone_GetCurrentMovementDirection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.GetAltitude
	 * 		Flags  -> ()
	 */
	float ADrone::GetAltitude()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.GetAltitude");
		
		ADrone_GetAltitude_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.Finished_CameraDamage
	 * 		Flags  -> ()
	 */
	void ADrone::Finished_CameraDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.Finished_CameraDamage");
		
		ADrone_Finished_CameraDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.ExitDrone
	 * 		Flags  -> ()
	 */
	void ADrone::ExitDrone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.ExitDrone");
		
		ADrone_ExitDrone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Drone.Client_UpdateDrone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                     NewTransform                                               (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              InRPM                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADrone::Client_UpdateDrone(const struct FTransform& NewTransform, float InRPM)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Drone.Client_UpdateDrone");
		
		ADrone_Client_UpdateDrone_Params params {};
		params.NewTransform = NewTransform;
		params.InRPM = InRPM;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADrone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADrone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Drone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DroneVehicle.UpdatePilotingInfo
	 * 		Flags  -> ()
	 */
	void ADroneVehicle::UpdatePilotingInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DroneVehicle.UpdatePilotingInfo");
		
		ADroneVehicle_UpdatePilotingInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DroneVehicle.Server_UpdateDroneTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                     NewTransform                                               (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ADroneVehicle::Server_UpdateDroneTransform(const struct FTransform& NewTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DroneVehicle.Server_UpdateDroneTransform");
		
		ADroneVehicle_Server_UpdateDroneTransform_Params params {};
		params.NewTransform = NewTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DroneVehicle.OnRep_DroneMovement
	 * 		Flags  -> ()
	 */
	void ADroneVehicle::OnRep_DroneMovement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DroneVehicle.OnRep_DroneMovement");
		
		ADroneVehicle_OnRep_DroneMovement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DroneVehicle.OnDroneHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADroneVehicle::OnDroneHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DroneVehicle.OnDroneHit");
		
		ADroneVehicle_OnDroneHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DroneVehicle.Drone_Yaw
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADroneVehicle::Drone_Yaw(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DroneVehicle.Drone_Yaw");
		
		ADroneVehicle_Drone_Yaw_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DroneVehicle.Drone_ToggleThirdPerson
	 * 		Flags  -> ()
	 */
	void ADroneVehicle::Drone_ToggleThirdPerson()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DroneVehicle.Drone_ToggleThirdPerson");
		
		ADroneVehicle_Drone_ToggleThirdPerson_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DroneVehicle.Drone_Throttle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADroneVehicle::Drone_Throttle(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DroneVehicle.Drone_Throttle");
		
		ADroneVehicle_Drone_Throttle_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DroneVehicle.Drone_Steady
	 * 		Flags  -> ()
	 */
	void ADroneVehicle::Drone_Steady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DroneVehicle.Drone_Steady");
		
		ADroneVehicle_Drone_Steady_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DroneVehicle.Drone_Right
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADroneVehicle::Drone_Right(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DroneVehicle.Drone_Right");
		
		ADroneVehicle_Drone_Right_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DroneVehicle.Drone_QuickTurn
	 * 		Flags  -> ()
	 */
	void ADroneVehicle::Drone_QuickTurn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DroneVehicle.Drone_QuickTurn");
		
		ADroneVehicle_Drone_QuickTurn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DroneVehicle.Drone_MoveForward
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADroneVehicle::Drone_MoveForward(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DroneVehicle.Drone_MoveForward");
		
		ADroneVehicle_Drone_MoveForward_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DroneVehicle.Drone_Exit
	 * 		Flags  -> ()
	 */
	void ADroneVehicle::Drone_Exit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DroneVehicle.Drone_Exit");
		
		ADroneVehicle_Drone_Exit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADroneVehicle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADroneVehicle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DroneVehicle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDropItemAtLocationActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDropItemAtLocationActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DropItemAtLocationActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDropWeaponAnimNotify.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDropWeaponAnimNotify::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DropWeaponAnimNotify");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDuelingCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDuelingCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DuelingCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DynamicInteractableWorldItem.OnItemStateToggled
	 * 		Flags  -> ()
	 */
	void ADynamicInteractableWorldItem::OnItemStateToggled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DynamicInteractableWorldItem.OnItemStateToggled");
		
		ADynamicInteractableWorldItem_OnItemStateToggled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DynamicInteractableWorldItem.OnItemDestroyed
	 * 		Flags  -> ()
	 */
	void ADynamicInteractableWorldItem::OnItemDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DynamicInteractableWorldItem.OnItemDestroyed");
		
		ADynamicInteractableWorldItem_OnItemDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DynamicInteractableWorldItem.OnHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADynamicInteractableWorldItem::OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DynamicInteractableWorldItem.OnHit");
		
		ADynamicInteractableWorldItem_OnHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComponent = OtherComponent;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DynamicInteractableWorldItem.Multicast_ItemStateToggle
	 * 		Flags  -> ()
	 */
	void ADynamicInteractableWorldItem::Multicast_ItemStateToggle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DynamicInteractableWorldItem.Multicast_ItemStateToggle");
		
		ADynamicInteractableWorldItem_Multicast_ItemStateToggle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DynamicInteractableWorldItem.Multicast_DestroyItem
	 * 		Flags  -> ()
	 */
	void ADynamicInteractableWorldItem::Multicast_DestroyItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DynamicInteractableWorldItem.Multicast_DestroyItem");
		
		ADynamicInteractableWorldItem_Multicast_DestroyItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADynamicInteractableWorldItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADynamicInteractableWorldItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DynamicInteractableWorldItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DynamicWorldActor.SetDynamicSpawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldSpawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADynamicWorldActor::SetDynamicSpawn(bool bShouldSpawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DynamicWorldActor.SetDynamicSpawn");
		
		ADynamicWorldActor_SetDynamicSpawn_Params params {};
		params.bShouldSpawn = bShouldSpawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DynamicWorldActor.OnRep_ReplicateSpawn
	 * 		Flags  -> ()
	 */
	void ADynamicWorldActor::OnRep_ReplicateSpawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DynamicWorldActor.OnRep_ReplicateSpawn");
		
		ADynamicWorldActor_OnRep_ReplicateSpawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DynamicWorldActor.OnDynamicallySpawned
	 * 		Flags  -> ()
	 */
	void ADynamicWorldActor::OnDynamicallySpawned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DynamicWorldActor.OnDynamicallySpawned");
		
		ADynamicWorldActor_OnDynamicallySpawned_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DynamicWorldActor.CheckDynamicSpawn
	 * 		Flags  -> ()
	 */
	void ADynamicWorldActor::CheckDynamicSpawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DynamicWorldActor.CheckDynamicSpawn");
		
		ADynamicWorldActor_CheckDynamicSpawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADynamicWorldActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADynamicWorldActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DynamicWorldActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADynamicReportable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADynamicReportable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DynamicReportable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DynamicWorldItem.OnRep_ItemDestroyed
	 * 		Flags  -> ()
	 */
	void ADynamicWorldItem::OnRep_ItemDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DynamicWorldItem.OnRep_ItemDestroyed");
		
		ADynamicWorldItem_OnRep_ItemDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DynamicWorldItem.OnItemDestroyed
	 * 		Flags  -> ()
	 */
	void ADynamicWorldItem::OnItemDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DynamicWorldItem.OnItemDestroyed");
		
		ADynamicWorldItem_OnItemDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DynamicWorldItem.OnHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADynamicWorldItem::OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DynamicWorldItem.OnHit");
		
		ADynamicWorldItem_OnHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComponent = OtherComponent;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.DynamicWorldItem.Multicast_DestroyItem
	 * 		Flags  -> ()
	 */
	void ADynamicWorldItem::Multicast_DestroyItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.DynamicWorldItem.Multicast_DestroyItem");
		
		ADynamicWorldItem_Multicast_DestroyItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADynamicWorldItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADynamicWorldItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DynamicWorldItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Elevator.StartMovingElevator
	 * 		Flags  -> ()
	 */
	void AElevator::StartMovingElevator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Elevator.StartMovingElevator");
		
		AElevator_StartMovingElevator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Elevator.SetSelectedFloor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Floor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AElevator::SetSelectedFloor(int32_t Floor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Elevator.SetSelectedFloor");
		
		AElevator_SetSelectedFloor_Params params {};
		params.Floor = Floor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Elevator.Server_SetSelectedFloor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Floor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AElevator::Server_SetSelectedFloor(int32_t Floor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Elevator.Server_SetSelectedFloor");
		
		AElevator_Server_SetSelectedFloor_Params params {};
		params.Floor = Floor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Elevator.Server_OpenCloseDoors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldCloseDoors                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AElevator::Server_OpenCloseDoors(bool bShouldCloseDoors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Elevator.Server_OpenCloseDoors");
		
		AElevator_Server_OpenCloseDoors_Params params {};
		params.bShouldCloseDoors = bShouldCloseDoors;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Elevator.Multicast_PlayFloorReachedSound
	 * 		Flags  -> ()
	 */
	void AElevator::Multicast_PlayFloorReachedSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Elevator.Multicast_PlayFloorReachedSound");
		
		AElevator_Multicast_PlayFloorReachedSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Elevator.Multicast_PlayDoorOpenSound
	 * 		Flags  -> ()
	 */
	void AElevator::Multicast_PlayDoorOpenSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Elevator.Multicast_PlayDoorOpenSound");
		
		AElevator_Multicast_PlayDoorOpenSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Elevator.Multicast_PlayDoorCloseSound
	 * 		Flags  -> ()
	 */
	void AElevator::Multicast_PlayDoorCloseSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Elevator.Multicast_PlayDoorCloseSound");
		
		AElevator_Multicast_PlayDoorCloseSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Elevator.Multicast_PlayDestinationReachedSound
	 * 		Flags  -> ()
	 */
	void AElevator::Multicast_PlayDestinationReachedSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Elevator.Multicast_PlayDestinationReachedSound");
		
		AElevator_Multicast_PlayDestinationReachedSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AElevator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AElevator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Elevator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UElevatorButtonComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UElevatorButtonComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ElevatorButtonComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.EnvironmentVolume.OnOverlapEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AEnvironmentVolume::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.EnvironmentVolume.OnOverlapEnd");
		
		AEnvironmentVolume_OnOverlapEnd_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.EnvironmentVolume.OnOverlapBegin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AEnvironmentVolume::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.EnvironmentVolume.OnOverlapBegin");
		
		AEnvironmentVolume_OnOverlapBegin_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AEnvironmentVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AEnvironmentVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.EnvironmentVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupActor.ToggleObjectiveMarker
	 * 		Flags  -> ()
	 */
	void APickupActor::ToggleObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupActor.ToggleObjectiveMarker");
		
		APickupActor_ToggleObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupActor.ShowObjectiveMarker
	 * 		Flags  -> ()
	 */
	void APickupActor::ShowObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupActor.ShowObjectiveMarker");
		
		APickupActor_ShowObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PickupActor.OnActorPickedUp_NoParam__DelegateSignature
	 * 		Flags  -> ()
	 */
	void APickupActor::OnActorPickedUp_NoParam__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PickupActor.OnActorPickedUp_NoParam__DelegateSignature");
		
		APickupActor_OnActorPickedUp_NoParam__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PickupActor.OnActorPickedUp__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      PickedActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APickupActor::OnActorPickedUp__DelegateSignature(class AActor* PickedActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PickupActor.OnActorPickedUp__DelegateSignature");
		
		APickupActor_OnActorPickedUp__DelegateSignature_Params params {};
		params.PickedActor = PickedActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PickupActor.OnActorDropped__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      DroppedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APickupActor::OnActorDropped__DelegateSignature(class AActor* DroppedActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PickupActor.OnActorDropped__DelegateSignature");
		
		APickupActor_OnActorDropped__DelegateSignature_Params params {};
		params.DroppedActor = DroppedActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupActor.HideObjectiveMarker
	 * 		Flags  -> ()
	 */
	void APickupActor::HideObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupActor.HideObjectiveMarker");
		
		APickupActor_HideObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupActor.GetPickupInstigator
	 * 		Flags  -> ()
	 */
	class AActor* APickupActor::GetPickupInstigator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupActor.GetPickupInstigator");
		
		APickupActor_GetPickupInstigator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupActor.EnableOutline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActorOutlineType                                  OutlineType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APickupActor::EnableOutline(EActorOutlineType OutlineType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupActor.EnableOutline");
		
		APickupActor_EnableOutline_Params params {};
		params.OutlineType = OutlineType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupActor.DisableOutline
	 * 		Flags  -> ()
	 */
	void APickupActor::DisableOutline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupActor.DisableOutline");
		
		APickupActor_DisableOutline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupActor.CanPickUpNow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PickerUpper                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APickupActor::CanPickUpNow(class APlayerCharacter* PickerUpper)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupActor.CanPickUpNow");
		
		APickupActor_CanPickUpNow_Params params {};
		params.PickerUpper = PickerUpper;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupActor.ActorPickedUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InPickupInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APickupActor::ActorPickedUp(class AActor* InPickupInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupActor.ActorPickedUp");
		
		APickupActor_ActorPickedUp_Params params {};
		params.InPickupInstigator = InPickupInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupActor.ActorDropped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InDroppedInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APickupActor::ActorDropped(class AActor* InDroppedInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupActor.ActorDropped");
		
		APickupActor_ActorDropped_Params params {};
		params.InDroppedInstigator = InDroppedInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APickupActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APickupActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PickupActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.EvidenceActor.UpdateEvidenceCollection_COOP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AEvidenceActor::UpdateEvidenceCollection_COOP(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.EvidenceActor.UpdateEvidenceCollection_COOP");
		
		AEvidenceActor_UpdateEvidenceCollection_COOP_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.EvidenceActor.StartExtractingEvidence
	 * 		Flags  -> ()
	 */
	void AEvidenceActor::StartExtractingEvidence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.EvidenceActor.StartExtractingEvidence");
		
		AEvidenceActor_StartExtractingEvidence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.EvidenceActor.OnRep_EvidenceStateChanged
	 * 		Flags  -> ()
	 */
	void AEvidenceActor::OnRep_EvidenceStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.EvidenceActor.OnRep_EvidenceStateChanged");
		
		AEvidenceActor_OnRep_EvidenceStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.EvidenceActor.GetEvidenceName
	 * 		Flags  -> ()
	 */
	class FString AEvidenceActor::GetEvidenceName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.EvidenceActor.GetEvidenceName");
		
		AEvidenceActor_GetEvidenceName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.EvidenceActor.FinishExtractingEvidence
	 * 		Flags  -> ()
	 */
	void AEvidenceActor::FinishExtractingEvidence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.EvidenceActor.FinishExtractingEvidence");
		
		AEvidenceActor_FinishExtractingEvidence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AEvidenceActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AEvidenceActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.EvidenceActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.EvidenceExtractionDevice.TryExtractEvidence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            EvidencePossessor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AEvidenceExtractionDevice::TryExtractEvidence(class APlayerCharacter* EvidencePossessor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.EvidenceExtractionDevice.TryExtractEvidence");
		
		AEvidenceExtractionDevice_TryExtractEvidence_Params params {};
		params.EvidencePossessor = EvidencePossessor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.EvidenceExtractionDevice.IsExtracting
	 * 		Flags  -> ()
	 */
	bool AEvidenceExtractionDevice::IsExtracting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.EvidenceExtractionDevice.IsExtracting");
		
		AEvidenceExtractionDevice_IsExtracting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.EvidenceExtractionDevice.HasEvidenceToExtract
	 * 		Flags  -> ()
	 */
	bool AEvidenceExtractionDevice::HasEvidenceToExtract()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.EvidenceExtractionDevice.HasEvidenceToExtract");
		
		AEvidenceExtractionDevice_HasEvidenceToExtract_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.EvidenceExtractionDevice.CanStartExtraction
	 * 		Flags  -> ()
	 */
	bool AEvidenceExtractionDevice::CanStartExtraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.EvidenceExtractionDevice.CanStartExtraction");
		
		AEvidenceExtractionDevice_CanStartExtraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.EvidenceExtractionDevice.CanCollectEvidence
	 * 		Flags  -> ()
	 */
	bool AEvidenceExtractionDevice::CanCollectEvidence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.EvidenceExtractionDevice.CanCollectEvidence");
		
		AEvidenceExtractionDevice_CanCollectEvidence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AEvidenceExtractionDevice.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AEvidenceExtractionDevice::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.EvidenceExtractionDevice");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AEvidenceExtractionDevice_Incrim.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AEvidenceExtractionDevice_Incrim::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.EvidenceExtractionDevice_Incrim");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AEvidenceSpawnPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AEvidenceSpawnPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.EvidenceSpawnPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ExplosionGibs.SpawnBloodDecal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AExplosionGibs::SpawnBloodDecal(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ExplosionGibs.SpawnBloodDecal");
		
		AExplosionGibs_SpawnBloodDecal_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ExplosionGibs.SetupGibsForSkeletalMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      Mesh                                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AExplosionGibs::SetupGibsForSkeletalMesh(class USkeletalMeshComponent* Mesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ExplosionGibs.SetupGibsForSkeletalMesh");
		
		AExplosionGibs_SetupGibsForSkeletalMesh_Params params {};
		params.Mesh = Mesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AExplosionGibs.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AExplosionGibs::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ExplosionGibs");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ExplosiveContainer.Multicast_TriggerExplosive
	 * 		Flags  -> ()
	 */
	void AExplosiveContainer::Multicast_TriggerExplosive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ExplosiveContainer.Multicast_TriggerExplosive");
		
		AExplosiveContainer_Multicast_TriggerExplosive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ExplosiveContainer.Multicast_PlayExplosionEffects
	 * 		Flags  -> ()
	 */
	void AExplosiveContainer::Multicast_PlayExplosionEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ExplosiveContainer.Multicast_PlayExplosionEffects");
		
		AExplosiveContainer_Multicast_PlayExplosionEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AExplosiveContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AExplosiveContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ExplosiveContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SuspectArmour.OnRep_ArmourData
	 * 		Flags  -> ()
	 */
	void ASuspectArmour::OnRep_ArmourData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SuspectArmour.OnRep_ArmourData");
		
		ASuspectArmour_OnRep_ArmourData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASuspectArmour.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASuspectArmour::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SuspectArmour");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ExplosiveVest.Multicast_PlayPreExplosionEffects
	 * 		Flags  -> ()
	 */
	void AExplosiveVest::Multicast_PlayPreExplosionEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ExplosiveVest.Multicast_PlayPreExplosionEffects");
		
		AExplosiveVest_Multicast_PlayPreExplosionEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ExplosiveVest.Multicast_PlayExplosionEffects
	 * 		Flags  -> ()
	 */
	void AExplosiveVest::Multicast_PlayExplosionEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ExplosiveVest.Multicast_PlayExplosionEffects");
		
		AExplosiveVest_Multicast_PlayExplosionEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ExplosiveVest.ExplodeVest
	 * 		Flags  -> ()
	 */
	void AExplosiveVest::ExplodeVest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ExplosiveVest.ExplodeVest");
		
		AExplosiveVest_ExplodeVest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AExplosiveVest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AExplosiveVest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ExplosiveVest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FirefightGM.RegenerateRandomLoadouts
	 * 		Flags  -> ()
	 */
	void AFirefightGM::RegenerateRandomLoadouts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FirefightGM.RegenerateRandomLoadouts");
		
		AFirefightGM_RegenerateRandomLoadouts_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FirefightGM.GetNumberOfActivePlayersOnTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AFirefightGM::GetNumberOfActivePlayersOnTeam(ETeamType Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FirefightGM.GetNumberOfActivePlayersOnTeam");
		
		AFirefightGM_GetNumberOfActivePlayersOnTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFirefightGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFirefightGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FirefightGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFirefightGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFirefightGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FirefightGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFireOnDroppedAnimNotify.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFireOnDroppedAnimNotify::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FireOnDroppedAnimNotify");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FirePointActor.PlayPreviewAnimation
	 * 		Flags  -> ()
	 */
	void AFirePointActor::PlayPreviewAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FirePointActor.PlayPreviewAnimation");
		
		AFirePointActor_PlayPreviewAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FirePointActor.IsInUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticController*                       MyController                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AFirePointActor::IsInUse(class ACyberneticController* MyController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FirePointActor.IsInUse");
		
		AFirePointActor_IsInUse_Params params {};
		params.MyController = MyController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FirePointActor.GetRandomFireMontage
	 * 		Flags  -> ()
	 */
	class FString AFirePointActor::GetRandomFireMontage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FirePointActor.GetRandomFireMontage");
		
		AFirePointActor_GetRandomFireMontage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FirePointActor.GetParentVolume
	 * 		Flags  -> ()
	 */
	class ACoverFireVolume* AFirePointActor::GetParentVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FirePointActor.GetParentVolume");
		
		AFirePointActor_GetParentVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFirePointActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFirePointActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FirePointActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFlankingAvoidanceVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFlankingAvoidanceVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FlankingAvoidanceVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFlankingCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFlankingCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FlankingCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFlashbangDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFlashbangDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FlashbangDamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFlashLightTrackingPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFlashLightTrackingPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FlashLightTrackingPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFleeingCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFleeingCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FleeingCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FMODAudioPropagationComponent.UpdateAudioPropagation
	 * 		Flags  -> ()
	 */
	bool UFMODAudioPropagationComponent::UpdateAudioPropagation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FMODAudioPropagationComponent.UpdateAudioPropagation");
		
		UFMODAudioPropagationComponent_UpdateAudioPropagation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FMODAudioPropagationComponent.PlayEventAttached
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFMODEvent*                                  EventToPlay                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             CompToAttach                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        AttachPoint                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FMODParam>                           Params                                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UFMODAudioPropagationComponent::PlayEventAttached(class UFMODEvent* EventToPlay, class USceneComponent* CompToAttach, const class FName& AttachPoint, TArray<struct FMODParam> Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FMODAudioPropagationComponent.PlayEventAttached");
		
		UFMODAudioPropagationComponent_PlayEventAttached_Params params {};
		params.EventToPlay = EventToPlay;
		params.CompToAttach = CompToAttach;
		params.AttachPoint = AttachPoint;
		params.Params = Params;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FMODAudioPropagationComponent.PlayEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFMODEvent*                                  EventToPlay                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FMODParam>                           Params                                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UFMODAudioPropagationComponent::PlayEvent(class UFMODEvent* EventToPlay, const struct FCoreUObject_FVector& Origin, TArray<struct FMODParam> Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FMODAudioPropagationComponent.PlayEvent");
		
		UFMODAudioPropagationComponent_PlayEvent_Params params {};
		params.EventToPlay = EventToPlay;
		params.Origin = Origin;
		params.Params = Params;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FMODAudioPropagationComponent.CheckOcclusion
	 * 		Flags  -> ()
	 */
	void UFMODAudioPropagationComponent::CheckOcclusion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FMODAudioPropagationComponent.CheckOcclusion");
		
		UFMODAudioPropagationComponent_CheckOcclusion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFMODAudioPropagationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFMODAudioPropagationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FMODAudioPropagationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFootstepComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFootstepComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FootstepComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FootstepFoleyComponent.StoppedOverlapping
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComp                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFootstepFoleyComponent::StoppedOverlapping(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FootstepFoleyComponent.StoppedOverlapping");
		
		UFootstepFoleyComponent_StoppedOverlapping_Params params {};
		params.OverlappedComp = OverlappedComp;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FootstepFoleyComponent.StartedOverlapping
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComp                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UFootstepFoleyComponent::StartedOverlapping(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FootstepFoleyComponent.StartedOverlapping");
		
		UFootstepFoleyComponent_StartedOverlapping_Params params {};
		params.OverlappedComp = OverlappedComp;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFootstepFoleyComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFootstepFoleyComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FootstepFoleyComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FootstepFoleyVolume.OnOverlapEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFootstepFoleyVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FootstepFoleyVolume.OnOverlapEnd");
		
		AFootstepFoleyVolume_OnOverlapEnd_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FootstepFoleyVolume.OnOverlapBegin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFootstepFoleyVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FootstepFoleyVolume.OnOverlapBegin");
		
		AFootstepFoleyVolume_OnOverlapBegin_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFootstepFoleyVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFootstepFoleyVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FootstepFoleyVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFootstepNativeAnimNotify.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFootstepNativeAnimNotify::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FootstepNativeAnimNotify");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UForceAimAtActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UForceAimAtActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ForceAimAtActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFormationActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFormationActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FormationActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFreeArrestedActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFreeArrestedActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FreeArrestedActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFreeMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFreeMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FreeMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.FriendsList.OnFriendsListUpdated__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UFriendsList::OnFriendsListUpdated__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.FriendsList.OnFriendsListUpdated__DelegateSignature");
		
		UFriendsList_OnFriendsListUpdated__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.FriendsList.GetFriendsList
	 * 		Flags  -> ()
	 */
	void UFriendsList::GetFriendsList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.FriendsList.GetFriendsList");
		
		UFriendsList_GetFriendsList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFriendsList.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFriendsList::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.FriendsList");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GameplayConfig.ReloadConfig
	 * 		Flags  -> ()
	 */
	void UGameplayConfig::ReloadConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GameplayConfig.ReloadConfig");
		
		UGameplayConfig_ReloadConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GameplayConfig.GetVector2D
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      FallbackValue                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D UGameplayConfig::GetVector2D(const class FString& ConfigKey, const struct FCoreUObject_FVector2D& FallbackValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GameplayConfig.GetVector2D");
		
		UGameplayConfig_GetVector2D_Params params {};
		params.ConfigKey = ConfigKey;
		params.FallbackValue = FallbackValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GameplayConfig.GetVector
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        FallbackValue                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector UGameplayConfig::GetVector(const class FString& ConfigKey, const struct FCoreUObject_FVector& FallbackValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GameplayConfig.GetVector");
		
		UGameplayConfig_GetVector_Params params {};
		params.ConfigKey = ConfigKey;
		params.FallbackValue = FallbackValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GameplayConfig.GetStringArray_SingleLine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FString>                              FallbackValue                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<class FString> UGameplayConfig::GetStringArray_SingleLine(const class FString& ConfigKey, TArray<class FString> FallbackValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GameplayConfig.GetStringArray_SingleLine");
		
		UGameplayConfig_GetStringArray_SingleLine_Params params {};
		params.ConfigKey = ConfigKey;
		params.FallbackValue = FallbackValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GameplayConfig.GetStringArray
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FString>                              FallbackValue                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<class FString> UGameplayConfig::GetStringArray(const class FString& ConfigKey, TArray<class FString> FallbackValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GameplayConfig.GetStringArray");
		
		UGameplayConfig_GetStringArray_Params params {};
		params.ConfigKey = ConfigKey;
		params.FallbackValue = FallbackValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GameplayConfig.GetString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      FallbackValue                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UGameplayConfig::GetString(const class FString& ConfigKey, const class FString& FallbackValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GameplayConfig.GetString");
		
		UGameplayConfig_GetString_Params params {};
		params.ConfigKey = ConfigKey;
		params.FallbackValue = FallbackValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GameplayConfig.GetInt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            FallbackValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGameplayConfig::GetInt(const class FString& ConfigKey, int32_t FallbackValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GameplayConfig.GetInt");
		
		UGameplayConfig_GetInt_Params params {};
		params.ConfigKey = ConfigKey;
		params.FallbackValue = FallbackValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GameplayConfig.GetFloat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FallbackValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGameplayConfig::GetFloat(const class FString& ConfigKey, float FallbackValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GameplayConfig.GetFloat");
		
		UGameplayConfig_GetFloat_Params params {};
		params.ConfigKey = ConfigKey;
		params.FallbackValue = FallbackValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GameplayConfig.GetBool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               FallbackValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameplayConfig::GetBool(const class FString& ConfigKey, bool FallbackValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GameplayConfig.GetBool");
		
		UGameplayConfig_GetBool_Params params {};
		params.ConfigKey = ConfigKey;
		params.FallbackValue = FallbackValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameplayConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameplayConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.GameplayConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGameplayManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGameplayManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.GameplayManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GatherDebugInterface.GatherDebugText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      OutText                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGatherDebugInterface::GatherDebugText(class FString* OutText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GatherDebugInterface.GatherDebugText");
		
		UGatherDebugInterface_GatherDebugText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutText != nullptr)
			*OutText = params.OutText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GatherDebugInterface.GatherDebugData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FDebugData>                          OutDebugData                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UGatherDebugInterface::GatherDebugData(TArray<struct FDebugData>* OutDebugData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GatherDebugInterface.GatherDebugData");
		
		UGatherDebugInterface_GatherDebugData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDebugData != nullptr)
			*OutDebugData = params.OutDebugData;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GatherDebugInterface.DrawVisualDebug
	 * 		Flags  -> ()
	 */
	void UGatherDebugInterface::DrawVisualDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GatherDebugInterface.DrawVisualDebug");
		
		UGatherDebugInterface_DrawVisualDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGatherDebugInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGatherDebugInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.GatherDebugInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GetFriendlyName.GetFriendlyName
	 * 		Flags  -> ()
	 */
	class FString UGetFriendlyName::GetFriendlyName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GetFriendlyName.GetFriendlyName");
		
		UGetFriendlyName_GetFriendlyName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GetFriendlyName.GetFriendlyIcon
	 * 		Flags  -> ()
	 */
	class UTexture2D* UGetFriendlyName::GetFriendlyIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GetFriendlyName.GetFriendlyIcon");
		
		UGetFriendlyName_GetFriendlyIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGetFriendlyName.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGetFriendlyName::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.GetFriendlyName");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGibComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGibComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.GibComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.GlassActor.OnApplyDamageToWindow__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        ImpulseDir                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ImpulseStrength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGlassActor::OnApplyDamageToWindow__DelegateSignature(float DamageAmount, const struct FCoreUObject_FVector& HitLocation, const struct FCoreUObject_FVector& ImpulseDir, float ImpulseStrength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.GlassActor.OnApplyDamageToWindow__DelegateSignature");
		
		AGlassActor_OnApplyDamageToWindow__DelegateSignature_Params params {};
		params.DamageAmount = DamageAmount;
		params.HitLocation = HitLocation;
		params.ImpulseDir = ImpulseDir;
		params.ImpulseStrength = ImpulseStrength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GlassActor.Multicast_TakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGlassActor::Multicast_TakeDamage(float DamageAmount, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GlassActor.Multicast_TakeDamage");
		
		AGlassActor_Multicast_TakeDamage_Params params {};
		params.DamageAmount = DamageAmount;
		params.DamageEvent = DamageEvent;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GlassActor.Multicast_ApplyDamageToWindow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        ImpulseDir                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ImpulseStrength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGlassActor::Multicast_ApplyDamageToWindow(float DamageAmount, const struct FCoreUObject_FVector& HitLocation, const struct FCoreUObject_FVector& ImpulseDir, float ImpulseStrength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GlassActor.Multicast_ApplyDamageToWindow");
		
		AGlassActor_Multicast_ApplyDamageToWindow_Params params {};
		params.DamageAmount = DamageAmount;
		params.HitLocation = HitLocation;
		params.ImpulseDir = ImpulseDir;
		params.ImpulseStrength = ImpulseStrength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GlassActor.GetRandomShatteredGlassMaterial
	 * 		Flags  -> ()
	 */
	class UMaterialInterface* AGlassActor::GetRandomShatteredGlassMaterial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GlassActor.GetRandomShatteredGlassMaterial");
		
		AGlassActor_GetRandomShatteredGlassMaterial_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GlassActor.GetRandomGlassMaterial
	 * 		Flags  -> ()
	 */
	class UMaterialInterface* AGlassActor::GetRandomGlassMaterial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GlassActor.GetRandomGlassMaterial");
		
		AGlassActor_GetRandomGlassMaterial_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGlassActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGlassActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.GlassActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GrenadeLauncher.UpdateServerPath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FVector_NetQuantize>                 Path                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Bounce1                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Bounce2                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Bounce3                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGrenadeLauncher::UpdateServerPath(TArray<struct FVector_NetQuantize> Path, int32_t Bounce1, int32_t Bounce2, int32_t Bounce3)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GrenadeLauncher.UpdateServerPath");
		
		AGrenadeLauncher_UpdateServerPath_Params params {};
		params.Path = Path;
		params.Bounce1 = Bounce1;
		params.Bounce2 = Bounce2;
		params.Bounce3 = Bounce3;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GrenadeLauncher.OnRep_GrenadePath
	 * 		Flags  -> ()
	 */
	void AGrenadeLauncher::OnRep_GrenadePath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GrenadeLauncher.OnRep_GrenadePath");
		
		AGrenadeLauncher_OnRep_GrenadePath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGrenadeLauncher.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGrenadeLauncher::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.GrenadeLauncher");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GrenadeProjectile.OnDetonate_Blueprint
	 * 		Flags  -> ()
	 */
	void AGrenadeProjectile::OnDetonate_Blueprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GrenadeProjectile.OnDetonate_Blueprint");
		
		AGrenadeProjectile_OnDetonate_Blueprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GrenadeProjectile.OnDetonate
	 * 		Flags  -> ()
	 */
	void AGrenadeProjectile::OnDetonate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GrenadeProjectile.OnDetonate");
		
		AGrenadeProjectile_OnDetonate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGrenadeProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGrenadeProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.GrenadeProjectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GunGameGM.FindTopKillers
	 * 		Flags  -> ()
	 */
	TArray<class AReadyOrNotPlayerState*> AGunGameGM::FindTopKillers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GunGameGM.FindTopKillers");
		
		AGunGameGM_FindTopKillers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.GunGameGM.EquipNextGun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAdvanceGunIdx                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABaseItem* AGunGameGM::EquipNextGun(class APlayerCharacter* Player, bool bAdvanceGunIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.GunGameGM.EquipNextGun");
		
		AGunGameGM_EquipNextGun_Params params {};
		params.Player = Player;
		params.bAdvanceGunIdx = bAdvanceGunIdx;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGunGameGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGunGameGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.GunGameGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGunGameGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGunGameGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.GunGameGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHardcoreMoneyGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHardcoreMoneyGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HardcoreMoneyGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHardcoreMoneyGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHardcoreMoneyGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HardcoreMoneyGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HardCoverCombatMove.TrackNewEnemy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        NewTrackedEnemy                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHardCoverCombatMove::TrackNewEnemy(class AReadyOrNotCharacter* NewTrackedEnemy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HardCoverCombatMove.TrackNewEnemy");
		
		UHardCoverCombatMove_TrackNewEnemy_Params params {};
		params.NewTrackedEnemy = NewTrackedEnemy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HardCoverCombatMove.OnTakeCoverAtLandmarkActivityFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               Activity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHardCoverCombatMove::OnTakeCoverAtLandmarkActivityFinished(class UBaseActivity* Activity, class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HardCoverCombatMove.OnTakeCoverAtLandmarkActivityFinished");
		
		UHardCoverCombatMove_OnTakeCoverAtLandmarkActivityFinished_Params params {};
		params.Activity = Activity;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HardCoverCombatMove.OnTakeCoverActivityFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               Activity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHardCoverCombatMove::OnTakeCoverActivityFinished(class UBaseActivity* Activity, class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HardCoverCombatMove.OnTakeCoverActivityFinished");
		
		UHardCoverCombatMove_OnTakeCoverActivityFinished_Params params {};
		params.Activity = Activity;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.HardCoverCombatMove.CoverFoundDelegate__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UHardCoverCombatMove::CoverFoundDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.HardCoverCombatMove.CoverFoundDelegate__DelegateSignature");
		
		UHardCoverCombatMove_CoverFoundDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.HardCoverCombatMove.CoverEventDelegate__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UHardCoverCombatMove::CoverEventDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.HardCoverCombatMove.CoverEventDelegate__DelegateSignature");
		
		UHardCoverCombatMove_CoverEventDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHardCoverCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHardCoverCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HardCoverCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHeadwear.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHeadwear::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Headwear");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HealthStatusWidget.UpdateIconColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              CurrentValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthStatusWidget::UpdateIconColor(float CurrentValue, float MinValue, float MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HealthStatusWidget.UpdateIconColor");
		
		UHealthStatusWidget_UpdateIconColor_Params params {};
		params.CurrentValue = CurrentValue;
		params.MinValue = MinValue;
		params.MaxValue = MaxValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HealthStatusWidget.UpdateHealthPercentage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              CurrentValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHealthStatusWidget::UpdateHealthPercentage(float CurrentValue, float MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HealthStatusWidget.UpdateHealthPercentage");
		
		UHealthStatusWidget_UpdateHealthPercentage_Params params {};
		params.CurrentValue = CurrentValue;
		params.MaxValue = MaxValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HealthStatusWidget.AutoDetermineIconImage
	 * 		Flags  -> ()
	 */
	void UHealthStatusWidget::AutoDetermineIconImage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HealthStatusWidget.AutoDetermineIconImage");
		
		UHealthStatusWidget_AutoDetermineIconImage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHealthStatusWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHealthStatusWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HealthStatusWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHesitateActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHesitateActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HesitateActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHidingCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHidingCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HidingCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HighgroundVolume.OnOverlapEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AHighgroundVolume::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HighgroundVolume.OnOverlapEnd");
		
		AHighgroundVolume_OnOverlapEnd_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HighgroundVolume.OnOverlapBegin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AHighgroundVolume::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HighgroundVolume.OnOverlapBegin");
		
		AHighgroundVolume_OnOverlapBegin_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HighgroundVolume.OnAudioFinished
	 * 		Flags  -> ()
	 */
	void AHighgroundVolume::OnAudioFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HighgroundVolume.OnAudioFinished");
		
		AHighgroundVolume_OnAudioFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHighgroundVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHighgroundVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HighgroundVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHoldActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHoldActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HoldActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HostMigrationManager.SaveState
	 * 		Flags  -> ()
	 */
	void UHostMigrationManager::SaveState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HostMigrationManager.SaveState");
		
		UHostMigrationManager_SaveState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HostMigrationManager.ReturnToMainMenu
	 * 		Flags  -> ()
	 */
	void UHostMigrationManager::ReturnToMainMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HostMigrationManager.ReturnToMainMenu");
		
		UHostMigrationManager_ReturnToMainMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HostMigrationManager.OnMigrationSessionFoundSuccess
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FBlueprintSessionResult>             Results                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UHostMigrationManager::OnMigrationSessionFoundSuccess(TArray<struct FBlueprintSessionResult> Results)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HostMigrationManager.OnMigrationSessionFoundSuccess");
		
		UHostMigrationManager_OnMigrationSessionFoundSuccess_Params params {};
		params.Results = Results;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HostMigrationManager.OnMigrationSessionFoundFailed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FBlueprintSessionResult>             Results                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UHostMigrationManager::OnMigrationSessionFoundFailed(TArray<struct FBlueprintSessionResult> Results)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HostMigrationManager.OnMigrationSessionFoundFailed");
		
		UHostMigrationManager_OnMigrationSessionFoundFailed_Params params {};
		params.Results = Results;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HostMigrationManager.OnLobbySuccess
	 * 		Flags  -> ()
	 */
	void UHostMigrationManager::OnLobbySuccess()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HostMigrationManager.OnLobbySuccess");
		
		UHostMigrationManager_OnLobbySuccess_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HostMigrationManager.FindMigrationSession
	 * 		Flags  -> ()
	 */
	void UHostMigrationManager::FindMigrationSession()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HostMigrationManager.FindMigrationSession");
		
		UHostMigrationManager_FindMigrationSession_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HostMigrationManager.CreateMigrationSession
	 * 		Flags  -> ()
	 */
	void UHostMigrationManager::CreateMigrationSession()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HostMigrationManager.CreateMigrationSession");
		
		UHostMigrationManager_CreateMigrationSession_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHostMigrationManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHostMigrationManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HostMigrationManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HotkeysWidget.SetHotkeyVisibility
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCondition                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHotkeysWidget::SetHotkeyVisibility(class UWidget* Widget, bool bCondition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HotkeysWidget.SetHotkeyVisibility");
		
		UHotkeysWidget_SetHotkeyVisibility_Params params {};
		params.Widget = Widget;
		params.bCondition = bCondition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HotkeysWidget.RefreshHotkeyInput
	 * 		Flags  -> ()
	 */
	void UHotkeysWidget::RefreshHotkeyInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HotkeysWidget.RefreshHotkeyInput");
		
		UHotkeysWidget_RefreshHotkeyInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHotkeysWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHotkeysWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HotkeysWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HotkeyWidget.SetHotkeyRemainingUses
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InRemainingUses                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHotkeyWidget::SetHotkeyRemainingUses(int32_t InRemainingUses)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HotkeyWidget.SetHotkeyRemainingUses");
		
		UHotkeyWidget_SetHotkeyRemainingUses_Params params {};
		params.InRemainingUses = InRemainingUses;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HotkeyWidget.SetHotkeyImage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSlateBrush                                 Brush                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UHotkeyWidget::SetHotkeyImage(const struct FSlateBrush& Brush)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HotkeyWidget.SetHotkeyImage");
		
		UHotkeyWidget_SetHotkeyImage_Params params {};
		params.Brush = Brush;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HotkeyWidget.RefreshHotkey
	 * 		Flags  -> ()
	 */
	void UHotkeyWidget::RefreshHotkey()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HotkeyWidget.RefreshHotkey");
		
		UHotkeyWidget_RefreshHotkey_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HotkeyWidget.PlayReleasedAnimation
	 * 		Flags  -> ()
	 */
	void UHotkeyWidget::PlayReleasedAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HotkeyWidget.PlayReleasedAnimation");
		
		UHotkeyWidget_PlayReleasedAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HotkeyWidget.PlayPressedAnimation
	 * 		Flags  -> ()
	 */
	void UHotkeyWidget::PlayPressedAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HotkeyWidget.PlayPressedAnimation");
		
		UHotkeyWidget_PlayPressedAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHotkeyWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHotkeyWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HotkeyWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHudWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHudWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HudWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.UpdateMapFloors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FBuildingFloor>                      Floors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD_V2::UpdateMapFloors(TArray<struct FBuildingFloor> Floors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.UpdateMapFloors");
		
		UHumanCharacterHUD_V2_UpdateMapFloors_Params params {};
		params.Floors = Floors;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.TeamChatPressed
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD_V2::TeamChatPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.TeamChatPressed");
		
		UHumanCharacterHUD_V2_TeamChatPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.ShowTutorialPrompt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MessageID                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstShowing                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        MessageTitle                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class FText>                                MessageContent                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD_V2::ShowTutorialPrompt(const class FString& MessageID, bool bFirstShowing, const class FText& MessageTitle, TArray<class FText> MessageContent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.ShowTutorialPrompt");
		
		UHumanCharacterHUD_V2_ShowTutorialPrompt_Params params {};
		params.MessageID = MessageID;
		params.bFirstShowing = bFirstShowing;
		params.MessageTitle = MessageTitle;
		params.MessageContent = MessageContent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.ShowTutorialOverview
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MessageID                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        MessageTitle                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class FText>                                MessageContent                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD_V2::ShowTutorialOverview(const class FString& MessageID, const class FText& MessageTitle, TArray<class FText> MessageContent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.ShowTutorialOverview");
		
		UHumanCharacterHUD_V2_ShowTutorialOverview_Params params {};
		params.MessageID = MessageID;
		params.MessageTitle = MessageTitle;
		params.MessageContent = MessageContent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.ShowHUD
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD_V2::ShowHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.ShowHUD");
		
		UHumanCharacterHUD_V2_ShowHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.RemovePlayerActionPrompt_Reserved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InSlot                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD_V2::RemovePlayerActionPrompt_Reserved(int32_t InSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.RemovePlayerActionPrompt_Reserved");
		
		UHumanCharacterHUD_V2_RemovePlayerActionPrompt_Reserved_Params params {};
		params.InSlot = InSlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.RemovePlayerActionPrompt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InSlot                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD_V2::RemovePlayerActionPrompt(int32_t InSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.RemovePlayerActionPrompt");
		
		UHumanCharacterHUD_V2_RemovePlayerActionPrompt_Params params {};
		params.InSlot = InSlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.RemoveMapActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMapActorComponent*                          MapActorComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD_V2::RemoveMapActor(class UMapActorComponent* MapActorComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.RemoveMapActor");
		
		UHumanCharacterHUD_V2_RemoveMapActor_Params params {};
		params.MapActorComponent = MapActorComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.ReflectHUDSettings
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD_V2::ReflectHUDSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.ReflectHUDSettings");
		
		UHumanCharacterHUD_V2_ReflectHUDSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.OnInventoryItemsChanged
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD_V2::OnInventoryItemsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.OnInventoryItemsChanged");
		
		UHumanCharacterHUD_V2_OnInventoryItemsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.IsActionSlotInUse_Reserved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InSlot                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UHumanCharacterHUD_V2::IsActionSlotInUse_Reserved(int32_t InSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.IsActionSlotInUse_Reserved");
		
		UHumanCharacterHUD_V2_IsActionSlotInUse_Reserved_Params params {};
		params.InSlot = InSlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.IsActionSlotInUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InSlot                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UHumanCharacterHUD_V2::IsActionSlotInUse(int32_t InSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.IsActionSlotInUse");
		
		UHumanCharacterHUD_V2_IsActionSlotInUse_Params params {};
		params.InSlot = InSlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.HideTutorialPrompt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MessageID                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD_V2::HideTutorialPrompt(const class FString& MessageID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.HideTutorialPrompt");
		
		UHumanCharacterHUD_V2_HideTutorialPrompt_Params params {};
		params.MessageID = MessageID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.HideTutorialOverview
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MessageID                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD_V2::HideTutorialOverview(const class FString& MessageID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.HideTutorialOverview");
		
		UHumanCharacterHUD_V2_HideTutorialOverview_Params params {};
		params.MessageID = MessageID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.HideHUD
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD_V2::HideHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.HideHUD");
		
		UHumanCharacterHUD_V2_HideHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.ClearAllPlayerActionPrompts
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD_V2::ClearAllPlayerActionPrompts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.ClearAllPlayerActionPrompts");
		
		UHumanCharacterHUD_V2_ClearAllPlayerActionPrompts_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.ChatPressed
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD_V2::ChatPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.ChatPressed");
		
		UHumanCharacterHUD_V2_ChatPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.AssignPlayerActionPromptToFreeSlot_Reserved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        InputKey                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInputEvent                                        InputEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        InActionText                                               (Parm, NativeAccessSpecifierPublic)
	 * 		class FString                                      InColorLabel                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoopAnimation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UHumanCharacterHUD_V2::AssignPlayerActionPromptToFreeSlot_Reserved(const struct FKey& InputKey, EInputEvent InputEvent, const class FText& InActionText, const class FString& InColorLabel, bool bAnimate, bool bLoopAnimation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.AssignPlayerActionPromptToFreeSlot_Reserved");
		
		UHumanCharacterHUD_V2_AssignPlayerActionPromptToFreeSlot_Reserved_Params params {};
		params.InputKey = InputKey;
		params.InputEvent = InputEvent;
		params.InActionText = InActionText;
		params.InColorLabel = InColorLabel;
		params.bAnimate = bAnimate;
		params.bLoopAnimation = bLoopAnimation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.AssignPlayerActionPromptToFreeSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        InputKey                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInputEvent                                        InputEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        InActionText                                               (Parm, NativeAccessSpecifierPublic)
	 * 		class FString                                      InColorLabel                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoopAnimation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD_V2::AssignPlayerActionPromptToFreeSlot(const struct FKey& InputKey, EInputEvent InputEvent, const class FText& InActionText, const class FString& InColorLabel, bool bAnimate, bool bLoopAnimation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.AssignPlayerActionPromptToFreeSlot");
		
		UHumanCharacterHUD_V2_AssignPlayerActionPromptToFreeSlot_Params params {};
		params.InputKey = InputKey;
		params.InputEvent = InputEvent;
		params.InActionText = InActionText;
		params.InColorLabel = InColorLabel;
		params.bAnimate = bAnimate;
		params.bLoopAnimation = bLoopAnimation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.AssignPlayerActionPrompt_Reserved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InSlot                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FKey                                        InputKey                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInputEvent                                        InputEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        InActionText                                               (Parm, NativeAccessSpecifierPublic)
	 * 		class FString                                      InColorLabel                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoopAnimation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD_V2::AssignPlayerActionPrompt_Reserved(int32_t InSlot, const struct FKey& InputKey, EInputEvent InputEvent, const class FText& InActionText, const class FString& InColorLabel, bool bAnimate, bool bLoopAnimation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.AssignPlayerActionPrompt_Reserved");
		
		UHumanCharacterHUD_V2_AssignPlayerActionPrompt_Reserved_Params params {};
		params.InSlot = InSlot;
		params.InputKey = InputKey;
		params.InputEvent = InputEvent;
		params.InActionText = InActionText;
		params.InColorLabel = InColorLabel;
		params.bAnimate = bAnimate;
		params.bLoopAnimation = bLoopAnimation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.AssignPlayerActionPrompt_Custom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InSlot                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        InCustomPromptText                                         (Parm, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoopAnimation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD_V2::AssignPlayerActionPrompt_Custom(int32_t InSlot, const class FText& InCustomPromptText, bool bAnimate, bool bLoopAnimation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.AssignPlayerActionPrompt_Custom");
		
		UHumanCharacterHUD_V2_AssignPlayerActionPrompt_Custom_Params params {};
		params.InSlot = InSlot;
		params.InCustomPromptText = InCustomPromptText;
		params.bAnimate = bAnimate;
		params.bLoopAnimation = bLoopAnimation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.AssignPlayerActionPrompt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InSlot                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FKey                                        InputKey                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInputEvent                                        InputEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        InActionText                                               (Parm, NativeAccessSpecifierPublic)
	 * 		class FString                                      InColorLabel                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoopAnimation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD_V2::AssignPlayerActionPrompt(int32_t InSlot, const struct FKey& InputKey, EInputEvent InputEvent, const class FText& InActionText, const class FString& InColorLabel, bool bAnimate, bool bLoopAnimation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.AssignPlayerActionPrompt");
		
		UHumanCharacterHUD_V2_AssignPlayerActionPrompt_Params params {};
		params.InSlot = InSlot;
		params.InputKey = InputKey;
		params.InputEvent = InputEvent;
		params.InActionText = InActionText;
		params.InColorLabel = InColorLabel;
		params.bAnimate = bAnimate;
		params.bLoopAnimation = bLoopAnimation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.AddScorePopup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        ScoreText                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ScoreValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGive                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD_V2::AddScorePopup(const class FText& ScoreText, int32_t ScoreValue, bool bGive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.AddScorePopup");
		
		UHumanCharacterHUD_V2_AddScorePopup_Params params {};
		params.ScoreText = ScoreText;
		params.ScoreValue = ScoreValue;
		params.bGive = bGive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD_V2.AddMapActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMapActorComponent*                          MapActorComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      MapActorIconWidgetClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSlateBrush                                 IconBrush                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                IconColor                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                IconTextColor                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RotationOffset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMapActorWidget* UHumanCharacterHUD_V2::AddMapActor(class UMapActorComponent* MapActorComponent, class UClass* MapActorIconWidgetClass, const struct FSlateBrush& IconBrush, const struct FLinearColor& IconColor, const struct FLinearColor& IconTextColor, float RotationOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD_V2.AddMapActor");
		
		UHumanCharacterHUD_V2_AddMapActor_Params params {};
		params.MapActorComponent = MapActorComponent;
		params.MapActorIconWidgetClass = MapActorIconWidgetClass;
		params.IconBrush = IconBrush;
		params.IconColor = IconColor;
		params.IconTextColor = IconTextColor;
		params.RotationOffset = RotationOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHumanCharacterHUD_V2.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHumanCharacterHUD_V2::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HumanCharacterHUD_V2");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IconWidget.GetAttachedObjectName
	 * 		Flags  -> ()
	 */
	class FString UIconWidget::GetAttachedObjectName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IconWidget.GetAttachedObjectName");
		
		UIconWidget_GetAttachedObjectName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IconWidget.GetAttachedObjectIcon
	 * 		Flags  -> ()
	 */
	class UTexture2D* UIconWidget::GetAttachedObjectIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IconWidget.GetAttachedObjectIcon");
		
		UIconWidget_GetAttachedObjectIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UIconWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UIconWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.IconWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AImpactEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AImpactEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ImpactEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncapacitatedHuman.SelectAllInGroup
	 * 		Flags  -> ()
	 */
	void AIncapacitatedHuman::SelectAllInGroup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncapacitatedHuman.SelectAllInGroup");
		
		AIncapacitatedHuman_SelectAllInGroup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncapacitatedHuman.MakeMasterInGroup
	 * 		Flags  -> ()
	 */
	void AIncapacitatedHuman::MakeMasterInGroup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncapacitatedHuman.MakeMasterInGroup");
		
		AIncapacitatedHuman_MakeMasterInGroup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncapacitatedHuman.HasBeenReported
	 * 		Flags  -> ()
	 */
	bool AIncapacitatedHuman::HasBeenReported()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncapacitatedHuman.HasBeenReported");
		
		AIncapacitatedHuman_HasBeenReported_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncapacitatedHuman.EnableOutline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActorOutlineType                                  OutlineType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AIncapacitatedHuman::EnableOutline(EActorOutlineType OutlineType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncapacitatedHuman.EnableOutline");
		
		AIncapacitatedHuman_EnableOutline_Params params {};
		params.OutlineType = OutlineType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncapacitatedHuman.DisableOutline
	 * 		Flags  -> ()
	 */
	void AIncapacitatedHuman::DisableOutline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncapacitatedHuman.DisableOutline");
		
		AIncapacitatedHuman_DisableOutline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AIncapacitatedHuman.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AIncapacitatedHuman::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.IncapacitatedHuman");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationClue.RevealNextClue
	 * 		Flags  -> ()
	 */
	void AIncriminationClue::RevealNextClue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationClue.RevealNextClue");
		
		AIncriminationClue_RevealNextClue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationClue.OnRep_OnClueStateChanged
	 * 		Flags  -> ()
	 */
	void AIncriminationClue::OnRep_OnClueStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationClue.OnRep_OnClueStateChanged");
		
		AIncriminationClue_OnRep_OnClueStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationClue.OnRep_OnClueFound
	 * 		Flags  -> ()
	 */
	void AIncriminationClue::OnRep_OnClueFound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationClue.OnRep_OnClueFound");
		
		AIncriminationClue_OnRep_OnClueFound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.IncriminationClue.OnClueFound__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AIncriminationClue*                          ClueActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ClueFounder                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AIncriminationClue::OnClueFound__DelegateSignature(class AIncriminationClue* ClueActor, class AActor* ClueFounder)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.IncriminationClue.OnClueFound__DelegateSignature");
		
		AIncriminationClue_OnClueFound__DelegateSignature_Params params {};
		params.ClueActor = ClueActor;
		params.ClueFounder = ClueFounder;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationClue.OnClueFound
	 * 		Flags  -> ()
	 */
	void AIncriminationClue::OnClueFound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationClue.OnClueFound");
		
		AIncriminationClue_OnClueFound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationClue.IsClueFound
	 * 		Flags  -> ()
	 */
	bool AIncriminationClue::IsClueFound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationClue.IsClueFound");
		
		AIncriminationClue_IsClueFound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationClue.Init
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AIncriminationClueSpawnPoint*                OwningSpawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      InClueNumber                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        InClueName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        InClueFoundMessage                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              InShowObjectiveMarkerIn                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AIncriminationClue::Init(class AIncriminationClueSpawnPoint* OwningSpawn, unsigned char InClueNumber, const class FText& InClueName, const class FText& InClueFoundMessage, float InShowObjectiveMarkerIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationClue.Init");
		
		AIncriminationClue_Init_Params params {};
		params.OwningSpawn = OwningSpawn;
		params.InClueNumber = InClueNumber;
		params.InClueName = InClueName;
		params.InClueFoundMessage = InClueFoundMessage;
		params.InShowObjectiveMarkerIn = InShowObjectiveMarkerIn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AIncriminationClue.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AIncriminationClue::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.IncriminationClue");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AIncriminationClueSpawnPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AIncriminationClueSpawnPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.IncriminationClueSpawnPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGM.OnEvidencePickedUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      PickupActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AIncriminationGM::OnEvidencePickedUp(class AActor* PickupActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGM.OnEvidencePickedUp");
		
		AIncriminationGM_OnEvidencePickedUp_Params params {};
		params.PickupActor = PickupActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGM.OnEvidenceDropped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      DropActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AIncriminationGM::OnEvidenceDropped(class AActor* DropActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGM.OnEvidenceDropped");
		
		AIncriminationGM_OnEvidenceDropped_Params params {};
		params.DropActor = DropActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGM.OnClueFound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AIncriminationClue*                          ClueActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ClueFounder                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AIncriminationGM::OnClueFound(class AIncriminationClue* ClueActor, class AActor* ClueFounder)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGM.OnClueFound");
		
		AIncriminationGM_OnClueFound_Params params {};
		params.ClueActor = ClueActor;
		params.ClueFounder = ClueFounder;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGM.HasVisitedAllEvidenceSpawns
	 * 		Flags  -> ()
	 */
	bool AIncriminationGM::HasVisitedAllEvidenceSpawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGM.HasVisitedAllEvidenceSpawns");
		
		AIncriminationGM_HasVisitedAllEvidenceSpawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AIncriminationGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AIncriminationGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.IncriminationGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGS.OnRep_OnPreviousActiveClueChanged
	 * 		Flags  -> ()
	 */
	void AIncriminationGS::OnRep_OnPreviousActiveClueChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGS.OnRep_OnPreviousActiveClueChanged");
		
		AIncriminationGS_OnRep_OnPreviousActiveClueChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGS.OnRep_OnIntelStateChanged
	 * 		Flags  -> ()
	 */
	void AIncriminationGS::OnRep_OnIntelStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGS.OnRep_OnIntelStateChanged");
		
		AIncriminationGS_OnRep_OnIntelStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGS.OnRep_OnIntelSearchAreaChosen
	 * 		Flags  -> ()
	 */
	void AIncriminationGS::OnRep_OnIntelSearchAreaChosen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGS.OnRep_OnIntelSearchAreaChosen");
		
		AIncriminationGS_OnRep_OnIntelSearchAreaChosen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGS.OnRep_OnIntelBuildingChosen
	 * 		Flags  -> ()
	 */
	void AIncriminationGS::OnRep_OnIntelBuildingChosen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGS.OnRep_OnIntelBuildingChosen");
		
		AIncriminationGS_OnRep_OnIntelBuildingChosen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGS.OnRep_OnCluesChanged
	 * 		Flags  -> ()
	 */
	void AIncriminationGS::OnRep_OnCluesChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGS.OnRep_OnCluesChanged");
		
		AIncriminationGS_OnRep_OnCluesChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGS.OnRep_OnActiveClueChanged
	 * 		Flags  -> ()
	 */
	void AIncriminationGS::OnRep_OnActiveClueChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGS.OnRep_OnActiveClueChanged");
		
		AIncriminationGS_OnRep_OnActiveClueChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.IncriminationGS.OnEvidenceSearchAreaChosen__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASplineTrigger_Incrimination*                EvidenceSearchArea                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AIncriminationGS::OnEvidenceSearchAreaChosen__DelegateSignature(class ASplineTrigger_Incrimination* EvidenceSearchArea)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.IncriminationGS.OnEvidenceSearchAreaChosen__DelegateSignature");
		
		AIncriminationGS_OnEvidenceSearchAreaChosen__DelegateSignature_Params params {};
		params.EvidenceSearchArea = EvidenceSearchArea;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.IncriminationGS.OnEvidenceBuildingChosen__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABuildingTrigger_Incrimination*              EvidenceSearchArea                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AIncriminationGS::OnEvidenceBuildingChosen__DelegateSignature(class ABuildingTrigger_Incrimination* EvidenceSearchArea)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.IncriminationGS.OnEvidenceBuildingChosen__DelegateSignature");
		
		AIncriminationGS_OnEvidenceBuildingChosen__DelegateSignature_Params params {};
		params.EvidenceSearchArea = EvidenceSearchArea;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.IncriminationGS.OnEvidenceActorStateChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AEvidenceActor*                              EvidenceActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEvidenceActorState                                NewEvidenceState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bExtracted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AIncriminationGS::OnEvidenceActorStateChanged__DelegateSignature(class AEvidenceActor* EvidenceActor, EEvidenceActorState NewEvidenceState, bool bExtracted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.IncriminationGS.OnEvidenceActorStateChanged__DelegateSignature");
		
		AIncriminationGS_OnEvidenceActorStateChanged__DelegateSignature_Params params {};
		params.EvidenceActor = EvidenceActor;
		params.NewEvidenceState = NewEvidenceState;
		params.bExtracted = bExtracted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.IncriminationGS.OnCluesChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AIncriminationClue*>                  Clues                                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AIncriminationGS::OnCluesChanged__DelegateSignature(TArray<class AIncriminationClue*> Clues)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.IncriminationGS.OnCluesChanged__DelegateSignature");
		
		AIncriminationGS_OnCluesChanged__DelegateSignature_Params params {};
		params.Clues = Clues;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.IncriminationGS.OnActiveClueChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AIncriminationClue*                          ActiveClue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AIncriminationGS::OnActiveClueChanged__DelegateSignature(class AIncriminationClue* ActiveClue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.IncriminationGS.OnActiveClueChanged__DelegateSignature");
		
		AIncriminationGS_OnActiveClueChanged__DelegateSignature_Params params {};
		params.ActiveClue = ActiveClue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGS.GetClue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ClueNumber                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccess                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMustBeFound                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AIncriminationClue* AIncriminationGS::GetClue(int32_t ClueNumber, bool* bSuccess, bool bMustBeFound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGS.GetClue");
		
		AIncriminationGS_GetClue_Params params {};
		params.ClueNumber = ClueNumber;
		params.bMustBeFound = bMustBeFound;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bSuccess != nullptr)
			*bSuccess = params.bSuccess;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGS.GetAllCluesOfNumber
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ClueNumber                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class AIncriminationClue*> AIncriminationGS::GetAllCluesOfNumber(int32_t ClueNumber)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGS.GetAllCluesOfNumber");
		
		AIncriminationGS_GetAllCluesOfNumber_Params params {};
		params.ClueNumber = ClueNumber;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGS.DoesPlayerPossessAnyClue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AIncriminationGS::DoesPlayerPossessAnyClue(class APlayerCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGS.DoesPlayerPossessAnyClue");
		
		AIncriminationGS_DoesPlayerPossessAnyClue_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGS.AnyLowerCluesFound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ClueNumber                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AIncriminationGS::AnyLowerCluesFound(int32_t ClueNumber)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGS.AnyLowerCluesFound");
		
		AIncriminationGS_AnyLowerCluesFound_Params params {};
		params.ClueNumber = ClueNumber;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IncriminationGS.AnyHigherCluesFound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ClueNumber                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AIncriminationGS::AnyHigherCluesFound(int32_t ClueNumber)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IncriminationGS.AnyHigherCluesFound");
		
		AIncriminationGS_AnyHigherCluesFound_Params params {};
		params.ClueNumber = ClueNumber;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AIncriminationGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AIncriminationGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.IncriminationGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.ToggleObjectiveMarker
	 * 		Flags  -> ()
	 */
	void APVPTriggerBox::ToggleObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.ToggleObjectiveMarker");
		
		APVPTriggerBox_ToggleObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.StartTimerEvent
	 * 		Flags  -> ()
	 */
	void APVPTriggerBox::StartTimerEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.StartTimerEvent");
		
		APVPTriggerBox_StartTimerEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.ShowObjectiveMarker
	 * 		Flags  -> ()
	 */
	void APVPTriggerBox::ShowObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.ShowObjectiveMarker");
		
		APVPTriggerBox_ShowObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.ResumeTimerEvent
	 * 		Flags  -> ()
	 */
	void APVPTriggerBox::ResumeTimerEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.ResumeTimerEvent");
		
		APVPTriggerBox_ResumeTimerEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.PauseTimerEvent
	 * 		Flags  -> ()
	 */
	void APVPTriggerBox::PauseTimerEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.PauseTimerEvent");
		
		APVPTriggerBox_PauseTimerEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.OnTimerExpired
	 * 		Flags  -> ()
	 */
	void APVPTriggerBox::OnTimerExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.OnTimerExpired");
		
		APVPTriggerBox_OnTimerExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.OnRep_CharactersInTriggerBoxUpdated
	 * 		Flags  -> ()
	 */
	void APVPTriggerBox::OnRep_CharactersInTriggerBoxUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.OnRep_CharactersInTriggerBoxUpdated");
		
		APVPTriggerBox_OnRep_CharactersInTriggerBoxUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.OnEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APVPTriggerBox::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.OnEndOverlap");
		
		APVPTriggerBox_OnEndOverlap_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.OnBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APVPTriggerBox::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.OnBeginOverlap");
		
		APVPTriggerBox_OnBeginOverlap_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.IsPlayerOnAcceptedTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APVPTriggerBox::IsPlayerOnAcceptedTeam(class APlayerCharacter* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.IsPlayerOnAcceptedTeam");
		
		APVPTriggerBox_IsPlayerOnAcceptedTeam_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.IsActorInTriggerBox
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APVPTriggerBox::IsActorInTriggerBox(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.IsActorInTriggerBox");
		
		APVPTriggerBox_IsActorInTriggerBox_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.HideObjectiveMarker
	 * 		Flags  -> ()
	 */
	void APVPTriggerBox::HideObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.HideObjectiveMarker");
		
		APVPTriggerBox_HideObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.GetLastElapsedTime
	 * 		Flags  -> ()
	 */
	float APVPTriggerBox::GetLastElapsedTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.GetLastElapsedTime");
		
		APVPTriggerBox_GetLastElapsedTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.GetCurrentElapsedTime
	 * 		Flags  -> ()
	 */
	float APVPTriggerBox::GetCurrentElapsedTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.GetCurrentElapsedTime");
		
		APVPTriggerBox_GetCurrentElapsedTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.DoesActorHaveAnyAcceptedTags
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APVPTriggerBox::DoesActorHaveAnyAcceptedTags(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.DoesActorHaveAnyAcceptedTags");
		
		APVPTriggerBox_DoesActorHaveAnyAcceptedTags_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PVPTriggerBox.CancelTimerEvent
	 * 		Flags  -> ()
	 */
	void APVPTriggerBox::CancelTimerEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PVPTriggerBox.CancelTimerEvent");
		
		APVPTriggerBox_CancelTimerEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APVPTriggerBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APVPTriggerBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PVPTriggerBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AIncriminationTriggerBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AIncriminationTriggerBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.IncriminationTriggerBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.InGameLogSubsystem.OnLogMessageEnqueued__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UInGameLogSubsystem::OnLogMessageEnqueued__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.InGameLogSubsystem.OnLogMessageEnqueued__DelegateSignature");
		
		UInGameLogSubsystem_OnLogMessageEnqueued__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.InGameLogSubsystem.OnLogMessageDequeued__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UInGameLogSubsystem::OnLogMessageDequeued__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.InGameLogSubsystem.OnLogMessageDequeued__DelegateSignature");
		
		UInGameLogSubsystem_OnLogMessageDequeued__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InGameLogSubsystem.GetNextLogMessage_PVP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInGameLogMessage_PVP                       OutLogMessage                                              (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool UInGameLogSubsystem::GetNextLogMessage_PVP(struct FInGameLogMessage_PVP* OutLogMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InGameLogSubsystem.GetNextLogMessage_PVP");
		
		UInGameLogSubsystem_GetNextLogMessage_PVP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLogMessage != nullptr)
			*OutLogMessage = params.OutLogMessage;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InGameLogSubsystem.GetNextLogMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInGameLogMessage                           OutLogMessage                                              (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool UInGameLogSubsystem::GetNextLogMessage(struct FInGameLogMessage* OutLogMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InGameLogSubsystem.GetNextLogMessage");
		
		UInGameLogSubsystem_GetNextLogMessage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLogMessage != nullptr)
			*OutLogMessage = params.OutLogMessage;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InGameLogSubsystem.EnqueuePVPMessages
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FInGameLogMessage_PVP>               InLogMessages                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UInGameLogSubsystem::EnqueuePVPMessages(TArray<struct FInGameLogMessage_PVP> InLogMessages)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InGameLogSubsystem.EnqueuePVPMessages");
		
		UInGameLogSubsystem_EnqueuePVPMessages_Params params {};
		params.InLogMessages = InLogMessages;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InGameLogSubsystem.EnqueuePVPMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInGameLogMessage_PVP                       InLogMessage                                               (Parm, NativeAccessSpecifierPublic)
	 */
	void UInGameLogSubsystem::EnqueuePVPMessage(const struct FInGameLogMessage_PVP& InLogMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InGameLogSubsystem.EnqueuePVPMessage");
		
		UInGameLogSubsystem_EnqueuePVPMessage_Params params {};
		params.InLogMessage = InLogMessage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InGameLogSubsystem.EnqueueLogMessages
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FInGameLogMessage>                   InLogMessages                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UInGameLogSubsystem::EnqueueLogMessages(TArray<struct FInGameLogMessage> InLogMessages)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InGameLogSubsystem.EnqueueLogMessages");
		
		UInGameLogSubsystem_EnqueueLogMessages_Params params {};
		params.InLogMessages = InLogMessages;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InGameLogSubsystem.EnqueueLogMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInGameLogMessage                           InLogMessage                                               (Parm, NativeAccessSpecifierPublic)
	 */
	void UInGameLogSubsystem::EnqueueLogMessage(const struct FInGameLogMessage& InLogMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InGameLogSubsystem.EnqueueLogMessage");
		
		UInGameLogSubsystem_EnqueueLogMessage_Params params {};
		params.InLogMessage = InLogMessage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInGameLogSubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInGameLogSubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.InGameLogSubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.UpdateTickRate
	 * 		Flags  -> ()
	 */
	void UInteractableComponent::UpdateTickRate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.UpdateTickRate");
		
		UInteractableComponent_UpdateTickRate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.UpdateLOSForDistanceFade
	 * 		Flags  -> ()
	 */
	void UInteractableComponent::UpdateLOSForDistanceFade()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.UpdateLOSForDistanceFade");
		
		UInteractableComponent_UpdateLOSForDistanceFade_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.SetInteractionIconState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValid                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableComponent::SetInteractionIconState(bool bValid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.SetInteractionIconState");
		
		UInteractableComponent_SetInteractionIconState_Params params {};
		params.bValid = bValid;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.SetInteractionIconSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InInteractCircleSize                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InInteractIconSize                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableComponent::SetInteractionIconSize(float InInteractCircleSize, float InInteractIconSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.SetInteractionIconSize");
		
		UInteractableComponent_SetInteractionIconSize_Params params {};
		params.InInteractCircleSize = InInteractCircleSize;
		params.InInteractIconSize = InInteractIconSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.SetAnimatedIconName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        NewIconName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableComponent::SetAnimatedIconName(const class FName& NewIconName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.SetAnimatedIconName");
		
		UInteractableComponent_SetAnimatedIconName_Params params {};
		params.NewIconName = NewIconName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.ResetToOriginalLocation
	 * 		Flags  -> ()
	 */
	void UInteractableComponent::ResetToOriginalLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.ResetToOriginalLocation");
		
		UInteractableComponent_ResetToOriginalLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.OnInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            InteractInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableComponent::OnInteract(class APlayerCharacter* InteractInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.OnInteract");
		
		UInteractableComponent_OnInteract_Params params {};
		params.InteractInstigator = InteractInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.IsInteractionEnabledForController
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           InController                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInteractableComponent::IsInteractionEnabledForController(class APlayerController* InController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.IsInteractionEnabledForController");
		
		UInteractableComponent_IsInteractionEnabledForController_Params params {};
		params.InController = InController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.IsInteractionEnabledFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInteractableComponent::IsInteractionEnabledFor(class APlayerCharacter* InCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.IsInteractionEnabledFor");
		
		UInteractableComponent_IsInteractionEnabledFor_Params params {};
		params.InCharacter = InCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.IsIconVisible
	 * 		Flags  -> ()
	 */
	bool UInteractableComponent::IsIconVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.IsIconVisible");
		
		UInteractableComponent_IsIconVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.IsFocused
	 * 		Flags  -> ()
	 */
	bool UInteractableComponent::IsFocused()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.IsFocused");
		
		UInteractableComponent_IsFocused_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.IsBeingLookedAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           InPlayerController                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxRange                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LookatThreshold                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseActorLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInteractableComponent::IsBeingLookedAt(class APlayerController* InPlayerController, float MaxRange, float LookatThreshold, bool bUseActorLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.IsBeingLookedAt");
		
		UInteractableComponent_IsBeingLookedAt_Params params {};
		params.InPlayerController = InPlayerController;
		params.MaxRange = MaxRange;
		params.LookatThreshold = LookatThreshold;
		params.bUseActorLocation = bUseActorLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.InputActionNameMatchesAnyValidSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        InInputActionName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInteractableComponent::InputActionNameMatchesAnyValidSlot(const class FName& InInputActionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.InputActionNameMatchesAnyValidSlot");
		
		UInteractableComponent_InputActionNameMatchesAnyValidSlot_Params params {};
		params.InInputActionName = InInputActionName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.InputActionNameMatchesAnySlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        InInputActionName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInteractableComponent::InputActionNameMatchesAnySlot(const class FName& InInputActionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.InputActionNameMatchesAnySlot");
		
		UInteractableComponent_InputActionNameMatchesAnySlot_Params params {};
		params.InInputActionName = InInputActionName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.GetUseActor
	 * 		Flags  -> ()
	 */
	class AActor* UInteractableComponent::GetUseActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.GetUseActor");
		
		UInteractableComponent_GetUseActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.GetPlayersFocusing
	 * 		Flags  -> ()
	 */
	TArray<class APlayerCharacter*> UInteractableComponent::GetPlayersFocusing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.GetPlayersFocusing");
		
		UInteractableComponent_GetPlayersFocusing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.GetOriginalLocation_Relative
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector UInteractableComponent::GetOriginalLocation_Relative()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.GetOriginalLocation_Relative");
		
		UInteractableComponent_GetOriginalLocation_Relative_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.GetOriginalLocation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector UInteractableComponent::GetOriginalLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.GetOriginalLocation");
		
		UInteractableComponent_GetOriginalLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.GetOriginalIconName
	 * 		Flags  -> ()
	 */
	class FName UInteractableComponent::GetOriginalIconName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.GetOriginalIconName");
		
		UInteractableComponent_GetOriginalIconName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.GetDistanceFromPlayer
	 * 		Flags  -> ()
	 */
	float UInteractableComponent::GetDistanceFromPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.GetDistanceFromPlayer");
		
		UInteractableComponent_GetDistanceFromPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.EnableInteractionFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableComponent::EnableInteractionFor(class APlayerCharacter* InCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.EnableInteractionFor");
		
		UInteractableComponent_EnableInteractionFor_Params params {};
		params.InCharacter = InCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.EnableInteractable
	 * 		Flags  -> ()
	 */
	void UInteractableComponent::EnableInteractable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.EnableInteractable");
		
		UInteractableComponent_EnableInteractable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.DisableInteractionFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableComponent::DisableInteractionFor(class APlayerCharacter* InCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.DisableInteractionFor");
		
		UInteractableComponent_DisableInteractionFor_Params params {};
		params.InCharacter = InCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.DisableInteractable
	 * 		Flags  -> ()
	 */
	void UInteractableComponent::DisableInteractable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.DisableInteractable");
		
		UInteractableComponent_DisableInteractable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.CanInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bLog                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInteractableComponent::CanInteract(bool bLog)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.CanInteract");
		
		UInteractableComponent_CanInteract_Params params {};
		params.bLog = bLog;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractableComponent.AnyActionSlotValid
	 * 		Flags  -> ()
	 */
	bool UInteractableComponent::AnyActionSlotValid()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractableComponent.AnyActionSlotValid");
		
		UInteractableComponent_AnyActionSlotValid_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInteractableComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInteractableComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.InteractableComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractionActor.Server_TryUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AInteractionActor::Server_TryUse(class AActor* User)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractionActor.Server_TryUse");
		
		AInteractionActor_Server_TryUse_Params params {};
		params.User = User;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractionActor.Server_EndUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AInteractionActor::Server_EndUse(class AActor* User)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractionActor.Server_EndUse");
		
		AInteractionActor_Server_EndUse_Params params {};
		params.User = User;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractionActor.OnActorUsedEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AInteractionActor::OnActorUsedEnd(class AActor* User)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractionActor.OnActorUsedEnd");
		
		AInteractionActor_OnActorUsedEnd_Params params {};
		params.User = User;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractionActor.OnActorUsed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AInteractionActor::OnActorUsed(class AActor* User)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractionActor.OnActorUsed");
		
		AInteractionActor_OnActorUsed_Params params {};
		params.User = User;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractionActor.CanBeUsedNow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      PotentialUser                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AInteractionActor::CanBeUsedNow(class AActor* PotentialUser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractionActor.CanBeUsedNow");
		
		AInteractionActor_CanBeUsedNow_Params params {};
		params.PotentialUser = PotentialUser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AInteractionActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AInteractionActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.InteractionActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractionsData.PlayPairedInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Driver                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Slave                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseItem*                                   OptionalItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APairedInteractionDriver* UInteractionsData::PlayPairedInteraction(class AActor* Driver, class AActor* Slave, class ABaseItem* OptionalItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractionsData.PlayPairedInteraction");
		
		UInteractionsData_PlayPairedInteraction_Params params {};
		params.Driver = Driver;
		params.Slave = Slave;
		params.OptionalItem = OptionalItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InteractionsData.IsPairedInteractionPlayingOn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APairedInteractionDriver* UInteractionsData::IsPairedInteractionPlayingOn(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InteractionsData.IsPairedInteractionPlayingOn");
		
		UInteractionsData_IsPairedInteractionPlayingOn_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInteractionsData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInteractionsData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.InteractionsData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.ThrowSpecificItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ThrowSpecificItem(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.ThrowSpecificItem");
		
		UInventoryComponent_ThrowSpecificItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.ThrowEquippedItem
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::ThrowEquippedItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.ThrowEquippedItem");
		
		UInventoryComponent_ThrowEquippedItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.ThrowAllWeapons
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::ThrowAllWeapons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.ThrowAllWeapons");
		
		UInventoryComponent_ThrowAllWeapons_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.ThrowAllItems
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::ThrowAllItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.ThrowAllItems");
		
		UInventoryComponent_ThrowAllItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.Server_PlayTPHolster
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemChangeRequest                          ItemChangeRequest                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::Server_PlayTPHolster(const struct FItemChangeRequest& ItemChangeRequest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.Server_PlayTPHolster");
		
		UInventoryComponent_Server_PlayTPHolster_Params params {};
		params.ItemChangeRequest = ItemChangeRequest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.Server_ChangeEquippedItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemChangeRequest                          ItemChangeRequest                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::Server_ChangeEquippedItem(const struct FItemChangeRequest& ItemChangeRequest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.Server_ChangeEquippedItem");
		
		UInventoryComponent_Server_ChangeEquippedItem_Params params {};
		params.ItemChangeRequest = ItemChangeRequest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.Server_AttemptEquipNewLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSavedLoadout                               Loadout                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::Server_AttemptEquipNewLoadout(const struct FSavedLoadout& Loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.Server_AttemptEquipNewLoadout");
		
		UInventoryComponent_Server_AttemptEquipNewLoadout_Params params {};
		params.Loadout = Loadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.RemoveInventoryItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNullOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::RemoveInventoryItem(class ABaseItem* Item, bool bNullOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.RemoveInventoryItem");
		
		UInventoryComponent_RemoveInventoryItem_Params params {};
		params.Item = Item;
		params.bNullOwner = bNullOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.PutItemInHands
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::PutItemInHands(class ABaseItem* Item, bool bInstant, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.PutItemInHands");
		
		UInventoryComponent_PutItemInHands_Params params {};
		params.Item = Item;
		params.bInstant = bInstant;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.PlayTPDraw
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemChangeRequest                          ItemChangeRequest                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::PlayTPDraw(const struct FItemChangeRequest& ItemChangeRequest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.PlayTPDraw");
		
		UInventoryComponent_PlayTPDraw_Params params {};
		params.ItemChangeRequest = ItemChangeRequest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.PlayLocalHolster
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemChangeRequest                          ItemChangeRequest                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::PlayLocalHolster(const struct FItemChangeRequest& ItemChangeRequest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.PlayLocalHolster");
		
		UInventoryComponent_PlayLocalHolster_Params params {};
		params.ItemChangeRequest = ItemChangeRequest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.PlayLocalDraw
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FItemChangeRequest                          ItemChangeRequest                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::PlayLocalDraw(const struct FItemChangeRequest& ItemChangeRequest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.PlayLocalDraw");
		
		UInventoryComponent_PlayLocalDraw_Params params {};
		params.ItemChangeRequest = ItemChangeRequest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.OnRep_SpawnedGear
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::OnRep_SpawnedGear()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.OnRep_SpawnedGear");
		
		UInventoryComponent_OnRep_SpawnedGear_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.OnRep_ItemChangeRequest
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::OnRep_ItemChangeRequest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.OnRep_ItemChangeRequest");
		
		UInventoryComponent_OnRep_ItemChangeRequest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.OnRep_InventoryItemsChanged
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::OnRep_InventoryItemsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.OnRep_InventoryItemsChanged");
		
		UInventoryComponent_OnRep_InventoryItemsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.InventoryComponent.OnPlayerItemChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::OnPlayerItemChanged__DelegateSignature(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.InventoryComponent.OnPlayerItemChanged__DelegateSignature");
		
		UInventoryComponent_OnPlayerItemChanged__DelegateSignature_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.InventoryComponent.OnItemRemoved__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::OnItemRemoved__DelegateSignature(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.InventoryComponent.OnItemRemoved__DelegateSignature");
		
		UInventoryComponent_OnItemRemoved__DelegateSignature_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.InventoryComponent.OnItemEquipped__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::OnItemEquipped__DelegateSignature(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.InventoryComponent.OnItemEquipped__DelegateSignature");
		
		UInventoryComponent_OnItemEquipped__DelegateSignature_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.InventoryComponent.OnEquippedItemChanged__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::OnEquippedItemChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.InventoryComponent.OnEquippedItemChanged__DelegateSignature");
		
		UInventoryComponent_OnEquippedItemChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.OnActorRelevancyChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsRelevant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::OnActorRelevancyChanged(class AActor* Actor, bool bIsRelevant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.OnActorRelevancyChanged");
		
		UInventoryComponent_OnActorRelevancyChanged_Params params {};
		params.Actor = Actor;
		params.bIsRelevant = bIsRelevant;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.Multicast_NotifyInventoryItemsChanged
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::Multicast_NotifyInventoryItemsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.Multicast_NotifyInventoryItemsChanged");
		
		UInventoryComponent_Multicast_NotifyInventoryItemsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsWearingHeadArmour
	 * 		Flags  -> ()
	 */
	bool UInventoryComponent::IsWearingHeadArmour()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsWearingHeadArmour");
		
		UInventoryComponent_IsWearingHeadArmour_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsWearingExplosiveVest
	 * 		Flags  -> ()
	 */
	bool UInventoryComponent::IsWearingExplosiveVest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsWearingExplosiveVest");
		
		UInventoryComponent_IsWearingExplosiveVest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsWearingArmour
	 * 		Flags  -> ()
	 */
	bool UInventoryComponent::IsWearingArmour()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsWearingArmour");
		
		UInventoryComponent_IsWearingArmour_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsWearingAntiFlashGoggles
	 * 		Flags  -> ()
	 */
	bool UInventoryComponent::IsWearingAntiFlashGoggles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsWearingAntiFlashGoggles");
		
		UInventoryComponent_IsWearingAntiFlashGoggles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsItemEquipped_Class
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::IsItemEquipped_Class(class UClass* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsItemEquipped_Class");
		
		UInventoryComponent_IsItemEquipped_Class_Params params {};
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsItemEquipped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      ItemCategory                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::IsItemEquipped(EItemCategory ItemCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsItemEquipped");
		
		UInventoryComponent_IsItemEquipped_Params params {};
		params.ItemCategory = ItemCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsEquippingSpecificItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::IsEquippingSpecificItem(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsEquippingSpecificItem");
		
		UInventoryComponent_IsEquippingSpecificItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsEquippingItemOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      ItemCategory                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::IsEquippingItemOfType(EItemCategory ItemCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsEquippingItemOfType");
		
		UInventoryComponent_IsEquippingItemOfType_Params params {};
		params.ItemCategory = ItemCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsEquippingItemOfClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ClassType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::IsEquippingItemOfClass(class UClass* ClassType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsEquippingItemOfClass");
		
		UInventoryComponent_IsEquippingItemOfClass_Params params {};
		params.ClassType = ClassType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsEquippingItem
	 * 		Flags  -> ()
	 */
	bool UInventoryComponent::IsEquippingItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsEquippingItem");
		
		UInventoryComponent_IsEquippingItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsEquippedWithShield
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::IsEquippedWithShield(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsEquippedWithShield");
		
		UInventoryComponent_IsEquippedWithShield_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsAnyItemAttachedToHands
	 * 		Flags  -> ()
	 */
	bool UInventoryComponent::IsAnyItemAttachedToHands()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsAnyItemAttachedToHands");
		
		UInventoryComponent_IsAnyItemAttachedToHands_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsAnyItemAttachedToBody
	 * 		Flags  -> ()
	 */
	bool UInventoryComponent::IsAnyItemAttachedToBody()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsAnyItemAttachedToBody");
		
		UInventoryComponent_IsAnyItemAttachedToBody_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.IsAnyBlockingAnimationPlaying
	 * 		Flags  -> ()
	 */
	bool UInventoryComponent::IsAnyBlockingAnimationPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.IsAnyBlockingAnimationPlaying");
		
		UInventoryComponent_IsAnyBlockingAnimationPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.HolsterEquippedItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::HolsterEquippedItem(bool bInstant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.HolsterEquippedItem");
		
		UInventoryComponent_HolsterEquippedItem_Params params {};
		params.bInstant = bInstant;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.Holster
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::Holster(class ABaseItem* Item, bool bInstant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.Holster");
		
		UInventoryComponent_Holster_Params params {};
		params.Item = Item;
		params.bInstant = bInstant;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.HasInventoryItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::HasInventoryItem(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.HasInventoryItem");
		
		UInventoryComponent_HasInventoryItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.HasAnyInventoryItemsOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      ItemCategory                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::HasAnyInventoryItemsOfType(EItemCategory ItemCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.HasAnyInventoryItemsOfType");
		
		UInventoryComponent_HasAnyInventoryItemsOfType_Params params {};
		params.ItemCategory = ItemCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.HasAnyInventoryItemsOfClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::HasAnyInventoryItemsOfClass(class UClass* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.HasAnyInventoryItemsOfClass");
		
		UInventoryComponent_HasAnyInventoryItemsOfClass_Params params {};
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.HasAnyInventoryItems
	 * 		Flags  -> ()
	 */
	bool UInventoryComponent::HasAnyInventoryItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.HasAnyInventoryItems");
		
		UInventoryComponent_HasAnyInventoryItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.GetRemovedInventoryItems
	 * 		Flags  -> ()
	 */
	TArray<class ABaseItem*> UInventoryComponent::GetRemovedInventoryItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.GetRemovedInventoryItems");
		
		UInventoryComponent_GetRemovedInventoryItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.GetLastEquippedLoadout
	 * 		Flags  -> ()
	 */
	struct FSavedLoadout UInventoryComponent::GetLastEquippedLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.GetLastEquippedLoadout");
		
		UInventoryComponent_GetLastEquippedLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.GetInventoryItemsOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      ItemCategory                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class ABaseItem*> UInventoryComponent::GetInventoryItemsOfType(EItemCategory ItemCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.GetInventoryItemsOfType");
		
		UInventoryComponent_GetInventoryItemsOfType_Params params {};
		params.ItemCategory = ItemCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.GetInventoryItems
	 * 		Flags  -> ()
	 */
	TArray<class ABaseItem*> UInventoryComponent::GetInventoryItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.GetInventoryItems");
		
		UInventoryComponent_GetInventoryItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.GetInventoryItemOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      ItemCategory                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABaseItem* UInventoryComponent::GetInventoryItemOfType(EItemCategory ItemCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.GetInventoryItemOfType");
		
		UInventoryComponent_GetInventoryItemOfType_Params params {};
		params.ItemCategory = ItemCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.GetInventoryItemOfClassType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemClass                                         ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABaseItem* UInventoryComponent::GetInventoryItemOfClassType(EItemClass ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.GetInventoryItemOfClassType");
		
		UInventoryComponent_GetInventoryItemOfClassType_Params params {};
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.GetInventoryItemOfClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanEquipCheck                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABaseItem* UInventoryComponent::GetInventoryItemOfClass(class UClass* Class, bool bCanEquipCheck)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.GetInventoryItemOfClass");
		
		UInventoryComponent_GetInventoryItemOfClass_Params params {};
		params.Class = Class;
		params.bCanEquipCheck = bCanEquipCheck;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.GetHolsteredItem
	 * 		Flags  -> ()
	 */
	class ABaseItem* UInventoryComponent::GetHolsteredItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.GetHolsteredItem");
		
		UInventoryComponent_GetHolsteredItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.GetHeadwear
	 * 		Flags  -> ()
	 */
	class AHeadwear* UInventoryComponent::GetHeadwear()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.GetHeadwear");
		
		UInventoryComponent_GetHeadwear_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.GetHeadArmour
	 * 		Flags  -> ()
	 */
	class AHeadwear* UInventoryComponent::GetHeadArmour()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.GetHeadArmour");
		
		UInventoryComponent_GetHeadArmour_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.GetEquippedItem
	 * 		Flags  -> ()
	 */
	class ABaseItem* UInventoryComponent::GetEquippedItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.GetEquippedItem");
		
		UInventoryComponent_GetEquippedItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.GetArmour
	 * 		Flags  -> ()
	 */
	class ABaseArmour* UInventoryComponent::GetArmour()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.GetArmour");
		
		UInventoryComponent_GetArmour_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.EquipLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLoadout                                    Loadout                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::EquipLoadout(const struct FLoadout& Loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.EquipLoadout");
		
		UInventoryComponent_EquipLoadout_Params params {};
		params.Loadout = Loadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.EquipLastEquippedWeapon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::EquipLastEquippedWeapon(bool bInstant, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.EquipLastEquippedWeapon");
		
		UInventoryComponent_EquipLastEquippedWeapon_Params params {};
		params.bInstant = bInstant;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.EquipLastEquippedItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::EquipLastEquippedItem(bool bInstant, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.EquipLastEquippedItem");
		
		UInventoryComponent_EquipLastEquippedItem_Params params {};
		params.bInstant = bInstant;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.EquipItemOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      ItemCategory                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABaseItem* UInventoryComponent::EquipItemOfType(EItemCategory ItemCategory, bool bInstant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.EquipItemOfType");
		
		UInventoryComponent_EquipItemOfType_Params params {};
		params.ItemCategory = ItemCategory;
		params.bInstant = bInstant;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.EquipItemOfClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ClassType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABaseItem* UInventoryComponent::EquipItemOfClass(class UClass* ClassType, bool bInstant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.EquipItemOfClass");
		
		UInventoryComponent_EquipItemOfClass_Params params {};
		params.ClassType = ClassType;
		params.bInstant = bInstant;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.EquipItemFromGroup_Name
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        GroupName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ItemCategoryIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABaseItem* UInventoryComponent::EquipItemFromGroup_Name(const class FName& GroupName, int32_t ItemCategoryIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.EquipItemFromGroup_Name");
		
		UInventoryComponent_EquipItemFromGroup_Name_Params params {};
		params.GroupName = GroupName;
		params.ItemCategoryIndex = ItemCategoryIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.EquipItemFromGroup_Index
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            GroupIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ItemCategoryIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABaseItem* UInventoryComponent::EquipItemFromGroup_Index(int32_t GroupIndex, int32_t ItemCategoryIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.EquipItemFromGroup_Index");
		
		UInventoryComponent_EquipItemFromGroup_Index_Params params {};
		params.GroupIndex = GroupIndex;
		params.ItemCategoryIndex = ItemCategoryIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.EquipHolsteredItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::EquipHolsteredItem(bool bInstant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.EquipHolsteredItem");
		
		UInventoryComponent_EquipHolsteredItem_Params params {};
		params.bInstant = bInstant;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.EquipDefaultItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bItemReplicates                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEquipToHands                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::EquipDefaultItems(bool bItemReplicates, bool bEquipToHands)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.EquipDefaultItems");
		
		UInventoryComponent_EquipDefaultItems_Params params {};
		params.bItemReplicates = bItemReplicates;
		params.bEquipToHands = bEquipToHands;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.DestroyInventoryItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::DestroyInventoryItem(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.DestroyInventoryItem");
		
		UInventoryComponent_DestroyInventoryItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.DestroyAllEquippedItems
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::DestroyAllEquippedItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.DestroyAllEquippedItems");
		
		UInventoryComponent_DestroyAllEquippedItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.CountInventoryItemType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      ItemCategory                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UInventoryComponent::CountInventoryItemType(EItemCategory ItemCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.CountInventoryItemType");
		
		UInventoryComponent_CountInventoryItemType_Params params {};
		params.ItemCategory = ItemCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.InventoryComponent.ClientOnItemAddedToInventory__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ClientOnItemAddedToInventory__DelegateSignature(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.InventoryComponent.ClientOnItemAddedToInventory__DelegateSignature");
		
		UInventoryComponent_ClientOnItemAddedToInventory__DelegateSignature_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.Client_NotifyInventorySpawned
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::Client_NotifyInventorySpawned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.Client_NotifyInventorySpawned");
		
		UInventoryComponent_Client_NotifyInventorySpawned_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.Client_NotifyInventoryItemsDestroyed
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::Client_NotifyInventoryItemsDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.Client_NotifyInventoryItemsDestroyed");
		
		UInventoryComponent_Client_NotifyInventoryItemsDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.Client_NotifyInventoryItemsChanged
	 * 		Flags  -> ()
	 */
	void UInventoryComponent::Client_NotifyInventoryItemsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.Client_NotifyInventoryItemsChanged");
		
		UInventoryComponent_Client_NotifyInventoryItemsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.CanEquip
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::CanEquip(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.CanEquip");
		
		UInventoryComponent_CanEquip_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.InventoryComponent.AddInventoryItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::AddInventoryItem(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.InventoryComponent.AddInventoryItem");
		
		UInventoryComponent_AddInventoryItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.InventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInvertedScrollBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInvertedScrollBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.InvertedScrollBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.TickMoveToState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWorldBuildingActivity::TickMoveToState(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.TickMoveToState");
		
		UWorldBuildingActivity_TickMoveToState_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.TickLoopState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWorldBuildingActivity::TickLoopState(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.TickLoopState");
		
		UWorldBuildingActivity_TickLoopState_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.ShouldStart
	 * 		Flags  -> ()
	 */
	bool UWorldBuildingActivity::ShouldStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.ShouldStart");
		
		UWorldBuildingActivity_ShouldStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.ShouldLoop
	 * 		Flags  -> ()
	 */
	bool UWorldBuildingActivity::ShouldLoop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.ShouldLoop");
		
		UWorldBuildingActivity_ShouldLoop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.ShouldEndAbruptly
	 * 		Flags  -> ()
	 */
	bool UWorldBuildingActivity::ShouldEndAbruptly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.ShouldEndAbruptly");
		
		UWorldBuildingActivity_ShouldEndAbruptly_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.ShouldEnd
	 * 		Flags  -> ()
	 */
	bool UWorldBuildingActivity::ShouldEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.ShouldEnd");
		
		UWorldBuildingActivity_ShouldEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.ShouldComplete
	 * 		Flags  -> ()
	 */
	bool UWorldBuildingActivity::ShouldComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.ShouldComplete");
		
		UWorldBuildingActivity_ShouldComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.SetRotation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FRotator                       NewRotator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UWorldBuildingActivity::SetRotation(const struct FCoreUObject_FRotator& NewRotator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.SetRotation");
		
		UWorldBuildingActivity_SetRotation_Params params {};
		params.NewRotator = NewRotator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.SetActivityData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorldBuildingActivityData*                  Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWorldBuildingActivity::SetActivityData(class UWorldBuildingActivityData* Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.SetActivityData");
		
		UWorldBuildingActivity_SetActivityData_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.IsSetupCorrectly
	 * 		Flags  -> ()
	 */
	bool UWorldBuildingActivity::IsSetupCorrectly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.IsSetupCorrectly");
		
		UWorldBuildingActivity_IsSetupCorrectly_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.GetRotationOffset
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FRotator UWorldBuildingActivity::GetRotationOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.GetRotationOffset");
		
		UWorldBuildingActivity_GetRotationOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.EnterStartState
	 * 		Flags  -> ()
	 */
	void UWorldBuildingActivity::EnterStartState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.EnterStartState");
		
		UWorldBuildingActivity_EnterStartState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.EnterMoveToState
	 * 		Flags  -> ()
	 */
	void UWorldBuildingActivity::EnterMoveToState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.EnterMoveToState");
		
		UWorldBuildingActivity_EnterMoveToState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.EnterLoopState
	 * 		Flags  -> ()
	 */
	void UWorldBuildingActivity::EnterLoopState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.EnterLoopState");
		
		UWorldBuildingActivity_EnterLoopState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.EnterEndState
	 * 		Flags  -> ()
	 */
	void UWorldBuildingActivity::EnterEndState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.EnterEndState");
		
		UWorldBuildingActivity_EnterEndState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.EnterCompleteState
	 * 		Flags  -> ()
	 */
	void UWorldBuildingActivity::EnterCompleteState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.EnterCompleteState");
		
		UWorldBuildingActivity_EnterCompleteState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingActivity.EnterAbruptEndState
	 * 		Flags  -> ()
	 */
	void UWorldBuildingActivity::EnterAbruptEndState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingActivity.EnterAbruptEndState");
		
		UWorldBuildingActivity_EnterAbruptEndState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWorldBuildingActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWorldBuildingActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WorldBuildingActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInvestigateActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInvestigateActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.InvestigateActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInvestigateStimulusActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInvestigateStimulusActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.InvestigateStimulusActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.IssueCommandQuestNode.OnIssuedCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESwatCommand                                       Command                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UIssueCommandQuestNode::OnIssuedCommand(ESwatCommand Command, ETeamType Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.IssueCommandQuestNode.OnIssuedCommand");
		
		UIssueCommandQuestNode_OnIssuedCommand_Params params {};
		params.Command = Command;
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UIssueCommandQuestNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UIssueCommandQuestNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.IssueCommandQuestNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ItemData.GetDeviceAmount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UItemData::GetDeviceAmount(class UClass* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ItemData.GetDeviceAmount");
		
		UItemData_GetDeviceAmount_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ItemData.GetAvailableSkinsForWeapon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UItemData*                                   ItemData                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FWeaponData                                 WeaponData                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	TArray<class UClass*> UItemData::GetAvailableSkinsForWeapon(class UItemData* ItemData, class UClass* Item, struct FWeaponData* WeaponData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ItemData.GetAvailableSkinsForWeapon");
		
		UItemData_GetAvailableSkinsForWeapon_Params params {};
		params.ItemData = ItemData;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (WeaponData != nullptr)
			*WeaponData = params.WeaponData;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ItemData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemVisualizationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemVisualizationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ItemVisualizationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKillHostageChanceAnimNotify.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKillHostageChanceAnimNotify::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.KillHostageChanceAnimNotify");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AKingOfTheHillGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AKingOfTheHillGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.KingOfTheHillGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AKingOfTheHillGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AKingOfTheHillGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.KingOfTheHillGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.KingOfTheHostageGM.SpawnHostage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      HostageClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FCoreUObject_FVector>                SpawnLocations                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	class APawn* AKingOfTheHostageGM::SpawnHostage(class UClass* HostageClass, TArray<struct FCoreUObject_FVector> SpawnLocations)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.KingOfTheHostageGM.SpawnHostage");
		
		AKingOfTheHostageGM_SpawnHostage_Params params {};
		params.HostageClass = HostageClass;
		params.SpawnLocations = SpawnLocations;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.KingOfTheHostageGM.OnHostageRescued__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APawn*                                       HostageRescued                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AKingOfTheHostageGM::OnHostageRescued__DelegateSignature(class APawn* HostageRescued)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.KingOfTheHostageGM.OnHostageRescued__DelegateSignature");
		
		AKingOfTheHostageGM_OnHostageRescued__DelegateSignature_Params params {};
		params.HostageRescued = HostageRescued;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.KingOfTheHostageGM.AreAllHostagesSafe
	 * 		Flags  -> ()
	 */
	bool AKingOfTheHostageGM::AreAllHostagesSafe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.KingOfTheHostageGM.AreAllHostagesSafe");
		
		AKingOfTheHostageGM_AreAllHostagesSafe_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AKingOfTheHostageGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AKingOfTheHostageGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.KingOfTheHostageGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AKingOfTheHostageGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AKingOfTheHostageGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.KingOfTheHostageGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALadder.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALadder::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Ladder");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LadderSnapZone.OnCollisionOverlapEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         Comp                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ALadderSnapZone::OnCollisionOverlapEnd(class UPrimitiveComponent* Comp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LadderSnapZone.OnCollisionOverlapEnd");
		
		ALadderSnapZone_OnCollisionOverlapEnd_Params params {};
		params.Comp = Comp;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LadderSnapZone.OnCollisionOverlapBegin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         Comp                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ALadderSnapZone::OnCollisionOverlapBegin(class UPrimitiveComponent* Comp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LadderSnapZone.OnCollisionOverlapBegin");
		
		ALadderSnapZone_OnCollisionOverlapBegin_Params params {};
		params.Comp = Comp;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LadderSnapZone.Multicast_StopShowingGhostMesh
	 * 		Flags  -> ()
	 */
	void ALadderSnapZone::Multicast_StopShowingGhostMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LadderSnapZone.Multicast_StopShowingGhostMesh");
		
		ALadderSnapZone_Multicast_StopShowingGhostMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LadderSnapZone.Multicast_StartShowingGhostMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bAbleToPlace                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ALadderSnapZone::Multicast_StartShowingGhostMesh(bool bAbleToPlace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LadderSnapZone.Multicast_StartShowingGhostMesh");
		
		ALadderSnapZone_Multicast_StartShowingGhostMesh_Params params {};
		params.bAbleToPlace = bAbleToPlace;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LadderSnapZone.EnableCollision
	 * 		Flags  -> ()
	 */
	void ALadderSnapZone::EnableCollision()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LadderSnapZone.EnableCollision");
		
		ALadderSnapZone_EnableCollision_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LadderSnapZone.DisableCollision
	 * 		Flags  -> ()
	 */
	void ALadderSnapZone::DisableCollision()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LadderSnapZone.DisableCollision");
		
		ALadderSnapZone_DisableCollision_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALadderSnapZone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALadderSnapZone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LadderSnapZone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WeaponAttachment.PlayToggleSound
	 * 		Flags  -> ()
	 */
	void UWeaponAttachment::PlayToggleSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WeaponAttachment.PlayToggleSound");
		
		UWeaponAttachment_PlayToggleSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WeaponAttachment.ApplyWetness
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Wetness                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RainAmount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponAttachment::ApplyWetness(float Wetness, float RainAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WeaponAttachment.ApplyWetness");
		
		UWeaponAttachment_ApplyWetness_Params params {};
		params.Wetness = Wetness;
		params.RainAmount = RainAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponAttachment.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponAttachment::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WeaponAttachment");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LaserAttachment.ToggleLaser
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOn                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULaserAttachment::ToggleLaser(bool bOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LaserAttachment.ToggleLaser");
		
		ULaserAttachment_ToggleLaser_Params params {};
		params.bOn = bOn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LaserAttachment.Server_SetBeamLocationAndNormal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Normal                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULaserAttachment::Server_SetBeamLocationAndNormal(const struct FCoreUObject_FVector& Location, const struct FCoreUObject_FVector& Normal, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LaserAttachment.Server_SetBeamLocationAndNormal");
		
		ULaserAttachment_Server_SetBeamLocationAndNormal_Params params {};
		params.Location = Location;
		params.Normal = Normal;
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LaserAttachment.OnRep_On
	 * 		Flags  -> ()
	 */
	void ULaserAttachment::OnRep_On()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LaserAttachment.OnRep_On");
		
		ULaserAttachment_OnRep_On_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LaserAttachment.IsLaserOn
	 * 		Flags  -> ()
	 */
	bool ULaserAttachment::IsLaserOn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LaserAttachment.IsLaserOn");
		
		ULaserAttachment_IsLaserOn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULaserAttachment.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULaserAttachment::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LaserAttachment");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALastKnownPositionActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALastKnownPositionActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LastKnownPositionActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALensFlare.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALensFlare::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LensFlare");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LevelData.IsPvPSupported
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLevelDataLookupTable                       LevelData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	bool ULevelData::IsPvPSupported(const struct FLevelDataLookupTable& LevelData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LevelData.IsPvPSupported");
		
		ULevelData_IsPvPSupported_Params params {};
		params.LevelData = LevelData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LevelData.IsCOOPSupported
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLevelDataLookupTable                       LevelData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	bool ULevelData::IsCOOPSupported(const struct FLevelDataLookupTable& LevelData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LevelData.IsCOOPSupported");
		
		ULevelData_IsCOOPSupported_Params params {};
		params.LevelData = LevelData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULevelData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULevelData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LevelData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LicenseSave.AcceptAlphaNDA
	 * 		Flags  -> ()
	 */
	void ULicenseSave::AcceptAlphaNDA()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LicenseSave.AcceptAlphaNDA");
		
		ULicenseSave_AcceptAlphaNDA_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULicenseSave.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULicenseSave::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LicenseSave");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LightAttachment.ToggleLight
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOn                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULightAttachment::ToggleLight(bool bOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LightAttachment.ToggleLight");
		
		ULightAttachment_ToggleLight_Params params {};
		params.bOn = bOn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LightAttachment.OnRep_On
	 * 		Flags  -> ()
	 */
	void ULightAttachment::OnRep_On()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LightAttachment.OnRep_On");
		
		ULightAttachment_OnRep_On_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LightAttachment.IsLightOn
	 * 		Flags  -> ()
	 */
	bool ULightAttachment::IsLightOn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LightAttachment.IsLightOn");
		
		ULightAttachment_IsLightOn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULightAttachment.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULightAttachment::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LightAttachment");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LightningGenerator.PlayThunder
	 * 		Flags  -> ()
	 */
	void ALightningGenerator::PlayThunder()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LightningGenerator.PlayThunder");
		
		ALightningGenerator_PlayThunder_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LightningGenerator.PlayLightning
	 * 		Flags  -> ()
	 */
	void ALightningGenerator::PlayLightning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LightningGenerator.PlayLightning");
		
		ALightningGenerator_PlayLightning_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALightningGenerator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALightningGenerator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LightningGenerator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForArrest.OnCharacterArrested
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ArrestedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Arrester                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForArrest::OnCharacterArrested(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* Arrester)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForArrest.OnCharacterArrested");
		
		UListenForArrest_OnCharacterArrested_Params params {};
		params.ArrestedCharacter = ArrestedCharacter;
		params.Arrester = Arrester;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForArrest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForArrest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForArrest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForDeath.OnCharacterDied
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Inflictor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForDeath::OnCharacterDied(class AReadyOrNotCharacter* Victim, class AReadyOrNotCharacter* Killer, class AActor* Inflictor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForDeath.OnCharacterDied");
		
		UListenForDeath_OnCharacterDied_Params params {};
		params.Victim = Victim;
		params.Killer = Killer;
		params.Inflictor = Inflictor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForDeath.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForDeath::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForDeath");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForEvidenceMarked.OnEvidenceMarked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   MarkedEvidence                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMark                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForEvidenceMarked::OnEvidenceMarked(class ABaseItem* MarkedEvidence, bool bMark)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForEvidenceMarked.OnEvidenceMarked");
		
		UListenForEvidenceMarked_OnEvidenceMarked_Params params {};
		params.MarkedEvidence = MarkedEvidence;
		params.bMark = bMark;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForEvidenceMarked.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForEvidenceMarked::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForEvidenceMarked");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForGameEnd.OnGameEnded
	 * 		Flags  -> ()
	 */
	void UListenForGameEnd::OnGameEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForGameEnd.OnGameEnded");
		
		UListenForGameEnd_OnGameEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForGameEnd.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForGameEnd::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForGameEnd");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForGamePreStart.OnGamePreStarted
	 * 		Flags  -> ()
	 */
	void UListenForGamePreStart::OnGamePreStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForGamePreStart.OnGamePreStarted");
		
		UListenForGamePreStart_OnGamePreStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForGamePreStart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForGamePreStart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForGamePreStart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForGameStart.OnGameStarted
	 * 		Flags  -> ()
	 */
	void UListenForGameStart::OnGameStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForGameStart.OnGameStarted");
		
		UListenForGameStart_OnGameStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForGameStart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForGameStart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForGameStart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForGrenades.OnGrenadeDetonated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class ABaseGrenade*                                Grenade                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForGrenades::OnGrenadeDetonated(const struct FHitResult& Hit, class ABaseGrenade* Grenade, class AReadyOrNotCharacter* Owner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForGrenades.OnGrenadeDetonated");
		
		UListenForGrenades_OnGrenadeDetonated_Params params {};
		params.Hit = Hit;
		params.Grenade = Grenade;
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForGrenades.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForGrenades::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForGrenades");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForIncapacitation.OnCharacterIncapacitated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Inflictor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForIncapacitation::OnCharacterIncapacitated(class AReadyOrNotCharacter* Victim, class AReadyOrNotCharacter* Killer, class AActor* Inflictor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForIncapacitation.OnCharacterIncapacitated");
		
		UListenForIncapacitation_OnCharacterIncapacitated_Params params {};
		params.Victim = Victim;
		params.Killer = Killer;
		params.Inflictor = Inflictor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForIncapacitation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForIncapacitation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForIncapacitation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForInjury.OnCharacterInjured
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForInjury::OnCharacterInjured(class AReadyOrNotCharacter* Victim, float Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForInjury.OnCharacterInjured");
		
		UListenForInjury_OnCharacterInjured_Params params {};
		params.Victim = Victim;
		params.Damage = Damage;
		params.DamageEvent = DamageEvent;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForInjury.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForInjury::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForInjury");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForPickup.OnEvidencePickedUpByPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   EvidenceActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForPickup::OnEvidencePickedUpByPlayer(class ABaseItem* EvidenceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForPickup.OnEvidencePickedUpByPlayer");
		
		UListenForPickup_OnEvidencePickedUpByPlayer_Params params {};
		params.EvidenceActor = EvidenceActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForPickup.OnEvidenceDropped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   EvidenceActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForPickup::OnEvidenceDropped(class ABaseItem* EvidenceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForPickup.OnEvidenceDropped");
		
		UListenForPickup_OnEvidenceDropped_Params params {};
		params.EvidenceActor = EvidenceActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForPickup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForPickup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForPickup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForReport.OnTargetReported
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Reporter                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ReportedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForReport::OnTargetReported(class AReadyOrNotCharacter* Reporter, class UObject* ReportedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForReport.OnTargetReported");
		
		UListenForReport_OnTargetReported_Params params {};
		params.Reporter = Reporter;
		params.ReportedCharacter = ReportedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForReport.OnTargetBecameReportable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForReport::OnTargetBecameReportable(class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForReport.OnTargetBecameReportable");
		
		UListenForReport_OnTargetBecameReportable_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForReport.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForReport::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForReport");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForRoundEnded.OnRoundEnded
	 * 		Flags  -> ()
	 */
	void UListenForRoundEnded::OnRoundEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForRoundEnded.OnRoundEnded");
		
		UListenForRoundEnded_OnRoundEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForRoundEnded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForRoundEnded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForRoundEnded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForSpawn.OnCharacterSpawned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        SpawnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForSpawn::OnCharacterSpawned(class AReadyOrNotCharacter* SpawnedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForSpawn.OnCharacterSpawned");
		
		UListenForSpawn_OnCharacterSpawned_Params params {};
		params.SpawnedCharacter = SpawnedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForSpawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForSpawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForSpawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForUncuffed.OnCharacterUncuffed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ArrestedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        Uncuffer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForUncuffed::OnCharacterUncuffed(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* Uncuffer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForUncuffed.OnCharacterUncuffed");
		
		UListenForUncuffed_OnCharacterUncuffed_Params params {};
		params.ArrestedCharacter = ArrestedCharacter;
		params.Uncuffer = Uncuffer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForUncuffed.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForUncuffed::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForUncuffed");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForWeaponClearing.OnWeaponCleared
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   WeaponActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForWeaponClearing::OnWeaponCleared(class ABaseItem* WeaponActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForWeaponClearing.OnWeaponCleared");
		
		UListenForWeaponClearing_OnWeaponCleared_Params params {};
		params.WeaponActor = WeaponActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForWeaponClearing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForWeaponClearing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForWeaponClearing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ListenForYell.OnCharacterYelled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Yeller                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UListenForYell::OnCharacterYelled(class AReadyOrNotCharacter* Yeller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ListenForYell.OnCharacterYelled");
		
		UListenForYell_OnCharacterYelled_Params params {};
		params.Yeller = Yeller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UListenForYell.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UListenForYell::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ListenForYell");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LoadingScreen.UpdateTip
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTextBlock*                                  TipBlock                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULoadingScreen::UpdateTip(class UTextBlock* TipBlock)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LoadingScreen.UpdateTip");
		
		ULoadingScreen_UpdateTip_Params params {};
		params.TipBlock = TipBlock;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LoadingScreen.SetLoadingScreen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InMap                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InMode                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InSessionName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSeamlessTravel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULoadingScreen::SetLoadingScreen(const class FString& InMap, const class FString& InMode, const class FString& InSessionName, bool bSeamlessTravel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LoadingScreen.SetLoadingScreen");
		
		ULoadingScreen_SetLoadingScreen_Params params {};
		params.InMap = InMap;
		params.InMode = InMode;
		params.InSessionName = InSessionName;
		params.bSeamlessTravel = bSeamlessTravel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LoadingScreen.GetMapName
	 * 		Flags  -> ()
	 */
	class FString ULoadingScreen::GetMapName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LoadingScreen.GetMapName");
		
		ULoadingScreen_GetMapName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LoadingScreen.GetLoadingScreenDetails
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      OutMap                                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OutMode                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OutSessionName                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULoadingScreen::GetLoadingScreenDetails(class FString* OutMap, class FString* OutMode, class FString* OutSessionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LoadingScreen.GetLoadingScreenDetails");
		
		ULoadingScreen_GetLoadingScreenDetails_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutMap != nullptr)
			*OutMap = params.OutMap;
		if (OutMode != nullptr)
			*OutMode = params.OutMode;
		if (OutSessionName != nullptr)
			*OutSessionName = params.OutSessionName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LoadingScreen.GetLoadingPercentage
	 * 		Flags  -> ()
	 */
	float ULoadingScreen::GetLoadingPercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LoadingScreen.GetLoadingPercentage");
		
		ULoadingScreen_GetLoadingPercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULoadingScreen.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULoadingScreen::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LoadingScreen");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALoadoutPortal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALoadoutPortal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LoadoutPortal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotTriggerVolume.OnActorSpawned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotTriggerVolume::OnActorSpawned(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotTriggerVolume.OnActorSpawned");
		
		AReadyOrNotTriggerVolume_OnActorSpawned_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotTriggerVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotTriggerVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotTriggerVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALobbyFiringRangeArea.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALobbyFiringRangeArea::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LobbyFiringRangeArea");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALobbyGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALobbyGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LobbyGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALobbyGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALobbyGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LobbyGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULockPickDoorActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULockPickDoorActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LockPickDoorActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Tool.StopUsingTool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATool::StopUsingTool(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Tool.StopUsingTool");
		
		ATool_StopUsingTool_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Tool.StartUsingTool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATool::StartUsingTool(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Tool.StartUsingTool");
		
		ATool_StartUsingTool_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Tool.Server_ToolComplete
	 * 		Flags  -> ()
	 */
	void ATool::Server_ToolComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Tool.Server_ToolComplete");
		
		ATool_Server_ToolComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Tool.Server_StopUsingTool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATool::Server_StopUsingTool(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Tool.Server_StopUsingTool");
		
		ATool_Server_StopUsingTool_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Tool.Server_StartUsingTool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATool::Server_StartUsingTool(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Tool.Server_StartUsingTool");
		
		ATool_Server_StartUsingTool_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Tool.IsOperating
	 * 		Flags  -> ()
	 */
	bool ATool::IsOperating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Tool.IsOperating");
		
		ATool_IsOperating_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Tool.GetMaxOperatingTime
	 * 		Flags  -> ()
	 */
	float ATool::GetMaxOperatingTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Tool.GetMaxOperatingTime");
		
		ATool_GetMaxOperatingTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Tool.GetCurrentOperatingTime
	 * 		Flags  -> ()
	 */
	float ATool::GetCurrentOperatingTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Tool.GetCurrentOperatingTime");
		
		ATool_GetCurrentOperatingTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Tool.Client_StopToolAnimation
	 * 		Flags  -> ()
	 */
	void ATool::Client_StopToolAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Tool.Client_StopToolAnimation");
		
		ATool_Client_StopToolAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Tool.Client_FinishedToolUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATool::Client_FinishedToolUse(class AActor* Target, class APlayerCharacter* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Tool.Client_FinishedToolUse");
		
		ATool_Client_FinishedToolUse_Params params {};
		params.Target = Target;
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATool.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATool::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Tool");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALockpickGun.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALockpickGun::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LockpickGun");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.LookupData.EmptyData
	 * 		Flags  -> ()
	 */
	void ULookupData::EmptyData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.LookupData.EmptyData");
		
		ULookupData_EmptyData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULookupData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULookupData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LookupData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULoudnessMeterWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULoudnessMeterWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.LoudnessMeterWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMagazineAttachment.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMagazineAttachment::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MagazineAttachment");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMagazineDisplayComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMagazineDisplayComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MagazineDisplayComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMagMaskingAnimNotify.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMagMaskingAnimNotify::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MagMaskingAnimNotify");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenu.IsLoggedIn
	 * 		Flags  -> ()
	 */
	bool UMainMenu::IsLoggedIn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenu.IsLoggedIn");
		
		UMainMenu_IsLoggedIn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenu.GetVersion
	 * 		Flags  -> ()
	 */
	class FText UMainMenu::GetVersion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenu.GetVersion");
		
		UMainMenu_GetVersion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenu.GetPublicLobbyCooldown
	 * 		Flags  -> ()
	 */
	class FText UMainMenu::GetPublicLobbyCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenu.GetPublicLobbyCooldown");
		
		UMainMenu_GetPublicLobbyCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenu.GetBackEndConnectionStatus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELoginState                                        LoginState                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UMainMenu::GetBackEndConnectionStatus(ELoginState LoginState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenu.GetBackEndConnectionStatus");
		
		UMainMenu_GetBackEndConnectionStatus_Params params {};
		params.LoginState = LoginState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenu.CanPlayPublicLobby
	 * 		Flags  -> ()
	 */
	bool UMainMenu::CanPlayPublicLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenu.CanPlayPublicLobby");
		
		UMainMenu_CanPlayPublicLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenu.CanFindSession
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bCOOP                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UMainMenu::CanFindSession(bool bCOOP)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenu.CanFindSession");
		
		UMainMenu_CanFindSession_Params params {};
		params.bCOOP = bCOOP;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMainMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMainMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MainMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenuGM.ShowMainMenuMsg
	 * 		Flags  -> ()
	 */
	void AMainMenuGM::ShowMainMenuMsg()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenuGM.ShowMainMenuMsg");
		
		AMainMenuGM_ShowMainMenuMsg_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.MainMenuGM.OnUpdateSessionSearch__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bComplete                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutMessage                                                 (Parm, NativeAccessSpecifierPublic)
	 * 		bool                                               bPVPSearch                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMainMenuGM::OnUpdateSessionSearch__DelegateSignature(bool bComplete, const class FText& OutMessage, bool bPVPSearch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.MainMenuGM.OnUpdateSessionSearch__DelegateSignature");
		
		AMainMenuGM_OnUpdateSessionSearch__DelegateSignature_Params params {};
		params.bComplete = bComplete;
		params.OutMessage = OutMessage;
		params.bPVPSearch = bPVPSearch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenuGM.OnLobbySuccess
	 * 		Flags  -> ()
	 */
	void AMainMenuGM::OnLobbySuccess()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenuGM.OnLobbySuccess");
		
		AMainMenuGM_OnLobbySuccess_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenuGM.OnLobbyFailed
	 * 		Flags  -> ()
	 */
	void AMainMenuGM::OnLobbyFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenuGM.OnLobbyFailed");
		
		AMainMenuGM_OnLobbyFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenuGM.OnFindSessionSuccess
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FBlueprintSessionResult>             Results                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AMainMenuGM::OnFindSessionSuccess(TArray<struct FBlueprintSessionResult> Results)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenuGM.OnFindSessionSuccess");
		
		AMainMenuGM_OnFindSessionSuccess_Params params {};
		params.Results = Results;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenuGM.OnFindSessionFailed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FBlueprintSessionResult>             Results                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AMainMenuGM::OnFindSessionFailed(TArray<struct FBlueprintSessionResult> Results)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenuGM.OnFindSessionFailed");
		
		AMainMenuGM_OnFindSessionFailed_Params params {};
		params.Results = Results;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenuGM.OnDestroySessionBeforeStartingLobby
	 * 		Flags  -> ()
	 */
	void AMainMenuGM::OnDestroySessionBeforeStartingLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenuGM.OnDestroySessionBeforeStartingLobby");
		
		AMainMenuGM_OnDestroySessionBeforeStartingLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenuGM.OnBanStatusChecked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SteamId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsBanned                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      BanReason                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsMySteamId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMainMenuGM::OnBanStatusChecked(const class FString& SteamId, bool bIsBanned, const class FString& BanReason, bool bIsMySteamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenuGM.OnBanStatusChecked");
		
		AMainMenuGM_OnBanStatusChecked_Params params {};
		params.SteamId = SteamId;
		params.bIsBanned = bIsBanned;
		params.BanReason = BanReason;
		params.bIsMySteamId = bIsMySteamId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenuGM.GoToLobby
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOnlineMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFriendsOnly                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMainMenuGM::GoToLobby(bool bOnlineMode, bool bFriendsOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenuGM.GoToLobby");
		
		AMainMenuGM_GoToLobby_Params params {};
		params.bOnlineMode = bOnlineMode;
		params.bFriendsOnly = bFriendsOnly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenuGM.FindOnlineSession
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewSearch                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPVPSession                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMainMenuGM::FindOnlineSession(bool bNewSearch, bool bPVPSession)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenuGM.FindOnlineSession");
		
		AMainMenuGM_FindOnlineSession_Params params {};
		params.bNewSearch = bNewSearch;
		params.bPVPSession = bPVPSession;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenuGM.FindNextSessionList
	 * 		Flags  -> ()
	 */
	void AMainMenuGM::FindNextSessionList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenuGM.FindNextSessionList");
		
		AMainMenuGM_FindNextSessionList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenuGM.CreateRestartWidget
	 * 		Flags  -> ()
	 */
	void AMainMenuGM::CreateRestartWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenuGM.CreateRestartWidget");
		
		AMainMenuGM_CreateRestartWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MainMenuGM.CancelSessionSearch
	 * 		Flags  -> ()
	 */
	void AMainMenuGM::CancelSessionSearch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MainMenuGM.CancelSessionSearch");
		
		AMainMenuGM_CancelSessionSearch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMainMenuGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMainMenuGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MainMenuGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapActorComponent.SetIconTextColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLinearColor                                InIconTextColor                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapActorComponent::SetIconTextColor(const struct FLinearColor& InIconTextColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapActorComponent.SetIconTextColor");
		
		UMapActorComponent_SetIconTextColor_Params params {};
		params.InIconTextColor = InIconTextColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapActorComponent.SetIconText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        InIconText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UMapActorComponent::SetIconText(const class FText& InIconText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapActorComponent.SetIconText");
		
		UMapActorComponent_SetIconText_Params params {};
		params.InIconText = InIconText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapActorComponent.SetIconColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLinearColor                                InIconColor                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapActorComponent::SetIconColor(const struct FLinearColor& InIconColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapActorComponent.SetIconColor");
		
		UMapActorComponent_SetIconColor_Params params {};
		params.InIconColor = InIconColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapActorComponent.IsUsingActorRotation
	 * 		Flags  -> ()
	 */
	bool UMapActorComponent::IsUsingActorRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapActorComponent.IsUsingActorRotation");
		
		UMapActorComponent_IsUsingActorRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapActorComponent.GetIconText
	 * 		Flags  -> ()
	 */
	class FText UMapActorComponent::GetIconText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapActorComponent.GetIconText");
		
		UMapActorComponent_GetIconText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapActorComponent.EnableMapActor
	 * 		Flags  -> ()
	 */
	void UMapActorComponent::EnableMapActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapActorComponent.EnableMapActor");
		
		UMapActorComponent_EnableMapActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapActorComponent.DisableMapActor
	 * 		Flags  -> ()
	 */
	void UMapActorComponent::DisableMapActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapActorComponent.DisableMapActor");
		
		UMapActorComponent_DisableMapActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapActorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapActorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MapActorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapActorWidget.SetMapActorTextColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLinearColor                                InTextColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapActorWidget::SetMapActorTextColor(const struct FLinearColor& InTextColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapActorWidget.SetMapActorTextColor");
		
		UMapActorWidget_SetMapActorTextColor_Params params {};
		params.InTextColor = InTextColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapActorWidget.SetMapActorText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        InText                                                     (Parm, NativeAccessSpecifierPublic)
	 */
	void UMapActorWidget::SetMapActorText(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapActorWidget.SetMapActorText");
		
		UMapActorWidget_SetMapActorText_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapActorWidget.InitializeWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActorToTrack                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInUseActorRotation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInUseLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        InLocationToTrack                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InRotationOffset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapActorWidget::InitializeWidget(class AActor* InActorToTrack, bool bInUseActorRotation, bool bInUseLocation, const struct FCoreUObject_FVector& InLocationToTrack, float InRotationOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapActorWidget.InitializeWidget");
		
		UMapActorWidget_InitializeWidget_Params params {};
		params.InActorToTrack = InActorToTrack;
		params.bInUseActorRotation = bInUseActorRotation;
		params.bInUseLocation = bInUseLocation;
		params.InLocationToTrack = InLocationToTrack;
		params.InRotationOffset = InRotationOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapActorWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapActorWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MapActorWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapActorIconWidget.SetIconColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLinearColor                                InIconColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapActorIconWidget::SetIconColor(const struct FLinearColor& InIconColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapActorIconWidget.SetIconColor");
		
		UMapActorIconWidget_SetIconColor_Params params {};
		params.InIconColor = InIconColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapActorIconWidget.SetIconBrushStyle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSlateBrush                                 InIconBrush                                                (Parm, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                InIconColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapActorIconWidget::SetIconBrushStyle(const struct FSlateBrush& InIconBrush, const struct FLinearColor& InIconColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapActorIconWidget.SetIconBrushStyle");
		
		UMapActorIconWidget_SetIconBrushStyle_Params params {};
		params.InIconBrush = InIconBrush;
		params.InIconColor = InIconColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapActorIconWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapActorIconWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MapActorIconWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.OnReferendumPassed
	 * 		Flags  -> ()
	 */
	void AReferendum::OnReferendumPassed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.OnReferendumPassed");
		
		AReferendum_OnReferendumPassed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.OnAnnounceYesVote
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotPlayerState*                      Voter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReferendum::OnAnnounceYesVote(class AReadyOrNotPlayerState* Voter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.OnAnnounceYesVote");
		
		AReferendum_OnAnnounceYesVote_Params params {};
		params.Voter = Voter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.OnAnnounceVoteStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotPlayerState*                      CallingVoter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReferendum::OnAnnounceVoteStarted(class AReadyOrNotPlayerState* CallingVoter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.OnAnnounceVoteStarted");
		
		AReferendum_OnAnnounceVoteStarted_Params params {};
		params.CallingVoter = CallingVoter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.OnAnnounceVotePassed
	 * 		Flags  -> ()
	 */
	void AReferendum::OnAnnounceVotePassed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.OnAnnounceVotePassed");
		
		AReferendum_OnAnnounceVotePassed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.OnAnnounceVoteFailed
	 * 		Flags  -> ()
	 */
	void AReferendum::OnAnnounceVoteFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.OnAnnounceVoteFailed");
		
		AReferendum_OnAnnounceVoteFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.OnAnnounceNoVote
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotPlayerState*                      Voter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReferendum::OnAnnounceNoVote(class AReadyOrNotPlayerState* Voter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.OnAnnounceNoVote");
		
		AReferendum_OnAnnounceNoVote_Params params {};
		params.Voter = Voter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.Multicast_AnnounceYesVote
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotPlayerState*                      Voter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReferendum::Multicast_AnnounceYesVote(class AReadyOrNotPlayerState* Voter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.Multicast_AnnounceYesVote");
		
		AReferendum_Multicast_AnnounceYesVote_Params params {};
		params.Voter = Voter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.Multicast_AnnounceVoteStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotPlayerState*                      CallingVoter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReferendum::Multicast_AnnounceVoteStarted(class AReadyOrNotPlayerState* CallingVoter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.Multicast_AnnounceVoteStarted");
		
		AReferendum_Multicast_AnnounceVoteStarted_Params params {};
		params.CallingVoter = CallingVoter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.Multicast_AnnounceVotePassed
	 * 		Flags  -> ()
	 */
	void AReferendum::Multicast_AnnounceVotePassed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.Multicast_AnnounceVotePassed");
		
		AReferendum_Multicast_AnnounceVotePassed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.Multicast_AnnounceVoteFailed
	 * 		Flags  -> ()
	 */
	void AReferendum::Multicast_AnnounceVoteFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.Multicast_AnnounceVoteFailed");
		
		AReferendum_Multicast_AnnounceVoteFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.Multicast_AnnounceNoVote
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotPlayerState*                      Voter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReferendum::Multicast_AnnounceNoVote(class AReadyOrNotPlayerState* Voter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.Multicast_AnnounceNoVote");
		
		AReferendum_Multicast_AnnounceNoVote_Params params {};
		params.Voter = Voter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.GetHudDescription
	 * 		Flags  -> ()
	 */
	class FText AReferendum::GetHudDescription()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.GetHudDescription");
		
		AReferendum_GetHudDescription_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.CastedYesVote
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotPlayerController*                 Voter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReferendum::CastedYesVote(class AReadyOrNotPlayerController* Voter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.CastedYesVote");
		
		AReferendum_CastedYesVote_Params params {};
		params.Voter = Voter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Referendum.CastedNoVote
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotPlayerController*                 Voter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReferendum::CastedNoVote(class AReadyOrNotPlayerController* Voter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Referendum.CastedNoVote");
		
		AReferendum_CastedNoVote_Params params {};
		params.Voter = Voter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReferendum.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReferendum::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Referendum");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMapReferendum.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMapReferendum::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MapReferendum");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapStatisticsSystem.StartRecording
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InLevelName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InGameMode                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMapStatisticsSystem::StartRecording(const class FString& InLevelName, const class FString& InGameMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapStatisticsSystem.StartRecording");
		
		AMapStatisticsSystem_StartRecording_Params params {};
		params.InLevelName = InLevelName;
		params.InGameMode = InGameMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapStatisticsSystem.IsRecording
	 * 		Flags  -> ()
	 */
	bool AMapStatisticsSystem::IsRecording()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapStatisticsSystem.IsRecording");
		
		AMapStatisticsSystem_IsRecording_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapStatisticsSystem.GetRecordingStatus
	 * 		Flags  -> ()
	 */
	class FString AMapStatisticsSystem::GetRecordingStatus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapStatisticsSystem.GetRecordingStatus");
		
		AMapStatisticsSystem_GetRecordingStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapStatisticsSystem.GetGameId
	 * 		Flags  -> ()
	 */
	struct FGuid AMapStatisticsSystem::GetGameId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapStatisticsSystem.GetGameId");
		
		AMapStatisticsSystem_GetGameId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MapStatisticsSystem.EndLevel
	 * 		Flags  -> ()
	 */
	void AMapStatisticsSystem::EndLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MapStatisticsSystem.EndLevel");
		
		AMapStatisticsSystem_EndLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMapStatisticsSystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMapStatisticsSystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MapStatisticsSystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMatchStatusCardWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMatchStatusCardWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MatchStatusCardWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMatchTimeRemainingWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMatchTimeRemainingWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MatchTimeRemainingWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MedicalHealWidget.StartHealCompleteAnim
	 * 		Flags  -> ()
	 */
	void UMedicalHealWidget::StartHealCompleteAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MedicalHealWidget.StartHealCompleteAnim");
		
		UMedicalHealWidget_StartHealCompleteAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MedicalHealWidget.StartFadeOutAnim
	 * 		Flags  -> ()
	 */
	void UMedicalHealWidget::StartFadeOutAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MedicalHealWidget.StartFadeOutAnim");
		
		UMedicalHealWidget_StartFadeOutAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MedicalHealWidget.StartFadeInAnim
	 * 		Flags  -> ()
	 */
	void UMedicalHealWidget::StartFadeInAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MedicalHealWidget.StartFadeInAnim");
		
		UMedicalHealWidget_StartFadeInAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MedicalHealWidget.ShowNoBrokenLimbsWidget
	 * 		Flags  -> ()
	 */
	void UMedicalHealWidget::ShowNoBrokenLimbsWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MedicalHealWidget.ShowNoBrokenLimbsWidget");
		
		UMedicalHealWidget_ShowNoBrokenLimbsWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MedicalHealWidget.ShowMortallyWoundedWidget
	 * 		Flags  -> ()
	 */
	void UMedicalHealWidget::ShowMortallyWoundedWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MedicalHealWidget.ShowMortallyWoundedWidget");
		
		UMedicalHealWidget_ShowMortallyWoundedWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MedicalHealWidget.ShowHealerWidget
	 * 		Flags  -> ()
	 */
	void UMedicalHealWidget::ShowHealerWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MedicalHealWidget.ShowHealerWidget");
		
		UMedicalHealWidget_ShowHealerWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MedicalHealWidget.ShowHealeeWidget
	 * 		Flags  -> ()
	 */
	void UMedicalHealWidget::ShowHealeeWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MedicalHealWidget.ShowHealeeWidget");
		
		UMedicalHealWidget_ShowHealeeWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MedicalHealWidget.SetCurrentHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMedicalHealWidget::SetCurrentHealth(float NewHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MedicalHealWidget.SetCurrentHealth");
		
		UMedicalHealWidget_SetCurrentHealth_Params params {};
		params.NewHealth = NewHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MedicalHealWidget.InitializeWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        InHealerName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        InHealeeName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InCurrentHealth                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InMinHealth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InMaxHealth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMedicalHealWidget::InitializeWidget(const class FName& InHealerName, const class FName& InHealeeName, float InCurrentHealth, float InMinHealth, float InMaxHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MedicalHealWidget.InitializeWidget");
		
		UMedicalHealWidget_InitializeWidget_Params params {};
		params.InHealerName = InHealerName;
		params.InHealeeName = InHealeeName;
		params.InCurrentHealth = InCurrentHealth;
		params.InMinHealth = InMinHealth;
		params.InMaxHealth = InMaxHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MedicalHealWidget.GetWidgetSwitcher
	 * 		Flags  -> ()
	 */
	class UWidgetSwitcher* UMedicalHealWidget::GetWidgetSwitcher()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MedicalHealWidget.GetWidgetSwitcher");
		
		UMedicalHealWidget_GetWidgetSwitcher_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MedicalHealWidget.GetHealerHealingProgressBar
	 * 		Flags  -> ()
	 */
	class UProgressBar* UMedicalHealWidget::GetHealerHealingProgressBar()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MedicalHealWidget.GetHealerHealingProgressBar");
		
		UMedicalHealWidget_GetHealerHealingProgressBar_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MedicalHealWidget.GetHealeeHealingProgressBar
	 * 		Flags  -> ()
	 */
	class UProgressBar* UMedicalHealWidget::GetHealeeHealingProgressBar()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MedicalHealWidget.GetHealeeHealingProgressBar");
		
		UMedicalHealWidget_GetHealeeHealingProgressBar_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMedicalHealWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMedicalHealWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MedicalHealWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Meleeable.ShouldPlayMeleeEffectsLocally
	 * 		Flags  -> ()
	 */
	bool UMeleeable::ShouldPlayMeleeEffectsLocally()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Meleeable.ShouldPlayMeleeEffectsLocally");
		
		UMeleeable_ShouldPlayMeleeEffectsLocally_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Meleeable.OnMelee
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Attacker                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UMeleeable::OnMelee(class AReadyOrNotCharacter* Attacker, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Meleeable.OnMelee");
		
		UMeleeable_OnMelee_Params params {};
		params.Attacker = Attacker;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Meleeable.GetMeleeImpactSound
	 * 		Flags  -> ()
	 */
	class UFMODEvent* UMeleeable::GetMeleeImpactSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Meleeable.GetMeleeImpactSound");
		
		UMeleeable_GetMeleeImpactSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Meleeable.GetMeleeImpactParticle
	 * 		Flags  -> ()
	 */
	class UParticleSystem* UMeleeable::GetMeleeImpactParticle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Meleeable.GetMeleeImpactParticle");
		
		UMeleeable_GetMeleeImpactParticle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMeleeable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMeleeable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Meleeable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMeleeWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMeleeWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MeleeWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMessageDisplayBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMessageDisplayBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MessageDisplayBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MessagePromptActor.ShowMessageThroughPopUp
	 * 		Flags  -> ()
	 */
	void AMessagePromptActor::ShowMessageThroughPopUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MessagePromptActor.ShowMessageThroughPopUp");
		
		AMessagePromptActor_ShowMessageThroughPopUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MessagePromptActor.HideMessagePopUp
	 * 		Flags  -> ()
	 */
	void AMessagePromptActor::HideMessagePopUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MessagePromptActor.HideMessagePopUp");
		
		AMessagePromptActor_HideMessagePopUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MessagePromptActor.GenerateMessageContent
	 * 		Flags  -> ()
	 */
	void AMessagePromptActor::GenerateMessageContent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MessagePromptActor.GenerateMessageContent");
		
		AMessagePromptActor_GenerateMessageContent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMessagePromptActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMessagePromptActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MessagePromptActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMirror.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMirror::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Mirror");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMirrorPortalComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMirrorPortalComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MirrorPortalComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MirrorUnderDoorActivity.MirrorForCustom
	 * 		Flags  -> ()
	 */
	void UMirrorUnderDoorActivity::MirrorForCustom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MirrorUnderDoorActivity.MirrorForCustom");
		
		UMirrorUnderDoorActivity_MirrorForCustom_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMirrorUnderDoorActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMirrorUnderDoorActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MirrorUnderDoorActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MirrorZoneComponent.GetFurthestMirrorPortalFrom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMirrorPortalComponent* UMirrorZoneComponent::GetFurthestMirrorPortalFrom(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MirrorZoneComponent.GetFurthestMirrorPortalFrom");
		
		UMirrorZoneComponent_GetFurthestMirrorPortalFrom_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMirrorZoneComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMirrorZoneComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MirrorZoneComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPlanWidget.RemoveMarker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMissionPlanWidget::RemoveMarker(int32_t ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPlanWidget.RemoveMarker");
		
		UMissionPlanWidget_RemoveMarker_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPlanWidget.RemoveLine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMissionPlanWidget::RemoveLine(int32_t ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPlanWidget.RemoveLine");
		
		UMissionPlanWidget_RemoveLine_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPlanWidget.OnMarkerRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMissionPlanWidget::OnMarkerRemoved(int32_t ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPlanWidget.OnMarkerRemoved");
		
		UMissionPlanWidget_OnMarkerRemoved_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPlanWidget.OnMarkerAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPlanningMarker                             Marker                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UMissionPlanWidget::OnMarkerAdded(int32_t ID, const struct FPlanningMarker& Marker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPlanWidget.OnMarkerAdded");
		
		UMissionPlanWidget_OnMarkerAdded_Params params {};
		params.ID = ID;
		params.Marker = Marker;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPlanWidget.OnLineRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMissionPlanWidget::OnLineRemoved(int32_t ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPlanWidget.OnLineRemoved");
		
		UMissionPlanWidget_OnLineRemoved_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPlanWidget.OnLineAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPlanningLine                               Line                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UMissionPlanWidget::OnLineAdded(int32_t ID, const struct FPlanningLine& Line)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPlanWidget.OnLineAdded");
		
		UMissionPlanWidget_OnLineAdded_Params params {};
		params.ID = ID;
		params.Line = Line;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPlanWidget.AddMarker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlanningMarker                             Marker                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UMissionPlanWidget::AddMarker(const struct FPlanningMarker& Marker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPlanWidget.AddMarker");
		
		UMissionPlanWidget_AddMarker_Params params {};
		params.Marker = Marker;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPlanWidget.AddLine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlanningLine                               Line                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UMissionPlanWidget::AddLine(const struct FPlanningLine& Line)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPlanWidget.AddLine");
		
		UMissionPlanWidget_AddLine_Params params {};
		params.Line = Line;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMissionPlanWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMissionPlanWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MissionPlanWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPortal.SetSelectedMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        InMode                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMissionPortal::SetSelectedMode(const class FName& InMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPortal.SetSelectedMode");
		
		AMissionPortal_SetSelectedMode_Params params {};
		params.InMode = InMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPortal.SetSelectedMission
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InMissionURL                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMissionPortal::SetSelectedMission(const class FString& InMissionURL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPortal.SetSelectedMission");
		
		AMissionPortal_SetSelectedMission_Params params {};
		params.InMissionURL = InMissionURL;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPortal.OnRep_MissionURL
	 * 		Flags  -> ()
	 */
	void AMissionPortal::OnRep_MissionURL()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPortal.OnRep_MissionURL");
		
		AMissionPortal_OnRep_MissionURL_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPortal.IsMissionStarting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bStarting                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Countdown                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AMissionPortal::IsMissionStarting(bool* bStarting, float* Countdown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPortal.IsMissionStarting");
		
		AMissionPortal_IsMissionStarting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bStarting != nullptr)
			*bStarting = params.bStarting;
		if (Countdown != nullptr)
			*Countdown = params.Countdown;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPortal.IsLevelUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InUrl                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               OutbUnlocked                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutScoreRequired                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OutLockedURl                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AMissionPortal::IsLevelUnlocked(const class FString& InUrl, bool* OutbUnlocked, float* OutScoreRequired, class FString* OutLockedURl)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPortal.IsLevelUnlocked");
		
		AMissionPortal_IsLevelUnlocked_Params params {};
		params.InUrl = InUrl;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutbUnlocked != nullptr)
			*OutbUnlocked = params.OutbUnlocked;
		if (OutScoreRequired != nullptr)
			*OutScoreRequired = params.OutScoreRequired;
		if (OutLockedURl != nullptr)
			*OutLockedURl = params.OutLockedURl;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPortal.IsGameModeSelectable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECOOPMode                                          InMode                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AMissionPortal::IsGameModeSelectable(ECOOPMode InMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPortal.IsGameModeSelectable");
		
		AMissionPortal_IsGameModeSelectable_Params params {};
		params.InMode = InMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPortal.GetSelectedModeName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      OutName                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AMissionPortal::GetSelectedModeName(class FString* OutName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPortal.GetSelectedModeName");
		
		AMissionPortal_GetSelectedModeName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutName != nullptr)
			*OutName = params.OutName;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPortal.GetSelectedMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      OutMode                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AMissionPortal::GetSelectedMode(class FString* OutMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPortal.GetSelectedMode");
		
		AMissionPortal_GetSelectedMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutMode != nullptr)
			*OutMode = params.OutMode;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPortal.GetSelectedMission
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      OutMissionURL                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMissionPortal::GetSelectedMission(class FString* OutMissionURL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPortal.GetSelectedMission");
		
		AMissionPortal_GetSelectedMission_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutMissionURL != nullptr)
			*OutMissionURL = params.OutMissionURL;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPortal.GetPlayersReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Ready                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Total                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AMissionPortal::GetPlayersReady(int32_t* Ready, int32_t* Total)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPortal.GetPlayersReady");
		
		AMissionPortal_GetPlayersReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Ready != nullptr)
			*Ready = params.Ready;
		if (Total != nullptr)
			*Total = params.Total;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPortal.GetAutostartCountdown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Countdown                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AMissionPortal::GetAutostartCountdown(float* Countdown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPortal.GetAutostartCountdown");
		
		AMissionPortal_GetAutostartCountdown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Countdown != nullptr)
			*Countdown = params.Countdown;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MissionPortal.DoesLevelExistInBuild
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InUrl                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AMissionPortal::DoesLevelExistInBuild(const class FString& InUrl)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MissionPortal.DoesLevelExistInBuild");
		
		AMissionPortal_DoesLevelExistInBuild_Params params {};
		params.InUrl = InUrl;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMissionPortal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMissionPortal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MissionPortal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.IsSubscribed
	 * 		Flags  -> ()
	 */
	bool UModData::IsSubscribed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.IsSubscribed");
		
		UModData_IsSubscribed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.IsInstalled
	 * 		Flags  -> ()
	 */
	bool UModData::IsInstalled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.IsInstalled");
		
		UModData_IsInstalled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetTotalRatings
	 * 		Flags  -> ()
	 */
	int32_t UModData::GetTotalRatings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetTotalRatings");
		
		UModData_GetTotalRatings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetSubscriptions
	 * 		Flags  -> ()
	 */
	int32_t UModData::GetSubscriptions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetSubscriptions");
		
		UModData_GetSubscriptions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetResourceID
	 * 		Flags  -> ()
	 */
	class FString UModData::GetResourceID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetResourceID");
		
		UModData_GetResourceID_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetRatingDisplayText
	 * 		Flags  -> ()
	 */
	class FString UModData::GetRatingDisplayText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetRatingDisplayText");
		
		UModData_GetRatingDisplayText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetPositiveRatings
	 * 		Flags  -> ()
	 */
	int32_t UModData::GetPositiveRatings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetPositiveRatings");
		
		UModData_GetPositiveRatings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetPositiveRatingPercent
	 * 		Flags  -> ()
	 */
	int32_t UModData::GetPositiveRatingPercent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetPositiveRatingPercent");
		
		UModData_GetPositiveRatingPercent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetPopularityRank
	 * 		Flags  -> ()
	 */
	int32_t UModData::GetPopularityRank()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetPopularityRank");
		
		UModData_GetPopularityRank_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetNegativeRatings
	 * 		Flags  -> ()
	 */
	int32_t UModData::GetNegativeRatings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetNegativeRatings");
		
		UModData_GetNegativeRatings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetModURL
	 * 		Flags  -> ()
	 */
	class FString UModData::GetModURL()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetModURL");
		
		UModData_GetModURL_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetModName
	 * 		Flags  -> ()
	 */
	class FString UModData::GetModName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetModName");
		
		UModData_GetModName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetModAuthor
	 * 		Flags  -> ()
	 */
	class FString UModData::GetModAuthor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetModAuthor");
		
		UModData_GetModAuthor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetLastUpdated
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FDateTime UModData::GetLastUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetLastUpdated");
		
		UModData_GetLastUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetGalleryImageCount
	 * 		Flags  -> ()
	 */
	int32_t UModData::GetGalleryImageCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetGalleryImageCount");
		
		UModData_GetGalleryImageCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetDownloadSize
	 * 		Flags  -> ()
	 */
	int32_t UModData::GetDownloadSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetDownloadSize");
		
		UModData_GetDownloadSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetDownloads
	 * 		Flags  -> ()
	 */
	int32_t UModData::GetDownloads()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetDownloads");
		
		UModData_GetDownloads_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModData.GetDescription
	 * 		Flags  -> ()
	 */
	class FText UModData::GetDescription()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModData.GetDescription");
		
		UModData_GetDescription_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UModData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UModData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ModData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.SetupMod
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UModData*                                    InModData                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UModManagerWidget*                           Parent                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModCardWidget::SetupMod(class UModData* InModData, class UModManagerWidget* Parent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.SetupMod");
		
		UModCardWidget_SetupMod_Params params {};
		params.InModData = InModData;
		params.Parent = Parent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.RequestSubscription
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSubscribe                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UModCardWidget::RequestSubscription(bool bSubscribe)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.RequestSubscription");
		
		UModCardWidget_RequestSubscription_Params params {};
		params.bSubscribe = bSubscribe;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.RequestRatingReset
	 * 		Flags  -> ()
	 */
	void UModCardWidget::RequestRatingReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.RequestRatingReset");
		
		UModCardWidget_RequestRatingReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.RequestPositiveRating
	 * 		Flags  -> ()
	 */
	void UModCardWidget::RequestPositiveRating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.RequestPositiveRating");
		
		UModCardWidget_RequestPositiveRating_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.RequestNegativeRating
	 * 		Flags  -> ()
	 */
	void UModCardWidget::RequestNegativeRating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.RequestNegativeRating");
		
		UModCardWidget_RequestNegativeRating_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.RequestImage
	 * 		Flags  -> ()
	 */
	void UModCardWidget::RequestImage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.RequestImage");
		
		UModCardWidget_RequestImage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.RequestGallery
	 * 		Flags  -> ()
	 */
	void UModCardWidget::RequestGallery()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.RequestGallery");
		
		UModCardWidget_RequestGallery_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.RequestFullSizeGalleryImage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModCardWidget::RequestFullSizeGalleryImage(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.RequestFullSizeGalleryImage");
		
		UModCardWidget_RequestFullSizeGalleryImage_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.OnThumbnailLoaded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTexture2DDynamic*                           Image                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModCardWidget::OnThumbnailLoaded(class UTexture2DDynamic* Image)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.OnThumbnailLoaded");
		
		UModCardWidget_OnThumbnailLoaded_Params params {};
		params.Image = Image;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.OnRatingSubmitted
	 * 		Flags  -> ()
	 */
	void UModCardWidget::OnRatingSubmitted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.OnRatingSubmitted");
		
		UModCardWidget_OnRatingSubmitted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.OnModStateUpdated
	 * 		Flags  -> ()
	 */
	void UModCardWidget::OnModStateUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.OnModStateUpdated");
		
		UModCardWidget_OnModStateUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.OnModSet
	 * 		Flags  -> ()
	 */
	void UModCardWidget::OnModSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.OnModSet");
		
		UModCardWidget_OnModSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.OnLoadingStarted
	 * 		Flags  -> ()
	 */
	void UModCardWidget::OnLoadingStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.OnLoadingStarted");
		
		UModCardWidget_OnLoadingStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.OnLoadingFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSubscribed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModCardWidget::OnLoadingFinished(bool bSubscribed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.OnLoadingFinished");
		
		UModCardWidget_OnLoadingFinished_Params params {};
		params.bSubscribed = bSubscribed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.OnGalleryImageLoaded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTexture2DDynamic*                           Image                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModCardWidget::OnGalleryImageLoaded(class UTexture2DDynamic* Image, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.OnGalleryImageLoaded");
		
		UModCardWidget_OnGalleryImageLoaded_Params params {};
		params.Image = Image;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.OnFullSizeGalleryImageLoaded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTexture2DDynamic*                           Image                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModCardWidget::OnFullSizeGalleryImageLoaded(class UTexture2DDynamic* Image, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.OnFullSizeGalleryImageLoaded");
		
		UModCardWidget_OnFullSizeGalleryImageLoaded_Params params {};
		params.Image = Image;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModCardWidget.GetModData
	 * 		Flags  -> ()
	 */
	class UModData* UModCardWidget::GetModData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModCardWidget.GetModData");
		
		UModCardWidget_GetModData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UModCardWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UModCardWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ModCardWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModioAuthenticatorWidget.SubmitSecurityCode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SecurityCode                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModioAuthenticatorWidget::SubmitSecurityCode(const class FString& SecurityCode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModioAuthenticatorWidget.SubmitSecurityCode");
		
		UModioAuthenticatorWidget_SubmitSecurityCode_Params params {};
		params.SecurityCode = SecurityCode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModioAuthenticatorWidget.SubmitEmail
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      EmailAddress                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModioAuthenticatorWidget::SubmitEmail(const class FString& EmailAddress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModioAuthenticatorWidget.SubmitEmail");
		
		UModioAuthenticatorWidget_SubmitEmail_Params params {};
		params.EmailAddress = EmailAddress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModioAuthenticatorWidget.SetupAuthenticator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UModManagerWidget*                           Parent                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModioAuthenticatorWidget::SetupAuthenticator(class UModManagerWidget* Parent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModioAuthenticatorWidget.SetupAuthenticator");
		
		UModioAuthenticatorWidget_SetupAuthenticator_Params params {};
		params.Parent = Parent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModioAuthenticatorWidget.RequestSteamAuthentication
	 * 		Flags  -> ()
	 */
	void UModioAuthenticatorWidget::RequestSteamAuthentication()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModioAuthenticatorWidget.RequestSteamAuthentication");
		
		UModioAuthenticatorWidget_RequestSteamAuthentication_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModioAuthenticatorWidget.OnTermsOfUseAcceptanceRequested
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Terms                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTermsOfUse                                 Localization                                               (Parm, NativeAccessSpecifierPublic)
	 */
	void UModioAuthenticatorWidget::OnTermsOfUseAcceptanceRequested(const class FString& Terms, const struct FTermsOfUse& Localization)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModioAuthenticatorWidget.OnTermsOfUseAcceptanceRequested");
		
		UModioAuthenticatorWidget_OnTermsOfUseAcceptanceRequested_Params params {};
		params.Terms = Terms;
		params.Localization = Localization;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModioAuthenticatorWidget.OnSecurityCodeRequested
	 * 		Flags  -> ()
	 */
	void UModioAuthenticatorWidget::OnSecurityCodeRequested()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModioAuthenticatorWidget.OnSecurityCodeRequested");
		
		UModioAuthenticatorWidget_OnSecurityCodeRequested_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModioAuthenticatorWidget.OnErrorSet
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ErrorMessage                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModioAuthenticatorWidget::OnErrorSet(const class FString& ErrorMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModioAuthenticatorWidget.OnErrorSet");
		
		UModioAuthenticatorWidget_OnErrorSet_Params params {};
		params.ErrorMessage = ErrorMessage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModioAuthenticatorWidget.OnEmailRequested
	 * 		Flags  -> ()
	 */
	void UModioAuthenticatorWidget::OnEmailRequested()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModioAuthenticatorWidget.OnEmailRequested");
		
		UModioAuthenticatorWidget_OnEmailRequested_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModioAuthenticatorWidget.AcceptTermsOfUse
	 * 		Flags  -> ()
	 */
	void UModioAuthenticatorWidget::AcceptTermsOfUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModioAuthenticatorWidget.AcceptTermsOfUse");
		
		UModioAuthenticatorWidget_AcceptTermsOfUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UModioAuthenticatorWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UModioAuthenticatorWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ModioAuthenticatorWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModioManager.IsRestartRequired
	 * 		Flags  -> ()
	 */
	bool UModioManager::IsRestartRequired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModioManager.IsRestartRequired");
		
		UModioManager_IsRestartRequired_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModioManager.IsModIoEnabled
	 * 		Flags  -> ()
	 */
	bool UModioManager::IsModIoEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModioManager.IsModIoEnabled");
		
		UModioManager_IsModIoEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModioManager.GetInstance
	 * 		Flags  -> ()
	 */
	class UModioManager* UModioManager::GetInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModioManager.GetInstance");
		
		UModioManager_GetInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModioManager.ClearUserData
	 * 		Flags  -> ()
	 */
	void UModioManager::ClearUserData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModioManager.ClearUserData");
		
		UModioManager_ClearUserData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UModioManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UModioManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ModioManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.ShowUserAuthenticator
	 * 		Flags  -> ()
	 */
	void UModManagerWidget::ShowUserAuthenticator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.ShowUserAuthenticator");
		
		UModManagerWidget_ShowUserAuthenticator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.ShowErrorDialog
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ErrorMessage                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModManagerWidget::ShowErrorDialog(const class FString& ErrorMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.ShowErrorDialog");
		
		UModManagerWidget_ShowErrorDialog_Params params {};
		params.ErrorMessage = ErrorMessage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.RequestSubscribedMods
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Search                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModManagerWidget::RequestSubscribedMods(const class FString& Search)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.RequestSubscribedMods");
		
		UModManagerWidget_RequestSubscribedMods_Params params {};
		params.Search = Search;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.RequestSearch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Query                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModManagerWidget::RequestSearch(const class FString& Query)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.RequestSearch");
		
		UModManagerWidget_RequestSearch_Params params {};
		params.Query = Query;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.RequestRefresh
	 * 		Flags  -> ()
	 */
	void UModManagerWidget::RequestRefresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.RequestRefresh");
		
		UModManagerWidget_RequestRefresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.RequestProfilePicture
	 * 		Flags  -> ()
	 */
	void UModManagerWidget::RequestProfilePicture()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.RequestProfilePicture");
		
		UModManagerWidget_RequestProfilePicture_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.RequestAllMods
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Search                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModManagerWidget::RequestAllMods(const class FString& Search)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.RequestAllMods");
		
		UModManagerWidget_RequestAllMods_Params params {};
		params.Search = Search;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.OnUserAuthenticated
	 * 		Flags  -> ()
	 */
	void UModManagerWidget::OnUserAuthenticated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.OnUserAuthenticated");
		
		UModManagerWidget_OnUserAuthenticated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.OnProfilePictureLoaded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTexture2DDynamic*                           Image                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModManagerWidget::OnProfilePictureLoaded(class UTexture2DDynamic* Image)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.OnProfilePictureLoaded");
		
		UModManagerWidget_OnProfilePictureLoaded_Params params {};
		params.Image = Image;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.OnLoadingStarted
	 * 		Flags  -> ()
	 */
	void UModManagerWidget::OnLoadingStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.OnLoadingStarted");
		
		UModManagerWidget_OnLoadingStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.OnLoadingFinished
	 * 		Flags  -> ()
	 */
	void UModManagerWidget::OnLoadingFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.OnLoadingFinished");
		
		UModManagerWidget_OnLoadingFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.GetUsername
	 * 		Flags  -> ()
	 */
	class FString UModManagerWidget::GetUsername()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.GetUsername");
		
		UModManagerWidget_GetUsername_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.ClearMods
	 * 		Flags  -> ()
	 */
	void UModManagerWidget::ClearMods()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.ClearMods");
		
		UModManagerWidget_ClearMods_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModManagerWidget.AddMod
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UModData*                                    ModData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModManagerWidget::AddMod(class UModData* ModData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModManagerWidget.AddMod");
		
		UModManagerWidget_AddMod_Params params {};
		params.ModData = ModData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UModManagerWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UModManagerWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ModManagerWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModProgressWidget.OnQueueProgressUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            CompletedMods                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TotalMods                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModProgressWidget::OnQueueProgressUpdated(int32_t CompletedMods, int32_t TotalMods)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModProgressWidget.OnQueueProgressUpdated");
		
		UModProgressWidget_OnQueueProgressUpdated_Params params {};
		params.CompletedMods = CompletedMods;
		params.TotalMods = TotalMods;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModProgressWidget.OnModNameUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ModName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModProgressWidget::OnModNameUpdated(const class FString& ModName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModProgressWidget.OnModNameUpdated");
		
		UModProgressWidget_OnModNameUpdated_Params params {};
		params.ModName = ModName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ModProgressWidget.OnDownloadProgressUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DownloadPercent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ExtractionPercent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        PercentText                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        RemainingText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UModProgressWidget::OnDownloadProgressUpdated(float DownloadPercent, float ExtractionPercent, const class FText& PercentText, const class FText& RemainingText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ModProgressWidget.OnDownloadProgressUpdated");
		
		UModProgressWidget_OnDownloadProgressUpdated_Params params {};
		params.DownloadPercent = DownloadPercent;
		params.ExtractionPercent = ExtractionPercent;
		params.PercentText = PercentText;
		params.RemainingText = RemainingText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UModProgressWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UModProgressWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ModProgressWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MoraleComponent.WillGiveUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Yeller                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UMoraleComponent::WillGiveUp(class AReadyOrNotCharacter* Yeller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MoraleComponent.WillGiveUp");
		
		UMoraleComponent_WillGiveUp_Params params {};
		params.Yeller = Yeller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MoraleComponent.ResetMoraleOnCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMoraleComponent::ResetMoraleOnCharacter(class ACyberneticCharacter* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MoraleComponent.ResetMoraleOnCharacter");
		
		UMoraleComponent_ResetMoraleOnCharacter_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MoraleComponent.LowerMoraleOnCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MoraleValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMoraleComponent::LowerMoraleOnCharacter(class ACyberneticCharacter* Character, float MoraleValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MoraleComponent.LowerMoraleOnCharacter");
		
		UMoraleComponent_LowerMoraleOnCharacter_Params params {};
		params.Character = Character;
		params.MoraleValue = MoraleValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MoraleComponent.IncreaseMoraleOnCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MoraleValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMoraleComponent::IncreaseMoraleOnCharacter(class ACyberneticCharacter* Character, float MoraleValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MoraleComponent.IncreaseMoraleOnCharacter");
		
		UMoraleComponent_IncreaseMoraleOnCharacter_Params params {};
		params.Character = Character;
		params.MoraleValue = MoraleValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MoraleComponent.HasBeenYelledAt
	 * 		Flags  -> ()
	 */
	bool UMoraleComponent::HasBeenYelledAt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MoraleComponent.HasBeenYelledAt");
		
		UMoraleComponent_HasBeenYelledAt_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MoraleComponent.GetTimeSinceLastYelledAt
	 * 		Flags  -> ()
	 */
	float UMoraleComponent::GetTimeSinceLastYelledAt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MoraleComponent.GetTimeSinceLastYelledAt");
		
		UMoraleComponent_GetTimeSinceLastYelledAt_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MoraleComponent.GetMorale
	 * 		Flags  -> ()
	 */
	float UMoraleComponent::GetMorale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MoraleComponent.GetMorale");
		
		UMoraleComponent_GetMorale_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MoraleComponent.ChangeMoraleOnCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MoraleValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMoraleComponent::ChangeMoraleOnCharacter(class ACyberneticCharacter* Character, float MoraleValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MoraleComponent.ChangeMoraleOnCharacter");
		
		UMoraleComponent_ChangeMoraleOnCharacter_Params params {};
		params.Character = Character;
		params.MoraleValue = MoraleValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MoraleComponent.ChangeMoraleInArea
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MoraleValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLOSOnly                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<ETeamType>                                  Teams                                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UMoraleComponent::ChangeMoraleInArea(const struct FCoreUObject_FVector& Location, float MoraleValue, float Range, bool bLOSOnly, TArray<ETeamType> Teams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MoraleComponent.ChangeMoraleInArea");
		
		UMoraleComponent_ChangeMoraleInArea_Params params {};
		params.Location = Location;
		params.MoraleValue = MoraleValue;
		params.Range = Range;
		params.bLOSOnly = bLOSOnly;
		params.Teams = Teams;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMoraleComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMoraleComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MoraleComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMoveActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMoveActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MoveActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MoveAndClearQuestNode.OnSWATBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      VolumeActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OverlappingActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMoveAndClearQuestNode::OnSWATBeginOverlap(class AActor* VolumeActor, class AActor* OverlappingActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MoveAndClearQuestNode.OnSWATBeginOverlap");
		
		UMoveAndClearQuestNode_OnSWATBeginOverlap_Params params {};
		params.VolumeActor = VolumeActor;
		params.OverlappingActor = OverlappingActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMoveAndClearQuestNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMoveAndClearQuestNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MoveAndClearQuestNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMoveIntoLOSActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMoveIntoLOSActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MoveIntoLOSActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMoveToPlayerSpawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMoveToPlayerSpawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MoveToPlayerSpawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Multitool.GetMultitoolOperatingTimeFromToolkit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMultitoolFunctions                                MultitoolFunction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AMultitool::GetMultitoolOperatingTimeFromToolkit(EMultitoolFunctions MultitoolFunction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Multitool.GetMultitoolOperatingTimeFromToolkit");
		
		AMultitool_GetMultitoolOperatingTimeFromToolkit_Params params {};
		params.MultitoolFunction = MultitoolFunction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Multitool.GetMultitoolOperatingTimeFromAudioLength
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFMODEvent*                                  Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AMultitool::GetMultitoolOperatingTimeFromAudioLength(class UFMODEvent* Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Multitool.GetMultitoolOperatingTimeFromAudioLength");
		
		AMultitool_GetMultitoolOperatingTimeFromAudioLength_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Multitool.GetMultitoolOperatingTimeFromActiveToolkit
	 * 		Flags  -> ()
	 */
	float AMultitool::GetMultitoolOperatingTimeFromActiveToolkit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Multitool.GetMultitoolOperatingTimeFromActiveToolkit");
		
		AMultitool_GetMultitoolOperatingTimeFromActiveToolkit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Multitool.Client_StopMultitoolAudio
	 * 		Flags  -> ()
	 */
	void AMultitool::Client_StopMultitoolAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Multitool.Client_StopMultitoolAudio");
		
		AMultitool_Client_StopMultitoolAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Multitool.Client_PlayMultitoolAudio
	 * 		Flags  -> ()
	 */
	void AMultitool::Client_PlayMultitoolAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Multitool.Client_PlayMultitoolAudio");
		
		AMultitool_Client_PlayMultitoolAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Multitool.Client_ChangeToolkit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMultitoolFunctions                                MultitoolFunction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayAnimation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMultitool::Client_ChangeToolkit(EMultitoolFunctions MultitoolFunction, bool bPlayAnimation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Multitool.Client_ChangeToolkit");
		
		AMultitool_Client_ChangeToolkit_Params params {};
		params.MultitoolFunction = MultitoolFunction;
		params.bPlayAnimation = bPlayAnimation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Multitool.ChangeToolkit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMultitoolFunctions                                MultitoolFunction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayAnimation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMultitool::ChangeToolkit(EMultitoolFunctions MultitoolFunction, bool bPlayAnimation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Multitool.ChangeToolkit");
		
		AMultitool_ChangeToolkit_Params params {};
		params.MultitoolFunction = MultitoolFunction;
		params.bPlayAnimation = bPlayAnimation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMultitool.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMultitool::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Multitool");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMusicData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMusicData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MusicData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicManager.UpdateMusicParameters
	 * 		Flags  -> ()
	 */
	void AMusicManager::UpdateMusicParameters()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicManager.UpdateMusicParameters");
		
		AMusicManager_UpdateMusicParameters_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicManager.StopTheMusic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bGoHome                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMusicManager::StopTheMusic(bool bGoHome)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicManager.StopTheMusic");
		
		AMusicManager_StopTheMusic_Params params {};
		params.bGoHome = bGoHome;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicManager.StopMusicParametersUpdate
	 * 		Flags  -> ()
	 */
	void AMusicManager::StopMusicParametersUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicManager.StopMusicParametersUpdate");
		
		AMusicManager_StopMusicParametersUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicManager.StartMusicParametersUpdate
	 * 		Flags  -> ()
	 */
	void AMusicManager::StartMusicParametersUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicManager.StartMusicParametersUpdate");
		
		AMusicManager_StartMusicParametersUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicManager.SetMusicParameterValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      paramName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ParamValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMusicManager::SetMusicParameterValue(const class FString& paramName, float ParamValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicManager.SetMusicParameterValue");
		
		AMusicManager_SetMusicParameterValue_Params params {};
		params.paramName = paramName;
		params.ParamValue = ParamValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicManager.ResumeMusicParametersUpdate
	 * 		Flags  -> ()
	 */
	void AMusicManager::ResumeMusicParametersUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicManager.ResumeMusicParametersUpdate");
		
		AMusicManager_ResumeMusicParametersUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicManager.PauseMusicParametersUpdate
	 * 		Flags  -> ()
	 */
	void AMusicManager::PauseMusicParametersUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicManager.PauseMusicParametersUpdate");
		
		AMusicManager_PauseMusicParametersUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicManager.GetMusicParameters
	 * 		Flags  -> ()
	 */
	TArray<class FString> AMusicManager::GetMusicParameters()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicManager.GetMusicParameters");
		
		AMusicManager_GetMusicParameters_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicManager.Get
	 * 		Flags  -> ()
	 */
	class AMusicManager* AMusicManager::Get()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicManager.Get");
		
		AMusicManager_Get_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMusicManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMusicManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MusicManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicSequencerBase.OnStoppedAudio
	 * 		Flags  -> ()
	 */
	void AMusicSequencerBase::OnStoppedAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicSequencerBase.OnStoppedAudio");
		
		AMusicSequencerBase_OnStoppedAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicSequencerBase.OnStartedTransitioningToState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMusicState                                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMusicSequencerBase::OnStartedTransitioningToState(EMusicState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicSequencerBase.OnStartedTransitioningToState");
		
		AMusicSequencerBase_OnStartedTransitioningToState_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicSequencerBase.OnAudioReset
	 * 		Flags  -> ()
	 */
	void AMusicSequencerBase::OnAudioReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicSequencerBase.OnAudioReset");
		
		AMusicSequencerBase_OnAudioReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicSequencerBase.Multicast_StopAudio
	 * 		Flags  -> ()
	 */
	void AMusicSequencerBase::Multicast_StopAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicSequencerBase.Multicast_StopAudio");
		
		AMusicSequencerBase_Multicast_StopAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicSequencerBase.Multicast_StartTransitioningToState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMusicState                                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMusicSequencerBase::Multicast_StartTransitioningToState(EMusicState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicSequencerBase.Multicast_StartTransitioningToState");
		
		AMusicSequencerBase_Multicast_StartTransitioningToState_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicSequencerBase.Multicast_ResetAudio
	 * 		Flags  -> ()
	 */
	void AMusicSequencerBase::Multicast_ResetAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicSequencerBase.Multicast_ResetAudio");
		
		AMusicSequencerBase_Multicast_ResetAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMusicSequencerBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMusicSequencerBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MusicSequencerBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicSequencerUnreal.PlayScriptedMusic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USoundCue*                                   Music                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMusicState                                        NewScriptedState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bImmediately                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMusicSequencerUnreal::PlayScriptedMusic(class USoundCue* Music, EMusicState NewScriptedState, bool bImmediately)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicSequencerUnreal.PlayScriptedMusic");
		
		AMusicSequencerUnreal_PlayScriptedMusic_Params params {};
		params.Music = Music;
		params.NewScriptedState = NewScriptedState;
		params.bImmediately = bImmediately;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicSequencerUnreal.OnAudioPlaybackPercent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USoundWave*                                  PlayingSoundWave                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlaybackPercent                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMusicSequencerUnreal::OnAudioPlaybackPercent(class USoundWave* PlayingSoundWave, float PlaybackPercent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicSequencerUnreal.OnAudioPlaybackPercent");
		
		AMusicSequencerUnreal_OnAudioPlaybackPercent_Params params {};
		params.PlayingSoundWave = PlayingSoundWave;
		params.PlaybackPercent = PlaybackPercent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.MusicSequencerUnreal.OnAudioFinished
	 * 		Flags  -> ()
	 */
	void AMusicSequencerUnreal::OnAudioFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.MusicSequencerUnreal.OnAudioFinished");
		
		AMusicSequencerUnreal_OnAudioFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMusicSequencerUnreal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMusicSequencerUnreal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.MusicSequencerUnreal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANavigationSplinePathPreview.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANavigationSplinePathPreview::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavigationSplinePathPreview");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANavSphereObstacle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANavSphereObstacle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavSphereObstacle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavSplinePathRenderingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavSplinePathRenderingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavSplinePathRenderingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANeutralizeSuspectByTag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANeutralizeSuspectByTag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NeutralizeSuspectByTag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.NightvisionGoggles.SpawnNightvisionWidget
	 * 		Flags  -> ()
	 */
	void ANightvisionGoggles::SpawnNightvisionWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.NightvisionGoggles.SpawnNightvisionWidget");
		
		ANightvisionGoggles_SpawnNightvisionWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.NightvisionGoggles.Server_SetTogglingNVG
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewTogglingNVG                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ANightvisionGoggles::Server_SetTogglingNVG(bool bNewTogglingNVG)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.NightvisionGoggles.Server_SetTogglingNVG");
		
		ANightvisionGoggles_Server_SetTogglingNVG_Params params {};
		params.bNewTogglingNVG = bNewTogglingNVG;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.NightvisionGoggles.OnNightvisionDeactivated
	 * 		Flags  -> ()
	 */
	void ANightvisionGoggles::OnNightvisionDeactivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.NightvisionGoggles.OnNightvisionDeactivated");
		
		ANightvisionGoggles_OnNightvisionDeactivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.NightvisionGoggles.OnNightvisionActivated
	 * 		Flags  -> ()
	 */
	void ANightvisionGoggles::OnNightvisionActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.NightvisionGoggles.OnNightvisionActivated");
		
		ANightvisionGoggles_OnNightvisionActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.NightvisionGoggles.DestroyNightvisionWidget
	 * 		Flags  -> ()
	 */
	void ANightvisionGoggles::DestroyNightvisionWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.NightvisionGoggles.DestroyNightvisionWidget");
		
		ANightvisionGoggles_DestroyNightvisionWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANightvisionGoggles.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANightvisionGoggles::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NightvisionGoggles");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNinebangDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNinebangDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NinebangDamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObituaryData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObituaryData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ObituaryData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.ToggleObjectiveMarkerVisibility
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerComponent::ToggleObjectiveMarkerVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.ToggleObjectiveMarkerVisibility");
		
		UObjectiveMarkerComponent_ToggleObjectiveMarkerVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.ShowObjectiveMarker
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerComponent::ShowObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.ShowObjectiveMarker");
		
		UObjectiveMarkerComponent_ShowObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.ShowMarkerText
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerComponent::ShowMarkerText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.ShowMarkerText");
		
		UObjectiveMarkerComponent_ShowMarkerText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.ShowIcon
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerComponent::ShowIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.ShowIcon");
		
		UObjectiveMarkerComponent_ShowIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.SetNewFadeDistance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewDistance                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerComponent::SetNewFadeDistance(float NewDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.SetNewFadeDistance");
		
		UObjectiveMarkerComponent_SetNewFadeDistance_Params params {};
		params.NewDistance = NewDistance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.SetMarkerTextFontSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewFontSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerComponent::SetMarkerTextFontSize(int32_t NewFontSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.SetMarkerTextFontSize");
		
		UObjectiveMarkerComponent_SetMarkerTextFontSize_Params params {};
		params.NewFontSize = NewFontSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.SetMarkerTextColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLinearColor                                InIconColorAndOpacity                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerComponent::SetMarkerTextColor(const struct FLinearColor& InIconColorAndOpacity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.SetMarkerTextColor");
		
		UObjectiveMarkerComponent_SetMarkerTextColor_Params params {};
		params.InIconColorAndOpacity = InIconColorAndOpacity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.SetMarkerText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        NewMarkerText                                              (Parm, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerComponent::SetMarkerText(const class FText& NewMarkerText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.SetMarkerText");
		
		UObjectiveMarkerComponent_SetMarkerText_Params params {};
		params.NewMarkerText = NewMarkerText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.SetIconSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector2D                      NewIconSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerComponent::SetIconSize(const struct FCoreUObject_FVector2D& NewIconSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.SetIconSize");
		
		UObjectiveMarkerComponent_SetIconSize_Params params {};
		params.NewIconSize = NewIconSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.SetIconColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLinearColor                                InIconColorAndOpacity                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerComponent::SetIconColor(const struct FLinearColor& InIconColorAndOpacity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.SetIconColor");
		
		UObjectiveMarkerComponent_SetIconColor_Params params {};
		params.InIconColorAndOpacity = InIconColorAndOpacity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.SetIconBrush
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSlateBrush                                 NewIconBrush                                               (Parm, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerComponent::SetIconBrush(const struct FSlateBrush& NewIconBrush)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.SetIconBrush");
		
		UObjectiveMarkerComponent_SetIconBrush_Params params {};
		params.NewIconBrush = NewIconBrush;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.IsObjectiveMarkerOffscreen
	 * 		Flags  -> ()
	 */
	bool UObjectiveMarkerComponent::IsObjectiveMarkerOffscreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.IsObjectiveMarkerOffscreen");
		
		UObjectiveMarkerComponent_IsObjectiveMarkerOffscreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.HideObjectiveMarker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFadeOut                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerComponent::HideObjectiveMarker(bool bFadeOut)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.HideObjectiveMarker");
		
		UObjectiveMarkerComponent_HideObjectiveMarker_Params params {};
		params.bFadeOut = bFadeOut;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.HideMarkerText
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerComponent::HideMarkerText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.HideMarkerText");
		
		UObjectiveMarkerComponent_HideMarkerText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.HideIcon
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerComponent::HideIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.HideIcon");
		
		UObjectiveMarkerComponent_HideIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.EnableObjectiveMarker
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerComponent::EnableObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.EnableObjectiveMarker");
		
		UObjectiveMarkerComponent_EnableObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.DisableObjectiveMarker
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerComponent::DisableObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.DisableObjectiveMarker");
		
		UObjectiveMarkerComponent_DisableObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerComponent.CanShowObjectiveMarker
	 * 		Flags  -> ()
	 */
	bool UObjectiveMarkerComponent::CanShowObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerComponent.CanShowObjectiveMarker");
		
		UObjectiveMarkerComponent_CanShowObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectiveMarkerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectiveMarkerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ObjectiveMarkerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.ShowMarkerText
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerWidget::ShowMarkerText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.ShowMarkerText");
		
		UObjectiveMarkerWidget_ShowMarkerText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.ShowIcon
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerWidget::ShowIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.ShowIcon");
		
		UObjectiveMarkerWidget_ShowIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.ShowAll
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerWidget::ShowAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.ShowAll");
		
		UObjectiveMarkerWidget_ShowAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.SetTargetLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerWidget::SetTargetLocation(const struct FCoreUObject_FVector& NewLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.SetTargetLocation");
		
		UObjectiveMarkerWidget_SetTargetLocation_Params params {};
		params.NewLocation = NewLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.SetMarkerNameTextFontSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewFontSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerWidget::SetMarkerNameTextFontSize(int32_t NewFontSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.SetMarkerNameTextFontSize");
		
		UObjectiveMarkerWidget_SetMarkerNameTextFontSize_Params params {};
		params.NewFontSize = NewFontSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.SetMarkerNameTextColorAndOpacity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLinearColor                                InColor                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerWidget::SetMarkerNameTextColorAndOpacity(const struct FLinearColor& InColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.SetMarkerNameTextColorAndOpacity");
		
		UObjectiveMarkerWidget_SetMarkerNameTextColorAndOpacity_Params params {};
		params.InColor = InColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.SetMarkerNameText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        NewMarkerNameText                                          (Parm, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerWidget::SetMarkerNameText(const class FText& NewMarkerNameText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.SetMarkerNameText");
		
		UObjectiveMarkerWidget_SetMarkerNameText_Params params {};
		params.NewMarkerNameText = NewMarkerNameText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.SetIconSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector2D                      NewIconSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerWidget::SetIconSize(const struct FCoreUObject_FVector2D& NewIconSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.SetIconSize");
		
		UObjectiveMarkerWidget_SetIconSize_Params params {};
		params.NewIconSize = NewIconSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.SetIconImage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSlateBrush                                 InBrush                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerWidget::SetIconImage(const struct FSlateBrush& InBrush)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.SetIconImage");
		
		UObjectiveMarkerWidget_SetIconImage_Params params {};
		params.InBrush = InBrush;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.SetIconColorAndOpacity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLinearColor                                InColor                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerWidget::SetIconColorAndOpacity(const struct FLinearColor& InColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.SetIconColorAndOpacity");
		
		UObjectiveMarkerWidget_SetIconColorAndOpacity_Params params {};
		params.InColor = InColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.SetDirectionAngle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveMarkerWidget::SetDirectionAngle(float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.SetDirectionAngle");
		
		UObjectiveMarkerWidget_SetDirectionAngle_Params params {};
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.OnMarkerVisibilityEnabled
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerWidget::OnMarkerVisibilityEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.OnMarkerVisibilityEnabled");
		
		UObjectiveMarkerWidget_OnMarkerVisibilityEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.OnMarkerVisibilityDisabled
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerWidget::OnMarkerVisibilityDisabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.OnMarkerVisibilityDisabled");
		
		UObjectiveMarkerWidget_OnMarkerVisibilityDisabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.HideMarkerText
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerWidget::HideMarkerText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.HideMarkerText");
		
		UObjectiveMarkerWidget_HideMarkerText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.HideIcon
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerWidget::HideIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.HideIcon");
		
		UObjectiveMarkerWidget_HideIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveMarkerWidget.HideAll
	 * 		Flags  -> ()
	 */
	void UObjectiveMarkerWidget::HideAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveMarkerWidget.HideAll");
		
		UObjectiveMarkerWidget_HideAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectiveMarkerWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectiveMarkerWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ObjectiveMarkerWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectivePoint.ToggleObjectiveMarkerVisibility
	 * 		Flags  -> ()
	 */
	void AObjectivePoint::ToggleObjectiveMarkerVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectivePoint.ToggleObjectiveMarkerVisibility");
		
		AObjectivePoint_ToggleObjectiveMarkerVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectivePoint.ShowObjectiveMarker
	 * 		Flags  -> ()
	 */
	void AObjectivePoint::ShowObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectivePoint.ShowObjectiveMarker");
		
		AObjectivePoint_ShowObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectivePoint.InitSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSlateBrush                                 Icon                                                       (Parm, NativeAccessSpecifierPublic)
	 * 		class FText                                        Text                                                       (Parm, NativeAccessSpecifierPublic)
	 * 		float                                              ShowMarkerAtDistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectivePoint::InitSettings(const struct FSlateBrush& Icon, const class FText& Text, float ShowMarkerAtDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectivePoint.InitSettings");
		
		AObjectivePoint_InitSettings_Params params {};
		params.Icon = Icon;
		params.Text = Text;
		params.ShowMarkerAtDistance = ShowMarkerAtDistance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectivePoint.HideObjectiveMarker
	 * 		Flags  -> ()
	 */
	void AObjectivePoint::HideObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectivePoint.HideObjectiveMarker");
		
		AObjectivePoint_HideObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AObjectivePoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AObjectivePoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ObjectivePoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AOcclusionTestActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AOcclusionTestActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.OcclusionTestActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.OneWayBlockingVolume.GetDirectionArrowComponent
	 * 		Flags  -> ()
	 */
	class UArrowComponent* AOneWayBlockingVolume::GetDirectionArrowComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.OneWayBlockingVolume.GetDirectionArrowComponent");
		
		AOneWayBlockingVolume_GetDirectionArrowComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.OneWayBlockingVolume.GetBoxComponent
	 * 		Flags  -> ()
	 */
	class UBoxComponent* AOneWayBlockingVolume::GetBoxComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.OneWayBlockingVolume.GetBoxComponent");
		
		AOneWayBlockingVolume_GetBoxComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AOneWayBlockingVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AOneWayBlockingVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.OneWayBlockingVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOpenCommandMenuQuestNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOpenCommandMenuQuestNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.OpenCommandMenuQuestNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOpenDoorQuestNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOpenDoorQuestNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.OpenDoorQuestNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOpenDoorTeamQuestNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOpenDoorTeamQuestNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.OpenDoorTeamQuestNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Optiwand.Server_NotifyMirroring
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsMirroring                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AOptiwand::Server_NotifyMirroring(bool bIsMirroring)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Optiwand.Server_NotifyMirroring");
		
		AOptiwand_Server_NotifyMirroring_Params params {};
		params.bIsMirroring = bIsMirroring;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Optiwand.IsCameraBlocked
	 * 		Flags  -> ()
	 */
	bool AOptiwand::IsCameraBlocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Optiwand.IsCameraBlocked");
		
		AOptiwand_IsCameraBlocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Optiwand.GetViewMode
	 * 		Flags  -> ()
	 */
	EOptiwandViewMode AOptiwand::GetViewMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Optiwand.GetViewMode");
		
		AOptiwand_GetViewMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AOptiwand.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AOptiwand::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Optiwand");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AOutOfBoundsVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AOutOfBoundsVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.OutOfBoundsVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PairedInteractionDriver.OnSlaveInteractionFinished
	 * 		Flags  -> ()
	 */
	void APairedInteractionDriver::OnSlaveInteractionFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PairedInteractionDriver.OnSlaveInteractionFinished");
		
		APairedInteractionDriver_OnSlaveInteractionFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PairedInteractionDriver.OnPairedInteractionStarted__DelegateSignature
	 * 		Flags  -> ()
	 */
	void APairedInteractionDriver::OnPairedInteractionStarted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PairedInteractionDriver.OnPairedInteractionStarted__DelegateSignature");
		
		APairedInteractionDriver_OnPairedInteractionStarted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PairedInteractionDriver.OnPairedInteractionFinished__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InDriver                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InSlave                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APairedInteractionDriver::OnPairedInteractionFinished__DelegateSignature(class AActor* InDriver, class AActor* InSlave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PairedInteractionDriver.OnPairedInteractionFinished__DelegateSignature");
		
		APairedInteractionDriver_OnPairedInteractionFinished__DelegateSignature_Params params {};
		params.InDriver = InDriver;
		params.InSlave = InSlave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PairedInteractionDriver.OnInteractionFinished
	 * 		Flags  -> ()
	 */
	void APairedInteractionDriver::OnInteractionFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PairedInteractionDriver.OnInteractionFinished");
		
		APairedInteractionDriver_OnInteractionFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PairedInteractionDriver.OnEquippedItemHolstered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APairedInteractionDriver::OnEquippedItemHolstered(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PairedInteractionDriver.OnEquippedItemHolstered");
		
		APairedInteractionDriver_OnEquippedItemHolstered_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PairedInteractionDriver.OnDriverInteractionFinished
	 * 		Flags  -> ()
	 */
	void APairedInteractionDriver::OnDriverInteractionFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PairedInteractionDriver.OnDriverInteractionFinished");
		
		APairedInteractionDriver_OnDriverInteractionFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PairedInteractionDriver.OnActorInteractionFinished__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APairedInteractionDriver::OnActorInteractionFinished__DelegateSignature(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PairedInteractionDriver.OnActorInteractionFinished__DelegateSignature");
		
		APairedInteractionDriver_OnActorInteractionFinished__DelegateSignature_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APairedInteractionDriver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APairedInteractionDriver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PairedInteractionDriver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APatrolPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APatrolPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PatrolPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PenetrationData.GetPenetrationData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPhysicalSurface                                   Surface                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FMaterialPenetration UPenetrationData::GetPenetrationData(EPhysicalSurface Surface)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PenetrationData.GetPenetrationData");
		
		UPenetrationData_GetPenetrationData_Params params {};
		params.Surface = Surface;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPenetrationData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPenetrationData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PenetrationData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPepperballDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPepperballDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PepperballDamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PepperballGun.IncrementStunShotCounter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        StunnedPerson                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APepperballGun::IncrementStunShotCounter(class ACyberneticCharacter* StunnedPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PepperballGun.IncrementStunShotCounter");
		
		APepperballGun_IncrementStunShotCounter_Params params {};
		params.StunnedPerson = StunnedPerson;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PepperballGun.IncrementHeadshotCounter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticCharacter*                        HeadshottedPerson                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APepperballGun::IncrementHeadshotCounter(class ACyberneticCharacter* HeadshottedPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PepperballGun.IncrementHeadshotCounter");
		
		APepperballGun_IncrementHeadshotCounter_Params params {};
		params.HeadshottedPerson = HeadshottedPerson;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APepperballGun.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APepperballGun::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PepperballGun");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Pepperspray.StopSpraySoundEffect
	 * 		Flags  -> ()
	 */
	void APepperspray::StopSpraySoundEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Pepperspray.StopSpraySoundEffect");
		
		APepperspray_StopSpraySoundEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Pepperspray.StopSprayParticleEffect
	 * 		Flags  -> ()
	 */
	void APepperspray::StopSprayParticleEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Pepperspray.StopSprayParticleEffect");
		
		APepperspray_StopSprayParticleEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Pepperspray.StopSpraying
	 * 		Flags  -> ()
	 */
	void APepperspray::StopSpraying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Pepperspray.StopSpraying");
		
		APepperspray_StopSpraying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Pepperspray.StartSpraying
	 * 		Flags  -> ()
	 */
	void APepperspray::StartSpraying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Pepperspray.StartSpraying");
		
		APepperspray_StartSpraying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Pepperspray.Server_StopSpraying
	 * 		Flags  -> ()
	 */
	void APepperspray::Server_StopSpraying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Pepperspray.Server_StopSpraying");
		
		APepperspray_Server_StopSpraying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Pepperspray.Server_StartSpraying
	 * 		Flags  -> ()
	 */
	void APepperspray::Server_StartSpraying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Pepperspray.Server_StartSpraying");
		
		APepperspray_Server_StartSpraying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Pepperspray.PlaySpraySoundEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bRunningOutEffect                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APepperspray::PlaySpraySoundEffect(bool bRunningOutEffect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Pepperspray.PlaySpraySoundEffect");
		
		APepperspray_PlaySpraySoundEffect_Params params {};
		params.bRunningOutEffect = bRunningOutEffect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Pepperspray.PlaySprayParticleEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bRunningOutEffect                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APepperspray::PlaySprayParticleEffect(bool bRunningOutEffect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Pepperspray.PlaySprayParticleEffect");
		
		APepperspray_PlaySprayParticleEffect_Params params {};
		params.bRunningOutEffect = bRunningOutEffect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Pepperspray.OnRep_Spraying
	 * 		Flags  -> ()
	 */
	void APepperspray::OnRep_Spraying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Pepperspray.OnRep_Spraying");
		
		APepperspray_OnRep_Spraying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Pepperspray.OnLowPeppersprayAmmo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              CurrentResource                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APepperspray::OnLowPeppersprayAmmo(float CurrentResource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Pepperspray.OnLowPeppersprayAmmo");
		
		APepperspray_OnLowPeppersprayAmmo_Params params {};
		params.CurrentResource = CurrentResource;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Pepperspray.OnDepletedPeppersprayAmmo
	 * 		Flags  -> ()
	 */
	void APepperspray::OnDepletedPeppersprayAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Pepperspray.OnDepletedPeppersprayAmmo");
		
		APepperspray_OnDepletedPeppersprayAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APepperspray.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APepperspray::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Pepperspray");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPepperSprayDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPepperSprayDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PepperSprayDamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPersonalizationWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPersonalizationWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PersonalizationWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupEvidenceByTag.HasCollectedEvidenceByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Tag                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APickupEvidenceByTag::HasCollectedEvidenceByTag(const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupEvidenceByTag.HasCollectedEvidenceByTag");
		
		APickupEvidenceByTag_HasCollectedEvidenceByTag_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APickupEvidenceByTag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APickupEvidenceByTag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PickupEvidenceByTag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupItemActivity.SetPickupItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   NewPickupItem                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPickupItemActivity::SetPickupItem(class ABaseItem* NewPickupItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupItemActivity.SetPickupItem");
		
		UPickupItemActivity_SetPickupItem_Params params {};
		params.NewPickupItem = NewPickupItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupItemActivity.OnPickupItemComplete
	 * 		Flags  -> ()
	 */
	void UPickupItemActivity::OnPickupItemComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupItemActivity.OnPickupItemComplete");
		
		UPickupItemActivity_OnPickupItemComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPickupItemActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPickupItemActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PickupItemActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupMagazineActor.Server_Pickup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InPickupInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APickupMagazineActor::Server_Pickup(class AActor* InPickupInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupMagazineActor.Server_Pickup");
		
		APickupMagazineActor_Server_Pickup_Params params {};
		params.InPickupInstigator = InPickupInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupMagazineActor.OnComponentHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void APickupMagazineActor::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupMagazineActor.OnComponentHit");
		
		APickupMagazineActor_OnComponentHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupMagazineActor.Multicast_SetWeapon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseMagazineWeapon*                         Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APickupMagazineActor::Multicast_SetWeapon(class ABaseMagazineWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupMagazineActor.Multicast_SetWeapon");
		
		APickupMagazineActor_Multicast_SetWeapon_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PickupMagazineActor.GetValidWeaponForPickerUpper
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABaseMagazineWeapon* APickupMagazineActor::GetValidWeaponForPickerUpper(class APlayerCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PickupMagazineActor.GetValidWeaponForPickerUpper");
		
		APickupMagazineActor_GetValidWeaponForPickerUpper_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APickupMagazineActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APickupMagazineActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PickupMagazineActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APickupWeaponActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APickupWeaponActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PickupWeaponActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PingActor.ToggleObjectiveMarkerVisibility
	 * 		Flags  -> ()
	 */
	void APingActor::ToggleObjectiveMarkerVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PingActor.ToggleObjectiveMarkerVisibility");
		
		APingActor_ToggleObjectiveMarkerVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PingActor.ShowObjectiveMarker
	 * 		Flags  -> ()
	 */
	void APingActor::ShowObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PingActor.ShowObjectiveMarker");
		
		APingActor_ShowObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PingActor.Setup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APingActor::Setup(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PingActor.Setup");
		
		APingActor_Setup_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PingActor.OnRep_SetPingText
	 * 		Flags  -> ()
	 */
	void APingActor::OnRep_SetPingText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PingActor.OnRep_SetPingText");
		
		APingActor_OnRep_SetPingText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PingActor.OnRep_SetIconBrush
	 * 		Flags  -> ()
	 */
	void APingActor::OnRep_SetIconBrush()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PingActor.OnRep_SetIconBrush");
		
		APingActor_OnRep_SetIconBrush_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PingActor.HideObjectiveMarker
	 * 		Flags  -> ()
	 */
	void APingActor::HideObjectiveMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PingActor.HideObjectiveMarker");
		
		APingActor_HideObjectiveMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APingActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APingActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PingActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PingInterface.GetPingText
	 * 		Flags  -> ()
	 */
	class FText UPingInterface::GetPingText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PingInterface.GetPingText");
		
		UPingInterface_GetPingText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PingInterface.GetPingLocation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector UPingInterface::GetPingLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PingInterface.GetPingLocation");
		
		UPingInterface_GetPingLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PingInterface.GetPingIcon
	 * 		Flags  -> ()
	 */
	struct FSlateBrush UPingInterface::GetPingIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PingInterface.GetPingIcon");
		
		UPingInterface_GetPingIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PingInterface.GetPingDuration
	 * 		Flags  -> ()
	 */
	float UPingInterface::GetPingDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PingInterface.GetPingDuration");
		
		UPingInterface_GetPingDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PingInterface.CanPing
	 * 		Flags  -> ()
	 */
	bool UPingInterface::CanPing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PingInterface.CanPing");
		
		UPingInterface_CanPing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPingInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPingInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PingInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlacedBag.StartUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APlacedBag::StartUse(class APlayerCharacter* User)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlacedBag.StartUse");
		
		APlacedBag_StartUse_Params params {};
		params.User = User;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlacedBag.OnPlacedBagUsed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlacedBag::OnPlacedBagUsed(class APlayerCharacter* User)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlacedBag.OnPlacedBagUsed");
		
		APlacedBag_OnPlacedBagUsed_Params params {};
		params.User = User;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlacedBag.GetUseViewComponents
	 * 		Flags  -> ()
	 */
	TArray<class USceneComponent*> APlacedBag::GetUseViewComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlacedBag.GetUseViewComponents");
		
		APlacedBag_GetUseViewComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlacedBag.EndUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlacedBag::EndUse(class APlayerCharacter* User)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlacedBag.EndUse");
		
		APlacedBag_EndUse_Params params {};
		params.User = User;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlacedBag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlacedBag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlacedBag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlacedC2Explosive.Server_DetonateC2
	 * 		Flags  -> ()
	 */
	void APlacedC2Explosive::Server_DetonateC2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlacedC2Explosive.Server_DetonateC2");
		
		APlacedC2Explosive_Server_DetonateC2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlacedC2Explosive.RemoveFromTarget
	 * 		Flags  -> ()
	 */
	void APlacedC2Explosive::RemoveFromTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlacedC2Explosive.RemoveFromTarget");
		
		APlacedC2Explosive_RemoveFromTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlacedC2Explosive.PostExplosionKill
	 * 		Flags  -> ()
	 */
	void APlacedC2Explosive::PostExplosionKill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlacedC2Explosive.PostExplosionKill");
		
		APlacedC2Explosive_PostExplosionKill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlacedC2Explosive.Multicast_OnC2Detonated
	 * 		Flags  -> ()
	 */
	void APlacedC2Explosive::Multicast_OnC2Detonated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlacedC2Explosive.Multicast_OnC2Detonated");
		
		APlacedC2Explosive_Multicast_OnC2Detonated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlacedC2Explosive.GetMeshComp
	 * 		Flags  -> ()
	 */
	class USkeletalMeshComponent* APlacedC2Explosive::GetMeshComp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlacedC2Explosive.GetMeshComp");
		
		APlacedC2Explosive_GetMeshComp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlacedC2Explosive.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlacedC2Explosive::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlacedC2Explosive");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlacedZipcuffs.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlacedZipcuffs::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlacedZipcuffs");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlaceGunDownActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlaceGunDownActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlaceGunDownActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWorldBuildingActivityData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWorldBuildingActivityData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WorldBuildingActivityData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlaceTrapActivityData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlaceTrapActivityData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlaceTrapActivityData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlaceTrapActivity.OnTrapPlacementInterrupted
	 * 		Flags  -> ()
	 */
	void UPlaceTrapActivity::OnTrapPlacementInterrupted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlaceTrapActivity.OnTrapPlacementInterrupted");
		
		UPlaceTrapActivity_OnTrapPlacementInterrupted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlaceTrapActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlaceTrapActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlaceTrapActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlanningMapWidget.OnPersonnelRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PersonnelNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlanningMapWidget::OnPersonnelRemoved(int32_t PersonnelNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlanningMapWidget.OnPersonnelRemoved");
		
		UPlanningMapWidget_OnPersonnelRemoved_Params params {};
		params.PersonnelNum = PersonnelNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlanningMapWidget.OnPersonnelAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PersonnelNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PersonnelZone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlanningMapWidget::OnPersonnelAdded(int32_t PersonnelNum, int32_t PersonnelZone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlanningMapWidget.OnPersonnelAdded");
		
		UPlanningMapWidget_OnPersonnelAdded_Params params {};
		params.PersonnelNum = PersonnelNum;
		params.PersonnelZone = PersonnelZone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlanningMapWidget.OnForceMapRefresh
	 * 		Flags  -> ()
	 */
	void UPlanningMapWidget::OnForceMapRefresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlanningMapWidget.OnForceMapRefresh");
		
		UPlanningMapWidget_OnForceMapRefresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlanningMapWidget.GetWorldContext
	 * 		Flags  -> ()
	 */
	class UWorld* UPlanningMapWidget::GetWorldContext()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlanningMapWidget.GetWorldContext");
		
		UPlanningMapWidget_GetWorldContext_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlanningMapWidget.ClearPointData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bClearAll                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            FloorNum                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bClearAllFloors                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlanningMapWidget::ClearPointData(bool bClearAll, int32_t FloorNum, bool bClearAllFloors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlanningMapWidget.ClearPointData");
		
		UPlanningMapWidget_ClearPointData_Params params {};
		params.bClearAll = bClearAll;
		params.FloorNum = FloorNum;
		params.bClearAllFloors = bClearAllFloors;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlanningMapWidget.AddPointData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector2D                      PointData                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            FloorNum                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFreeDrawColor                                     Color                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNewPoint                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlanningMapWidget::AddPointData(const struct FCoreUObject_FVector2D& PointData, int32_t FloorNum, EFreeDrawColor Color, bool bNewPoint, float Thickness)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlanningMapWidget.AddPointData");
		
		UPlanningMapWidget_AddPointData_Params params {};
		params.PointData = PointData;
		params.FloorNum = FloorNum;
		params.Color = Color;
		params.bNewPoint = bNewPoint;
		params.Thickness = Thickness;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlanningMapWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlanningMapWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlanningMapWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlantArea.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlantArea::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlantArea");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayableCharacterData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayableCharacterData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayableCharacterData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayDeadActivity.OnStunned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayDeadActivity::OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayDeadActivity.OnStunned");
		
		UPlayDeadActivity_OnStunned_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayDeadActivity.OnHeardYell
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Shouter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLOS                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayDeadActivity::OnHeardYell(class AReadyOrNotCharacter* Shouter, bool bLOS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayDeadActivity.OnHeardYell");
		
		UPlayDeadActivity_OnHeardYell_Params params {};
		params.Shouter = Shouter;
		params.bLOS = bLOS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayDeadActivity.OnDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayDeadActivity::OnDamaged(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayDeadActivity.OnDamaged");
		
		UPlayDeadActivity_OnDamaged_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayDeadActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayDeadActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayDeadActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlayDeadSpot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlayDeadSpot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayDeadSpot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerActionPromptWidget.UpdateText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        InText                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bAnimate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoopAnimation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerActionPromptWidget::UpdateText(const class FText& InText, bool bAnimate, bool bLoopAnimation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerActionPromptWidget.UpdateText");
		
		UPlayerActionPromptWidget_UpdateText_Params params {};
		params.InText = InText;
		params.bAnimate = bAnimate;
		params.bLoopAnimation = bLoopAnimation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerActionPromptWidget.IsInUse
	 * 		Flags  -> ()
	 */
	bool UPlayerActionPromptWidget::IsInUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerActionPromptWidget.IsInUse");
		
		UPlayerActionPromptWidget_IsInUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerActionPromptWidget.ClearText
	 * 		Flags  -> ()
	 */
	void UPlayerActionPromptWidget::ClearText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerActionPromptWidget.ClearText");
		
		UPlayerActionPromptWidget_ClearText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerActionPromptWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerActionPromptWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayerActionPromptWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.UpdateRotator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FRotator                       Value                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FRotator                       Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::UpdateRotator(struct FCoreUObject_FRotator* Value, const struct FCoreUObject_FRotator& Target, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.UpdateRotator");
		
		APlayerCharacter_UpdateRotator_Params params {};
		params.Target = Target;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Value != nullptr)
			*Value = params.Value;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.UpdatePictureInPictureVisibility
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::UpdatePictureInPictureVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.UpdatePictureInPictureVisibility");
		
		APlayerCharacter_UpdatePictureInPictureVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.UpdateFloat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::UpdateFloat(float* Value, float Target, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.UpdateFloat");
		
		APlayerCharacter_UpdateFloat_Params params {};
		params.Target = Target;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Value != nullptr)
			*Value = params.Value;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.UnavailableHolsterNameForType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FName APlayerCharacter::UnavailableHolsterNameForType(EItemCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.UnavailableHolsterNameForType");
		
		APlayerCharacter_UnavailableHolsterNameForType_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.TryPlayAISuspectResponseToReload
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::TryPlayAISuspectResponseToReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.TryPlayAISuspectResponseToReload");
		
		APlayerCharacter_TryPlayAISuspectResponseToReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.TryNextPlayerView_Released
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::TryNextPlayerView_Released()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.TryNextPlayerView_Released");
		
		APlayerCharacter_TryNextPlayerView_Released_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleUnderbarrelAttachment
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleUnderbarrelAttachment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleUnderbarrelAttachment");
		
		APlayerCharacter_ToggleUnderbarrelAttachment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleThirdPerson
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleThirdPerson()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleThirdPerson");
		
		APlayerCharacter_ToggleThirdPerson_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleSprint
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleSprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleSprint");
		
		APlayerCharacter_ToggleSprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleSightTweaker
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleSightTweaker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleSightTweaker");
		
		APlayerCharacter_ToggleSightTweaker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleSecondarySight
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleSecondarySight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleSecondarySight");
		
		APlayerCharacter_ToggleSecondarySight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleNoTarget
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleNoTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleNoTarget");
		
		APlayerCharacter_ToggleNoTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleNightvisionGoggles
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleNightvisionGoggles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleNightvisionGoggles");
		
		APlayerCharacter_ToggleNightvisionGoggles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleLowReady
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleLowReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleLowReady");
		
		APlayerCharacter_ToggleLowReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleLeanRight
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleLeanRight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleLeanRight");
		
		APlayerCharacter_ToggleLeanRight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleLeanLeft
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleLeanLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleLeanLeft");
		
		APlayerCharacter_ToggleLeanLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleHUD
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleHUD");
		
		APlayerCharacter_ToggleHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleGodMode
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleGodMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleGodMode");
		
		APlayerCharacter_ToggleGodMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleFreeThirdPerson
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleFreeThirdPerson()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleFreeThirdPerson");
		
		APlayerCharacter_ToggleFreeThirdPerson_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleFreeLook
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleFreeLook()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleFreeLook");
		
		APlayerCharacter_ToggleFreeLook_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleFreeLean
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleFreeLean()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleFreeLean");
		
		APlayerCharacter_ToggleFreeLean_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleDebugDamage
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleDebugDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleDebugDamage");
		
		APlayerCharacter_ToggleDebugDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleDebugBallistics
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleDebugBallistics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleDebugBallistics");
		
		APlayerCharacter_ToggleDebugBallistics_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleCrouch
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleCrouch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleCrouch");
		
		APlayerCharacter_ToggleCrouch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ToggleCrosshairOverlay
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ToggleCrosshairOverlay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ToggleCrosshairOverlay");
		
		APlayerCharacter_ToggleCrosshairOverlay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.StunMe
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      WithType                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::StunMe(float Duration, const class FString& WithType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.StunMe");
		
		APlayerCharacter_StunMe_Params params {};
		params.Duration = Duration;
		params.WithType = WithType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.StopUsingMultitool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::StopUsingMultitool(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.StopUsingMultitool");
		
		APlayerCharacter_StopUsingMultitool_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.StopLockPicking
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::StopLockPicking(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.StopLockPicking");
		
		APlayerCharacter_StopLockPicking_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.StopFreeLook
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::StopFreeLook()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.StopFreeLook");
		
		APlayerCharacter_StopFreeLook_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.StopFPMontageFromTable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendoutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::StopFPMontageFromTable(const class FString& Animation, float BlendoutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.StopFPMontageFromTable");
		
		APlayerCharacter_StopFPMontageFromTable_Params params {};
		params.Animation = Animation;
		params.BlendoutTime = BlendoutTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.StartUsingMultitool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::StartUsingMultitool(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.StartUsingMultitool");
		
		APlayerCharacter_StartUsingMultitool_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.StartQuickThrow
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::StartQuickThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.StartQuickThrow");
		
		APlayerCharacter_StartQuickThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.StartLockPicking
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::StartLockPicking(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.StartLockPicking");
		
		APlayerCharacter_StartLockPicking_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.StartFreeLook
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::StartFreeLook()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.StartFreeLook");
		
		APlayerCharacter_StartFreeLook_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.StartCinematicSequence
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::StartCinematicSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.StartCinematicSequence");
		
		APlayerCharacter_StartCinematicSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.StartChemThrow
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::StartChemThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.StartChemThrow");
		
		APlayerCharacter_StartChemThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.StartBleeding
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::StartBleeding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.StartBleeding");
		
		APlayerCharacter_StartBleeding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ShowPlayer
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ShowPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ShowPlayer");
		
		APlayerCharacter_ShowPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.SetWeaponUp
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::SetWeaponUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.SetWeaponUp");
		
		APlayerCharacter_SetWeaponUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.SetWeaponDown
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::SetWeaponDown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.SetWeaponDown");
		
		APlayerCharacter_SetWeaponDown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.SetRunSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newRunSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::SetRunSpeed(float newRunSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.SetRunSpeed");
		
		APlayerCharacter_SetRunSpeed_Params params {};
		params.newRunSpeed = newRunSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.SetMaxRunSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newMaxSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::SetMaxRunSpeed(float newMaxSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.SetMaxRunSpeed");
		
		APlayerCharacter_SetMaxRunSpeed_Params params {};
		params.newMaxSpeed = newMaxSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.SetHumanCharacterWidget_V2
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UHumanCharacterHUD_V2*                       NewHumanCharacterWidget                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::SetHumanCharacterWidget_V2(class UHumanCharacterHUD_V2* NewHumanCharacterWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.SetHumanCharacterWidget_V2");
		
		APlayerCharacter_SetHumanCharacterWidget_V2_Params params {};
		params.NewHumanCharacterWidget = NewHumanCharacterWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.SetFreelookYawMin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewYawMinValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::SetFreelookYawMin(float NewYawMinValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.SetFreelookYawMin");
		
		APlayerCharacter_SetFreelookYawMin_Params params {};
		params.NewYawMinValue = NewYawMinValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.SetFreelookYawMax
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewYawMaxValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::SetFreelookYawMax(float NewYawMaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.SetFreelookYawMax");
		
		APlayerCharacter_SetFreelookYawMax_Params params {};
		params.NewYawMaxValue = NewYawMaxValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.SetFreelookPitchMin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewPitchMinValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::SetFreelookPitchMin(float NewPitchMinValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.SetFreelookPitchMin");
		
		APlayerCharacter_SetFreelookPitchMin_Params params {};
		params.NewPitchMinValue = NewPitchMinValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.SetFreelookPitchMax
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewPitchMaxValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::SetFreelookPitchMax(float NewPitchMaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.SetFreelookPitchMax");
		
		APlayerCharacter_SetFreelookPitchMax_Params params {};
		params.NewPitchMaxValue = NewPitchMaxValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.SetForceLowReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldForceLowReady                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::SetForceLowReady(bool bShouldForceLowReady)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.SetForceLowReady");
		
		APlayerCharacter_SetForceLowReady_Params params {};
		params.bShouldForceLowReady = bShouldForceLowReady;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_Walk
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_Walk()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_Walk");
		
		APlayerCharacter_Server_Walk_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_UpdateLean
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              QuickLean                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              newFreeLeanY                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewFreeLeanZ                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_UpdateLean(float QuickLean, float newFreeLeanY, float NewFreeLeanZ)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_UpdateLean");
		
		APlayerCharacter_Server_UpdateLean_Params params {};
		params.QuickLean = QuickLean;
		params.newFreeLeanY = newFreeLeanY;
		params.NewFreeLeanZ = NewFreeLeanZ;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_UpdateLastSetRunSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newRunSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_UpdateLastSetRunSpeed(float newRunSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_UpdateLastSetRunSpeed");
		
		APlayerCharacter_Server_UpdateLastSetRunSpeed_Params params {};
		params.newRunSpeed = newRunSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_UpdateIsBlockingAnimationPlaying
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsBlockingAnimationPlaying                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_UpdateIsBlockingAnimationPlaying(bool bIsBlockingAnimationPlaying)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_UpdateIsBlockingAnimationPlaying");
		
		APlayerCharacter_Server_UpdateIsBlockingAnimationPlaying_Params params {};
		params.bIsBlockingAnimationPlaying = bIsBlockingAnimationPlaying;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_UpdateFreeLookCache
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FRotator                       NewFreeLookCache                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_UpdateFreeLookCache(const struct FCoreUObject_FRotator& NewFreeLookCache)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_UpdateFreeLookCache");
		
		APlayerCharacter_Server_UpdateFreeLookCache_Params params {};
		params.NewFreeLookCache = NewFreeLookCache;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_UpdateCameraRotationRate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FRotator                       NewCameraRotRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_UpdateCameraRotationRate(const struct FCoreUObject_FRotator& NewCameraRotRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_UpdateCameraRotationRate");
		
		APlayerCharacter_Server_UpdateCameraRotationRate_Params params {};
		params.NewCameraRotRate = NewCameraRotRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_UpdateADS
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bADS                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_UpdateADS(bool bADS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_UpdateADS");
		
		APlayerCharacter_Server_UpdateADS_Params params {};
		params.bADS = bADS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_UnlockMovementAndAim
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_UnlockMovementAndAim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_UnlockMovementAndAim");
		
		APlayerCharacter_Server_UnlockMovementAndAim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_UnlockMovementAndActions
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_UnlockMovementAndActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_UnlockMovementAndActions");
		
		APlayerCharacter_Server_UnlockMovementAndActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_UnlockMovement
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_UnlockMovement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_UnlockMovement");
		
		APlayerCharacter_Server_UnlockMovement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_UnlockAllActions
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_UnlockAllActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_UnlockAllActions");
		
		APlayerCharacter_Server_UnlockAllActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_UnlockAim
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_UnlockAim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_UnlockAim");
		
		APlayerCharacter_Server_UnlockAim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_ToggleWalk
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_ToggleWalk()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_ToggleWalk");
		
		APlayerCharacter_Server_ToggleWalk_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_ToggleNoTarget
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_ToggleNoTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_ToggleNoTarget");
		
		APlayerCharacter_Server_ToggleNoTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_ToggleLightByClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELightRadialSelection                              LightType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_ToggleLightByClass(ELightRadialSelection LightType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_ToggleLightByClass");
		
		APlayerCharacter_Server_ToggleLightByClass_Params params {};
		params.LightType = LightType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_ToggleGodMode
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_ToggleGodMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_ToggleGodMode");
		
		APlayerCharacter_Server_ToggleGodMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_TakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_TakeDamage(float Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_TakeDamage");
		
		APlayerCharacter_Server_TakeDamage_Params params {};
		params.Damage = Damage;
		params.DamageEvent = DamageEvent;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_Sprint
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_Sprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_Sprint");
		
		APlayerCharacter_Server_Sprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_SpawnEjectedMagazine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                     SpawnTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ABaseMagazineWeapon*                         Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_SpawnEjectedMagazine(const struct FTransform& SpawnTransform, class ABaseMagazineWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_SpawnEjectedMagazine");
		
		APlayerCharacter_Server_SpawnEjectedMagazine_Params params {};
		params.SpawnTransform = SpawnTransform;
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_SetWalkSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newWalkSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              newCrouchWalkSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_SetWalkSpeed(float newWalkSpeed, float newCrouchWalkSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_SetWalkSpeed");
		
		APlayerCharacter_Server_SetWalkSpeed_Params params {};
		params.newWalkSpeed = newWalkSpeed;
		params.newCrouchWalkSpeed = newCrouchWalkSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_SetUserLowReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldUserLowReady                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_SetUserLowReady(bool bShouldUserLowReady)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_SetUserLowReady");
		
		APlayerCharacter_Server_SetUserLowReady_Params params {};
		params.bShouldUserLowReady = bShouldUserLowReady;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_SetLowReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bUp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLowReady                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsUserLowReady                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_SetLowReady(bool bUp, bool bLowReady, bool bIsUserLowReady)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_SetLowReady");
		
		APlayerCharacter_Server_SetLowReady_Params params {};
		params.bUp = bUp;
		params.bLowReady = bLowReady;
		params.bIsUserLowReady = bIsUserLowReady;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_SecondaryUse
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_SecondaryUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_SecondaryUse");
		
		APlayerCharacter_Server_SecondaryUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_ResetPlayerEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      InPlayerEffectClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMulticast                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_ResetPlayerEffect(class UClass* InPlayerEffectClass, bool bMulticast)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_ResetPlayerEffect");
		
		APlayerCharacter_Server_ResetPlayerEffect_Params params {};
		params.InPlayerEffectClass = InPlayerEffectClass;
		params.bMulticast = bMulticast;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_RepNVGOn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsOn                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_RepNVGOn(bool bIsOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_RepNVGOn");
		
		APlayerCharacter_Server_RepNVGOn_Params params {};
		params.bIsOn = bIsOn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_RemovePendingC2
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_RemovePendingC2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_RemovePendingC2");
		
		APlayerCharacter_Server_RemovePendingC2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_RemoveLadder
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ATelescopicLadder*                           Ladder                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_RemoveLadder(class ATelescopicLadder* Ladder)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_RemoveLadder");
		
		APlayerCharacter_Server_RemoveLadder_Params params {};
		params.Ladder = Ladder;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_PrimaryUse
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_PrimaryUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_PrimaryUse");
		
		APlayerCharacter_Server_PrimaryUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_PrepareForHeal
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_PrepareForHeal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_PrepareForHeal");
		
		APlayerCharacter_Server_PrepareForHeal_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_PlayVaultAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        ledge                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        legeWallNormal                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        ledgeTraceDown                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ledgeZ                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ELedgeWidth                                        ledgeWidth                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ELedgeHeight                                       ledgeHeight                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_PlayVaultAnimation(const struct FCoreUObject_FVector& ledge, const struct FCoreUObject_FVector& legeWallNormal, const struct FCoreUObject_FVector& ledgeTraceDown, float ledgeZ, ELedgeWidth ledgeWidth, ELedgeHeight ledgeHeight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_PlayVaultAnimation");
		
		APlayerCharacter_Server_PlayVaultAnimation_Params params {};
		params.ledge = ledge;
		params.legeWallNormal = legeWallNormal;
		params.ledgeTraceDown = ledgeTraceDown;
		params.ledgeZ = ledgeZ;
		params.ledgeWidth = ledgeWidth;
		params.ledgeHeight = ledgeHeight;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_PlaySound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USoundCue*                                   Cue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_PlaySound(class USoundCue* Cue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_PlaySound");
		
		APlayerCharacter_Server_PlaySound_Params params {};
		params.Cue = Cue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_PlayPVPSpeech
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SpeechRowName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_PlayPVPSpeech(const class FString& SpeechRowName, ETeamType TeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_PlayPVPSpeech");
		
		APlayerCharacter_Server_PlayPVPSpeech_Params params {};
		params.SpeechRowName = SpeechRowName;
		params.TeamType = TeamType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_Ping
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_Ping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_Ping");
		
		APlayerCharacter_Server_Ping_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_OnReviveComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_OnReviveComplete(class APlayerCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_OnReviveComplete");
		
		APlayerCharacter_Server_OnReviveComplete_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_OnReloadComplete
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_OnReloadComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_OnReloadComplete");
		
		APlayerCharacter_Server_OnReloadComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_MarkWeaponCleaned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_MarkWeaponCleaned(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_MarkWeaponCleaned");
		
		APlayerCharacter_Server_MarkWeaponCleaned_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_LockMovementAndAim
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_LockMovementAndAim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_LockMovementAndAim");
		
		APlayerCharacter_Server_LockMovementAndAim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_LockMovementAndActions
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_LockMovementAndActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_LockMovementAndActions");
		
		APlayerCharacter_Server_LockMovementAndActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_LockMovement
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_LockMovement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_LockMovement");
		
		APlayerCharacter_Server_LockMovement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_LockAllActions
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_LockAllActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_LockAllActions");
		
		APlayerCharacter_Server_LockAllActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_LockAim
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_LockAim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_LockAim");
		
		APlayerCharacter_Server_LockAim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_KillfeedMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseItem*                                   Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_KillfeedMessage(class APlayerCharacter* Killer, class APlayerCharacter* Victim, class ABaseItem* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_KillfeedMessage");
		
		APlayerCharacter_Server_KillfeedMessage_Params params {};
		params.Killer = Killer;
		params.Victim = Victim;
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_InstaStartFree
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_InstaStartFree(class APlayerCharacter* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_InstaStartFree");
		
		APlayerCharacter_Server_InstaStartFree_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_InstaStartArrest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_InstaStartArrest(class APlayerCharacter* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_InstaStartArrest");
		
		APlayerCharacter_Server_InstaStartArrest_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_InstantSurrenderTarget
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_InstantSurrenderTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_InstantSurrenderTarget");
		
		APlayerCharacter_Server_InstantSurrenderTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_FreefeedMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Freer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_FreefeedMessage(class APlayerCharacter* Freer, class APlayerCharacter* Victim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_FreefeedMessage");
		
		APlayerCharacter_Server_FreefeedMessage_Params params {};
		params.Freer = Freer;
		params.Victim = Victim;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_FinishHealing
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_FinishHealing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_FinishHealing");
		
		APlayerCharacter_Server_FinishHealing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_FastWalk
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_FastWalk()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_FastWalk");
		
		APlayerCharacter_Server_FastWalk_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipZipcuffs
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipZipcuffs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipZipcuffs");
		
		APlayerCharacter_Server_EquipZipcuffs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipTablet
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipTablet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipTablet");
		
		APlayerCharacter_Server_EquipTablet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipStinger
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipStinger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipStinger");
		
		APlayerCharacter_Server_EquipStinger_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipSecondaryItem
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipSecondaryItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipSecondaryItem");
		
		APlayerCharacter_Server_EquipSecondaryItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipPrimaryItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_EquipPrimaryItem(bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipPrimaryItem");
		
		APlayerCharacter_Server_EquipPrimaryItem_Params params {};
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipPepperSpray
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipPepperSpray()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipPepperSpray");
		
		APlayerCharacter_Server_EquipPepperSpray_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipNinebang
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipNinebang()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipNinebang");
		
		APlayerCharacter_Server_EquipNinebang_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipMultitool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMultitoolFunctions                                MultitoolFunction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_EquipMultitool(EMultitoolFunctions MultitoolFunction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipMultitool");
		
		APlayerCharacter_Server_EquipMultitool_Params params {};
		params.MultitoolFunction = MultitoolFunction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipMirrorgun
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipMirrorgun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipMirrorgun");
		
		APlayerCharacter_Server_EquipMirrorgun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipLastItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHolsterAnimationType                              AnimationType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_EquipLastItem(EHolsterAnimationType AnimationType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipLastItem");
		
		APlayerCharacter_Server_EquipLastItem_Params params {};
		params.AnimationType = AnimationType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipGrenade_5
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipGrenade_5()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipGrenade_5");
		
		APlayerCharacter_Server_EquipGrenade_5_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipGrenade_4
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipGrenade_4()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipGrenade_4");
		
		APlayerCharacter_Server_EquipGrenade_4_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipGrenade_3
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipGrenade_3()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipGrenade_3");
		
		APlayerCharacter_Server_EquipGrenade_3_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipGrenade_2
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipGrenade_2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipGrenade_2");
		
		APlayerCharacter_Server_EquipGrenade_2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipFlashbang
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipFlashbang()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipFlashbang");
		
		APlayerCharacter_Server_EquipFlashbang_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipDoorjam
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipDoorjam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipDoorjam");
		
		APlayerCharacter_Server_EquipDoorjam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipDevice_5
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipDevice_5()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipDevice_5");
		
		APlayerCharacter_Server_EquipDevice_5_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipDevice_4
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipDevice_4()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipDevice_4");
		
		APlayerCharacter_Server_EquipDevice_4_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipDevice_3
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipDevice_3()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipDevice_3");
		
		APlayerCharacter_Server_EquipDevice_3_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipDevice_2
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipDevice_2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipDevice_2");
		
		APlayerCharacter_Server_EquipDevice_2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipCSGas
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipCSGas()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipCSGas");
		
		APlayerCharacter_Server_EquipCSGas_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipC2
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipC2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipC2");
		
		APlayerCharacter_Server_EquipC2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EquipBreachingShotgun
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EquipBreachingShotgun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EquipBreachingShotgun");
		
		APlayerCharacter_Server_EquipBreachingShotgun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EndSecondaryUse
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EndSecondaryUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EndSecondaryUse");
		
		APlayerCharacter_Server_EndSecondaryUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EndPrimaryUse
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EndPrimaryUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EndPrimaryUse");
		
		APlayerCharacter_Server_EndPrimaryUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_EndFastWalk
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Server_EndFastWalk()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_EndFastWalk");
		
		APlayerCharacter_Server_EndFastWalk_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_ChangeMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMesh*                               FPMesh                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMesh*                               TPMesh                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMesh*                               TPHeadMesh                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_ChangeMesh(class USkeletalMesh* FPMesh, class USkeletalMesh* TPMesh, class USkeletalMesh* TPHeadMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_ChangeMesh");
		
		APlayerCharacter_Server_ChangeMesh_Params params {};
		params.FPMesh = FPMesh;
		params.TPMesh = TPMesh;
		params.TPHeadMesh = TPHeadMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_ChangeFPMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMesh*                               NewFPMesh                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_ChangeFPMesh(class USkeletalMesh* NewFPMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_ChangeFPMesh");
		
		APlayerCharacter_Server_ChangeFPMesh_Params params {};
		params.NewFPMesh = NewFPMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_ArrestfeedMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Arrester                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_ArrestfeedMessage(class APlayerCharacter* Arrester, class APlayerCharacter* Victim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_ArrestfeedMessage");
		
		APlayerCharacter_Server_ArrestfeedMessage_Params params {};
		params.Arrester = Arrester;
		params.Victim = Victim;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_ApplyPlayerEffectFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      InPlayerEffectClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMulticast                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_ApplyPlayerEffectFor(class UClass* InPlayerEffectClass, float Seconds, bool bMulticast)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_ApplyPlayerEffectFor");
		
		APlayerCharacter_Server_ApplyPlayerEffectFor_Params params {};
		params.InPlayerEffectClass = InPlayerEffectClass;
		params.Seconds = Seconds;
		params.bMulticast = bMulticast;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_ApplyPlayerEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      InPlayerEffectClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bResettable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMulticast                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_ApplyPlayerEffect(class UClass* InPlayerEffectClass, bool bResettable, bool bMulticast)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_ApplyPlayerEffect");
		
		APlayerCharacter_Server_ApplyPlayerEffect_Params params {};
		params.InPlayerEffectClass = InPlayerEffectClass;
		params.bResettable = bResettable;
		params.bMulticast = bMulticast;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Server_ActorPickedUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APickupActor*                                PickupActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Server_ActorPickedUp(class APickupActor* PickupActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Server_ActorPickedUp");
		
		APlayerCharacter_Server_ActorPickedUp_Params params {};
		params.PickupActor = PickupActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.SecondaryUse
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::SecondaryUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.SecondaryUse");
		
		APlayerCharacter_SecondaryUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ResetLODS_Player
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ResetLODS_Player()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ResetLODS_Player");
		
		APlayerCharacter_ResetLODS_Player_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ResetLODs_Items
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ResetLODs_Items()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ResetLODs_Items");
		
		APlayerCharacter_ResetLODs_Items_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ReplenishAllMagazineAmmo
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ReplenishAllMagazineAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ReplenishAllMagazineAmmo");
		
		APlayerCharacter_ReplenishAllMagazineAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ReplenishAllGrenadeAmmo
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ReplenishAllGrenadeAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ReplenishAllGrenadeAmmo");
		
		APlayerCharacter_ReplenishAllGrenadeAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.RemoveItemFromWeaponWheel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::RemoveItemFromWeaponWheel(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.RemoveItemFromWeaponWheel");
		
		APlayerCharacter_RemoveItemFromWeaponWheel_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ReloadOrMagCheck_Released
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ReloadOrMagCheck_Released()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ReloadOrMagCheck_Released");
		
		APlayerCharacter_ReloadOrMagCheck_Released_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ReloadOrMagCheck
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ReloadOrMagCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ReloadOrMagCheck");
		
		APlayerCharacter_ReloadOrMagCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Reload
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Reload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Reload");
		
		APlayerCharacter_Reload_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.PrintItemAttachmentListToLog
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::PrintItemAttachmentListToLog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.PrintItemAttachmentListToLog");
		
		APlayerCharacter_PrintItemAttachmentListToLog_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.PrimaryUseComplete
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::PrimaryUseComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.PrimaryUseComplete");
		
		APlayerCharacter_PrimaryUseComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.PrimaryUse
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::PrimaryUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.PrimaryUse");
		
		APlayerCharacter_PrimaryUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.PlayVaultAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        ledge                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        ledgeWallNormal                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        ledgeTraceDown                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ledgeZ                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ELedgeWidth                                        ledgeWidth                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ELedgeHeight                                       ledgeHeight                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::PlayVaultAnimation(const struct FCoreUObject_FVector& ledge, const struct FCoreUObject_FVector& ledgeWallNormal, const struct FCoreUObject_FVector& ledgeTraceDown, float ledgeZ, ELedgeWidth ledgeWidth, ELedgeHeight ledgeHeight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.PlayVaultAnimation");
		
		APlayerCharacter_PlayVaultAnimation_Params params {};
		params.ledge = ledge;
		params.ledgeWallNormal = ledgeWallNormal;
		params.ledgeTraceDown = ledgeTraceDown;
		params.ledgeZ = ledgeZ;
		params.ledgeWidth = ledgeWidth;
		params.ledgeHeight = ledgeHeight;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.PlayerStopJumping
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::PlayerStopJumping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.PlayerStopJumping");
		
		APlayerCharacter_PlayerStopJumping_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.PlayerJump
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::PlayerJump()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.PlayerJump");
		
		APlayerCharacter_PlayerJump_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Ping
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Ping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Ping");
		
		APlayerCharacter_Ping_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OpenTablet
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OpenTablet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OpenTablet");
		
		APlayerCharacter_OpenTablet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnWeaponMagCheckSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseMagazineWeapon*                         MagazineWeapon                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnWeaponMagCheckSignature__DelegateSignature(class ABaseMagazineWeapon* MagazineWeapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnWeaponMagCheckSignature__DelegateSignature");
		
		APlayerCharacter_OnWeaponMagCheckSignature__DelegateSignature_Params params {};
		params.MagazineWeapon = MagazineWeapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnWeaponFireModeChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EFireMode                                          newFireMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFireMode                                          LastFireMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnWeaponFireModeChanged__DelegateSignature(EFireMode newFireMode, EFireMode LastFireMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnWeaponFireModeChanged__DelegateSignature");
		
		APlayerCharacter_OnWeaponFireModeChanged__DelegateSignature_Params params {};
		params.newFireMode = newFireMode;
		params.LastFireMode = LastFireMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnWeaponFired__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnWeaponFired__DelegateSignature(class ABaseWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnWeaponFired__DelegateSignature");
		
		APlayerCharacter_OnWeaponFired__DelegateSignature_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnTurn
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnTurn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnTurn");
		
		APlayerCharacter_OnTurn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnTeamViewSet__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        NewViewCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnTeamViewSet__DelegateSignature(class AReadyOrNotCharacter* NewViewCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnTeamViewSet__DelegateSignature");
		
		APlayerCharacter_OnTeamViewSet__DelegateSignature_Params params {};
		params.NewViewCharacter = NewViewCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnTeamChatPressed
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnTeamChatPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnTeamChatPressed");
		
		APlayerCharacter_OnTeamChatPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnSupression__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnSupression__DelegateSignature(float Strength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnSupression__DelegateSignature");
		
		APlayerCharacter_OnSupression__DelegateSignature_Params params {};
		params.Strength = Strength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnSupression
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnSupression(float Strength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnSupression");
		
		APlayerCharacter_OnSupression_Params params {};
		params.Strength = Strength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnSelectDeviceReleased
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnSelectDeviceReleased(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnSelectDeviceReleased");
		
		APlayerCharacter_OnSelectDeviceReleased_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnSelectDevicePressed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnSelectDevicePressed(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnSelectDevicePressed");
		
		APlayerCharacter_OnSelectDevicePressed_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnSecondarySightToggled__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bUsingSecondarySight                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseMagazineWeapon*                         Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnSecondarySightToggled__DelegateSignature(bool bUsingSecondarySight, class ABaseMagazineWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnSecondarySightToggled__DelegateSignature");
		
		APlayerCharacter_OnSecondarySightToggled__DelegateSignature_Params params {};
		params.bUsingSecondarySight = bUsingSecondarySight;
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnRep_UpdateMontageSection
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnRep_UpdateMontageSection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnRep_UpdateMontageSection");
		
		APlayerCharacter_OnRep_UpdateMontageSection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnRep_UpdateAnimInstance
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnRep_UpdateAnimInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnRep_UpdateAnimInstance");
		
		APlayerCharacter_OnRep_UpdateAnimInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnRep_StartBoneBlend
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnRep_StartBoneBlend()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnRep_StartBoneBlend");
		
		APlayerCharacter_OnRep_StartBoneBlend_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnRep_RunSpeedUpdate
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnRep_RunSpeedUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnRep_RunSpeedUpdate");
		
		APlayerCharacter_OnRep_RunSpeedUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnRep_BaseAimRotation
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnRep_BaseAimRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnRep_BaseAimRotation");
		
		APlayerCharacter_OnRep_BaseAimRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnPlayerTakeDamageDetails__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bWasHeadshot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DamageTaken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBlockedByArmour                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBlockedByHelmet                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnPlayerTakeDamageDetails__DelegateSignature(bool bWasHeadshot, float DamageTaken, float HealthRemaining, bool bBlockedByArmour, bool bBlockedByHelmet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnPlayerTakeDamageDetails__DelegateSignature");
		
		APlayerCharacter_OnPlayerTakeDamageDetails__DelegateSignature_Params params {};
		params.bWasHeadshot = bWasHeadshot;
		params.DamageTaken = DamageTaken;
		params.HealthRemaining = HealthRemaining;
		params.bBlockedByArmour = bBlockedByArmour;
		params.bBlockedByHelmet = bBlockedByHelmet;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnPlayerEffectExpired
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      InPlayerEffectClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnPlayerEffectExpired(class UClass* InPlayerEffectClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnPlayerEffectExpired");
		
		APlayerCharacter_OnPlayerEffectExpired_Params params {};
		params.InPlayerEffectClass = InPlayerEffectClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnNightVisionGogglesToggled__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNVGOn                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnNightVisionGogglesToggled__DelegateSignature(bool bNVGOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnNightVisionGogglesToggled__DelegateSignature");
		
		APlayerCharacter_OnNightVisionGogglesToggled__DelegateSignature_Params params {};
		params.bNVGOn = bNVGOn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnMelee__DelegateSignature
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnMelee__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnMelee__DelegateSignature");
		
		APlayerCharacter_OnMelee__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnLowReadyButtonUp
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnLowReadyButtonUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnLowReadyButtonUp");
		
		APlayerCharacter_OnLowReadyButtonUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnLowReadyButtonDown
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnLowReadyButtonDown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnLowReadyButtonDown");
		
		APlayerCharacter_OnLowReadyButtonDown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnLowHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              CurrentHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnLowHealth(float CurrentHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnLowHealth");
		
		APlayerCharacter_OnLowHealth_Params params {};
		params.CurrentHealth = CurrentHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnLeanStart
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnLeanStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnLeanStart");
		
		APlayerCharacter_OnLeanStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnLeanEnd
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnLeanEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnLeanEnd");
		
		APlayerCharacter_OnLeanEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnKilledOrGoneUnconciousBP
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnKilledOrGoneUnconciousBP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnKilledOrGoneUnconciousBP");
		
		APlayerCharacter_OnKilledOrGoneUnconciousBP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnJumpStart
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnJumpStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnJumpStart");
		
		APlayerCharacter_OnJumpStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnJumpLand
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnJumpLand()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnJumpLand");
		
		APlayerCharacter_OnJumpLand_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnItemSelectionStyleChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemSelectionInterfaceType                        NewItemSelectionInterface                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnItemSelectionStyleChanged(EItemSelectionInterfaceType NewItemSelectionInterface)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnItemSelectionStyleChanged");
		
		APlayerCharacter_OnItemSelectionStyleChanged_Params params {};
		params.NewItemSelectionInterface = NewItemSelectionInterface;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnItemGroupSelection__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            GroupIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CategoryIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnItemGroupSelection__DelegateSignature(int32_t GroupIndex, int32_t CategoryIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnItemGroupSelection__DelegateSignature");
		
		APlayerCharacter_OnItemGroupSelection__DelegateSignature_Params params {};
		params.GroupIndex = GroupIndex;
		params.CategoryIndex = CategoryIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnFullHealth
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnFullHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnFullHealth");
		
		APlayerCharacter_OnFullHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnDefaultCommandIssued__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Issuer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESwatCommand                                       CommandIssued                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnDefaultCommandIssued__DelegateSignature(class APlayerCharacter* Issuer, ESwatCommand CommandIssued)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnDefaultCommandIssued__DelegateSignature");
		
		APlayerCharacter_OnDefaultCommandIssued__DelegateSignature_Params params {};
		params.Issuer = Issuer;
		params.CommandIssued = CommandIssued;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnClientPossessed__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AController*                                 NewController                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnClientPossessed__DelegateSignature(class AController* NewController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnClientPossessed__DelegateSignature");
		
		APlayerCharacter_OnClientPossessed__DelegateSignature_Params params {};
		params.NewController = NewController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnChatPressed
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnChatPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnChatPressed");
		
		APlayerCharacter_OnChatPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnBulletImpact__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DirectionForward                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DirectionRight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnBulletImpact__DelegateSignature(float DirectionForward, float DirectionRight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnBulletImpact__DelegateSignature");
		
		APlayerCharacter_OnBulletImpact__DelegateSignature_Params params {};
		params.DirectionForward = DirectionForward;
		params.DirectionRight = DirectionRight;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.OnBulletImpact
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DirectionForward                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DirectionRight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::OnBulletImpact(float DirectionForward, float DirectionRight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.OnBulletImpact");
		
		APlayerCharacter_OnBulletImpact_Params params {};
		params.DirectionForward = DirectionForward;
		params.DirectionRight = DirectionRight;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PlayerCharacter.OnAttachmentLightToggled__DelegateSignature
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::OnAttachmentLightToggled__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PlayerCharacter.OnAttachmentLightToggled__DelegateSignature");
		
		APlayerCharacter_OnAttachmentLightToggled__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Multicast_ToggleLaserLight
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Multicast_ToggleLaserLight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Multicast_ToggleLaserLight");
		
		APlayerCharacter_Multicast_ToggleLaserLight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Multicast_ShowThirdPerson
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Multicast_ShowThirdPerson()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Multicast_ShowThirdPerson");
		
		APlayerCharacter_Multicast_ShowThirdPerson_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Multicast_PlaySound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USoundCue*                                   Cue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Multicast_PlaySound(class USoundCue* Cue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Multicast_PlaySound");
		
		APlayerCharacter_Multicast_PlaySound_Params params {};
		params.Cue = Cue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Multicast_PlayPVPSpeech
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SpeechRowName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Multicast_PlayPVPSpeech(const class FString& SpeechRowName, ETeamType TeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Multicast_PlayPVPSpeech");
		
		APlayerCharacter_Multicast_PlayPVPSpeech_Params params {};
		params.SpeechRowName = SpeechRowName;
		params.TeamType = TeamType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Multicast_PlayInjuredScream
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Multicast_PlayInjuredScream()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Multicast_PlayInjuredScream");
		
		APlayerCharacter_Multicast_PlayInjuredScream_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Multicast_PlayArmourRelatedEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseArmour*                                 Armour                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UParticleSystem*                             Particle                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                     AtTransform                                                (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Multicast_PlayArmourRelatedEffects(class ABaseArmour* Armour, class UParticleSystem* Particle, const struct FTransform& AtTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Multicast_PlayArmourRelatedEffects");
		
		APlayerCharacter_Multicast_PlayArmourRelatedEffects_Params params {};
		params.Armour = Armour;
		params.Particle = Particle;
		params.AtTransform = AtTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Multicast_HideThirdPerson
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Multicast_HideThirdPerson()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Multicast_HideThirdPerson");
		
		APlayerCharacter_Multicast_HideThirdPerson_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Melee
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Melee()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Melee");
		
		APlayerCharacter_Melee_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.MagCheck
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::MagCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.MagCheck");
		
		APlayerCharacter_MagCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.LocalKillFeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseItem*                                   Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::LocalKillFeed(class APlayerCharacter* Killer, class APlayerCharacter* Victim, class ABaseItem* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.LocalKillFeed");
		
		APlayerCharacter_LocalKillFeed_Params params {};
		params.Killer = Killer;
		params.Victim = Victim;
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.LocalFreeFeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Freer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::LocalFreeFeed(class APlayerCharacter* Freer, class APlayerCharacter* Victim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.LocalFreeFeed");
		
		APlayerCharacter_LocalFreeFeed_Params params {};
		params.Freer = Freer;
		params.Victim = Victim;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.LocalDeathFeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotPlayerController*                 PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::LocalDeathFeed(class AReadyOrNotPlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.LocalDeathFeed");
		
		APlayerCharacter_LocalDeathFeed_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.LocalArrestFeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Arrester                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::LocalArrestFeed(class APlayerCharacter* Arrester, class APlayerCharacter* Victim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.LocalArrestFeed");
		
		APlayerCharacter_LocalArrestFeed_Params params {};
		params.Arrester = Arrester;
		params.Victim = Victim;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.LeanUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::LeanUp(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.LeanUp");
		
		APlayerCharacter_LeanUp_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.LeanRight
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::LeanRight(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.LeanRight");
		
		APlayerCharacter_LeanRight_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Lean
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Lean(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Lean");
		
		APlayerCharacter_Lean_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.JamDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::JamDoor(class ADoor* Door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.JamDoor");
		
		APlayerCharacter_JamDoor_Params params {};
		params.Door = Door;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IsSprinting
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::IsSprinting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IsSprinting");
		
		APlayerCharacter_IsSprinting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IsReloading
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::IsReloading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IsReloading");
		
		APlayerCharacter_IsReloading_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IsPointPartiallyReachable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Position                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APlayerCharacter::IsPointPartiallyReachable(const struct FCoreUObject_FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IsPointPartiallyReachable");
		
		APlayerCharacter_IsPointPartiallyReachable_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IsPointFullyReachable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Position                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APlayerCharacter::IsPointFullyReachable(const struct FCoreUObject_FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IsPointFullyReachable");
		
		APlayerCharacter_IsPointFullyReachable_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IsMovingForward
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::IsMovingForward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IsMovingForward");
		
		APlayerCharacter_IsMovingForward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IsMoving
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::IsMoving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IsMoving");
		
		APlayerCharacter_IsMoving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IsMagCheckPlaying
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::IsMagCheckPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IsMagCheckPlaying");
		
		APlayerCharacter_IsMagCheckPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IsInTightSpaces
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::IsInTightSpaces()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IsInTightSpaces");
		
		APlayerCharacter_IsInTightSpaces_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IsInLightSource
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            VisibleLightSources                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinimumLightLevel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APlayerCharacter::IsInLightSource(int32_t* VisibleLightSources, float MinimumLightLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IsInLightSource");
		
		APlayerCharacter_IsInLightSource_Params params {};
		params.MinimumLightLevel = MinimumLightLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (VisibleLightSources != nullptr)
			*VisibleLightSources = params.VisibleLightSources;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IsInCinematicAnimation
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::IsInCinematicAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IsInCinematicAnimation");
		
		APlayerCharacter_IsInCinematicAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IsHoldingSprint
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::IsHoldingSprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IsHoldingSprint");
		
		APlayerCharacter_IsHoldingSprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IsFreelooking
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::IsFreelooking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IsFreelooking");
		
		APlayerCharacter_IsFreelooking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IsFireModeSelectPlaying
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::IsFireModeSelectPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IsFireModeSelectPlaying");
		
		APlayerCharacter_IsFireModeSelectPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Is1PMontagePlaying
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APlayerCharacter::Is1PMontagePlaying(class UAnimMontage* Montage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Is1PMontagePlaying");
		
		APlayerCharacter_Is1PMontagePlaying_Params params {};
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.IncrementalUse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::IncrementalUse(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.IncrementalUse");
		
		APlayerCharacter_IncrementalUse_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.HidePlayer
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::HidePlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.HidePlayer");
		
		APlayerCharacter_HidePlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.HasWedge
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::HasWedge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.HasWedge");
		
		APlayerCharacter_HasWedge_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.HasOptiwand
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::HasOptiwand()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.HasOptiwand");
		
		APlayerCharacter_HasOptiwand_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.HasNVG
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::HasNVG()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.HasNVG");
		
		APlayerCharacter_HasNVG_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.HasLockpick
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::HasLockpick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.HasLockpick");
		
		APlayerCharacter_HasLockpick_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.HasLineOfSightToAnyPlayerControlledCharacter
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::HasLineOfSightToAnyPlayerControlledCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.HasLineOfSightToAnyPlayerControlledCharacter");
		
		APlayerCharacter_HasLineOfSightToAnyPlayerControlledCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.HasGrenadesInInventory
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::HasGrenadesInInventory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.HasGrenadesInInventory");
		
		APlayerCharacter_HasGrenadesInInventory_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.HasChemlightsInInventory
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::HasChemlightsInInventory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.HasChemlightsInInventory");
		
		APlayerCharacter_HasChemlightsInInventory_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.HasC2
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::HasC2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.HasC2");
		
		APlayerCharacter_HasC2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.HasBSG
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::HasBSG()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.HasBSG");
		
		APlayerCharacter_HasBSG_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.GetViewPitch
	 * 		Flags  -> ()
	 */
	float APlayerCharacter::GetViewPitch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.GetViewPitch");
		
		APlayerCharacter_GetViewPitch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.GetQuickthrowGrenadeAmmo
	 * 		Flags  -> ()
	 */
	int32_t APlayerCharacter::GetQuickthrowGrenadeAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.GetQuickthrowGrenadeAmmo");
		
		APlayerCharacter_GetQuickthrowGrenadeAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.GetLeanAmount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Component                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InOutPendingVal                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float APlayerCharacter::GetLeanAmount(const struct FCoreUObject_FVector& Component, float* InOutPendingVal, float MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.GetLeanAmount");
		
		APlayerCharacter_GetLeanAmount_Params params {};
		params.Component = Component;
		params.MaxValue = MaxValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InOutPendingVal != nullptr)
			*InOutPendingVal = params.InOutPendingVal;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.GetHitFromCamera
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              MaxDistance                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<ECollisionChannel>                          CollisionChannels                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FRotator                       OffsetRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        OffsetVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDrawTrace                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FHitResult APlayerCharacter::GetHitFromCamera(float MaxDistance, TArray<ECollisionChannel> CollisionChannels, const struct FCoreUObject_FRotator& OffsetRotation, const struct FCoreUObject_FVector& OffsetVector, bool bDrawTrace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.GetHitFromCamera");
		
		APlayerCharacter_GetHitFromCamera_Params params {};
		params.MaxDistance = MaxDistance;
		params.CollisionChannels = CollisionChannels;
		params.OffsetRotation = OffsetRotation;
		params.OffsetVector = OffsetVector;
		params.bDrawTrace = bDrawTrace;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.GetFootConstant
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EFootConstEnum                                     FootConst                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t APlayerCharacter::GetFootConstant(EFootConstEnum FootConst)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.GetFootConstant");
		
		APlayerCharacter_GetFootConstant_Params params {};
		params.FootConst = FootConst;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.GetFiringMode
	 * 		Flags  -> ()
	 */
	EFireMode APlayerCharacter::GetFiringMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.GetFiringMode");
		
		APlayerCharacter_GetFiringMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.GetCurrentFreelookSettings
	 * 		Flags  -> ()
	 */
	struct FCameraFreelookSetting APlayerCharacter::GetCurrentFreelookSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.GetCurrentFreelookSettings");
		
		APlayerCharacter_GetCurrentFreelookSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.GetClosestPlayerCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutClosestDistance                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bExcludeArrested                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APlayerCharacter* APlayerCharacter::GetClosestPlayerCharacter(ETeamType Team, float* OutClosestDistance, bool bExcludeArrested)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.GetClosestPlayerCharacter");
		
		APlayerCharacter_GetClosestPlayerCharacter_Params params {};
		params.Team = Team;
		params.bExcludeArrested = bExcludeArrested;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutClosestDistance != nullptr)
			*OutClosestDistance = params.OutClosestDistance;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.GetChemlightAmmo
	 * 		Flags  -> ()
	 */
	int32_t APlayerCharacter::GetChemlightAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.GetChemlightAmmo");
		
		APlayerCharacter_GetChemlightAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.GetAvaliablePlayersForTeamView
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIncludeDeadViews                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class AReadyOrNotCharacter*> APlayerCharacter::GetAvaliablePlayersForTeamView(bool bIncludeDeadViews)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.GetAvaliablePlayersForTeamView");
		
		APlayerCharacter_GetAvaliablePlayersForTeamView_Params params {};
		params.bIncludeDeadViews = bIncludeDeadViews;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.GetAllOtherPlayerCharacters
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class APlayerCharacter*> APlayerCharacter::GetAllOtherPlayerCharacters(ETeamType Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.GetAllOtherPlayerCharacters");
		
		APlayerCharacter_GetAllOtherPlayerCharacters_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.GetAimOffsets
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FRotator APlayerCharacter::GetAimOffsets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.GetAimOffsets");
		
		APlayerCharacter_GetAimOffsets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ForceMaxLODs_Player
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ForceMaxLODs_Player()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ForceMaxLODs_Player");
		
		APlayerCharacter_ForceMaxLODs_Player_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ForceMaxLODs_Items
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ForceMaxLODs_Items()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ForceMaxLODs_Items");
		
		APlayerCharacter_ForceMaxLODs_Items_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ForceFirstDraw
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ForceFirstDraw()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ForceFirstDraw");
		
		APlayerCharacter_ForceFirstDraw_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.FireLaserEyes
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::FireLaserEyes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.FireLaserEyes");
		
		APlayerCharacter_FireLaserEyes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.FadeToBlackEnable
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::FadeToBlackEnable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.FadeToBlackEnable");
		
		APlayerCharacter_FadeToBlackEnable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.FadeToBlackDisable
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::FadeToBlackDisable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.FadeToBlackDisable");
		
		APlayerCharacter_FadeToBlackDisable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipZipcuffs
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipZipcuffs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipZipcuffs");
		
		APlayerCharacter_EquipZipcuffs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipTacticalDevice
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipTacticalDevice()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipTacticalDevice");
		
		APlayerCharacter_EquipTacticalDevice_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipTablet
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipTablet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipTablet");
		
		APlayerCharacter_EquipTablet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipStinger
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipStinger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipStinger");
		
		APlayerCharacter_EquipStinger_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipSecondaryItem
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipSecondaryItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipSecondaryItem");
		
		APlayerCharacter_EquipSecondaryItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipPrimaryItem
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipPrimaryItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipPrimaryItem");
		
		APlayerCharacter_EquipPrimaryItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipPepperspray
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipPepperspray()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipPepperspray");
		
		APlayerCharacter_EquipPepperspray_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquippedWeaponHasSecondarySight
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::EquippedWeaponHasSecondarySight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquippedWeaponHasSecondarySight");
		
		APlayerCharacter_EquippedWeaponHasSecondarySight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquippedWeaponHasLightAttachment
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::EquippedWeaponHasLightAttachment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquippedWeaponHasLightAttachment");
		
		APlayerCharacter_EquippedWeaponHasLightAttachment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquippedWeaponHasLaserAttachment
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::EquippedWeaponHasLaserAttachment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquippedWeaponHasLaserAttachment");
		
		APlayerCharacter_EquippedWeaponHasLaserAttachment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipNinebang
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipNinebang()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipNinebang");
		
		APlayerCharacter_EquipNinebang_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipMultitool
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipMultitool()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipMultitool");
		
		APlayerCharacter_EquipMultitool_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipMirrorgun
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipMirrorgun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipMirrorgun");
		
		APlayerCharacter_EquipMirrorgun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipLongTactical
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipLongTactical()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipLongTactical");
		
		APlayerCharacter_EquipLongTactical_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipItemOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      ItemCategory                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABaseItem* APlayerCharacter::EquipItemOfType(EItemCategory ItemCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipItemOfType");
		
		APlayerCharacter_EquipItemOfType_Params params {};
		params.ItemCategory = ItemCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipItemFromGroup_Name
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        GroupName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ItemCategoryIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABaseItem* APlayerCharacter::EquipItemFromGroup_Name(const class FName& GroupName, int32_t ItemCategoryIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipItemFromGroup_Name");
		
		APlayerCharacter_EquipItemFromGroup_Name_Params params {};
		params.GroupName = GroupName;
		params.ItemCategoryIndex = ItemCategoryIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipItemFromGroup_Index
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            GroupIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ItemCategoryIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABaseItem* APlayerCharacter::EquipItemFromGroup_Index(int32_t GroupIndex, int32_t ItemCategoryIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipItemFromGroup_Index");
		
		APlayerCharacter_EquipItemFromGroup_Index_Params params {};
		params.GroupIndex = GroupIndex;
		params.ItemCategoryIndex = ItemCategoryIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipGrenade_5
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipGrenade_5()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipGrenade_5");
		
		APlayerCharacter_EquipGrenade_5_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipGrenade_4
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipGrenade_4()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipGrenade_4");
		
		APlayerCharacter_EquipGrenade_4_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipGrenade_3
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipGrenade_3()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipGrenade_3");
		
		APlayerCharacter_EquipGrenade_3_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipGrenade_2
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipGrenade_2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipGrenade_2");
		
		APlayerCharacter_EquipGrenade_2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipGrenade
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipGrenade()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipGrenade");
		
		APlayerCharacter_EquipGrenade_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipFlashbang
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipFlashbang()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipFlashbang");
		
		APlayerCharacter_EquipFlashbang_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipDoorJam
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipDoorJam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipDoorJam");
		
		APlayerCharacter_EquipDoorJam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipDevice_5
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipDevice_5()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipDevice_5");
		
		APlayerCharacter_EquipDevice_5_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipDevice_4
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipDevice_4()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipDevice_4");
		
		APlayerCharacter_EquipDevice_4_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipDevice_3
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipDevice_3()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipDevice_3");
		
		APlayerCharacter_EquipDevice_3_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipDevice_2
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipDevice_2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipDevice_2");
		
		APlayerCharacter_EquipDevice_2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipCSGas
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipCSGas()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipCSGas");
		
		APlayerCharacter_EquipCSGas_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipC2
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipC2()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipC2");
		
		APlayerCharacter_EquipC2_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipBreachingShotgun
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipBreachingShotgun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipBreachingShotgun");
		
		APlayerCharacter_EquipBreachingShotgun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EquipBatteringRam
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EquipBatteringRam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EquipBatteringRam");
		
		APlayerCharacter_EquipBatteringRam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EndSecondaryUse
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EndSecondaryUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EndSecondaryUse");
		
		APlayerCharacter_EndSecondaryUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EndQuickThrow
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EndQuickThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EndQuickThrow");
		
		APlayerCharacter_EndQuickThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EndCinematicSequence
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EndCinematicSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EndCinematicSequence");
		
		APlayerCharacter_EndCinematicSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EndChemThrow
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EndChemThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EndChemThrow");
		
		APlayerCharacter_EndChemThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.EnableNightVisionGoggles
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::EnableNightVisionGoggles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.EnableNightVisionGoggles");
		
		APlayerCharacter_EnableNightVisionGoggles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Drone_Yaw
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Drone_Yaw(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Drone_Yaw");
		
		APlayerCharacter_Drone_Yaw_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Drone_Throttle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Drone_Throttle(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Drone_Throttle");
		
		APlayerCharacter_Drone_Throttle_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Drone_Steady
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Drone_Steady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Drone_Steady");
		
		APlayerCharacter_Drone_Steady_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Drone_Right
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Drone_Right(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Drone_Right");
		
		APlayerCharacter_Drone_Right_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Drone_MoveForward
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Drone_MoveForward(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Drone_MoveForward");
		
		APlayerCharacter_Drone_MoveForward_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.DrawPermanentMarker
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::DrawPermanentMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.DrawPermanentMarker");
		
		APlayerCharacter_DrawPermanentMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.DisableNightVisionGoggles
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::DisableNightVisionGoggles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.DisableNightVisionGoggles");
		
		APlayerCharacter_DisableNightVisionGoggles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.DestroyNonDevelopmentComponents
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::DestroyNonDevelopmentComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.DestroyNonDevelopmentComponents");
		
		APlayerCharacter_DestroyNonDevelopmentComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.DebugDetachAllComponentsAndSubComponents
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::DebugDetachAllComponentsAndSubComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.DebugDetachAllComponentsAndSubComponents");
		
		APlayerCharacter_DebugDetachAllComponentsAndSubComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.CreateTeamViewWidget
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::CreateTeamViewWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.CreateTeamViewWidget");
		
		APlayerCharacter_CreateTeamViewWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.CreateHUDWidget
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::CreateHUDWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.CreateHUDWidget");
		
		APlayerCharacter_CreateHUDWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.CloseTablet
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::CloseTablet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.CloseTablet");
		
		APlayerCharacter_CloseTablet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ClosePlayerView
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::ClosePlayerView()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ClosePlayerView");
		
		APlayerCharacter_ClosePlayerView_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_UpdateMagBeforeReload
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Client_UpdateMagBeforeReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_UpdateMagBeforeReload");
		
		APlayerCharacter_Client_UpdateMagBeforeReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_StartStun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      StunCauser                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        DamageCauserLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Client_StartStun(EStunType StunType, class AActor* StunCauser, const struct FCoreUObject_FVector& DamageCauserLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_StartStun");
		
		APlayerCharacter_Client_StartStun_Params params {};
		params.StunType = StunType;
		params.StunCauser = StunCauser;
		params.DamageCauserLocation = DamageCauserLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_ShowMagDiscarded
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Client_ShowMagDiscarded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_ShowMagDiscarded");
		
		APlayerCharacter_Client_ShowMagDiscarded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_ShowMagCheck
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Client_ShowMagCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_ShowMagCheck");
		
		APlayerCharacter_Client_ShowMagCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_ShowMagAfterReload
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Client_ShowMagAfterReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_ShowMagAfterReload");
		
		APlayerCharacter_Client_ShowMagAfterReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_ShowFireModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EFireMode                                          newFireMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Client_ShowFireModeChanged(EFireMode newFireMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_ShowFireModeChanged");
		
		APlayerCharacter_Client_ShowFireModeChanged_Params params {};
		params.newFireMode = newFireMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_SetWalkSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newWalkSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              newCrouchWalkSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Client_SetWalkSpeed(float newWalkSpeed, float newCrouchWalkSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_SetWalkSpeed");
		
		APlayerCharacter_Client_SetWalkSpeed_Params params {};
		params.newWalkSpeed = newWalkSpeed;
		params.newCrouchWalkSpeed = newCrouchWalkSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_ResetPlayerEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      InPlayerEffectClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Client_ResetPlayerEffect(class UClass* InPlayerEffectClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_ResetPlayerEffect");
		
		APlayerCharacter_Client_ResetPlayerEffect_Params params {};
		params.InPlayerEffectClass = InPlayerEffectClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_PossessedBy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AController*                                 NewController                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Client_PossessedBy(class AController* NewController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_PossessedBy");
		
		APlayerCharacter_Client_PossessedBy_Params params {};
		params.NewController = NewController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_PlayPostProcessEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        InPostProcessEffect                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Client_PlayPostProcessEffect(const class FName& InPostProcessEffect, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_PlayPostProcessEffect");
		
		APlayerCharacter_Client_PlayPostProcessEffect_Params params {};
		params.InPostProcessEffect = InPostProcessEffect;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_OnTakenDamageDetail
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bWasHeadshot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTorsoShot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeftArm                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeftLeg                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRightArm                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRightLeg                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DamageTaken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RemainingHealth                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBlockedByArmour                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBlockedByHelmet                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Client_OnTakenDamageDetail(bool bWasHeadshot, bool bTorsoShot, bool bLeftArm, bool bLeftLeg, bool bRightArm, bool bRightLeg, float DamageTaken, float RemainingHealth, bool bBlockedByArmour, bool bBlockedByHelmet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_OnTakenDamageDetail");
		
		APlayerCharacter_Client_OnTakenDamageDetail_Params params {};
		params.bWasHeadshot = bWasHeadshot;
		params.bTorsoShot = bTorsoShot;
		params.bLeftArm = bLeftArm;
		params.bLeftLeg = bLeftLeg;
		params.bRightArm = bRightArm;
		params.bRightLeg = bRightLeg;
		params.DamageTaken = DamageTaken;
		params.RemainingHealth = RemainingHealth;
		params.bBlockedByArmour = bBlockedByArmour;
		params.bBlockedByHelmet = bBlockedByHelmet;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_OnPlayerDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bTakenDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InDamage                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Client_OnPlayerDamage(bool bTakenDamage, float InDamage, class AReadyOrNotCharacter* InstigatorCharacter, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_OnPlayerDamage");
		
		APlayerCharacter_Client_OnPlayerDamage_Params params {};
		params.bTakenDamage = bTakenDamage;
		params.InDamage = InDamage;
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_OnLimbBroken
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Client_OnLimbBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_OnLimbBroken");
		
		APlayerCharacter_Client_OnLimbBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_HideMagCheck
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::Client_HideMagCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_HideMagCheck");
		
		APlayerCharacter_Client_HideMagCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_CreateWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Widget                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Client_CreateWidget(class UClass* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_CreateWidget");
		
		APlayerCharacter_Client_CreateWidget_Params params {};
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_BulletHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  BulletImpact                                               (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Client_BulletHit(const struct FHitResult& BulletImpact)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_BulletHit");
		
		APlayerCharacter_Client_BulletHit_Params params {};
		params.BulletImpact = BulletImpact;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_AutoSelectNewQuickthrowItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseGrenade*                                CallingGrenade                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Client_AutoSelectNewQuickthrowItem(class ABaseGrenade* CallingGrenade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_AutoSelectNewQuickthrowItem");
		
		APlayerCharacter_Client_AutoSelectNewQuickthrowItem_Params params {};
		params.CallingGrenade = CallingGrenade;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.Client_ApplyPlayerEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      InPlayerEffectClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bResettable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMulticast                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::Client_ApplyPlayerEffect(class UClass* InPlayerEffectClass, bool bResettable, bool bMulticast)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.Client_ApplyPlayerEffect");
		
		APlayerCharacter_Client_ApplyPlayerEffect_Params params {};
		params.InPlayerEffectClass = InPlayerEffectClass;
		params.bResettable = bResettable;
		params.bMulticast = bMulticast;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.CheckSprintingGroup
	 * 		Flags  -> ()
	 */
	void APlayerCharacter::CheckSprintingGroup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.CheckSprintingGroup");
		
		APlayerCharacter_CheckSprintingGroup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.CaptureFPCamera
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::CaptureFPCamera(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.CaptureFPCamera");
		
		APlayerCharacter_CaptureFPCamera_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.CanUseIncrementalSystem
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::CanUseIncrementalSystem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.CanUseIncrementalSystem");
		
		APlayerCharacter_CanUseIncrementalSystem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.CanQuickThrow
	 * 		Flags  -> ()
	 */
	bool APlayerCharacter::CanQuickThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.CanQuickThrow");
		
		APlayerCharacter_CanQuickThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.CanPingActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APlayerCharacter::CanPingActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.CanPingActor");
		
		APlayerCharacter_CanPingActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.CalculateStopLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        OutStopLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CurrentLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Velocity                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Acceleration                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Friction                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BrakingDeceleration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              TimeStep                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxSimulationIterations                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool APlayerCharacter::CalculateStopLocation(struct FCoreUObject_FVector* OutStopLocation, const struct FCoreUObject_FVector& CurrentLocation, const struct FCoreUObject_FVector& Velocity, const struct FCoreUObject_FVector& Acceleration, float Friction, float BrakingDeceleration, float TimeStep, int32_t MaxSimulationIterations)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.CalculateStopLocation");
		
		APlayerCharacter_CalculateStopLocation_Params params {};
		params.CurrentLocation = CurrentLocation;
		params.Velocity = Velocity;
		params.Acceleration = Acceleration;
		params.Friction = Friction;
		params.BrakingDeceleration = BrakingDeceleration;
		params.TimeStep = TimeStep;
		params.MaxSimulationIterations = MaxSimulationIterations;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutStopLocation != nullptr)
			*OutStopLocation = params.OutStopLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.CalculateLeanMovement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::CalculateLeanMovement(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.CalculateLeanMovement");
		
		APlayerCharacter_CalculateLeanMovement_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.C2Door
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::C2Door(class ADoor* Door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.C2Door");
		
		APlayerCharacter_C2Door_Params params {};
		params.Door = Door;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ApplyPlayerEffectFor_Class
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      InPlayerEffectClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::ApplyPlayerEffectFor_Class(class UClass* InPlayerEffectClass, float Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ApplyPlayerEffectFor_Class");
		
		APlayerCharacter_ApplyPlayerEffectFor_Class_Params params {};
		params.InPlayerEffectClass = InPlayerEffectClass;
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ApplyPlayerEffectFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBasePlayerEffect*                           InPlayerEffect                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::ApplyPlayerEffectFor(class UBasePlayerEffect* InPlayerEffect, float Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ApplyPlayerEffectFor");
		
		APlayerCharacter_ApplyPlayerEffectFor_Params params {};
		params.InPlayerEffect = InPlayerEffect;
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ApplyPlayerEffect_Class
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      InPlayerEffectClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bResettable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::ApplyPlayerEffect_Class(class UClass* InPlayerEffectClass, bool bResettable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ApplyPlayerEffect_Class");
		
		APlayerCharacter_ApplyPlayerEffect_Class_Params params {};
		params.InPlayerEffectClass = InPlayerEffectClass;
		params.bResettable = bResettable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.ApplyPlayerEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBasePlayerEffect*                           InPlayerEffect                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bResettable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::ApplyPlayerEffect(class UBasePlayerEffect* InPlayerEffect, bool bResettable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.ApplyPlayerEffect");
		
		APlayerCharacter_ApplyPlayerEffect_Params params {};
		params.InPlayerEffect = InPlayerEffect;
		params.bResettable = bResettable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.AdjustScopeOffsetVertical
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewOffset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::AdjustScopeOffsetVertical(float NewOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.AdjustScopeOffsetVertical");
		
		APlayerCharacter_AdjustScopeOffsetVertical_Params params {};
		params.NewOffset = NewOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerCharacter.AdjustScopeOffsetHorizontal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewOffset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacter::AdjustScopeOffsetHorizontal(float NewOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerCharacter.AdjustScopeOffsetHorizontal");
		
		APlayerCharacter_AdjustScopeOffsetHorizontal_Params params {};
		params.NewOffset = NewOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlayerCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlayerCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayerCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerDetailsWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerDetailsWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayerDetailsWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerDetailsWidgetComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerDetailsWidgetComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayerDetailsWidgetComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerEffect_ModifyRecoil.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerEffect_ModifyRecoil::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayerEffect_ModifyRecoil");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerHealthStatusWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerHealthStatusWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayerHealthStatusWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerHUD.SetWidgetTranslationByMouseDelta
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UUserWidget*                                 Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InputScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ClampAt                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerHUD::SetWidgetTranslationByMouseDelta(class APlayerController* Controller, class UUserWidget* Widget, float DeltaSeconds, float InterpSpeed, float InputScale, float ClampAt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerHUD.SetWidgetTranslationByMouseDelta");
		
		APlayerHUD_SetWidgetTranslationByMouseDelta_Params params {};
		params.Controller = Controller;
		params.Widget = Widget;
		params.DeltaSeconds = DeltaSeconds;
		params.InterpSpeed = InterpSpeed;
		params.InputScale = InputScale;
		params.ClampAt = ClampAt;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerHUD.SetCanvasTranslationByMouseDelta
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCanvasPanel*                                Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InputScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ClampAt                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerHUD::SetCanvasTranslationByMouseDelta(class APlayerController* Controller, class UCanvasPanel* Widget, float DeltaSeconds, float InterpSpeed, float InputScale, float ClampAt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerHUD.SetCanvasTranslationByMouseDelta");
		
		APlayerHUD_SetCanvasTranslationByMouseDelta_Params params {};
		params.Controller = Controller;
		params.Widget = Widget;
		params.DeltaSeconds = DeltaSeconds;
		params.InterpSpeed = InterpSpeed;
		params.InputScale = InputScale;
		params.ClampAt = ClampAt;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlayerHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlayerHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayerHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerPaperdollWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerPaperdollWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayerPaperdollWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopTaserEffect
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StopTaserEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopTaserEffect");
		
		UPlayerPostProcessing_StopTaserEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopSuppressionEffects
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StopSuppressionEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopSuppressionEffects");
		
		UPlayerPostProcessing_StopSuppressionEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopStingerEffect
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StopStingerEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopStingerEffect");
		
		UPlayerPostProcessing_StopStingerEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopPostProcessEffect_Name
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        EffectName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StopPostProcessEffect_Name(const class FName& EffectName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopPostProcessEffect_Name");
		
		UPlayerPostProcessing_StopPostProcessEffect_Name_Params params {};
		params.EffectName = EffectName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopPostProcessEffect_FromDataAsset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPostProcessEffectData*                      InPostProcessEffectData                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StopPostProcessEffect_FromDataAsset(class UPostProcessEffectData* InPostProcessEffectData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopPostProcessEffect_FromDataAsset");
		
		UPlayerPostProcessing_StopPostProcessEffect_FromDataAsset_Params params {};
		params.InPostProcessEffectData = InPostProcessEffectData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopPostProcessEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPostProcessEffect                          InPostProcessEffect                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StopPostProcessEffect(struct FPostProcessEffect* InPostProcessEffect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopPostProcessEffect");
		
		UPlayerPostProcessing_StopPostProcessEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InPostProcessEffect != nullptr)
			*InPostProcessEffect = params.InPostProcessEffect;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopPeppersprayEffect
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StopPeppersprayEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopPeppersprayEffect");
		
		UPlayerPostProcessing_StopPeppersprayEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopInjuryEffects
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StopInjuryEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopInjuryEffects");
		
		UPlayerPostProcessing_StopInjuryEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopHeartbeatEffect
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StopHeartbeatEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopHeartbeatEffect");
		
		UPlayerPostProcessing_StopHeartbeatEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopHealingEffect
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StopHealingEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopHealingEffect");
		
		UPlayerPostProcessing_StopHealingEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopGasEffect
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StopGasEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopGasEffect");
		
		UPlayerPostProcessing_StopGasEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopFlashbangEffect
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StopFlashbangEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopFlashbangEffect");
		
		UPlayerPostProcessing_StopFlashbangEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopDeathEffect
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StopDeathEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopDeathEffect");
		
		UPlayerPostProcessing_StopDeathEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StopBleedingEffect
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StopBleedingEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StopBleedingEffect");
		
		UPlayerPostProcessing_StopBleedingEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartTaserEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StartTaserEffect(class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartTaserEffect");
		
		UPlayerPostProcessing_StartTaserEffect_Params params {};
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartSuppressionEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StartSuppressionEffects(class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartSuppressionEffects");
		
		UPlayerPostProcessing_StartSuppressionEffects_Params params {};
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartStingerEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StartStingerEffect(class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartStingerEffect");
		
		UPlayerPostProcessing_StartStingerEffect_Params params {};
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartPostProcessEffect_Specific
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPostProcessEffectPlayer                    InPostProcessSetting                                       (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StartPostProcessEffect_Specific(struct FPostProcessEffectPlayer* InPostProcessSetting, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartPostProcessEffect_Specific");
		
		UPlayerPostProcessing_StartPostProcessEffect_Specific_Params params {};
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InPostProcessSetting != nullptr)
			*InPostProcessSetting = params.InPostProcessSetting;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartPostProcessEffect_FromDataAsset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPostProcessEffectData*                      InPostProcessEffectData                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StartPostProcessEffect_FromDataAsset(class UPostProcessEffectData* InPostProcessEffectData, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartPostProcessEffect_FromDataAsset");
		
		UPlayerPostProcessing_StartPostProcessEffect_FromDataAsset_Params params {};
		params.InPostProcessEffectData = InPostProcessEffectData;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartPostProcessEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPostProcessEffect                          InPostProcessEffect                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StartPostProcessEffect(struct FPostProcessEffect* InPostProcessEffect, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartPostProcessEffect");
		
		UPlayerPostProcessing_StartPostProcessEffect_Params params {};
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InPostProcessEffect != nullptr)
			*InPostProcessEffect = params.InPostProcessEffect;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartPeppersprayEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StartPeppersprayEffect(class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartPeppersprayEffect");
		
		UPlayerPostProcessing_StartPeppersprayEffect_Params params {};
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartInjuryEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StartInjuryEffects(class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartInjuryEffects");
		
		UPlayerPostProcessing_StartInjuryEffects_Params params {};
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartHeartbeatEffect
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StartHeartbeatEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartHeartbeatEffect");
		
		UPlayerPostProcessing_StartHeartbeatEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartHealingEffect
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StartHealingEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartHealingEffect");
		
		UPlayerPostProcessing_StartHealingEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartGasEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StartGasEffect(class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartGasEffect");
		
		UPlayerPostProcessing_StartGasEffect_Params params {};
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartFlashbangEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StartFlashbangEffect(class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartFlashbangEffect");
		
		UPlayerPostProcessing_StartFlashbangEffect_Params params {};
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartDeathEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::StartDeathEffect(class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartDeathEffect");
		
		UPlayerPostProcessing_StartDeathEffect_Params params {};
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.StartBleedingEffect
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::StartBleedingEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.StartBleedingEffect");
		
		UPlayerPostProcessing_StartBleedingEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.ResetInjuryRadialBlur
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::ResetInjuryRadialBlur(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.ResetInjuryRadialBlur");
		
		UPlayerPostProcessing_ResetInjuryRadialBlur_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.ProcessPostProcessEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPostProcessEffect                          InPostProcessEffect                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::ProcessPostProcessEffect(struct FPostProcessEffect* InPostProcessEffect, float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.ProcessPostProcessEffect");
		
		UPlayerPostProcessing_ProcessPostProcessEffect_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InPostProcessEffect != nullptr)
			*InPostProcessEffect = params.InPostProcessEffect;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.PlayPostProcessEffect_Name
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        EffectName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::PlayPostProcessEffect_Name(const class FName& EffectName, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.PlayPostProcessEffect_Name");
		
		UPlayerPostProcessing_PlayPostProcessEffect_Name_Params params {};
		params.EffectName = EffectName;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.OnSupression
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::OnSupression(float Strength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.OnSupression");
		
		UPlayerPostProcessing_OnSupression_Params params {};
		params.Strength = Strength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.OnPlayerStunned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::OnPlayerStunned(class AReadyOrNotCharacter* Character, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.OnPlayerStunned");
		
		UPlayerPostProcessing_OnPlayerStunned_Params params {};
		params.Character = Character;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.OnPlayerKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::OnPlayerKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.OnPlayerKilled");
		
		UPlayerPostProcessing_OnPlayerKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.OnItemHolstered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::OnItemHolstered(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.OnItemHolstered");
		
		UPlayerPostProcessing_OnItemHolstered_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.OnItemEquipped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseItem*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::OnItemEquipped(class ABaseItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.OnItemEquipped");
		
		UPlayerPostProcessing_OnItemEquipped_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.OnFootstep
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::OnFootstep()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.OnFootstep");
		
		UPlayerPostProcessing_OnFootstep_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.OnFire
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::OnFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.OnFire");
		
		UPlayerPostProcessing_OnFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.OnDamageTakenDetails
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bWasHeadshot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DamageTaken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBlockedByArmour                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBlockedByHelmet                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::OnDamageTakenDetails(bool bWasHeadshot, float DamageTaken, float HealthRemaining, bool bBlockedByArmour, bool bBlockedByHelmet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.OnDamageTakenDetails");
		
		UPlayerPostProcessing_OnDamageTakenDetails_Params params {};
		params.bWasHeadshot = bWasHeadshot;
		params.DamageTaken = DamageTaken;
		params.HealthRemaining = HealthRemaining;
		params.bBlockedByArmour = bBlockedByArmour;
		params.bBlockedByHelmet = bBlockedByHelmet;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.OnDamageTaken
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::OnDamageTaken(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.OnDamageTaken");
		
		UPlayerPostProcessing_OnDamageTaken_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.OnBulletImpact
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DirectionForward                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DirectionRight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerPostProcessing::OnBulletImpact(float DirectionForward, float DirectionRight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.OnBulletImpact");
		
		UPlayerPostProcessing_OnBulletImpact_Params params {};
		params.DirectionForward = DirectionForward;
		params.DirectionRight = DirectionRight;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.IsPostProcessEffectPlaying
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPostProcessEffectData*                      InPostProcessEffectData                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerPostProcessing::IsPostProcessEffectPlaying(class UPostProcessEffectData* InPostProcessEffectData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.IsPostProcessEffectPlaying");
		
		UPlayerPostProcessing_IsPostProcessEffectPlaying_Params params {};
		params.InPostProcessEffectData = InPostProcessEffectData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.InitializePostProcessFloatParam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPostProcessEffect                          InPostProcessEffect                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        InParameterName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Instance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CurveKey                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerPostProcessing::InitializePostProcessFloatParam(const struct FPostProcessEffect& InPostProcessEffect, const class FName& InParameterName, float Value, int32_t Instance, int32_t CurveKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.InitializePostProcessFloatParam");
		
		UPlayerPostProcessing_InitializePostProcessFloatParam_Params params {};
		params.InPostProcessEffect = InPostProcessEffect;
		params.InParameterName = InParameterName;
		params.Value = Value;
		params.Instance = Instance;
		params.CurveKey = CurveKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.GetPostProcessFromFloatParam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPostProcessEffect                          InPostProcessEffect                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        InParameterName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Instance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerPostProcessing::GetPostProcessFromFloatParam(const struct FPostProcessEffect& InPostProcessEffect, const class FName& InParameterName, int32_t Instance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.GetPostProcessFromFloatParam");
		
		UPlayerPostProcessing_GetPostProcessFromFloatParam_Params params {};
		params.InPostProcessEffect = InPostProcessEffect;
		params.InParameterName = InParameterName;
		params.Instance = Instance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.FulfillsAllRequirements
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UClass*>                              InRequirementClasses                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InDamageCauser                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceFulfillment                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerPostProcessing::FulfillsAllRequirements(TArray<class UClass*> InRequirementClasses, class AActor* InDamageCauser, bool bForceFulfillment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.FulfillsAllRequirements");
		
		UPlayerPostProcessing_FulfillsAllRequirements_Params params {};
		params.InRequirementClasses = InRequirementClasses;
		params.InDamageCauser = InDamageCauser;
		params.bForceFulfillment = bForceFulfillment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.FlashOnDeath
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::FlashOnDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.FlashOnDeath");
		
		UPlayerPostProcessing_FlashOnDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerPostProcessing.FadeToGrey
	 * 		Flags  -> ()
	 */
	void UPlayerPostProcessing::FadeToGrey()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerPostProcessing.FadeToGrey");
		
		UPlayerPostProcessing_FadeToGrey_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerPostProcessing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerPostProcessing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayerPostProcessing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlayerReferendum.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlayerReferendum::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayerReferendum");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerSpeedIndicator_V2.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerSpeedIndicator_V2::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayerSpeedIndicator_V2");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerStart_VIP_Spawn.GetVIPSpawnDescriptor
	 * 		Flags  -> ()
	 */
	class FText APlayerStart_VIP_Spawn::GetVIPSpawnDescriptor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerStart_VIP_Spawn.GetVIPSpawnDescriptor");
		
		APlayerStart_VIP_Spawn_GetVIPSpawnDescriptor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerStart_VIP_Spawn.GetSpawnDirection
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FRotator APlayerStart_VIP_Spawn::GetSpawnDirection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerStart_VIP_Spawn.GetSpawnDirection");
		
		APlayerStart_VIP_Spawn_GetSpawnDirection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerStart_VIP_Spawn.GetRandomSpawnPoint
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector APlayerStart_VIP_Spawn::GetRandomSpawnPoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerStart_VIP_Spawn.GetRandomSpawnPoint");
		
		APlayerStart_VIP_Spawn_GetRandomSpawnPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlayerStart_VIP_Spawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlayerStart_VIP_Spawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayerStart_VIP_Spawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerViewActor.UpdateViewTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        NewLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FRotator                       NewRotation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void APlayerViewActor::UpdateViewTarget(const struct FCoreUObject_FVector& NewLocation, const struct FCoreUObject_FRotator& NewRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerViewActor.UpdateViewTarget");
		
		APlayerViewActor_UpdateViewTarget_Params params {};
		params.NewLocation = NewLocation;
		params.NewRotation = NewRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerViewActor.TryNextView
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bRequestClose                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeDeadViews                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerViewActor::TryNextView(bool bRequestClose, bool bIncludeDeadViews)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerViewActor.TryNextView");
		
		APlayerViewActor_TryNextView_Params params {};
		params.bRequestClose = bRequestClose;
		params.bIncludeDeadViews = bIncludeDeadViews;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerViewActor.SetViewPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        NewViewCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerViewActor::SetViewPlayer(class AReadyOrNotCharacter* NewViewCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerViewActor.SetViewPlayer");
		
		APlayerViewActor_SetViewPlayer_Params params {};
		params.NewViewCharacter = NewViewCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerViewActor.SetOwningPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            NewOwnerCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerViewActor::SetOwningPlayer(class APlayerCharacter* NewOwnerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerViewActor.SetOwningPlayer");
		
		APlayerViewActor_SetOwningPlayer_Params params {};
		params.NewOwnerCharacter = NewOwnerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerViewActor.IsSwitchingView
	 * 		Flags  -> ()
	 */
	bool APlayerViewActor::IsSwitchingView()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerViewActor.IsSwitchingView");
		
		APlayerViewActor_IsSwitchingView_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerViewActor.HideComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         ComponentToHide                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerViewActor::HideComponent(class UPrimitiveComponent* ComponentToHide)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerViewActor.HideComponent");
		
		APlayerViewActor_HideComponent_Params params {};
		params.ComponentToHide = ComponentToHide;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerViewActor.HideActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ActorToHide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeChildActors                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerViewActor::HideActor(class AActor* ActorToHide, bool bIncludeChildActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerViewActor.HideActor");
		
		APlayerViewActor_HideActor_Params params {};
		params.ActorToHide = ActorToHide;
		params.bIncludeChildActors = bIncludeChildActors;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PlayerViewActor.ClearHiddenComponents
	 * 		Flags  -> ()
	 */
	void APlayerViewActor::ClearHiddenComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PlayerViewActor.ClearHiddenComponents");
		
		APlayerViewActor_ClearHiddenComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlayerViewActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlayerViewActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PlayerViewActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APolicePresenceTestActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APolicePresenceTestActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PolicePresenceTestActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PopupTarget.Popup
	 * 		Flags  -> ()
	 */
	void APopupTarget::Popup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PopupTarget.Popup");
		
		APopupTarget_Popup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PopupTarget.IsAlive
	 * 		Flags  -> ()
	 */
	bool APopupTarget::IsAlive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PopupTarget.IsAlive");
		
		APopupTarget_IsAlive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APopupTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APopupTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PopupTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPostProcessEffectData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPostProcessEffectData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PostProcessEffectData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PostProcessRequirement.Initialize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            InPlayerCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InDamageCauser                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPostProcessRequirement::Initialize(class APlayerCharacter* InPlayerCharacter, class AActor* InDamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PostProcessRequirement.Initialize");
		
		UPostProcessRequirement_Initialize_Params params {};
		params.InPlayerCharacter = InPlayerCharacter;
		params.InDamageCauser = InDamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PostProcessRequirement.GetPlayerCharacter
	 * 		Flags  -> ()
	 */
	class APlayerCharacter* UPostProcessRequirement::GetPlayerCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PostProcessRequirement.GetPlayerCharacter");
		
		UPostProcessRequirement_GetPlayerCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PostProcessRequirement.GetDamageCauser
	 * 		Flags  -> ()
	 */
	class AActor* UPostProcessRequirement::GetDamageCauser()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PostProcessRequirement.GetDamageCauser");
		
		UPostProcessRequirement_GetDamageCauser_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PostProcessRequirement.EnablePostProcessEffect
	 * 		Flags  -> ()
	 */
	bool UPostProcessRequirement::EnablePostProcessEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PostProcessRequirement.EnablePostProcessEffect");
		
		UPostProcessRequirement_EnablePostProcessEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPostProcessRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPostProcessRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PostProcessRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPPR_IsDamageCauserOnScreen.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPPR_IsDamageCauserOnScreen::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PPR_IsDamageCauserOnScreen");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Pouch.OnRep_UpdateVisibility
	 * 		Flags  -> ()
	 */
	void APouch::OnRep_UpdateVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Pouch.OnRep_UpdateVisibility");
		
		APouch_OnRep_UpdateVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Pouch.OnRep_Attach
	 * 		Flags  -> ()
	 */
	void APouch::OnRep_Attach()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Pouch.OnRep_Attach");
		
		APouch_OnRep_Attach_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APouch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APouch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Pouch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.UpdateWorkbenchItemAttachments
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::UpdateWorkbenchItemAttachments()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.UpdateWorkbenchItemAttachments");
		
		UPreMissionPlanning_UpdateWorkbenchItemAttachments_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.UpdateWeaponPresets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSavedWeaponPreset                          Presets                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::UpdateWeaponPresets(class UClass* Weapon, const struct FSavedWeaponPreset& Presets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.UpdateWeaponPresets");
		
		UPreMissionPlanning_UpdateWeaponPresets_Params params {};
		params.Weapon = Weapon;
		params.Presets = Presets;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.UpdateWeaponPreset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FWeaponPreset                               PresetData                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::UpdateWeaponPreset(class UClass* Weapon, const struct FWeaponPreset& PresetData, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.UpdateWeaponPreset");
		
		UPreMissionPlanning_UpdateWeaponPreset_Params params {};
		params.Weapon = Weapon;
		params.PresetData = PresetData;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.UpdateWeaponDefaultFireMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFireMode                                          NewDefaultFireMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::UpdateWeaponDefaultFireMode(class UClass* Weapon, EFireMode NewDefaultFireMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.UpdateWeaponDefaultFireMode");
		
		UPreMissionPlanning_UpdateWeaponDefaultFireMode_Params params {};
		params.Weapon = Weapon;
		params.NewDefaultFireMode = NewDefaultFireMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.UpdatePreviewWeaponSkin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsSecondary                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      SkinAttachment                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::UpdatePreviewWeaponSkin(bool IsSecondary, class UClass* SkinAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.UpdatePreviewWeaponSkin");
		
		UPreMissionPlanning_UpdatePreviewWeaponSkin_Params params {};
		params.IsSecondary = IsSecondary;
		params.SkinAttachment = SkinAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.UpdatePreviewWeaponAttachments
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsSecondary                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Attachment                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::UpdatePreviewWeaponAttachments(bool IsSecondary, class UClass* Attachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.UpdatePreviewWeaponAttachments");
		
		UPreMissionPlanning_UpdatePreviewWeaponAttachments_Params params {};
		params.IsSecondary = IsSecondary;
		params.Attachment = Attachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.UpdatePreviewCharacterSecondary
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::UpdatePreviewCharacterSecondary()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.UpdatePreviewCharacterSecondary");
		
		UPreMissionPlanning_UpdatePreviewCharacterSecondary_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.UpdatePreviewCharacterPrimary
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::UpdatePreviewCharacterPrimary()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.UpdatePreviewCharacterPrimary");
		
		UPreMissionPlanning_UpdatePreviewCharacterPrimary_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.UpdatePreviewCharacterLongTactical
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::UpdatePreviewCharacterLongTactical()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.UpdatePreviewCharacterLongTactical");
		
		UPreMissionPlanning_UpdatePreviewCharacterLongTactical_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.UpdatePreviewCharacterHeadwear
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::UpdatePreviewCharacterHeadwear()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.UpdatePreviewCharacterHeadwear");
		
		UPreMissionPlanning_UpdatePreviewCharacterHeadwear_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.UpdatePreviewCharacterArmour
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::UpdatePreviewCharacterArmour()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.UpdatePreviewCharacterArmour");
		
		UPreMissionPlanning_UpdatePreviewCharacterArmour_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.UpdatePreviewCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotPlayerState*                      InPreviewPlayerState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::UpdatePreviewCharacter(class AReadyOrNotPlayerState* InPreviewPlayerState, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.UpdatePreviewCharacter");
		
		UPreMissionPlanning_UpdatePreviewCharacter_Params params {};
		params.InPreviewPlayerState = InPreviewPlayerState;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetWorkbenchItemClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetWorkbenchItemClass(class UClass* Item, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetWorkbenchItemClass");
		
		UPreMissionPlanning_SetWorkbenchItemClass_Params params {};
		params.Item = Item;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetSubcategory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPreMissionSubCategory                             NewSubCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetSubcategory(EPreMissionSubCategory NewSubCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetSubcategory");
		
		UPreMissionPlanning_SetSubcategory_Params params {};
		params.NewSubCategory = NewSubCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetSecondaryWeapon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FWeaponData                                 WeaponData                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetSecondaryWeapon(const struct FWeaponData& WeaponData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetSecondaryWeapon");
		
		UPreMissionPlanning_SetSecondaryWeapon_Params params {};
		params.WeaponData = WeaponData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetSecondaryUnderbarrelAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      UnderbarrelAttachment                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetSecondaryUnderbarrelAttachment(class UClass* UnderbarrelAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetSecondaryUnderbarrelAttachment");
		
		UPreMissionPlanning_SetSecondaryUnderbarrelAttachment_Params params {};
		params.UnderbarrelAttachment = UnderbarrelAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetSecondaryStockAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      StockAttachment                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetSecondaryStockAttachment(class UClass* StockAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetSecondaryStockAttachment");
		
		UPreMissionPlanning_SetSecondaryStockAttachment_Params params {};
		params.StockAttachment = StockAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetSecondarySkinAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      SkinAttachment                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetSecondarySkinAttachment(class UClass* SkinAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetSecondarySkinAttachment");
		
		UPreMissionPlanning_SetSecondarySkinAttachment_Params params {};
		params.SkinAttachment = SkinAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetSecondaryScopeAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ScopeAttachment                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetSecondaryScopeAttachment(class UClass* ScopeAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetSecondaryScopeAttachment");
		
		UPreMissionPlanning_SetSecondaryScopeAttachment_Params params {};
		params.ScopeAttachment = ScopeAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetSecondaryOverbarrelAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      OverbarrelAttachment                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetSecondaryOverbarrelAttachment(class UClass* OverbarrelAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetSecondaryOverbarrelAttachment");
		
		UPreMissionPlanning_SetSecondaryOverbarrelAttachment_Params params {};
		params.OverbarrelAttachment = OverbarrelAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetSecondaryMuzzleAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      MuzzleAttachment                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetSecondaryMuzzleAttachment(class UClass* MuzzleAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetSecondaryMuzzleAttachment");
		
		UPreMissionPlanning_SetSecondaryMuzzleAttachment_Params params {};
		params.MuzzleAttachment = MuzzleAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetSecondaryIlluminatorAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      IlluminatorAttachment                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetSecondaryIlluminatorAttachment(class UClass* IlluminatorAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetSecondaryIlluminatorAttachment");
		
		UPreMissionPlanning_SetSecondaryIlluminatorAttachment_Params params {};
		params.IlluminatorAttachment = IlluminatorAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetSecondaryGripAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      GripAttachment                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetSecondaryGripAttachment(class UClass* GripAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetSecondaryGripAttachment");
		
		UPreMissionPlanning_SetSecondaryGripAttachment_Params params {};
		params.GripAttachment = GripAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetSecondaryAmmunitionAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      AmmunitionAttachment                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetSecondaryAmmunitionAttachment(class UClass* AmmunitionAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetSecondaryAmmunitionAttachment");
		
		UPreMissionPlanning_SetSecondaryAmmunitionAttachment_Params params {};
		params.AmmunitionAttachment = AmmunitionAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetPrimaryWeapon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FWeaponData                                 WeaponData                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetPrimaryWeapon(const struct FWeaponData& WeaponData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetPrimaryWeapon");
		
		UPreMissionPlanning_SetPrimaryWeapon_Params params {};
		params.WeaponData = WeaponData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetPrimaryUnderbarrelAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      UnderbarrelAttachment                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetPrimaryUnderbarrelAttachment(class UClass* UnderbarrelAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetPrimaryUnderbarrelAttachment");
		
		UPreMissionPlanning_SetPrimaryUnderbarrelAttachment_Params params {};
		params.UnderbarrelAttachment = UnderbarrelAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetPrimaryStockAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      StockAttachment                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetPrimaryStockAttachment(class UClass* StockAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetPrimaryStockAttachment");
		
		UPreMissionPlanning_SetPrimaryStockAttachment_Params params {};
		params.StockAttachment = StockAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetPrimarySkinAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      SkinAttachment                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetPrimarySkinAttachment(class UClass* SkinAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetPrimarySkinAttachment");
		
		UPreMissionPlanning_SetPrimarySkinAttachment_Params params {};
		params.SkinAttachment = SkinAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetPrimaryScopeAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ScopeAttachment                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetPrimaryScopeAttachment(class UClass* ScopeAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetPrimaryScopeAttachment");
		
		UPreMissionPlanning_SetPrimaryScopeAttachment_Params params {};
		params.ScopeAttachment = ScopeAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetPrimaryOverbarrelAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      OverbarrelAttachment                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetPrimaryOverbarrelAttachment(class UClass* OverbarrelAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetPrimaryOverbarrelAttachment");
		
		UPreMissionPlanning_SetPrimaryOverbarrelAttachment_Params params {};
		params.OverbarrelAttachment = OverbarrelAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetPrimaryMuzzleAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      MuzzleAttachment                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetPrimaryMuzzleAttachment(class UClass* MuzzleAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetPrimaryMuzzleAttachment");
		
		UPreMissionPlanning_SetPrimaryMuzzleAttachment_Params params {};
		params.MuzzleAttachment = MuzzleAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetPrimaryIlluminatorAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      IlluminatorAttachment                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetPrimaryIlluminatorAttachment(class UClass* IlluminatorAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetPrimaryIlluminatorAttachment");
		
		UPreMissionPlanning_SetPrimaryIlluminatorAttachment_Params params {};
		params.IlluminatorAttachment = IlluminatorAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetPrimaryGripAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      GripAttachment                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetPrimaryGripAttachment(class UClass* GripAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetPrimaryGripAttachment");
		
		UPreMissionPlanning_SetPrimaryGripAttachment_Params params {};
		params.GripAttachment = GripAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetPrimaryAmmunitionAttachment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      AmmunitionAttachment                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetPrimaryAmmunitionAttachment(class UClass* AmmunitionAttachment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetPrimaryAmmunitionAttachment");
		
		UPreMissionPlanning_SetPrimaryAmmunitionAttachment_Params params {};
		params.AmmunitionAttachment = AmmunitionAttachment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetPlayerSkin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      SkinCompClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetPlayerSkin(class UClass* SkinCompClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetPlayerSkin");
		
		UPreMissionPlanning_SetPlayerSkin_Params params {};
		params.SkinCompClass = SkinCompClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetLongTactical
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      LongTactical                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetLongTactical(class UClass* LongTactical)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetLongTactical");
		
		UPreMissionPlanning_SetLongTactical_Params params {};
		params.LongTactical = LongTactical;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetLockInput
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldLockInput                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetLockInput(bool bShouldLockInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetLockInput");
		
		UPreMissionPlanning_SetLockInput_Params params {};
		params.bShouldLockInput = bShouldLockInput;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetLightColorByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                Color                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetLightColorByTag(const class FName& Tag, const struct FLinearColor& Color)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetLightColorByTag");
		
		UPreMissionPlanning_SetLightColorByTag_Params params {};
		params.Tag = Tag;
		params.Color = Color;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetItem_V2
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemClass                                         ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ItemObjectClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetItem_V2(EItemClass ItemClass, class UClass* ItemObjectClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetItem_V2");
		
		UPreMissionPlanning_SetItem_V2_Params params {};
		params.ItemClass = ItemClass;
		params.ItemObjectClass = ItemObjectClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemType                                          ItemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetItem(EItemType ItemType, class UClass* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetItem");
		
		UPreMissionPlanning_SetItem_Params params {};
		params.ItemType = ItemType;
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetHeadwear
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Headwear                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetHeadwear(class UClass* Headwear)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetHeadwear");
		
		UPreMissionPlanning_SetHeadwear_Params params {};
		params.Headwear = Headwear;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetEquippingSwatMember
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquippingSwat                                     NewEquippingSwat                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotPlayerState*                      NewEquippingPlayerState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetEquippingSwatMember(EEquippingSwat NewEquippingSwat, class AReadyOrNotPlayerState* NewEquippingPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetEquippingSwatMember");
		
		UPreMissionPlanning_SetEquippingSwatMember_Params params {};
		params.NewEquippingSwat = NewEquippingSwat;
		params.NewEquippingPlayerState = NewEquippingPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetBodyArmour
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      BodyArmour                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetBodyArmour(class UClass* BodyArmour)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetBodyArmour");
		
		UPreMissionPlanning_SetBodyArmour_Params params {};
		params.BodyArmour = BodyArmour;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SetActiveCameraByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SetActiveCameraByTag(const class FName& Tag, float BlendTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SetActiveCameraByTag");
		
		UPreMissionPlanning_SetActiveCameraByTag_Params params {};
		params.Tag = Tag;
		params.BlendTime = BlendTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SaveWeaponPresets
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::SaveWeaponPresets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SaveWeaponPresets");
		
		UPreMissionPlanning_SaveWeaponPresets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SaveWeaponDefaultFireMode
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::SaveWeaponDefaultFireMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SaveWeaponDefaultFireMode");
		
		UPreMissionPlanning_SaveWeaponDefaultFireMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SaveWeaponAttachments
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::SaveWeaponAttachments()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SaveWeaponAttachments");
		
		UPreMissionPlanning_SaveWeaponAttachments_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SaveLoadoutPresets
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::SaveLoadoutPresets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SaveLoadoutPresets");
		
		UPreMissionPlanning_SaveLoadoutPresets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SaveItemClassAsSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemType                                          ItemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::SaveItemClassAsSlot(EItemType ItemType, class UClass* Class)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SaveItemClassAsSlot");
		
		UPreMissionPlanning_SaveItemClassAsSlot_Params params {};
		params.ItemType = ItemType;
		params.Class = Class;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.SaveActiveLoadout
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::SaveActiveLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.SaveActiveLoadout");
		
		UPreMissionPlanning_SaveActiveLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.PlayAnimationOnQuartermaster
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::PlayAnimationOnQuartermaster(const class FString& Animation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.PlayAnimationOnQuartermaster");
		
		UPreMissionPlanning_PlayAnimationOnQuartermaster_Params params {};
		params.Animation = Animation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.PlayAnimationOnPreviewCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Animation                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::PlayAnimationOnPreviewCharacter(const class FString& Animation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.PlayAnimationOnPreviewCharacter");
		
		UPreMissionPlanning_PlayAnimationOnPreviewCharacter_Params params {};
		params.Animation = Animation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.OnWeaponDefaultFireModesLoaded
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::OnWeaponDefaultFireModesLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.OnWeaponDefaultFireModesLoaded");
		
		UPreMissionPlanning_OnWeaponDefaultFireModesLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.OnSwatCharacterChanged
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::OnSwatCharacterChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.OnSwatCharacterChanged");
		
		UPreMissionPlanning_OnSwatCharacterChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.PreMissionPlanning.OnRequestRefresh__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::OnRequestRefresh__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.PreMissionPlanning.OnRequestRefresh__DelegateSignature");
		
		UPreMissionPlanning_OnRequestRefresh__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.OnLoadoutSaved
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::OnLoadoutSaved()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.OnLoadoutSaved");
		
		UPreMissionPlanning_OnLoadoutSaved_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.OnLoadoutPresetsSaved
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::OnLoadoutPresetsSaved()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.OnLoadoutPresetsSaved");
		
		UPreMissionPlanning_OnLoadoutPresetsSaved_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.OnLoadoutPresetsLoaded
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::OnLoadoutPresetsLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.OnLoadoutPresetsLoaded");
		
		UPreMissionPlanning_OnLoadoutPresetsLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.OnLoadoutLoaded
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::OnLoadoutLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.OnLoadoutLoaded");
		
		UPreMissionPlanning_OnLoadoutLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.OnLoadoutItemPresetsSaved
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::OnLoadoutItemPresetsSaved()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.OnLoadoutItemPresetsSaved");
		
		UPreMissionPlanning_OnLoadoutItemPresetsSaved_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.OnLoadoutItemPresetsLoaded
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::OnLoadoutItemPresetsLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.OnLoadoutItemPresetsLoaded");
		
		UPreMissionPlanning_OnLoadoutItemPresetsLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.OnLoadoutItemAttachmentsSaved
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::OnLoadoutItemAttachmentsSaved()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.OnLoadoutItemAttachmentsSaved");
		
		UPreMissionPlanning_OnLoadoutItemAttachmentsSaved_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.OnLoadoutItemAttachmentsLoaded
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::OnLoadoutItemAttachmentsLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.OnLoadoutItemAttachmentsLoaded");
		
		UPreMissionPlanning_OnLoadoutItemAttachmentsLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.LoadWeaponPresets
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::LoadWeaponPresets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.LoadWeaponPresets");
		
		UPreMissionPlanning_LoadWeaponPresets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.LoadWeaponDefaultFireModes
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::LoadWeaponDefaultFireModes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.LoadWeaponDefaultFireModes");
		
		UPreMissionPlanning_LoadWeaponDefaultFireModes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.LoadWeaponAttachments
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::LoadWeaponAttachments()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.LoadWeaponAttachments");
		
		UPreMissionPlanning_LoadWeaponAttachments_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.LoadLoadoutPresets
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::LoadLoadoutPresets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.LoadLoadoutPresets");
		
		UPreMissionPlanning_LoadLoadoutPresets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.ItemClassToItemType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemClass                                         InItemClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EItemType UPreMissionPlanning::ItemClassToItemType(EItemClass InItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.ItemClassToItemType");
		
		UPreMissionPlanning_ItemClassToItemType_Params params {};
		params.InItemClass = InItemClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.IsInLobby
	 * 		Flags  -> ()
	 */
	bool UPreMissionPlanning::IsInLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.IsInLobby");
		
		UPreMissionPlanning_IsInLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.IsAnyWeaponVisible
	 * 		Flags  -> ()
	 */
	bool UPreMissionPlanning::IsAnyWeaponVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.IsAnyWeaponVisible");
		
		UPreMissionPlanning_IsAnyWeaponVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.Init
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bReadOnly                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSavedLoadout                               PreviewLoadout                                             (Parm, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::Init(bool bReadOnly, const struct FSavedLoadout& PreviewLoadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.Init");
		
		UPreMissionPlanning_Init_Params params {};
		params.bReadOnly = bReadOnly;
		params.PreviewLoadout = PreviewLoadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.HideWeapons
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHidePrimary                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHideSecondary                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::HideWeapons(bool bHidePrimary, bool bHideSecondary, float Delay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.HideWeapons");
		
		UPreMissionPlanning_HideWeapons_Params params {};
		params.bHidePrimary = bHidePrimary;
		params.bHideSecondary = bHideSecondary;
		params.Delay = Delay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.HideSecondary
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsHidden                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::HideSecondary(bool bIsHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.HideSecondary");
		
		UPreMissionPlanning_HideSecondary_Params params {};
		params.bIsHidden = bIsHidden;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.HidePrimary
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsHidden                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::HidePrimary(bool bIsHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.HidePrimary");
		
		UPreMissionPlanning_HidePrimary_Params params {};
		params.bIsHidden = bIsHidden;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.GetWeaponPresetsData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FSavedWeaponPreset UPreMissionPlanning::GetWeaponPresetsData(class UClass* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.GetWeaponPresetsData");
		
		UPreMissionPlanning_GetWeaponPresetsData_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.GetWeaponPresetData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FWeaponPreset UPreMissionPlanning::GetWeaponPresetData(class UClass* Weapon, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.GetWeaponPresetData");
		
		UPreMissionPlanning_GetWeaponPresetData_Params params {};
		params.Weapon = Weapon;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.GetWeaponData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemType                                          ItemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FWeaponData> UPreMissionPlanning::GetWeaponData(EItemType ItemType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.GetWeaponData");
		
		UPreMissionPlanning_GetWeaponData_Params params {};
		params.ItemType = ItemType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.GetSubcategory
	 * 		Flags  -> ()
	 */
	EPreMissionSubCategory UPreMissionPlanning::GetSubcategory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.GetSubcategory");
		
		UPreMissionPlanning_GetSubcategory_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.GetPremissionPlanning
	 * 		Flags  -> ()
	 */
	class UPreMissionPlanning* UPreMissionPlanning::GetPremissionPlanning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.GetPremissionPlanning");
		
		UPreMissionPlanning_GetPremissionPlanning_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.GetLastItemInSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemType                                          ItemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UPreMissionPlanning::GetLastItemInSlot(EItemType ItemType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.GetLastItemInSlot");
		
		UPreMissionPlanning_GetLastItemInSlot_Params params {};
		params.ItemType = ItemType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.GetItemAttachmentData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FSavedWeaponAttachmentData UPreMissionPlanning::GetItemAttachmentData(class UClass* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.GetItemAttachmentData");
		
		UPreMissionPlanning_GetItemAttachmentData_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.GetInputLocked
	 * 		Flags  -> ()
	 */
	bool UPreMissionPlanning::GetInputLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.GetInputLocked");
		
		UPreMissionPlanning_GetInputLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.GetEquippingSwatMember
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquippingSwat                                     EquippingSwat                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::GetEquippingSwatMember(EEquippingSwat* EquippingSwat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.GetEquippingSwatMember");
		
		UPreMissionPlanning_GetEquippingSwatMember_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (EquippingSwat != nullptr)
			*EquippingSwat = params.EquippingSwat;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.GetDeviceData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemType                                          ItemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FDeviceData> UPreMissionPlanning::GetDeviceData(EItemType ItemType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.GetDeviceData");
		
		UPreMissionPlanning_GetDeviceData_Params params {};
		params.ItemType = ItemType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.GetDefaultPreviewCharacter
	 * 		Flags  -> ()
	 */
	class AReadyOrNotCharacter* UPreMissionPlanning::GetDefaultPreviewCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.GetDefaultPreviewCharacter");
		
		UPreMissionPlanning_GetDefaultPreviewCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.GetAvailablePlayerSkins
	 * 		Flags  -> ()
	 */
	TArray<class UClass*> UPreMissionPlanning::GetAvailablePlayerSkins()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.GetAvailablePlayerSkins");
		
		UPreMissionPlanning_GetAvailablePlayerSkins_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.GetArmourData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemType                                          ItemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FArmourData> UPreMissionPlanning::GetArmourData(EItemType ItemType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.GetArmourData");
		
		UPreMissionPlanning_GetArmourData_Params params {};
		params.ItemType = ItemType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.EquipSecondary
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::EquipSecondary()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.EquipSecondary");
		
		UPreMissionPlanning_EquipSecondary_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.EquipPrimary
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::EquipPrimary()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.EquipPrimary");
		
		UPreMissionPlanning_EquipPrimary_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.DoSaveLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EEquippingSwat                                     SwatMember                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSavedLoadout                               Loadout                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::DoSaveLoadout(EEquippingSwat SwatMember, const struct FSavedLoadout& Loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.DoSaveLoadout");
		
		UPreMissionPlanning_DoSaveLoadout_Params params {};
		params.SwatMember = SwatMember;
		params.Loadout = Loadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.DoPrimaryWeaponPreviewBlend
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::DoPrimaryWeaponPreviewBlend()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.DoPrimaryWeaponPreviewBlend");
		
		UPreMissionPlanning_DoPrimaryWeaponPreviewBlend_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.ClearPreviewWeaponSkin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsSecondary                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::ClearPreviewWeaponSkin(bool IsSecondary)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.ClearPreviewWeaponSkin");
		
		UPreMissionPlanning_ClearPreviewWeaponSkin_Params params {};
		params.IsSecondary = IsSecondary;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.CleanSecondaryGun
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::CleanSecondaryGun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.CleanSecondaryGun");
		
		UPreMissionPlanning_CleanSecondaryGun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.CleanPrimaryGun
	 * 		Flags  -> ()
	 */
	void UPreMissionPlanning::CleanPrimaryGun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.CleanPrimaryGun");
		
		UPreMissionPlanning_CleanPrimaryGun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.AttachSecondaryToSocket
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Socket                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::AttachSecondaryToSocket(const class FName& Socket)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.AttachSecondaryToSocket");
		
		UPreMissionPlanning_AttachSecondaryToSocket_Params params {};
		params.Socket = Socket;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.PreMissionPlanning.AttachPrimaryToSocket
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Socket                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreMissionPlanning::AttachPrimaryToSocket(const class FName& Socket)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.PreMissionPlanning.AttachPrimaryToSocket");
		
		UPreMissionPlanning_AttachPrimaryToSocket_Params params {};
		params.Socket = Socket;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPreMissionPlanning.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPreMissionPlanning::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PreMissionPlanning");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APremissionStreetView.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APremissionStreetView::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PremissionStreetView");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APreplanningManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APreplanningManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PreplanningManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotProfile.SaveProfile
	 * 		Flags  -> ()
	 */
	void UReadyOrNotProfile::SaveProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotProfile.SaveProfile");
		
		UReadyOrNotProfile_SaveProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotProfile.SaveLevelStats
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBasicLevelStats                            InStats                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               NewBestRating                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               NewBestTime                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotProfile::SaveLevelStats(const struct FBasicLevelStats& InStats, bool* NewBestRating, bool* NewBestTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotProfile.SaveLevelStats");
		
		UReadyOrNotProfile_SaveLevelStats_Params params {};
		params.InStats = InStats;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (NewBestRating != nullptr)
			*NewBestRating = params.NewBestRating;
		if (NewBestTime != nullptr)
			*NewBestTime = params.NewBestTime;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotProfile.ResetProfile
	 * 		Flags  -> ()
	 */
	void UReadyOrNotProfile::ResetProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotProfile.ResetProfile");
		
		UReadyOrNotProfile_ResetProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotProfile.LoadLevelStats
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBasicLevelStats                            OutStats                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		ECOOPMode                                          Mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      MapName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotProfile::LoadLevelStats(struct FBasicLevelStats* OutStats, ECOOPMode Mode, const class FString& MapName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotProfile.LoadLevelStats");
		
		UReadyOrNotProfile_LoadLevelStats_Params params {};
		params.Mode = Mode;
		params.MapName = MapName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutStats != nullptr)
			*OutStats = params.OutStats;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotProfile.CreateDefaultSavegame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ProfileClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      LoadSlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UReadyOrNotProfile* UReadyOrNotProfile::CreateDefaultSavegame(class UClass* ProfileClass, const class FString& LoadSlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotProfile.CreateDefaultSavegame");
		
		UReadyOrNotProfile_CreateDefaultSavegame_Params params {};
		params.ProfileClass = ProfileClass;
		params.LoadSlotName = LoadSlotName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotMetaProfile.SaveProfile
	 * 		Flags  -> ()
	 */
	void UReadyOrNotMetaProfile::SaveProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotMetaProfile.SaveProfile");
		
		UReadyOrNotMetaProfile_SaveProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotMetaProfile.IsProfileNameAllowed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ProfileName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotMetaProfile::IsProfileNameAllowed(const class FString& ProfileName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotMetaProfile.IsProfileNameAllowed");
		
		UReadyOrNotMetaProfile_IsProfileNameAllowed_Params params {};
		params.ProfileName = ProfileName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotMetaProfile.DoesSingleplayerProfileExist
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ProfileName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotMetaProfile::DoesSingleplayerProfileExist(const class FString& ProfileName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotMetaProfile.DoesSingleplayerProfileExist");
		
		UReadyOrNotMetaProfile_DoesSingleplayerProfileExist_Params params {};
		params.ProfileName = ProfileName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotMetaProfile.DeleteSingleplayerProfile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Profile                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotMetaProfile::DeleteSingleplayerProfile(const class FString& Profile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotMetaProfile.DeleteSingleplayerProfile");
		
		UReadyOrNotMetaProfile_DeleteSingleplayerProfile_Params params {};
		params.Profile = Profile;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotMetaProfile.CreateDefaultSavegame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      LoadSlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UReadyOrNotMetaProfile* UReadyOrNotMetaProfile::CreateDefaultSavegame(const class FString& LoadSlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotMetaProfile.CreateDefaultSavegame");
		
		UReadyOrNotMetaProfile_CreateDefaultSavegame_Params params {};
		params.LoadSlotName = LoadSlotName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotMetaProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotMetaProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotMetaProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotMultiplayerProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotMultiplayerProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotMultiplayerProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotSingleplayerProfile.CreateNewSingleplayerProfile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SaveName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UReadyOrNotSingleplayerProfile* UReadyOrNotSingleplayerProfile::CreateNewSingleplayerProfile(const class FString& SaveName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotSingleplayerProfile.CreateNewSingleplayerProfile");
		
		UReadyOrNotSingleplayerProfile_CreateNewSingleplayerProfile_Params params {};
		params.SaveName = SaveName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotSingleplayerProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotSingleplayerProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotSingleplayerProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ProgressionComponent.AddExperience
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              XP                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UProgressionComponent::AddExperience(float XP)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ProgressionComponent.AddExperience");
		
		UProgressionComponent_AddExperience_Params params {};
		params.XP = XP;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProgressionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProgressionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ProgressionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProgressionData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProgressionData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ProgressionData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APropagationPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APropagationPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PropagationPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPushCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPushCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.PushCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Quadrotor.Server_SpawnDrone
	 * 		Flags  -> ()
	 */
	void AQuadrotor::Server_SpawnDrone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Quadrotor.Server_SpawnDrone");
		
		AQuadrotor_Server_SpawnDrone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AQuadrotor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AQuadrotor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Quadrotor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.QuadrotorPawn.Server_UpdateDroneTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                     NewTransform                                               (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AQuadrotorPawn::Server_UpdateDroneTransform(const struct FTransform& NewTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.QuadrotorPawn.Server_UpdateDroneTransform");
		
		AQuadrotorPawn_Server_UpdateDroneTransform_Params params {};
		params.NewTransform = NewTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.QuadrotorPawn.OnRep_DroneMovement
	 * 		Flags  -> ()
	 */
	void AQuadrotorPawn::OnRep_DroneMovement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.QuadrotorPawn.OnRep_DroneMovement");
		
		AQuadrotorPawn_OnRep_DroneMovement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AQuadrotorPawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AQuadrotorPawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.QuadrotorPawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.QuestManager.StartQuest
	 * 		Flags  -> ()
	 */
	void AQuestManager::StartQuest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.QuestManager.StartQuest");
		
		AQuestManager_StartQuest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.QuestManager.OnFinishedAllQuestNodes
	 * 		Flags  -> ()
	 */
	void AQuestManager::OnFinishedAllQuestNodes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.QuestManager.OnFinishedAllQuestNodes");
		
		AQuestManager_OnFinishedAllQuestNodes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.QuestManager.IterateQuestNodeList
	 * 		Flags  -> ()
	 */
	void AQuestManager::IterateQuestNodeList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.QuestManager.IterateQuestNodeList");
		
		AQuestManager_IterateQuestNodeList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AQuestManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AQuestManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.QuestManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialSectorWidget.SetSectorColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLinearColor                                NewColor                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UImage*                                      InSectorImage                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URadialSectorWidget::SetSectorColor(const struct FLinearColor& NewColor, class UImage* InSectorImage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialSectorWidget.SetSectorColor");
		
		URadialSectorWidget_SetSectorColor_Params params {};
		params.NewColor = NewColor;
		params.InSectorImage = InSectorImage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialSectorWidget.InitializeSectorWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Percentage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InSectorInnerRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InSectorOuterRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMaterialInterface*                          InSectorMaterial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                UnselectedColor                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UImage*                                      InSectorImage                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URadialSectorWidget::InitializeSectorWidget(float Angle, float Percentage, float InSectorInnerRadius, float InSectorOuterRadius, class UMaterialInterface* InSectorMaterial, const struct FLinearColor& UnselectedColor, class UImage* InSectorImage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialSectorWidget.InitializeSectorWidget");
		
		URadialSectorWidget_InitializeSectorWidget_Params params {};
		params.Angle = Angle;
		params.Percentage = Percentage;
		params.InSectorInnerRadius = InSectorInnerRadius;
		params.InSectorOuterRadius = InSectorOuterRadius;
		params.InSectorMaterial = InSectorMaterial;
		params.UnselectedColor = UnselectedColor;
		params.InSectorImage = InSectorImage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URadialSectorWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URadialSectorWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RadialSectorWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.WasForceClosed
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::WasForceClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.WasForceClosed");
		
		URadialWidgetBase_WasForceClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.UseMouseControl
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::UseMouseControl()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.UseMouseControl");
		
		URadialWidgetBase_UseMouseControl_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.UseGamepadControl
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::UseGamepadControl()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.UseGamepadControl");
		
		URadialWidgetBase_UseGamepadControl_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.UpdateSectorColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            SectorIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                SectorColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::UpdateSectorColor(int32_t SectorIndex, const struct FLinearColor& SectorColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.UpdateSectorColor");
		
		URadialWidgetBase_UpdateSectorColor_Params params {};
		params.SectorIndex = SectorIndex;
		params.SectorColor = SectorColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.UpdateMouseSelectionLogic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     RadialCursorWidget                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::UpdateMouseSelectionLogic(class UWidget* RadialCursorWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.UpdateMouseSelectionLogic");
		
		URadialWidgetBase_UpdateMouseSelectionLogic_Params params {};
		params.RadialCursorWidget = RadialCursorWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.UpdateGamepadSelectionLogic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     RadialCursorWidget                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::UpdateGamepadSelectionLogic(class UWidget* RadialCursorWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.UpdateGamepadSelectionLogic");
		
		URadialWidgetBase_UpdateGamepadSelectionLogic_Params params {};
		params.RadialCursorWidget = RadialCursorWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.ShowWheel
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::ShowWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.ShowWheel");
		
		URadialWidgetBase_ShowWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.ShowMouseCursor
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::ShowMouseCursor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.ShowMouseCursor");
		
		URadialWidgetBase_ShowMouseCursor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.Setup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRadialWidgetSpawnProperties                RadialWidgetSpawnProperties                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::Setup(const struct FRadialWidgetSpawnProperties& RadialWidgetSpawnProperties)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.Setup");
		
		URadialWidgetBase_Setup_Params params {};
		params.RadialWidgetSpawnProperties = RadialWidgetSpawnProperties;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.SetMouseWheelDelta
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InDelta                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::SetMouseWheelDelta(float InDelta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.SetMouseWheelDelta");
		
		URadialWidgetBase_SetMouseWheelDelta_Params params {};
		params.InDelta = InDelta;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.SetMousePositionToCenterScreen
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::SetMousePositionToCenterScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.SetMousePositionToCenterScreen");
		
		URadialWidgetBase_SetMousePositionToCenterScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.SetMousePosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector2D                      NewMousePosition                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::SetMousePosition(const struct FCoreUObject_FVector2D& NewMousePosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.SetMousePosition");
		
		URadialWidgetBase_SetMousePosition_Params params {};
		params.NewMousePosition = NewMousePosition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.SetGamepadYAxis
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InGamepadYAxis                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::SetGamepadYAxis(float InGamepadYAxis)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.SetGamepadYAxis");
		
		URadialWidgetBase_SetGamepadYAxis_Params params {};
		params.InGamepadYAxis = InGamepadYAxis;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.SetGamepadXYAxis
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InGamepadXAxis                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InGamepadYAxis                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::SetGamepadXYAxis(float InGamepadXAxis, float InGamepadYAxis)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.SetGamepadXYAxis");
		
		URadialWidgetBase_SetGamepadXYAxis_Params params {};
		params.InGamepadXAxis = InGamepadXAxis;
		params.InGamepadYAxis = InGamepadYAxis;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.SetGamepadXAxis
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InGamepadXAxis                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::SetGamepadXAxis(float InGamepadXAxis)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.SetGamepadXAxis");
		
		URadialWidgetBase_SetGamepadXAxis_Params params {};
		params.InGamepadXAxis = InGamepadXAxis;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.SetCloseDelay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewDelay                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::SetCloseDelay(float NewDelay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.SetCloseDelay");
		
		URadialWidgetBase_SetCloseDelay_Params params {};
		params.NewDelay = NewDelay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.Select
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URadialWidgetBase::Select(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.Select");
		
		URadialWidgetBase_Select_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.SaveMousePosition
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::SaveMousePosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.SaveMousePosition");
		
		URadialWidgetBase_SaveMousePosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.RestoreMousePosition
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::RestoreMousePosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.RestoreMousePosition");
		
		URadialWidgetBase_RestoreMousePosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.RefreshWheel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InStartingSectorIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URadialWidgetBase::RefreshWheel(int32_t InStartingSectorIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.RefreshWheel");
		
		URadialWidgetBase_RefreshWheel_Params params {};
		params.InStartingSectorIndex = InStartingSectorIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.Previous
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::Previous()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.Previous");
		
		URadialWidgetBase_Previous_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.OpenWheel_Internal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bForceRefresh                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::OpenWheel_Internal(bool bForceRefresh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.OpenWheel_Internal");
		
		URadialWidgetBase_OpenWheel_Internal_Params params {};
		params.bForceRefresh = bForceRefresh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.OpenWheel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bForceRefresh                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URadialWidgetBase::OpenWheel(bool bForceRefresh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.OpenWheel");
		
		URadialWidgetBase_OpenWheel_Params params {};
		params.bForceRefresh = bForceRefresh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.OnSectorSelected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            SelectedIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::OnSectorSelected(int32_t SelectedIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.OnSectorSelected");
		
		URadialWidgetBase_OnSectorSelected_Params params {};
		params.SelectedIndex = SelectedIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.OnSectorDeselected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            DeselectedIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::OnSectorDeselected(int32_t DeselectedIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.OnSectorDeselected");
		
		URadialWidgetBase_OnSectorDeselected_Params params {};
		params.DeselectedIndex = DeselectedIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.OnRadialSectorCreated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InAngle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URadialWidgetBase::OnRadialSectorCreated(int32_t Index, float InAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.OnRadialSectorCreated");
		
		URadialWidgetBase_OnRadialSectorCreated_Params params {};
		params.Index = Index;
		params.InAngle = InAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.RadialWidgetBase.OnRadialMenuOpened__DelegateSignature
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::OnRadialMenuOpened__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.RadialWidgetBase.OnRadialMenuOpened__DelegateSignature");
		
		URadialWidgetBase_OnRadialMenuOpened__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.OnRadialMenuOpened
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::OnRadialMenuOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.OnRadialMenuOpened");
		
		URadialWidgetBase_OnRadialMenuOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.OnRadialMenuInitialized
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::OnRadialMenuInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.OnRadialMenuInitialized");
		
		URadialWidgetBase_OnRadialMenuInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.OnRadialMenuCreated
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::OnRadialMenuCreated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.OnRadialMenuCreated");
		
		URadialWidgetBase_OnRadialMenuCreated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.RadialWidgetBase.OnRadialMenuClosed__DelegateSignature
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::OnRadialMenuClosed__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.RadialWidgetBase.OnRadialMenuClosed__DelegateSignature");
		
		URadialWidgetBase_OnRadialMenuClosed__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.OnRadialMenuClosed
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::OnRadialMenuClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.OnRadialMenuClosed");
		
		URadialWidgetBase_OnRadialMenuClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.Next
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::Next()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.Next");
		
		URadialWidgetBase_Next_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.IsWheelOpen
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::IsWheelOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.IsWheelOpen");
		
		URadialWidgetBase_IsWheelOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.IsWheelCursorVisible
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::IsWheelCursorVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.IsWheelCursorVisible");
		
		URadialWidgetBase_IsWheelCursorVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.IsWheelClosed
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::IsWheelClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.IsWheelClosed");
		
		URadialWidgetBase_IsWheelClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.IsMenuOpening
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::IsMenuOpening()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.IsMenuOpening");
		
		URadialWidgetBase_IsMenuOpening_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.IsMenuClosing
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::IsMenuClosing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.IsMenuClosing");
		
		URadialWidgetBase_IsMenuClosing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.InitializeMenuProperties
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::InitializeMenuProperties()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.InitializeMenuProperties");
		
		URadialWidgetBase_InitializeMenuProperties_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.InitializeMenu
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URadialWidgetBase::InitializeMenu(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.InitializeMenu");
		
		URadialWidgetBase_InitializeMenu_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.HideWheel
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::HideWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.HideWheel");
		
		URadialWidgetBase_HideWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.HideMouseCursor
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::HideMouseCursor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.HideMouseCursor");
		
		URadialWidgetBase_HideMouseCursor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.GetViewportPositionOfWidgetCenter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     InWidget                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D URadialWidgetBase::GetViewportPositionOfWidgetCenter(class UWidget* InWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.GetViewportPositionOfWidgetCenter");
		
		URadialWidgetBase_GetViewportPositionOfWidgetCenter_Params params {};
		params.InWidget = InWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.GetViewportPositionOfWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     InWidget                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      InCoordinates                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D URadialWidgetBase::GetViewportPositionOfWidget(class UWidget* InWidget, const struct FCoreUObject_FVector2D& InCoordinates)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.GetViewportPositionOfWidget");
		
		URadialWidgetBase_GetViewportPositionOfWidget_Params params {};
		params.InWidget = InWidget;
		params.InCoordinates = InCoordinates;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.GetPixelPositionOfWidgetCenter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     InWidget                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D URadialWidgetBase::GetPixelPositionOfWidgetCenter(class UWidget* InWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.GetPixelPositionOfWidgetCenter");
		
		URadialWidgetBase_GetPixelPositionOfWidgetCenter_Params params {};
		params.InWidget = InWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.GetPixelPositionOfWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     InWidget                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      InCoordinates                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D URadialWidgetBase::GetPixelPositionOfWidget(class UWidget* InWidget, const struct FCoreUObject_FVector2D& InCoordinates)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.GetPixelPositionOfWidget");
		
		URadialWidgetBase_GetPixelPositionOfWidget_Params params {};
		params.InWidget = InWidget;
		params.InCoordinates = InCoordinates;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.GetLastClosedReason
	 * 		Flags  -> ()
	 */
	ERadialMenuCloseReason URadialWidgetBase::GetLastClosedReason()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.GetLastClosedReason");
		
		URadialWidgetBase_GetLastClosedReason_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.GetDirectionToMouse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector2D                      MidWidgetCoordinates                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URadialWidgetBase::GetDirectionToMouse(const struct FCoreUObject_FVector2D& MidWidgetCoordinates)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.GetDirectionToMouse");
		
		URadialWidgetBase_GetDirectionToMouse_Params params {};
		params.MidWidgetCoordinates = MidWidgetCoordinates;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.GetDirectionToGamepadAxis
	 * 		Flags  -> ()
	 */
	float URadialWidgetBase::GetDirectionToGamepadAxis()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.GetDirectionToGamepadAxis");
		
		URadialWidgetBase_GetDirectionToGamepadAxis_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.GetCorrectSelectionColor
	 * 		Flags  -> ()
	 */
	struct FLinearColor URadialWidgetBase::GetCorrectSelectionColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.GetCorrectSelectionColor");
		
		URadialWidgetBase_GetCorrectSelectionColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.GetCorrectAngle
	 * 		Flags  -> ()
	 */
	float URadialWidgetBase::GetCorrectAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.GetCorrectAngle");
		
		URadialWidgetBase_GetCorrectAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.ExecuteRadial
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::ExecuteRadial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.ExecuteRadial");
		
		URadialWidgetBase_ExecuteRadial_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.DetermineSelectedSector
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InAngle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URadialWidgetBase::DetermineSelectedSector(float InAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.DetermineSelectedSector");
		
		URadialWidgetBase_DetermineSelectedSector_Params params {};
		params.InAngle = InAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.DetermineInputDevice
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::DetermineInputDevice()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.DetermineInputDevice");
		
		URadialWidgetBase_DetermineInputDevice_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.DeselectAll
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::DeselectAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.DeselectAll");
		
		URadialWidgetBase_DeselectAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.Deselect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URadialWidgetBase::Deselect(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.Deselect");
		
		URadialWidgetBase_Deselect_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.CreateWheelSector
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPanelWidget*                                PanelWidget                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InAngle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InSectorInnerRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InSectorOuterRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMaterialInterface*                          InSectorMaterial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCreateGap                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URadialWidgetBase::CreateWheelSector(class UPanelWidget* PanelWidget, float InAngle, float InSectorInnerRadius, float InSectorOuterRadius, class UMaterialInterface* InSectorMaterial, bool bCreateGap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.CreateWheelSector");
		
		URadialWidgetBase_CreateWheelSector_Params params {};
		params.PanelWidget = PanelWidget;
		params.InAngle = InAngle;
		params.InSectorInnerRadius = InSectorInnerRadius;
		params.InSectorOuterRadius = InSectorOuterRadius;
		params.InSectorMaterial = InSectorMaterial;
		params.bCreateGap = bCreateGap;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.CreateWheel
	 * 		Flags  -> ()
	 */
	bool URadialWidgetBase::CreateWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.CreateWheel");
		
		URadialWidgetBase_CreateWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.CloseWheel_Internal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bExecuteRadial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRemoveFromParent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHideMouseCursor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERadialMenuCloseReason                             CloseReason                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URadialWidgetBase::CloseWheel_Internal(bool bExecuteRadial, bool bRemoveFromParent, bool bHideMouseCursor, ERadialMenuCloseReason CloseReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.CloseWheel_Internal");
		
		URadialWidgetBase_CloseWheel_Internal_Params params {};
		params.bExecuteRadial = bExecuteRadial;
		params.bRemoveFromParent = bRemoveFromParent;
		params.bHideMouseCursor = bHideMouseCursor;
		params.CloseReason = CloseReason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.CloseWheel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bExecuteRadial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRemoveFromParent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHideMouseCursor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERadialMenuCloseReason                             CloseReason                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URadialWidgetBase::CloseWheel(bool bExecuteRadial, bool bRemoveFromParent, bool bHideMouseCursor, ERadialMenuCloseReason CloseReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.CloseWheel");
		
		URadialWidgetBase_CloseWheel_Params params {};
		params.bExecuteRadial = bExecuteRadial;
		params.bRemoveFromParent = bRemoveFromParent;
		params.bHideMouseCursor = bHideMouseCursor;
		params.CloseReason = CloseReason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.CalculatePositionOnCircleFromWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPanelWidget*                                PanelWidget                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      InPadding                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InAngle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D URadialWidgetBase::CalculatePositionOnCircleFromWidget(class UPanelWidget* PanelWidget, const struct FCoreUObject_FVector2D& Origin, const struct FCoreUObject_FVector2D& InPadding, float InAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.CalculatePositionOnCircleFromWidget");
		
		URadialWidgetBase_CalculatePositionOnCircleFromWidget_Params params {};
		params.PanelWidget = PanelWidget;
		params.Origin = Origin;
		params.InPadding = InPadding;
		params.InAngle = InAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.BeginOpenWheel
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::BeginOpenWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.BeginOpenWheel");
		
		URadialWidgetBase_BeginOpenWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RadialWidgetBase.BeginCloseWheel
	 * 		Flags  -> ()
	 */
	void URadialWidgetBase::BeginCloseWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RadialWidgetBase.BeginCloseWheel");
		
		URadialWidgetBase_BeginCloseWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URadialWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URadialWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RadialWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URadialWidgetThemeData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URadialWidgetThemeData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RadialWidgetThemeData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RandomizedShippingContainerActor.RandomizeContainer
	 * 		Flags  -> ()
	 */
	void ARandomizedShippingContainerActor::RandomizeContainer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RandomizedShippingContainerActor.RandomizeContainer");
		
		ARandomizedShippingContainerActor_RandomizeContainer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARandomizedShippingContainerActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARandomizedShippingContainerActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RandomizedShippingContainerActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotAIConfig.Get
	 * 		Flags  -> ()
	 */
	class UReadyOrNotAIConfig* UReadyOrNotAIConfig::Get()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotAIConfig.Get");
		
		UReadyOrNotAIConfig_Get_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotAIConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotAIConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotAIConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotAISense_Sight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotAISense_Sight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotAISense_Sight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotAISenseConfig_Sight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotAISenseConfig_Sight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotAISenseConfig_Sight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotAnimInstance.GetWeightFromSlotInversed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        SlotName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UReadyOrNotAnimInstance::GetWeightFromSlotInversed(const class FName& SlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotAnimInstance.GetWeightFromSlotInversed");
		
		UReadyOrNotAnimInstance_GetWeightFromSlotInversed_Params params {};
		params.SlotName = SlotName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotAnimInstance.GetWeightFromSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        SlotName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UReadyOrNotAnimInstance::GetWeightFromSlot(const class FName& SlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotAnimInstance.GetWeightFromSlot");
		
		UReadyOrNotAnimInstance_GetWeightFromSlot_Params params {};
		params.SlotName = SlotName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotAnimInstance.GetOppositeDirectionExt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMoveDirectionExt                                  CurrentDir                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EMoveDirectionExt UReadyOrNotAnimInstance::GetOppositeDirectionExt(EMoveDirectionExt CurrentDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotAnimInstance.GetOppositeDirectionExt");
		
		UReadyOrNotAnimInstance_GetOppositeDirectionExt_Params params {};
		params.CurrentDir = CurrentDir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotAnimInstance.GetLookAtRotation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FRotator UReadyOrNotAnimInstance::GetLookAtRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotAnimInstance.GetLookAtRotation");
		
		UReadyOrNotAnimInstance_GetLookAtRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotAnimInstance.GetCurrentDirectionExtFromYawAngle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              YawAngle                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EMoveDirectionExt UReadyOrNotAnimInstance::GetCurrentDirectionExtFromYawAngle(float YawAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotAnimInstance.GetCurrentDirectionExtFromYawAngle");
		
		UReadyOrNotAnimInstance_GetCurrentDirectionExtFromYawAngle_Params params {};
		params.YawAngle = YawAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotAudioVolume.IsAnotherVolumeActivatedAndPlayingEventInst
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFMODEventInstance                          EventInst                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotAudioVolume::IsAnotherVolumeActivatedAndPlayingEventInst(const struct FFMODEventInstance& EventInst)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotAudioVolume.IsAnotherVolumeActivatedAndPlayingEventInst");
		
		AReadyOrNotAudioVolume_IsAnotherVolumeActivatedAndPlayingEventInst_Params params {};
		params.EventInst = EventInst;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotAudioVolume.IsAnotherVolumeActivatedAndPlayingEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFMODEvent*                                  Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FFMODEventInstance                          EventInstance                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotAudioVolume::IsAnotherVolumeActivatedAndPlayingEvent(class UFMODEvent* Event, struct FFMODEventInstance* EventInstance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotAudioVolume.IsAnotherVolumeActivatedAndPlayingEvent");
		
		AReadyOrNotAudioVolume_IsAnotherVolumeActivatedAndPlayingEvent_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (EventInstance != nullptr)
			*EventInstance = params.EventInstance;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotAudioVolume.HasRanOnce
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotAudioVolume::HasRanOnce()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotAudioVolume.HasRanOnce");
		
		AReadyOrNotAudioVolume_HasRanOnce_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotAudioVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotAudioVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotAudioVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotAvoidanceManager.Test_RedMoveTagTwo
	 * 		Flags  -> ()
	 */
	void AReadyOrNotAvoidanceManager::Test_RedMoveTagTwo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotAvoidanceManager.Test_RedMoveTagTwo");
		
		AReadyOrNotAvoidanceManager_Test_RedMoveTagTwo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotAvoidanceManager.Test_RedMoveTagOne
	 * 		Flags  -> ()
	 */
	void AReadyOrNotAvoidanceManager::Test_RedMoveTagOne()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotAvoidanceManager.Test_RedMoveTagOne");
		
		AReadyOrNotAvoidanceManager_Test_RedMoveTagOne_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotAvoidanceManager.Test_BlueMoveTagTwo
	 * 		Flags  -> ()
	 */
	void AReadyOrNotAvoidanceManager::Test_BlueMoveTagTwo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotAvoidanceManager.Test_BlueMoveTagTwo");
		
		AReadyOrNotAvoidanceManager_Test_BlueMoveTagTwo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotAvoidanceManager.Test_BlueMoveTagOne
	 * 		Flags  -> ()
	 */
	void AReadyOrNotAvoidanceManager::Test_BlueMoveTagOne()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotAvoidanceManager.Test_BlueMoveTagOne");
		
		AReadyOrNotAvoidanceManager_Test_BlueMoveTagOne_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotAvoidanceManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotAvoidanceManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotAvoidanceManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotBackend.TickLoginDelay
	 * 		Flags  -> ()
	 */
	void UReadyOrNotBackend::TickLoginDelay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotBackend.TickLoginDelay");
		
		UReadyOrNotBackend_TickLoginDelay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotBackend.StartCapturingProfile
	 * 		Flags  -> ()
	 */
	void UReadyOrNotBackend::StartCapturingProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotBackend.StartCapturingProfile");
		
		UReadyOrNotBackend_StartCapturingProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotBackend.OnStatsUploadProgress__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filename                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Percentage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotBackend::OnStatsUploadProgress__DelegateSignature(const class FString& Filename, float Percentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotBackend.OnStatsUploadProgress__DelegateSignature");
		
		UReadyOrNotBackend_OnStatsUploadProgress__DelegateSignature_Params params {};
		params.Filename = Filename;
		params.Percentage = Percentage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotBackend.OnStatsStarted__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UReadyOrNotBackend::OnStatsStarted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotBackend.OnStatsStarted__DelegateSignature");
		
		UReadyOrNotBackend_OnStatsStarted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotBackend.OnStatsSaved__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bWasSuccessful                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      StatsName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotBackend::OnStatsSaved__DelegateSignature(bool bWasSuccessful, const class FString& StatsName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotBackend.OnStatsSaved__DelegateSignature");
		
		UReadyOrNotBackend_OnStatsSaved__DelegateSignature_Params params {};
		params.bWasSuccessful = bWasSuccessful;
		params.StatsName = StatsName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotBackend.OnPlayerGameFinishedMetric
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InMap                                                      (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InGameType                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InAverageFps                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotBackend::OnPlayerGameFinishedMetric(const class FString& InMap, const class FString& InGameType, float InAverageFps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotBackend.OnPlayerGameFinishedMetric");
		
		UReadyOrNotBackend_OnPlayerGameFinishedMetric_Params params {};
		params.InMap = InMap;
		params.InGameType = InGameType;
		params.InAverageFps = InAverageFps;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotBackend.OnGameStartedMetric
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InMap                                                      (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InGameType                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InNumPlayers                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotBackend::OnGameStartedMetric(const class FString& InMap, const class FString& InGameType, int32_t InNumPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotBackend.OnGameStartedMetric");
		
		UReadyOrNotBackend_OnGameStartedMetric_Params params {};
		params.InMap = InMap;
		params.InGameType = InGameType;
		params.InNumPlayers = InNumPlayers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotBackend.OnGameFinishedMetric
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InMap                                                      (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InGameType                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InGameResult                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotBackend::OnGameFinishedMetric(const class FString& InMap, const class FString& InGameType, const class FString& InGameResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotBackend.OnGameFinishedMetric");
		
		UReadyOrNotBackend_OnGameFinishedMetric_Params params {};
		params.InMap = InMap;
		params.InGameType = InGameType;
		params.InGameResult = InGameResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotBackend.OnGameCrashedMetric
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InState                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotBackend::OnGameCrashedMetric(const class FString& InState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotBackend.OnGameCrashedMetric");
		
		UReadyOrNotBackend_OnGameCrashedMetric_Params params {};
		params.InState = InState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotBackend.OnFinishedCapturingProfile
	 * 		Flags  -> ()
	 */
	void UReadyOrNotBackend::OnFinishedCapturingProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotBackend.OnFinishedCapturingProfile");
		
		UReadyOrNotBackend_OnFinishedCapturingProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotBackend.OnCheckedBanStatus__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      BannedSteamId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsBanned                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      BanReason                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsMySteamId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotBackend::OnCheckedBanStatus__DelegateSignature(const class FString& BannedSteamId, bool bIsBanned, const class FString& BanReason, bool bIsMySteamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotBackend.OnCheckedBanStatus__DelegateSignature");
		
		UReadyOrNotBackend_OnCheckedBanStatus__DelegateSignature_Params params {};
		params.BannedSteamId = BannedSteamId;
		params.bIsBanned = bIsBanned;
		params.BanReason = BanReason;
		params.bIsMySteamId = bIsMySteamId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotBackend.DoLogin
	 * 		Flags  -> ()
	 */
	void UReadyOrNotBackend::DoLogin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotBackend.DoLogin");
		
		UReadyOrNotBackend_DoLogin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotBackend.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotBackend::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotBackend");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotCharacterAnimData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotCharacterAnimData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotCharacterAnimData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotCharMovementComp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotCharMovementComp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotCharMovementComp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotCoverData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotCoverData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotCoverData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotCrowdManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotCrowdManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotCrowdManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.WeakenAllEnemiesToLowHealth
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::WeakenAllEnemiesToLowHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.WeakenAllEnemiesToLowHealth");
		
		UReadyOrNotDebugSubsystem_WeakenAllEnemiesToLowHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleVSync
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleVSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleVSync");
		
		UReadyOrNotDebugSubsystem_ToggleVSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleSWATDynamicCover
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleSWATDynamicCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleSWATDynamicCover");
		
		UReadyOrNotDebugSubsystem_ToggleSWATDynamicCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleSuspectDynamicCover
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleSuspectDynamicCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleSuspectDynamicCover");
		
		UReadyOrNotDebugSubsystem_ToggleSuspectDynamicCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleRuleOfThirdsOverlayGuide
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMaterialInterface*                          InMaterial                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::ToggleRuleOfThirdsOverlayGuide(class UMaterialInterface* InMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleRuleOfThirdsOverlayGuide");
		
		UReadyOrNotDebugSubsystem_ToggleRuleOfThirdsOverlayGuide_Params params {};
		params.InMaterial = InMaterial;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleRTXSettings
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleRTXSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleRTXSettings");
		
		UReadyOrNotDebugSubsystem_ToggleRTXSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleRifleLineOverlayGuide
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMaterialInterface*                          InMaterial                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::ToggleRifleLineOverlayGuide(class UMaterialInterface* InMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleRifleLineOverlayGuide");
		
		UReadyOrNotDebugSubsystem_ToggleRifleLineOverlayGuide_Params params {};
		params.InMaterial = InMaterial;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.TogglePistolLineOverlayGuide
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMaterialInterface*                          InMaterial                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::TogglePistolLineOverlayGuide(class UMaterialInterface* InMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.TogglePistolLineOverlayGuide");
		
		UReadyOrNotDebugSubsystem_TogglePistolLineOverlayGuide_Params params {};
		params.InMaterial = InMaterial;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.TogglePauseFMOD
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::TogglePauseFMOD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.TogglePauseFMOD");
		
		UReadyOrNotDebugSubsystem_TogglePauseFMOD_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleObjectiveMarkers
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleObjectiveMarkers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleObjectiveMarkers");
		
		UReadyOrNotDebugSubsystem_ToggleObjectiveMarkers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleMuteFMOD
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleMuteFMOD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleMuteFMOD");
		
		UReadyOrNotDebugSubsystem_ToggleMuteFMOD_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleMusic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bMusicOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::ToggleMusic(bool bMusicOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleMusic");
		
		UReadyOrNotDebugSubsystem_ToggleMusic_Params params {};
		params.bMusicOn = bMusicOn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleLogWeaponDamage
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleLogWeaponDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleLogWeaponDamage");
		
		UReadyOrNotDebugSubsystem_ToggleLogWeaponDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleLogPlayerAnimationStatus
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleLogPlayerAnimationStatus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleLogPlayerAnimationStatus");
		
		UReadyOrNotDebugSubsystem_ToggleLogPlayerAnimationStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleLineUpOverlayGuide
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMaterialInterface*                          InMaterial                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::ToggleLineUpOverlayGuide(class UMaterialInterface* InMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleLineUpOverlayGuide");
		
		UReadyOrNotDebugSubsystem_ToggleLineUpOverlayGuide_Params params {};
		params.InMaterial = InMaterial;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleLaserEyes
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleLaserEyes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleLaserEyes");
		
		UReadyOrNotDebugSubsystem_ToggleLaserEyes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleInteractableComponents
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleInteractableComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleInteractableComponents");
		
		UReadyOrNotDebugSubsystem_ToggleInteractableComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleInfiniteSWATItems
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleInfiniteSWATItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleInfiniteSWATItems");
		
		UReadyOrNotDebugSubsystem_ToggleInfiniteSWATItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleInfiniteHealth
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleInfiniteHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleInfiniteHealth");
		
		UReadyOrNotDebugSubsystem_ToggleInfiniteHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleInfiniteAmmo
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleInfiniteAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleInfiniteAmmo");
		
		UReadyOrNotDebugSubsystem_ToggleInfiniteAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleHesitationBar
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleHesitationBar()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleHesitationBar");
		
		UReadyOrNotDebugSubsystem_ToggleHesitationBar_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleGrenadeDrawDebug
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleGrenadeDrawDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleGrenadeDrawDebug");
		
		UReadyOrNotDebugSubsystem_ToggleGrenadeDrawDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleGlobalDamageMultiplier_Weapons
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleGlobalDamageMultiplier_Weapons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleGlobalDamageMultiplier_Weapons");
		
		UReadyOrNotDebugSubsystem_ToggleGlobalDamageMultiplier_Weapons_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleGlobalDamageMultiplier_Grenades
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleGlobalDamageMultiplier_Grenades()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleGlobalDamageMultiplier_Grenades");
		
		UReadyOrNotDebugSubsystem_ToggleGlobalDamageMultiplier_Grenades_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleFibonacciOverlayGuide
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMaterialInterface*                          InMaterial                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::ToggleFibonacciOverlayGuide(class UMaterialInterface* InMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleFibonacciOverlayGuide");
		
		UReadyOrNotDebugSubsystem_ToggleFibonacciOverlayGuide_Params params {};
		params.InMaterial = InMaterial;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleDrawSWATCoverLogic
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleDrawSWATCoverLogic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleDrawSWATCoverLogic");
		
		UReadyOrNotDebugSubsystem_ToggleDrawSWATCoverLogic_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleDrawSuspectCoverLogic
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleDrawSuspectCoverLogic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleDrawSuspectCoverLogic");
		
		UReadyOrNotDebugSubsystem_ToggleDrawSuspectCoverLogic_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleDrawMeleeRange
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleDrawMeleeRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleDrawMeleeRange");
		
		UReadyOrNotDebugSubsystem_ToggleDrawMeleeRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleDrawInteractableComponents
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleDrawInteractableComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleDrawInteractableComponents");
		
		UReadyOrNotDebugSubsystem_ToggleDrawInteractableComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleDrawDoorKillStunDistances
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleDrawDoorKillStunDistances()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleDrawDoorKillStunDistances");
		
		UReadyOrNotDebugSubsystem_ToggleDrawDoorKillStunDistances_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleDrawDebugTraces
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleDrawDebugTraces()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleDrawDebugTraces");
		
		UReadyOrNotDebugSubsystem_ToggleDrawDebugTraces_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleCoverPoints
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleCoverPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleCoverPoints");
		
		UReadyOrNotDebugSubsystem_ToggleCoverPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleCoverOctree
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleCoverOctree()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleCoverOctree");
		
		UReadyOrNotDebugSubsystem_ToggleCoverOctree_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleAllEvidenceActorMarkers
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::ToggleAllEvidenceActorMarkers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.ToggleAllEvidenceActorMarkers");
		
		UReadyOrNotDebugSubsystem_ToggleAllEvidenceActorMarkers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.SetMeleeRange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewMeleeRange                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::SetMeleeRange(class APlayerCharacter* PlayerCharacter, float NewMeleeRange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.SetMeleeRange");
		
		UReadyOrNotDebugSubsystem_SetMeleeRange_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		params.NewMeleeRange = NewMeleeRange;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.SetMeleeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewMeleeDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::SetMeleeDamage(class APlayerCharacter* PlayerCharacter, float NewMeleeDamage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.SetMeleeDamage");
		
		UReadyOrNotDebugSubsystem_SetMeleeDamage_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		params.NewMeleeDamage = NewMeleeDamage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.SetGlobalDamageMultiplier_Weapons
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewDamageMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::SetGlobalDamageMultiplier_Weapons(float NewDamageMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.SetGlobalDamageMultiplier_Weapons");
		
		UReadyOrNotDebugSubsystem_SetGlobalDamageMultiplier_Weapons_Params params {};
		params.NewDamageMultiplier = NewDamageMultiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.SetGlobalDamageMultiplier_Grenades
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewDamageMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::SetGlobalDamageMultiplier_Grenades(float NewDamageMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.SetGlobalDamageMultiplier_Grenades");
		
		UReadyOrNotDebugSubsystem_SetGlobalDamageMultiplier_Grenades_Params params {};
		params.NewDamageMultiplier = NewDamageMultiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.RTX_ToggleTranslucency
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::RTX_ToggleTranslucency()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.RTX_ToggleTranslucency");
		
		UReadyOrNotDebugSubsystem_RTX_ToggleTranslucency_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.RTX_ToggleShadows
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::RTX_ToggleShadows()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.RTX_ToggleShadows");
		
		UReadyOrNotDebugSubsystem_RTX_ToggleShadows_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.RTX_ToggleReflections
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::RTX_ToggleReflections()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.RTX_ToggleReflections");
		
		UReadyOrNotDebugSubsystem_RTX_ToggleReflections_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.RTX_ToggleGlobalIllumination
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::RTX_ToggleGlobalIllumination()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.RTX_ToggleGlobalIllumination");
		
		UReadyOrNotDebugSubsystem_RTX_ToggleGlobalIllumination_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.RTX_ToggleAmbientOcclusion
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::RTX_ToggleAmbientOcclusion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.RTX_ToggleAmbientOcclusion");
		
		UReadyOrNotDebugSubsystem_RTX_ToggleAmbientOcclusion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.OpenAllDoors
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::OpenAllDoors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.OpenAllDoors");
		
		UReadyOrNotDebugSubsystem_OpenAllDoors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.IncreaseGlobalDamageMultiplier_Weapons
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::IncreaseGlobalDamageMultiplier_Weapons(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.IncreaseGlobalDamageMultiplier_Weapons");
		
		UReadyOrNotDebugSubsystem_IncreaseGlobalDamageMultiplier_Weapons_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.IncreaseGlobalDamageMultiplier_Grenades
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::IncreaseGlobalDamageMultiplier_Grenades(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.IncreaseGlobalDamageMultiplier_Grenades");
		
		UReadyOrNotDebugSubsystem_IncreaseGlobalDamageMultiplier_Grenades_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.DecreaseGlobalDamageMultiplier_Weapons
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::DecreaseGlobalDamageMultiplier_Weapons(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.DecreaseGlobalDamageMultiplier_Weapons");
		
		UReadyOrNotDebugSubsystem_DecreaseGlobalDamageMultiplier_Weapons_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.DecreaseGlobalDamageMultiplier_Grenades
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::DecreaseGlobalDamageMultiplier_Grenades(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.DecreaseGlobalDamageMultiplier_Grenades");
		
		UReadyOrNotDebugSubsystem_DecreaseGlobalDamageMultiplier_Grenades_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.CloseAllDoors
	 * 		Flags  -> ()
	 */
	void UReadyOrNotDebugSubsystem::CloseAllDoors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.CloseAllDoors");
		
		UReadyOrNotDebugSubsystem_CloseAllDoors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotDebugSubsystem.AddOrUpdatePostProcessMaterial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMaterialInterface*                          InMaterial                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMaterialOn                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotDebugSubsystem::AddOrUpdatePostProcessMaterial(class UMaterialInterface* InMaterial, bool* bMaterialOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotDebugSubsystem.AddOrUpdatePostProcessMaterial");
		
		UReadyOrNotDebugSubsystem_AddOrUpdatePostProcessMaterial_Params params {};
		params.InMaterial = InMaterial;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bMaterialOn != nullptr)
			*bMaterialOn = params.bMaterialOn;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotDebugSubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotDebugSubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotDebugSubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFaceAnimInstance.GetFaceROM
	 * 		Flags  -> ()
	 */
	class UPoseAsset* UReadyOrNotFaceAnimInstance::GetFaceROM()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFaceAnimInstance.GetFaceROM");
		
		UReadyOrNotFaceAnimInstance_GetFaceROM_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotFaceAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotFaceAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotFaceAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.SwatCommandToString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESwatCommand                                       SwatCommand                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UReadyOrNotFunctionLibrary::SwatCommandToString(ESwatCommand SwatCommand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.SwatCommandToString");
		
		UReadyOrNotFunctionLibrary_SwatCommandToString_Params params {};
		params.SwatCommand = SwatCommand;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.StopPostProcessEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPostProcessSettings                        PostProcessSettings                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		struct FPostProcessEffect                          InPostProcessEffect                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::StopPostProcessEffect(struct FPostProcessSettings* PostProcessSettings, struct FPostProcessEffect* InPostProcessEffect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.StopPostProcessEffect");
		
		UReadyOrNotFunctionLibrary_StopPostProcessEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PostProcessSettings != nullptr)
			*PostProcessSettings = params.PostProcessSettings;
		if (InPostProcessEffect != nullptr)
			*InPostProcessEffect = params.InPostProcessEffect;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.StartPostProcessEffect_Specific
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPostProcessSettings                        PostProcessSettings                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		struct FPostProcessEffectPlayer                    InPostProcessEffectPlayer                                  (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::StartPostProcessEffect_Specific(class UObject* Context, struct FPostProcessSettings* PostProcessSettings, struct FPostProcessEffectPlayer* InPostProcessEffectPlayer, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.StartPostProcessEffect_Specific");
		
		UReadyOrNotFunctionLibrary_StartPostProcessEffect_Specific_Params params {};
		params.Context = Context;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PostProcessSettings != nullptr)
			*PostProcessSettings = params.PostProcessSettings;
		if (InPostProcessEffectPlayer != nullptr)
			*InPostProcessEffectPlayer = params.InPostProcessEffectPlayer;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.StartPostProcessEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPostProcessSettings                        PostProcessSettings                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		struct FPostProcessEffect                          InPostProcessEffect                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::StartPostProcessEffect(class UObject* Context, struct FPostProcessSettings* PostProcessSettings, struct FPostProcessEffect* InPostProcessEffect, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.StartPostProcessEffect");
		
		UReadyOrNotFunctionLibrary_StartPostProcessEffect_Params params {};
		params.Context = Context;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PostProcessSettings != nullptr)
			*PostProcessSettings = params.PostProcessSettings;
		if (InPostProcessEffect != nullptr)
			*InPostProcessEffect = params.InPostProcessEffect;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.SimulateAnimatedText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      FinalString                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Iterator                                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FString>                              Chars                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              ElapsedTime                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CurrentDelay                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DelayBetweenLetters                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DelayBetweenWords                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCompleted                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UReadyOrNotFunctionLibrary::SimulateAnimatedText(class FString* FinalString, int32_t* Iterator, TArray<class FString>* Chars, float* ElapsedTime, float* CurrentDelay, float DelayBetweenLetters, float DelayBetweenWords, float DeltaTime, bool* bCompleted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.SimulateAnimatedText");
		
		UReadyOrNotFunctionLibrary_SimulateAnimatedText_Params params {};
		params.DelayBetweenLetters = DelayBetweenLetters;
		params.DelayBetweenWords = DelayBetweenWords;
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (FinalString != nullptr)
			*FinalString = params.FinalString;
		if (Iterator != nullptr)
			*Iterator = params.Iterator;
		if (Chars != nullptr)
			*Chars = params.Chars;
		if (ElapsedTime != nullptr)
			*ElapsedTime = params.ElapsedTime;
		if (CurrentDelay != nullptr)
			*CurrentDelay = params.CurrentDelay;
		if (bCompleted != nullptr)
			*bCompleted = params.bCompleted;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.SetupPostProcessEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPostProcessEffect                          InPostProcessEffect                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::SetupPostProcessEffect(class UObject* Context, struct FPostProcessEffect* InPostProcessEffect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.SetupPostProcessEffect");
		
		UReadyOrNotFunctionLibrary_SetupPostProcessEffect_Params params {};
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InPostProcessEffect != nullptr)
			*InPostProcessEffect = params.InPostProcessEffect;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.SetSafeZonePadding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USafeZoneSlot*                               SafeZoneSlot                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMargin                                     Padding                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::SetSafeZonePadding(class USafeZoneSlot* SafeZoneSlot, const struct FMargin& Padding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.SetSafeZonePadding");
		
		UReadyOrNotFunctionLibrary_SetSafeZonePadding_Params params {};
		params.SafeZoneSlot = SafeZoneSlot;
		params.Padding = Padding;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.SetPlanarReflectionScreenPercentage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPlanarReflectionComponent*                  InPlanarReflectionComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewScreenPercentage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::SetPlanarReflectionScreenPercentage(class UPlanarReflectionComponent* InPlanarReflectionComponent, float NewScreenPercentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.SetPlanarReflectionScreenPercentage");
		
		UReadyOrNotFunctionLibrary_SetPlanarReflectionScreenPercentage_Params params {};
		params.InPlanarReflectionComponent = InPlanarReflectionComponent;
		params.NewScreenPercentage = NewScreenPercentage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.SetFMODVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::SetFMODVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.SetFMODVolume");
		
		UReadyOrNotFunctionLibrary_SetFMODVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.SetDecalSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UDecalComponent*                             InDecalComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        DecalSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::SetDecalSize(class UDecalComponent* InDecalComponent, const struct FCoreUObject_FVector& DecalSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.SetDecalSize");
		
		UReadyOrNotFunctionLibrary_SetDecalSize_Params params {};
		params.InDecalComponent = InDecalComponent;
		params.DecalSize = DecalSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.ServerTravel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::ServerTravel(const class FString& URL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.ServerTravel");
		
		UReadyOrNotFunctionLibrary_ServerTravel_Params params {};
		params.URL = URL;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.RestartGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::RestartGame(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.RestartGame");
		
		UReadyOrNotFunctionLibrary_RestartGame_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.ReportBadAIAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABadAIAction*                                InBadAIActionActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        InSummary                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        InDescription                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bReportToLog                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDrawDebugString                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::ReportBadAIAction(class ABadAIAction* InBadAIActionActor, const class FText& InSummary, const class FText& InDescription, bool bReportToLog, bool bDrawDebugString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.ReportBadAIAction");
		
		UReadyOrNotFunctionLibrary_ReportBadAIAction_Params params {};
		params.InBadAIActionActor = InBadAIActionActor;
		params.InSummary = InSummary;
		params.InDescription = InDescription;
		params.bReportToLog = bReportToLog;
		params.bDrawDebugString = bDrawDebugString;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.RemoveFromParentAndClear
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UWidget*>                             InWidgets                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::RemoveFromParentAndClear(TArray<class UWidget*>* InWidgets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.RemoveFromParentAndClear");
		
		UReadyOrNotFunctionLibrary_RemoveFromParentAndClear_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InWidgets != nullptr)
			*InWidgets = params.InWidgets;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.RemoveBadAIActionReport
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABadAIAction*                                InBadAIActionActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReportToLog                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDrawDebugString                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::RemoveBadAIActionReport(class ABadAIAction* InBadAIActionActor, bool bReportToLog, bool bDrawDebugString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.RemoveBadAIActionReport");
		
		UReadyOrNotFunctionLibrary_RemoveBadAIActionReport_Params params {};
		params.InBadAIActionActor = InBadAIActionActor;
		params.bReportToLog = bReportToLog;
		params.bDrawDebugString = bDrawDebugString;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.RemoveAllNullElements_BP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UClass*>                              Array                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::RemoveAllNullElements_BP(TArray<class UClass*> Array)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.RemoveAllNullElements_BP");
		
		UReadyOrNotFunctionLibrary_RemoveAllNullElements_BP_Params params {};
		params.Array = Array;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.ProcessPostProcessEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPostProcessSettings                        PostProcessSettings                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		struct FPostProcessEffect                          InPostProcessEffect                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::ProcessPostProcessEffect(class UObject* Context, struct FPostProcessSettings* PostProcessSettings, struct FPostProcessEffect* InPostProcessEffect, float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.ProcessPostProcessEffect");
		
		UReadyOrNotFunctionLibrary_ProcessPostProcessEffect_Params params {};
		params.Context = Context;
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PostProcessSettings != nullptr)
			*PostProcessSettings = params.PostProcessSettings;
		if (InPostProcessEffect != nullptr)
			*InPostProcessEffect = params.InPostProcessEffect;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.PlayRandomFMODEventAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UFMODEvent*>                          FMODEvents                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::PlayRandomFMODEventAtLocation(class UObject* WorldContextObject, const struct FCoreUObject_FVector& Location, TArray<class UFMODEvent*>* FMODEvents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.PlayRandomFMODEventAtLocation");
		
		UReadyOrNotFunctionLibrary_PlayRandomFMODEventAtLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (FMODEvents != nullptr)
			*FMODEvents = params.FMODEvents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.PlayRandomFMODEvent_2D
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UFMODEvent*>                          FMODEvents                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::PlayRandomFMODEvent_2D(class UObject* WorldContextObject, TArray<class UFMODEvent*>* FMODEvents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.PlayRandomFMODEvent_2D");
		
		UReadyOrNotFunctionLibrary_PlayRandomFMODEvent_2D_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (FMODEvents != nullptr)
			*FMODEvents = params.FMODEvents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.PauseFMOD
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bPaused                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::PauseFMOD(bool bPaused)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.PauseFMOD");
		
		UReadyOrNotFunctionLibrary_PauseFMOD_Params params {};
		params.bPaused = bPaused;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.MuteFMOD
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bMuted                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotFunctionLibrary::MuteFMOD(bool bMuted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.MuteFMOD");
		
		UReadyOrNotFunctionLibrary_MuteFMOD_Params params {};
		params.bMuted = bMuted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsTableMontagePlaying
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      AnimationName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsCrouching                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::IsTableMontagePlaying(class APlayerCharacter* PlayerCharacter, const class FString& AnimationName, bool bIsCrouching)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsTableMontagePlaying");
		
		UReadyOrNotFunctionLibrary_IsTableMontagePlaying_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		params.AnimationName = AnimationName;
		params.bIsCrouching = bIsCrouching;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsItemInInventory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EItemCategory                                      ItemCategory                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::IsItemInInventory(class AReadyOrNotCharacter* PlayerCharacter, EItemCategory ItemCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsItemInInventory");
		
		UReadyOrNotFunctionLibrary_IsItemInInventory_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		params.ItemCategory = ItemCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsItemEquipped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EItemCategory                                      ItemCategory                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::IsItemEquipped(class AReadyOrNotCharacter* PlayerCharacter, EItemCategory ItemCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsItemEquipped");
		
		UReadyOrNotFunctionLibrary_IsItemEquipped_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		params.ItemCategory = ItemCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsInLobby
	 * 		Flags  -> ()
	 */
	bool UReadyOrNotFunctionLibrary::IsInLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsInLobby");
		
		UReadyOrNotFunctionLibrary_IsInLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsHalloween
	 * 		Flags  -> ()
	 */
	bool UReadyOrNotFunctionLibrary::IsHalloween()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsHalloween");
		
		UReadyOrNotFunctionLibrary_IsHalloween_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsFSREnabled
	 * 		Flags  -> ()
	 */
	bool UReadyOrNotFunctionLibrary::IsFSREnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsFSREnabled");
		
		UReadyOrNotFunctionLibrary_IsFSREnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsFMODBusPaused
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFMODBus*                                    Bus                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::IsFMODBusPaused(class UFMODBus* Bus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsFMODBusPaused");
		
		UReadyOrNotFunctionLibrary_IsFMODBusPaused_Params params {};
		params.Bus = Bus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsFMODBusMuted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFMODBus*                                    Bus                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::IsFMODBusMuted(class UFMODBus* Bus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsFMODBusMuted");
		
		UReadyOrNotFunctionLibrary_IsFMODBusMuted_Params params {};
		params.Bus = Bus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsDLSSEnabled
	 * 		Flags  -> ()
	 */
	bool UReadyOrNotFunctionLibrary::IsDLSSEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsDLSSEnabled");
		
		UReadyOrNotFunctionLibrary_IsDLSSEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsBuildPirated
	 * 		Flags  -> ()
	 */
	bool UReadyOrNotFunctionLibrary::IsBuildPirated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsBuildPirated");
		
		UReadyOrNotFunctionLibrary_IsBuildPirated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsAprilFools
	 * 		Flags  -> ()
	 */
	bool UReadyOrNotFunctionLibrary::IsAprilFools()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsAprilFools");
		
		UReadyOrNotFunctionLibrary_IsAprilFools_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsActorOutsideSplineEnclosure
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASplineTrigger*                              InSplineTrigger                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::IsActorOutsideSplineEnclosure(class ASplineTrigger* InSplineTrigger, class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsActorOutsideSplineEnclosure");
		
		UReadyOrNotFunctionLibrary_IsActorOutsideSplineEnclosure_Params params {};
		params.InSplineTrigger = InSplineTrigger;
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsActorInsideSplineEnclosure
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASplineTrigger*                              InSplineTrigger                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::IsActorInsideSplineEnclosure(class ASplineTrigger* InSplineTrigger, class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.IsActorInsideSplineEnclosure");
		
		UReadyOrNotFunctionLibrary_IsActorInsideSplineEnclosure_Params params {};
		params.InSplineTrigger = InSplineTrigger;
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetWidgetSize_Local
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     InWidget                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D UReadyOrNotFunctionLibrary::GetWidgetSize_Local(class UWidget* InWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetWidgetSize_Local");
		
		UReadyOrNotFunctionLibrary_GetWidgetSize_Local_Params params {};
		params.InWidget = InWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetWidgetSize_Absolute
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     InWidget                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D UReadyOrNotFunctionLibrary::GetWidgetSize_Absolute(class UWidget* InWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetWidgetSize_Absolute");
		
		UReadyOrNotFunctionLibrary_GetWidgetSize_Absolute_Params params {};
		params.InWidget = InWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetWeaponFOVOffset
	 * 		Flags  -> ()
	 */
	float UReadyOrNotFunctionLibrary::GetWeaponFOVOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetWeaponFOVOffset");
		
		UReadyOrNotFunctionLibrary_GetWeaponFOVOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetViewportPositionOfWidgetCenter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     InParentWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     InWidget                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D UReadyOrNotFunctionLibrary::GetViewportPositionOfWidgetCenter(class UObject* WorldContext, class UWidget* InParentWidget, class UWidget* InWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetViewportPositionOfWidgetCenter");
		
		UReadyOrNotFunctionLibrary_GetViewportPositionOfWidgetCenter_Params params {};
		params.WorldContext = WorldContext;
		params.InParentWidget = InParentWidget;
		params.InWidget = InWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetViewportPositionOfWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     InParentWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     InWidget                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      InCoordinates                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D UReadyOrNotFunctionLibrary::GetViewportPositionOfWidget(class UObject* WorldContext, class UWidget* InParentWidget, class UWidget* InWidget, const struct FCoreUObject_FVector2D& InCoordinates)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetViewportPositionOfWidget");
		
		UReadyOrNotFunctionLibrary_GetViewportPositionOfWidget_Params params {};
		params.WorldContext = WorldContext;
		params.InParentWidget = InParentWidget;
		params.InWidget = InWidget;
		params.InCoordinates = InCoordinates;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetVectorFromINIFile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigFilePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Section                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector UReadyOrNotFunctionLibrary::GetVectorFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetVectorFromINIFile");
		
		UReadyOrNotFunctionLibrary_GetVectorFromINIFile_Params params {};
		params.ConfigFilePath = ConfigFilePath;
		params.Section = Section;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetVector2DFromINIFile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigFilePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Section                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D UReadyOrNotFunctionLibrary::GetVector2DFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetVector2DFromINIFile");
		
		UReadyOrNotFunctionLibrary_GetVector2DFromINIFile_Params params {};
		params.ConfigFilePath = ConfigFilePath;
		params.Section = Section;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetUseGearListInsteadOfRadial
	 * 		Flags  -> ()
	 */
	bool UReadyOrNotFunctionLibrary::GetUseGearListInsteadOfRadial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetUseGearListInsteadOfRadial");
		
		UReadyOrNotFunctionLibrary_GetUseGearListInsteadOfRadial_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetSWATManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASWATManager* UReadyOrNotFunctionLibrary::GetSWATManager(class UObject* WorldContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetSWATManager");
		
		UReadyOrNotFunctionLibrary_GetSWATManager_Params params {};
		params.WorldContext = WorldContext;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetStringFromINIFile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigFilePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Section                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UReadyOrNotFunctionLibrary::GetStringFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetStringFromINIFile");
		
		UReadyOrNotFunctionLibrary_GetStringFromINIFile_Params params {};
		params.ConfigFilePath = ConfigFilePath;
		params.Section = Section;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetStringArrayFromINIFile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigFilePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Section                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class FString> UReadyOrNotFunctionLibrary::GetStringArrayFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetStringArrayFromINIFile");
		
		UReadyOrNotFunctionLibrary_GetStringArrayFromINIFile_Params params {};
		params.ConfigFilePath = ConfigFilePath;
		params.Section = Section;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetSingleLineArrayFromINIFile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigFilePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Section                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class FString> UReadyOrNotFunctionLibrary::GetSingleLineArrayFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetSingleLineArrayFromINIFile");
		
		UReadyOrNotFunctionLibrary_GetSingleLineArrayFromINIFile_Params params {};
		params.ConfigFilePath = ConfigFilePath;
		params.Section = Section;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetServerNameFromCurrentSession
	 * 		Flags  -> ()
	 */
	class FString UReadyOrNotFunctionLibrary::GetServerNameFromCurrentSession()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetServerNameFromCurrentSession");
		
		UReadyOrNotFunctionLibrary_GetServerNameFromCurrentSession_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetReadyOrNotLevelScript
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AReadyOrNotLevelScript* UReadyOrNotFunctionLibrary::GetReadyOrNotLevelScript(class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetReadyOrNotLevelScript");
		
		UReadyOrNotFunctionLibrary_GetReadyOrNotLevelScript_Params params {};
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetReadyOrNotGameUserSettings
	 * 		Flags  -> ()
	 */
	class UReadyOrNotGameUserSettings* UReadyOrNotFunctionLibrary::GetReadyOrNotGameUserSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetReadyOrNotGameUserSettings");
		
		UReadyOrNotFunctionLibrary_GetReadyOrNotGameUserSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetPlayerHUD
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UHumanCharacterHUD_V2* UReadyOrNotFunctionLibrary::GetPlayerHUD(class UObject* WorldContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetPlayerHUD");
		
		UReadyOrNotFunctionLibrary_GetPlayerHUD_Params params {};
		params.WorldContext = WorldContext;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetPlayerCharacterMutableDefaultObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APlayerCharacter* UReadyOrNotFunctionLibrary::GetPlayerCharacterMutableDefaultObject(class UClass* Class)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetPlayerCharacterMutableDefaultObject");
		
		UReadyOrNotFunctionLibrary_GetPlayerCharacterMutableDefaultObject_Params params {};
		params.Class = Class;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetPixelPositionOfWidgetCenter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     InParentWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     InWidget                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D UReadyOrNotFunctionLibrary::GetPixelPositionOfWidgetCenter(class UObject* WorldContext, class UWidget* InParentWidget, class UWidget* InWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetPixelPositionOfWidgetCenter");
		
		UReadyOrNotFunctionLibrary_GetPixelPositionOfWidgetCenter_Params params {};
		params.WorldContext = WorldContext;
		params.InParentWidget = InParentWidget;
		params.InWidget = InWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetPixelPositionOfWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     InParentWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     InWidget                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector2D                      InCoordinates                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D UReadyOrNotFunctionLibrary::GetPixelPositionOfWidget(class UObject* WorldContext, class UWidget* InParentWidget, class UWidget* InWidget, const struct FCoreUObject_FVector2D& InCoordinates)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetPixelPositionOfWidget");
		
		UReadyOrNotFunctionLibrary_GetPixelPositionOfWidget_Params params {};
		params.WorldContext = WorldContext;
		params.InParentWidget = InParentWidget;
		params.InWidget = InWidget;
		params.InCoordinates = InCoordinates;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetKeyFromInputAxisName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        AxisName                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyGamepadKey                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FKey UReadyOrNotFunctionLibrary::GetKeyFromInputAxisName(const class FName& AxisName, bool bOnlyGamepadKey, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetKeyFromInputAxisName");
		
		UReadyOrNotFunctionLibrary_GetKeyFromInputAxisName_Params params {};
		params.AxisName = AxisName;
		params.bOnlyGamepadKey = bOnlyGamepadKey;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetKeyFromInputActionName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ActionName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyGamepadKey                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FKey UReadyOrNotFunctionLibrary::GetKeyFromInputActionName(const class FName& ActionName, bool bOnlyGamepadKey, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetKeyFromInputActionName");
		
		UReadyOrNotFunctionLibrary_GetKeyFromInputActionName_Params params {};
		params.ActionName = ActionName;
		params.bOnlyGamepadKey = bOnlyGamepadKey;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetInterfaceFovOffset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InFov                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UReadyOrNotFunctionLibrary::GetInterfaceFovOffset(float InFov)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetInterfaceFovOffset");
		
		UReadyOrNotFunctionLibrary_GetInterfaceFovOffset_Params params {};
		params.InFov = InFov;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetIntegerFromINIFile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigFilePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Section                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UReadyOrNotFunctionLibrary::GetIntegerFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetIntegerFromINIFile");
		
		UReadyOrNotFunctionLibrary_GetIntegerFromINIFile_Params params {};
		params.ConfigFilePath = ConfigFilePath;
		params.Section = Section;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetFMODBusVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UFMODBus*                                    Bus                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UReadyOrNotFunctionLibrary::GetFMODBusVolume(class UFMODBus* Bus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetFMODBusVolume");
		
		UReadyOrNotFunctionLibrary_GetFMODBusVolume_Params params {};
		params.Bus = Bus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetFloatFromINIFile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigFilePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Section                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UReadyOrNotFunctionLibrary::GetFloatFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetFloatFromINIFile");
		
		UReadyOrNotFunctionLibrary_GetFloatFromINIFile_Params params {};
		params.ConfigFilePath = ConfigFilePath;
		params.Section = Section;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetDLCNumber
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDLC                                               InDLC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UReadyOrNotFunctionLibrary::GetDLCNumber(EDLC InDLC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetDLCNumber");
		
		UReadyOrNotFunctionLibrary_GetDLCNumber_Params params {};
		params.InDLC = InDLC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetDLCENum
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            InDLC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EDLC UReadyOrNotFunctionLibrary::GetDLCENum(int32_t InDLC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetDLCENum");
		
		UReadyOrNotFunctionLibrary_GetDLCENum_Params params {};
		params.InDLC = InDLC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetCurrentLevelNameForLookupTable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FName UReadyOrNotFunctionLibrary::GetCurrentLevelNameForLookupTable(class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetCurrentLevelNameForLookupTable");
		
		UReadyOrNotFunctionLibrary_GetCurrentLevelNameForLookupTable_Params params {};
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetCOOPMode
	 * 		Flags  -> ()
	 */
	ECOOPMode UReadyOrNotFunctionLibrary::GetCOOPMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetCOOPMode");
		
		UReadyOrNotFunctionLibrary_GetCOOPMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetClassFromObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UReadyOrNotFunctionLibrary::GetClassFromObject(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetClassFromObject");
		
		UReadyOrNotFunctionLibrary_GetClassFromObject_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetClassDefaultObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UObject* UReadyOrNotFunctionLibrary::GetClassDefaultObject(class UClass* Class)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetClassDefaultObject");
		
		UReadyOrNotFunctionLibrary_GetClassDefaultObject_Params params {};
		params.Class = Class;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetBuildConfiguration
	 * 		Flags  -> ()
	 */
	ERONBuildConfiguration UReadyOrNotFunctionLibrary::GetBuildConfiguration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetBuildConfiguration");
		
		UReadyOrNotFunctionLibrary_GetBuildConfiguration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetBoolFromINIFile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigFilePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Section                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::GetBoolFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetBoolFromINIFile");
		
		UReadyOrNotFunctionLibrary_GetBoolFromINIFile_Params params {};
		params.ConfigFilePath = ConfigFilePath;
		params.Section = Section;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAspectRatio
	 * 		Flags  -> ()
	 */
	float UReadyOrNotFunctionLibrary::GetAspectRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAspectRatio");
		
		UReadyOrNotFunctionLibrary_GetAspectRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAnimationFromTable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      AnimationName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsCrouching                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimMontage* UReadyOrNotFunctionLibrary::GetAnimationFromTable(const class FString& AnimationName, bool bIsCrouching)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAnimationFromTable");
		
		UReadyOrNotFunctionLibrary_GetAnimationFromTable_Params params {};
		params.AnimationName = AnimationName;
		params.bIsCrouching = bIsCrouching;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAllSoundsInWorld
	 * 		Flags  -> ()
	 */
	TArray<class USoundBase*> UReadyOrNotFunctionLibrary::GetAllSoundsInWorld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAllSoundsInWorld");
		
		UReadyOrNotFunctionLibrary_GetAllSoundsInWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAllSectionNamesFromINIFile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigFilePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class FString> UReadyOrNotFunctionLibrary::GetAllSectionNamesFromINIFile(const class FString& ConfigFilePath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAllSectionNamesFromINIFile");
		
		UReadyOrNotFunctionLibrary_GetAllSectionNamesFromINIFile_Params params {};
		params.ConfigFilePath = ConfigFilePath;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAllItemsInMemory
	 * 		Flags  -> ()
	 */
	TArray<class ABaseItem*> UReadyOrNotFunctionLibrary::GetAllItemsInMemory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAllItemsInMemory");
		
		UReadyOrNotFunctionLibrary_GetAllItemsInMemory_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAllFMODBusObjects
	 * 		Flags  -> ()
	 */
	TArray<class UFMODBus*> UReadyOrNotFunctionLibrary::GetAllFMODBusObjects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAllFMODBusObjects");
		
		UReadyOrNotFunctionLibrary_GetAllFMODBusObjects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAllAudioComponents
	 * 		Flags  -> ()
	 */
	TArray<class UAudioComponent*> UReadyOrNotFunctionLibrary::GetAllAudioComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAllAudioComponents");
		
		UReadyOrNotFunctionLibrary_GetAllAudioComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAll2DFMODAudioEvents
	 * 		Flags  -> ()
	 */
	TArray<class UFMODEvent*> UReadyOrNotFunctionLibrary::GetAll2DFMODAudioEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.GetAll2DFMODAudioEvents");
		
		UReadyOrNotFunctionLibrary_GetAll2DFMODAudioEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.FulfillsAllPostProcessRequirements
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            OwningCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UClass*>                              InRequirementClasses                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceSuccess                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::FulfillsAllPostProcessRequirements(class UObject* Context, class APlayerCharacter* OwningCharacter, class AActor* DamageCauser, TArray<class UClass*> InRequirementClasses, bool bForceSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.FulfillsAllPostProcessRequirements");
		
		UReadyOrNotFunctionLibrary_FulfillsAllPostProcessRequirements_Params params {};
		params.Context = Context;
		params.OwningCharacter = OwningCharacter;
		params.DamageCauser = DamageCauser;
		params.InRequirementClasses = InRequirementClasses;
		params.bForceSuccess = bForceSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.FormatPlayerActionText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        InKey                                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInputEvent                                        InInputEvent                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        InActionText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      InColorLabel                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UReadyOrNotFunctionLibrary::FormatPlayerActionText(const struct FKey& InKey, EInputEvent InInputEvent, const class FText& InActionText, const class FString& InColorLabel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.FormatPlayerActionText");
		
		UReadyOrNotFunctionLibrary_FormatPlayerActionText_Params params {};
		params.InKey = InKey;
		params.InInputEvent = InInputEvent;
		params.InActionText = InActionText;
		params.InColorLabel = InColorLabel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.FindNearestFloor_BP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              InActorsToIgnore                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class UPrimitiveComponent*>                 InComponentsToIgnore                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	float UReadyOrNotFunctionLibrary::FindNearestFloor_BP(class AActor* InActor, TArray<class AActor*> InActorsToIgnore, TArray<class UPrimitiveComponent*> InComponentsToIgnore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.FindNearestFloor_BP");
		
		UReadyOrNotFunctionLibrary_FindNearestFloor_BP_Params params {};
		params.InActor = InActor;
		params.InActorsToIgnore = InActorsToIgnore;
		params.InComponentsToIgnore = InComponentsToIgnore;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.FindItemClassInItemDataTable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        RowName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UReadyOrNotFunctionLibrary::FindItemClassInItemDataTable(const class FName& RowName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.FindItemClassInItemDataTable");
		
		UReadyOrNotFunctionLibrary_FindItemClassInItemDataTable_Params params {};
		params.RowName = RowName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.FindConfigKeyFromINIFile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConfigFilePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Section                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::FindConfigKeyFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.FindConfigKeyFromINIFile");
		
		UReadyOrNotFunctionLibrary_FindConfigKeyFromINIFile_Params params {};
		params.ConfigFilePath = ConfigFilePath;
		params.Section = Section;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.DoorCheckResultToVoiceline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDoorCheckResult                                   DoorBreachType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UReadyOrNotFunctionLibrary::DoorCheckResultToVoiceline(EDoorCheckResult DoorBreachType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.DoorCheckResultToVoiceline");
		
		UReadyOrNotFunctionLibrary_DoorCheckResultToVoiceline_Params params {};
		params.DoorBreachType = DoorBreachType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.DoorBreachTypeToVoiceline_Negative
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDoorBreachType                                    DoorBreachType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UReadyOrNotFunctionLibrary::DoorBreachTypeToVoiceline_Negative(EDoorBreachType DoorBreachType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.DoorBreachTypeToVoiceline_Negative");
		
		UReadyOrNotFunctionLibrary_DoorBreachTypeToVoiceline_Negative_Params params {};
		params.DoorBreachType = DoorBreachType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.DoorBreachTypeToVoiceline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDoorBreachType                                    DoorBreachType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UReadyOrNotFunctionLibrary::DoorBreachTypeToVoiceline(EDoorBreachType DoorBreachType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.DoorBreachTypeToVoiceline");
		
		UReadyOrNotFunctionLibrary_DoorBreachTypeToVoiceline_Params params {};
		params.DoorBreachType = DoorBreachType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.DoesWidgetOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     ParentWidget                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     WidgetA                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWidget*                                     WidgetB                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::DoesWidgetOverlap(class UObject* WorldContext, class UWidget* ParentWidget, class UWidget* WidgetA, class UWidget* WidgetB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.DoesWidgetOverlap");
		
		UReadyOrNotFunctionLibrary_DoesWidgetOverlap_Params params {};
		params.WorldContext = WorldContext;
		params.ParentWidget = ParentWidget;
		params.WidgetA = WidgetA;
		params.WidgetB = WidgetB;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.DevMenuSettingsConfigDir
	 * 		Flags  -> ()
	 */
	class FString UReadyOrNotFunctionLibrary::DevMenuSettingsConfigDir()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.DevMenuSettingsConfigDir");
		
		UReadyOrNotFunctionLibrary_DevMenuSettingsConfigDir_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.ConvertUnrealKeyToRonKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        InKey                                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRonKey UReadyOrNotFunctionLibrary::ConvertUnrealKeyToRonKey(const struct FKey& InKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.ConvertUnrealKeyToRonKey");
		
		UReadyOrNotFunctionLibrary_ConvertUnrealKeyToRonKey_Params params {};
		params.InKey = InKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.ConvertUnrealKeyNameToRonKeyName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        InKey                                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UReadyOrNotFunctionLibrary::ConvertUnrealKeyNameToRonKeyName(const struct FKey& InKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.ConvertUnrealKeyNameToRonKeyName");
		
		UReadyOrNotFunctionLibrary_ConvertUnrealKeyNameToRonKeyName_Params params {};
		params.InKey = InKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.ConvertKeyToIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        InKey                                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FSlateBrush UReadyOrNotFunctionLibrary::ConvertKeyToIcon(const struct FKey& InKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.ConvertKeyToIcon");
		
		UReadyOrNotFunctionLibrary_ConvertKeyToIcon_Params params {};
		params.InKey = InKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.ConvertIntToFKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Integer                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FKey UReadyOrNotFunctionLibrary::ConvertIntToFKey(int32_t Integer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.ConvertIntToFKey");
		
		UReadyOrNotFunctionLibrary_ConvertIntToFKey_Params params {};
		params.Integer = Integer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.CalculateOffscreenPositionFromWorldLocation_Square
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        WorldLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ViewportOffset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsOffscreen                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Angle                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ForwardDotProduct                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RightDotProduct                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D UReadyOrNotFunctionLibrary::CalculateOffscreenPositionFromWorldLocation_Square(class UObject* WorldContext, const struct FCoreUObject_FVector& WorldLocation, float ViewportOffset, bool* bIsOffscreen, float* Angle, float* ForwardDotProduct, float* RightDotProduct)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.CalculateOffscreenPositionFromWorldLocation_Square");
		
		UReadyOrNotFunctionLibrary_CalculateOffscreenPositionFromWorldLocation_Square_Params params {};
		params.WorldContext = WorldContext;
		params.WorldLocation = WorldLocation;
		params.ViewportOffset = ViewportOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bIsOffscreen != nullptr)
			*bIsOffscreen = params.bIsOffscreen;
		if (Angle != nullptr)
			*Angle = params.Angle;
		if (ForwardDotProduct != nullptr)
			*ForwardDotProduct = params.ForwardDotProduct;
		if (RightDotProduct != nullptr)
			*RightDotProduct = params.RightDotProduct;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.CalculateOffscreenPositionFromWorldLocation_Ellipse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        WorldLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ViewportOffset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsOffscreen                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Angle                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ForwardDotProduct                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RightDotProduct                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D UReadyOrNotFunctionLibrary::CalculateOffscreenPositionFromWorldLocation_Ellipse(class UObject* WorldContext, const struct FCoreUObject_FVector& WorldLocation, float ViewportOffset, bool* bIsOffscreen, float* Angle, float* ForwardDotProduct, float* RightDotProduct)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.CalculateOffscreenPositionFromWorldLocation_Ellipse");
		
		UReadyOrNotFunctionLibrary_CalculateOffscreenPositionFromWorldLocation_Ellipse_Params params {};
		params.WorldContext = WorldContext;
		params.WorldLocation = WorldLocation;
		params.ViewportOffset = ViewportOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bIsOffscreen != nullptr)
			*bIsOffscreen = params.bIsOffscreen;
		if (Angle != nullptr)
			*Angle = params.Angle;
		if (ForwardDotProduct != nullptr)
			*ForwardDotProduct = params.ForwardDotProduct;
		if (RightDotProduct != nullptr)
			*RightDotProduct = params.RightDotProduct;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.BadAIActionConfigDir
	 * 		Flags  -> ()
	 */
	class FString UReadyOrNotFunctionLibrary::BadAIActionConfigDir()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.BadAIActionConfigDir");
		
		UReadyOrNotFunctionLibrary_BadAIActionConfigDir_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.AnyTrue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<bool>                                       BoolArray                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::AnyTrue(TArray<bool>* BoolArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.AnyTrue");
		
		UReadyOrNotFunctionLibrary_AnyTrue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (BoolArray != nullptr)
			*BoolArray = params.BoolArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.AnyFalse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<bool>                                       BoolArray                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::AnyFalse(TArray<bool>* BoolArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.AnyFalse");
		
		UReadyOrNotFunctionLibrary_AnyFalse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (BoolArray != nullptr)
			*BoolArray = params.BoolArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.AllTrue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<bool>                                       BoolArray                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::AllTrue(TArray<bool>* BoolArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.AllTrue");
		
		UReadyOrNotFunctionLibrary_AllTrue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (BoolArray != nullptr)
			*BoolArray = params.BoolArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotFunctionLibrary.AllFalse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<bool>                                       BoolArray                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotFunctionLibrary::AllFalse(TArray<bool>* BoolArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotFunctionLibrary.AllFalse");
		
		UReadyOrNotFunctionLibrary_AllFalse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (BoolArray != nullptr)
			*BoolArray = params.BoolArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.StopRecordingReplayFromBP
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameInstance::StopRecordingReplayFromBP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.StopRecordingReplayFromBP");
		
		UReadyOrNotGameInstance_StopRecordingReplayFromBP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.StopRecordingReplay
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameInstance::StopRecordingReplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.StopRecordingReplay");
		
		UReadyOrNotGameInstance_StopRecordingReplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.StopGeneratingPSOCache
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameInstance::StopGeneratingPSOCache()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.StopGeneratingPSOCache");
		
		UReadyOrNotGameInstance_StopGeneratingPSOCache_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.StartRecordingReplay
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameInstance::StartRecordingReplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.StartRecordingReplay");
		
		UReadyOrNotGameInstance_StartRecordingReplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.StartGeneratingPSOCache
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameInstance::StartGeneratingPSOCache()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.StartGeneratingPSOCache");
		
		UReadyOrNotGameInstance_StartGeneratingPSOCache_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.SetLastJoinState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELastMenuStateBeforeJoin                           LastJoiNState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameInstance::SetLastJoinState(ELastMenuStateBeforeJoin LastJoiNState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.SetLastJoinState");
		
		UReadyOrNotGameInstance_SetLastJoinState_Params params {};
		params.LastJoiNState = LastJoiNState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.SetInputAudioDevice
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      DeviceName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShouldSave                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotGameInstance::SetInputAudioDevice(const class FString& DeviceName, bool bShouldSave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.SetInputAudioDevice");
		
		UReadyOrNotGameInstance_SetInputAudioDevice_Params params {};
		params.DeviceName = DeviceName;
		params.bShouldSave = bShouldSave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.RetryLogin
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameInstance::RetryLogin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.RetryLogin");
		
		UReadyOrNotGameInstance_RetryLogin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.RenameReplay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ReplayName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      NewFriendlyReplayName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameInstance::RenameReplay(const class FString& ReplayName, const class FString& NewFriendlyReplayName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.RenameReplay");
		
		UReadyOrNotGameInstance_RenameReplay_Params params {};
		params.ReplayName = ReplayName;
		params.NewFriendlyReplayName = NewFriendlyReplayName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.RemovePauseGameCondition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      PauseCondition                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameInstance::RemovePauseGameCondition(const class FString& PauseCondition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.RemovePauseGameCondition");
		
		UReadyOrNotGameInstance_RemovePauseGameCondition_Params params {};
		params.PauseCondition = PauseCondition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.PlayReplayFromBP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ReplayName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameInstance::PlayReplayFromBP(const class FString& ReplayName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.PlayReplayFromBP");
		
		UReadyOrNotGameInstance_PlayReplayFromBP_Params params {};
		params.ReplayName = ReplayName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.OpenReplayFolder
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameInstance::OpenReplayFolder()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.OpenReplayFolder");
		
		UReadyOrNotGameInstance_OpenReplayFolder_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.OnWindowCloseRequested
	 * 		Flags  -> ()
	 */
	bool UReadyOrNotGameInstance::OnWindowCloseRequested()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.OnWindowCloseRequested");
		
		UReadyOrNotGameInstance_OnWindowCloseRequested_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotGameInstance.OnGameServerPinged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConnectionAddress                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameInstance::OnGameServerPinged__DelegateSignature(const class FString& ConnectionAddress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotGameInstance.OnGameServerPinged__DelegateSignature");
		
		UReadyOrNotGameInstance_OnGameServerPinged__DelegateSignature_Params params {};
		params.ConnectionAddress = ConnectionAddress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.OnConnectSteamServer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameInstance::OnConnectSteamServer(const class FString& URL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.OnConnectSteamServer");
		
		UReadyOrNotGameInstance_OnConnectSteamServer_Params params {};
		params.URL = URL;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.IsReplaySystemEnabled
	 * 		Flags  -> ()
	 */
	bool UReadyOrNotGameInstance::IsReplaySystemEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.IsReplaySystemEnabled");
		
		UReadyOrNotGameInstance_IsReplaySystemEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.IsPublicMissionInProgress
	 * 		Flags  -> ()
	 */
	bool UReadyOrNotGameInstance::IsPublicMissionInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.IsPublicMissionInProgress");
		
		UReadyOrNotGameInstance_IsPublicMissionInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.IsNetworkCompatible
	 * 		Flags  -> ()
	 * Parameters:
	 * 		uint32_t                                           LocalNetworkVersion                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           RemoteNetworkVersion                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotGameInstance::IsNetworkCompatible(uint32_t LocalNetworkVersion, uint32_t RemoteNetworkVersion)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.IsNetworkCompatible");
		
		UReadyOrNotGameInstance_IsNetworkCompatible_Params params {};
		params.LocalNetworkVersion = LocalNetworkVersion;
		params.RemoteNetworkVersion = RemoteNetworkVersion;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.IsLoggedIntoBackend
	 * 		Flags  -> ()
	 */
	bool UReadyOrNotGameInstance::IsLoggedIntoBackend()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.IsLoggedIntoBackend");
		
		UReadyOrNotGameInstance_IsLoggedIntoBackend_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.IsHostMigrationInProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MigratedHostToName                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotGameInstance::IsHostMigrationInProgress(class FString* MigratedHostToName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.IsHostMigrationInProgress");
		
		UReadyOrNotGameInstance_IsHostMigrationInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MigratedHostToName != nullptr)
			*MigratedHostToName = params.MigratedHostToName;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.IsGameModded
	 * 		Flags  -> ()
	 */
	bool UReadyOrNotGameInstance::IsGameModded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.IsGameModded");
		
		UReadyOrNotGameInstance_IsGameModded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.Gratr
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameInstance::Gratr()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.Gratr");
		
		UReadyOrNotGameInstance_Gratr_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetSessionTicket
	 * 		Flags  -> ()
	 */
	class FString UReadyOrNotGameInstance::GetSessionTicket()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetSessionTicket");
		
		UReadyOrNotGameInstance_GetSessionTicket_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetReplayEvents
	 * 		Flags  -> ()
	 */
	TArray<struct FReplayEvent> UReadyOrNotGameInstance::GetReplayEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetReplayEvents");
		
		UReadyOrNotGameInstance_GetReplayEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetLocalNetworkVersion
	 * 		Flags  -> ()
	 */
	uint32_t UReadyOrNotGameInstance::GetLocalNetworkVersion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetLocalNetworkVersion");
		
		UReadyOrNotGameInstance_GetLocalNetworkVersion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetFriendlyGamemodeName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      UnfriendlyName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UReadyOrNotGameInstance::GetFriendlyGamemodeName(const class FString& UnfriendlyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetFriendlyGamemodeName");
		
		UReadyOrNotGameInstance_GetFriendlyGamemodeName_Params params {};
		params.UnfriendlyName = UnfriendlyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetDiscordOneTimeUseCode
	 * 		Flags  -> ()
	 */
	class FString UReadyOrNotGameInstance::GetDiscordOneTimeUseCode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetDiscordOneTimeUseCode");
		
		UReadyOrNotGameInstance_GetDiscordOneTimeUseCode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetBuiltModdedMapList
	 * 		Flags  -> ()
	 */
	TArray<class FString> UReadyOrNotGameInstance::GetBuiltModdedMapList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetBuiltModdedMapList");
		
		UReadyOrNotGameInstance_GetBuiltModdedMapList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetBuiltMapList
	 * 		Flags  -> ()
	 */
	TArray<class FString> UReadyOrNotGameInstance::GetBuiltMapList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetBuiltMapList");
		
		UReadyOrNotGameInstance_GetBuiltMapList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetBestGuessMapName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MapName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UReadyOrNotGameInstance::GetBestGuessMapName(const class FString& MapName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetBestGuessMapName");
		
		UReadyOrNotGameInstance_GetBestGuessMapName_Params params {};
		params.MapName = MapName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetBanned
	 * 		Flags  -> ()
	 */
	bool UReadyOrNotGameInstance::GetBanned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetBanned");
		
		UReadyOrNotGameInstance_GetBanned_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetBackendState
	 * 		Flags  -> ()
	 */
	unsigned char UReadyOrNotGameInstance::GetBackendState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetBackendState");
		
		UReadyOrNotGameInstance_GetBackendState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetAvailableAudioDevices
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FString>                              OutAudioDevices                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotGameInstance::GetAvailableAudioDevices(TArray<class FString>* OutAudioDevices)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetAvailableAudioDevices");
		
		UReadyOrNotGameInstance_GetAvailableAudioDevices_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutAudioDevices != nullptr)
			*OutAudioDevices = params.OutAudioDevices;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetAndClearMainMenuDisplayMessage
	 * 		Flags  -> ()
	 */
	class FString UReadyOrNotGameInstance::GetAndClearMainMenuDisplayMessage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetAndClearMainMenuDisplayMessage");
		
		UReadyOrNotGameInstance_GetAndClearMainMenuDisplayMessage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetAndClearLastJoinState
	 * 		Flags  -> ()
	 */
	ELastMenuStateBeforeJoin UReadyOrNotGameInstance::GetAndClearLastJoinState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetAndClearLastJoinState");
		
		UReadyOrNotGameInstance_GetAndClearLastJoinState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetAllGameStates
	 * 		Flags  -> ()
	 */
	TArray<class AReadyOrNotGameState*> UReadyOrNotGameInstance::GetAllGameStates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetAllGameStates");
		
		UReadyOrNotGameInstance_GetAllGameStates_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GetAllGameModes
	 * 		Flags  -> ()
	 */
	TArray<class AReadyOrNotGameMode*> UReadyOrNotGameInstance::GetAllGameModes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GetAllGameModes");
		
		UReadyOrNotGameInstance_GetAllGameModes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.GenerateURLMap
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameInstance::GenerateURLMap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.GenerateURLMap");
		
		UReadyOrNotGameInstance_GenerateURLMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.FindReplays
	 * 		Flags  -> ()
	 */
	TMap<class FString, struct FReplayData> UReadyOrNotGameInstance::FindReplays()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.FindReplays");
		
		UReadyOrNotGameInstance_FindReplays_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.DeleteReplay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ReplayName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameInstance::DeleteReplay(const class FString& ReplayName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.DeleteReplay");
		
		UReadyOrNotGameInstance_DeleteReplay_Params params {};
		params.ReplayName = ReplayName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.ConnectSteamServer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ServerConnect                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameInstance::ConnectSteamServer(const class FString& ServerConnect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.ConnectSteamServer");
		
		UReadyOrNotGameInstance_ConnectSteamServer_Params params {};
		params.ServerConnect = ServerConnect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.BuildMapList
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameInstance::BuildMapList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.BuildMapList");
		
		UReadyOrNotGameInstance_BuildMapList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.ApplyDecalSettings
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameInstance::ApplyDecalSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.ApplyDecalSettings");
		
		UReadyOrNotGameInstance_ApplyDecalSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.AddReplayEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Timestamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameInstance::AddReplayEvent(const class FString& Name, const struct FCoreUObject_FVector& Location, float Timestamp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.AddReplayEvent");
		
		UReadyOrNotGameInstance_AddReplayEvent_Params params {};
		params.Name = Name;
		params.Location = Location;
		params.Timestamp = Timestamp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameInstance.AddPauseGameCondition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      PauseCondition                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotGameInstance::AddPauseGameCondition(const class FString& PauseCondition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameInstance.AddPauseGameCondition");
		
		UReadyOrNotGameInstance_AddPauseGameCondition_Params params {};
		params.PauseCondition = PauseCondition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotGameInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotGameInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotGameInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameSession.WriteOutConfig
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameSession::WriteOutConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameSession.WriteOutConfig");
		
		AReadyOrNotGameSession_WriteOutConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameSession.UpdateServerMatchmakeQueue
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameSession::UpdateServerMatchmakeQueue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameSession.UpdateServerMatchmakeQueue");
		
		AReadyOrNotGameSession_UpdateServerMatchmakeQueue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameSession.SetServerSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewRoundTimerGameStart                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewRoundTimerBetweenMaps                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewReinforcementTimer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewTimelimit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewRoundsPerMap                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewScorelimit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               NewAiEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameSession::SetServerSettings(float NewRoundTimerGameStart, float NewRoundTimerBetweenMaps, float NewReinforcementTimer, float NewTimelimit, int32_t NewRoundsPerMap, int32_t NewScorelimit, bool NewAiEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameSession.SetServerSettings");
		
		AReadyOrNotGameSession_SetServerSettings_Params params {};
		params.NewRoundTimerGameStart = NewRoundTimerGameStart;
		params.NewRoundTimerBetweenMaps = NewRoundTimerBetweenMaps;
		params.NewReinforcementTimer = NewReinforcementTimer;
		params.NewTimelimit = NewTimelimit;
		params.NewRoundsPerMap = NewRoundsPerMap;
		params.NewScorelimit = NewScorelimit;
		params.NewAiEnabled = NewAiEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameSession.RefreshMatchmakeServer
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameSession::RefreshMatchmakeServer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameSession.RefreshMatchmakeServer");
		
		AReadyOrNotGameSession_RefreshMatchmakeServer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameSession.OnMatchmakingCreateParty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FZeuzMatchMakingStatus                      MatchmakingStatus                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      Error                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameSession::OnMatchmakingCreateParty(const struct FZeuzMatchMakingStatus& MatchmakingStatus, const class FString& Error)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameSession.OnMatchmakingCreateParty");
		
		AReadyOrNotGameSession_OnMatchmakingCreateParty_Params params {};
		params.MatchmakingStatus = MatchmakingStatus;
		params.Error = Error;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameSession.OnGetRegions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FZeuzRegion>                         ZeuzRegions                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      Error                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameSession::OnGetRegions(TArray<struct FZeuzRegion> ZeuzRegions, const class FString& Error)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameSession.OnGetRegions");
		
		AReadyOrNotGameSession_OnGetRegions_Params params {};
		params.ZeuzRegions = ZeuzRegions;
		params.Error = Error;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameSession.OnGetPayloadsMatchmakingCreateParty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FZeuzPayloadGetOut                          PayloadOut                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      Error                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameSession::OnGetPayloadsMatchmakingCreateParty(const struct FZeuzPayloadGetOut& PayloadOut, const class FString& Error)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameSession.OnGetPayloadsMatchmakingCreateParty");
		
		AReadyOrNotGameSession_OnGetPayloadsMatchmakingCreateParty_Params params {};
		params.PayloadOut = PayloadOut;
		params.Error = Error;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameSession.OnGetPayloadServerRefresh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FZeuzPayloadGetOut                          PayloadOut                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      Error                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameSession::OnGetPayloadServerRefresh(const struct FZeuzPayloadGetOut& PayloadOut, const class FString& Error)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameSession.OnGetPayloadServerRefresh");
		
		AReadyOrNotGameSession_OnGetPayloadServerRefresh_Params params {};
		params.PayloadOut = PayloadOut;
		params.Error = Error;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameSession.MakeLoadingMapOnlyURL
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MapURL                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotGameSession::MakeLoadingMapOnlyURL(const class FString& MapURL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameSession.MakeLoadingMapOnlyURL");
		
		AReadyOrNotGameSession_MakeLoadingMapOnlyURL_Params params {};
		params.MapURL = MapURL;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameSession.AddServerToMatchMakeQueue
	 * 		Flags  -> ()
	 */
	void AReadyOrNotGameSession::AddServerToMatchMakeQueue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameSession.AddServerToMatchMakeQueue");
		
		AReadyOrNotGameSession_AddServerToMatchMakeQueue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotGameSession.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotGameSession::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotGameSession");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGameUserSettings.ResetKeybinds
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGameUserSettings::ResetKeybinds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGameUserSettings.ResetKeybinds");
		
		UReadyOrNotGameUserSettings_ResetKeybinds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotGameUserSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotGameUserSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotGameUserSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGauntletTestController.StopProfiling
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGauntletTestController::StopProfiling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGauntletTestController.StopProfiling");
		
		UReadyOrNotGauntletTestController_StopProfiling_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotGauntletTestController.StartTesting
	 * 		Flags  -> ()
	 */
	void UReadyOrNotGauntletTestController::StartTesting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotGauntletTestController.StartTesting");
		
		UReadyOrNotGauntletTestController_StartTesting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotGauntletTestController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotGauntletTestController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotGauntletTestController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.StopOutOfBoundsCountdown
	 * 		Flags  -> ()
	 */
	void AReadyOrNotLevelScript::StopOutOfBoundsCountdown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.StopOutOfBoundsCountdown");
		
		AReadyOrNotLevelScript_StopOutOfBoundsCountdown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.Stop3DAudioVisualizer
	 * 		Flags  -> ()
	 */
	void AReadyOrNotLevelScript::Stop3DAudioVisualizer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.Stop3DAudioVisualizer");
		
		AReadyOrNotLevelScript_Stop3DAudioVisualizer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.StartOutOfBoundsCountdown
	 * 		Flags  -> ()
	 */
	void AReadyOrNotLevelScript::StartOutOfBoundsCountdown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.StartOutOfBoundsCountdown");
		
		AReadyOrNotLevelScript_StartOutOfBoundsCountdown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.Start3DAudioVisualizer
	 * 		Flags  -> ()
	 */
	void AReadyOrNotLevelScript::Start3DAudioVisualizer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.Start3DAudioVisualizer");
		
		AReadyOrNotLevelScript_Start3DAudioVisualizer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.SetFlashlightIntensityBoost
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Boost                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotLevelScript::SetFlashlightIntensityBoost(float Boost)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.SetFlashlightIntensityBoost");
		
		AReadyOrNotLevelScript_SetFlashlightIntensityBoost_Params params {};
		params.Boost = Boost;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.SetFlashlightBouncedIntensityBoost
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Boost                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotLevelScript::SetFlashlightBouncedIntensityBoost(float Boost)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.SetFlashlightBouncedIntensityBoost");
		
		AReadyOrNotLevelScript_SetFlashlightBouncedIntensityBoost_Params params {};
		params.Boost = Boost;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.PlayMVPSequence
	 * 		Flags  -> ()
	 */
	void AReadyOrNotLevelScript::PlayMVPSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.PlayMVPSequence");
		
		AReadyOrNotLevelScript_PlayMVPSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.OnTeamSequenceFinished
	 * 		Flags  -> ()
	 */
	void AReadyOrNotLevelScript::OnTeamSequenceFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.OnTeamSequenceFinished");
		
		AReadyOrNotLevelScript_OnTeamSequenceFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.OnPiracyCheckUpdate_Private
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsPirated                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ProgramDetected                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotLevelScript::OnPiracyCheckUpdate_Private(bool bIsPirated, const class FString& ProgramDetected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.OnPiracyCheckUpdate_Private");
		
		AReadyOrNotLevelScript_OnPiracyCheckUpdate_Private_Params params {};
		params.bIsPirated = bIsPirated;
		params.ProgramDetected = ProgramDetected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.OnPiracyCheckUpdate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsPirated                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ProgramDetected                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotLevelScript::OnPiracyCheckUpdate(bool bIsPirated, const class FString& ProgramDetected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.OnPiracyCheckUpdate");
		
		AReadyOrNotLevelScript_OnPiracyCheckUpdate_Params params {};
		params.bIsPirated = bIsPirated;
		params.ProgramDetected = ProgramDetected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotLevelScript.OnOutOfBoundsTimeLimitEnded__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotLevelScript::OnOutOfBoundsTimeLimitEnded__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotLevelScript.OnOutOfBoundsTimeLimitEnded__DelegateSignature");
		
		AReadyOrNotLevelScript_OnOutOfBoundsTimeLimitEnded__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.OnOutOfBoundsTimeLimitEnded
	 * 		Flags  -> ()
	 */
	void AReadyOrNotLevelScript::OnOutOfBoundsTimeLimitEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.OnOutOfBoundsTimeLimitEnded");
		
		AReadyOrNotLevelScript_OnOutOfBoundsTimeLimitEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.OnMVPSequenceFinished
	 * 		Flags  -> ()
	 */
	void AReadyOrNotLevelScript::OnMVPSequenceFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.OnMVPSequenceFinished");
		
		AReadyOrNotLevelScript_OnMVPSequenceFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.IsVisualizingAudioSources
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotLevelScript::IsVisualizingAudioSources()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.IsVisualizingAudioSources");
		
		AReadyOrNotLevelScript_IsVisualizingAudioSources_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.IsOutOfBoundsEnabled
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotLevelScript::IsOutOfBoundsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.IsOutOfBoundsEnabled");
		
		AReadyOrNotLevelScript_IsOutOfBoundsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.IsCountingDownForOutOfBounds
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotLevelScript::IsCountingDownForOutOfBounds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.IsCountingDownForOutOfBounds");
		
		AReadyOrNotLevelScript_IsCountingDownForOutOfBounds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.GetConversationManager
	 * 		Flags  -> ()
	 */
	class AConversationManager* AReadyOrNotLevelScript::GetConversationManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.GetConversationManager");
		
		AReadyOrNotLevelScript_GetConversationManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.EnableOutOfBounds
	 * 		Flags  -> ()
	 */
	void AReadyOrNotLevelScript::EnableOutOfBounds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.EnableOutOfBounds");
		
		AReadyOrNotLevelScript_EnableOutOfBounds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.DisableOutOfBounds
	 * 		Flags  -> ()
	 */
	void AReadyOrNotLevelScript::DisableOutOfBounds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.DisableOutOfBounds");
		
		AReadyOrNotLevelScript_DisableOutOfBounds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotLevelScript.AllAudioVolumesTicked
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotLevelScript::AllAudioVolumesTicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotLevelScript.AllAudioVolumesTicked");
		
		AReadyOrNotLevelScript_AllAudioVolumesTicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotLevelScript.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotLevelScript::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotLevelScript");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotMathLibrary.WrapAngleIfOutOfBounds
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinBounds                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxBounds                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UReadyOrNotMathLibrary::WrapAngleIfOutOfBounds(float Angle, float MinBounds, float MaxBounds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotMathLibrary.WrapAngleIfOutOfBounds");
		
		UReadyOrNotMathLibrary_WrapAngleIfOutOfBounds_Params params {};
		params.Angle = Angle;
		params.MinBounds = MinBounds;
		params.MaxBounds = MaxBounds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotMathLibrary.KeepAngleBelow360
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UReadyOrNotMathLibrary::KeepAngleBelow360(float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotMathLibrary.KeepAngleBelow360");
		
		UReadyOrNotMathLibrary_KeepAngleBelow360_Params params {};
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotMathLibrary.KeepAngleAbove0
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UReadyOrNotMathLibrary::KeepAngleAbove0(float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotMathLibrary.KeepAngleAbove0");
		
		UReadyOrNotMathLibrary_KeepAngleAbove0_Params params {};
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotMathLibrary.GetLastKeyTime_FloatCurve
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRuntimeFloatCurve                          InCurve                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	float UReadyOrNotMathLibrary::GetLastKeyTime_FloatCurve(const struct FRuntimeFloatCurve& InCurve)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotMathLibrary.GetLastKeyTime_FloatCurve");
		
		UReadyOrNotMathLibrary_GetLastKeyTime_FloatCurve_Params params {};
		params.InCurve = InCurve;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotMathLibrary.GenerateRandomLocationOnSphere
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector UReadyOrNotMathLibrary::GenerateRandomLocationOnSphere(const struct FCoreUObject_FVector& Origin, float Radius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotMathLibrary.GenerateRandomLocationOnSphere");
		
		UReadyOrNotMathLibrary_GenerateRandomLocationOnSphere_Params params {};
		params.Origin = Origin;
		params.Radius = Radius;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotMathLibrary.CalculatePositionOnEllipse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector2D                      Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RadiusX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RadiusY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D UReadyOrNotMathLibrary::CalculatePositionOnEllipse(const struct FCoreUObject_FVector2D& Origin, float RadiusX, float RadiusY, float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotMathLibrary.CalculatePositionOnEllipse");
		
		UReadyOrNotMathLibrary_CalculatePositionOnEllipse_Params params {};
		params.Origin = Origin;
		params.RadiusX = RadiusX;
		params.RadiusY = RadiusY;
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotMathLibrary.CalculatePositionOnCircle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector2D                      Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector2D UReadyOrNotMathLibrary::CalculatePositionOnCircle(const struct FCoreUObject_FVector2D& Origin, float Radius, float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotMathLibrary.CalculatePositionOnCircle");
		
		UReadyOrNotMathLibrary_CalculatePositionOnCircle_Params params {};
		params.Origin = Origin;
		params.Radius = Radius;
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotMathLibrary.CalculateLocationOnSphere
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Phi                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector UReadyOrNotMathLibrary::CalculateLocationOnSphere(const struct FCoreUObject_FVector& Origin, float Radius, float Angle, float Phi)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotMathLibrary.CalculateLocationOnSphere");
		
		UReadyOrNotMathLibrary_CalculateLocationOnSphere_Params params {};
		params.Origin = Origin;
		params.Radius = Radius;
		params.Angle = Angle;
		params.Phi = Phi;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotMathLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotMathLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotMathLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_NoSuspects.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_NoSuspects::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_NoSuspects");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_FlankingAvoidanceArea.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_FlankingAvoidanceArea::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_FlankingAvoidanceArea");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_LockedDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_LockedDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_LockedDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_ClosedDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_ClosedDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_ClosedDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_TrappedDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_TrappedDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_TrappedDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_HasBeenOpenedDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_HasBeenOpenedDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_HasBeenOpenedDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_TrappedHasBeenOpenedDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_TrappedHasBeenOpenedDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_TrappedHasBeenOpenedDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_WallTraversalHole.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_WallTraversalHole::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_WallTraversalHole");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_Player.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_Player::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_Player");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_CivilianA.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_CivilianA::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_CivilianA");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_CivilianB.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_CivilianB::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_CivilianB");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_CivilianC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_CivilianC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_CivilianC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_CivilianD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_CivilianD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_CivilianD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_CivilianE.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_CivilianE::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_CivilianE");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_SuspectA.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_SuspectA::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_SuspectA");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_SuspectB.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_SuspectB::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_SuspectB");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_SuspectC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_SuspectC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_SuspectC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_SuspectD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_SuspectD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_SuspectD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_SuspectE.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_SuspectE::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavArea_SuspectE");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotNavigationSystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotNavigationSystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotNavigationSystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavQuery_DoorTest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavQuery_DoorTest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavQuery_DoorTest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavQuery_Swat.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavQuery_Swat::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavQuery_Swat");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavQuery_Civilian.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavQuery_Civilian::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavQuery_Civilian");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavQuery_Suspect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavQuery_Suspect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavQuery_Suspect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavQuery_FlankingSuspect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavQuery_FlankingSuspect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavQuery_FlankingSuspect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavQuery_NoiseCheck.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavQuery_NoiseCheck::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.NavQuery_NoiseCheck");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPathFollowingComp.OnHoleTraversalFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               Activity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReadyOrNotPathFollowingComp::OnHoleTraversalFinished(class UBaseActivity* Activity, class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPathFollowingComp.OnHoleTraversalFinished");
		
		UReadyOrNotPathFollowingComp_OnHoleTraversalFinished_Params params {};
		params.Activity = Activity;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotPathFollowingComp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotPathFollowingComp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotPathFollowingComp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.WinCoop
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::WinCoop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.WinCoop");
		
		AReadyOrNotPlayerController_WinCoop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Vote
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               VoteYes                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Vote(bool VoteYes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Vote");
		
		AReadyOrNotPlayerController_Vote_Params params {};
		params.VoteYes = VoteYes;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.UpdateAchievementProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Percent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::UpdateAchievementProgress(const class FString& ID, float Percent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.UpdateAchievementProgress");
		
		AReadyOrNotPlayerController_UpdateAchievementProgress_Params params {};
		params.ID = ID;
		params.Percent = Percent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.UnhideAllWeaponAttachments
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::UnhideAllWeaponAttachments()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.UnhideAllWeaponAttachments");
		
		AReadyOrNotPlayerController_UnhideAllWeaponAttachments_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.UnhideAllSmallItemMeshes
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::UnhideAllSmallItemMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.UnhideAllSmallItemMeshes");
		
		AReadyOrNotPlayerController_UnhideAllSmallItemMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.UnhideAllItemMeshes
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::UnhideAllItemMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.UnhideAllItemMeshes");
		
		AReadyOrNotPlayerController_UnhideAllItemMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ToggleRTXDMO
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ToggleRTXDMO()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ToggleRTXDMO");
		
		AReadyOrNotPlayerController_ToggleRTXDMO_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ToggleGodModeOnEveryone
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ToggleGodModeOnEveryone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ToggleGodModeOnEveryone");
		
		AReadyOrNotPlayerController_ToggleGodModeOnEveryone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ToggleDeployMenu
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ToggleDeployMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ToggleDeployMenu");
		
		AReadyOrNotPlayerController_ToggleDeployMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.TestSendCrash
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::TestSendCrash()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.TestSendCrash");
		
		AReadyOrNotPlayerController_TestSendCrash_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.TestMatchmakingServerRefresh
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::TestMatchmakingServerRefresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.TestMatchmakingServerRefresh");
		
		AReadyOrNotPlayerController_TestMatchmakingServerRefresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.TestMatchmakingServerCreateParty
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::TestMatchmakingServerCreateParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.TestMatchmakingServerCreateParty");
		
		AReadyOrNotPlayerController_TestMatchmakingServerCreateParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.TeleportUp
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::TeleportUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.TeleportUp");
		
		AReadyOrNotPlayerController_TeleportUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.TeleportToNextRemainingAI
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::TeleportToNextRemainingAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.TeleportToNextRemainingAI");
		
		AReadyOrNotPlayerController_TeleportToNextRemainingAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.TakeDamageExec
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::TakeDamageExec(float DamageAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.TakeDamageExec");
		
		AReadyOrNotPlayerController_TakeDamageExec_Params params {};
		params.DamageAmount = DamageAmount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SwapAllItemSkeletalMeshesToCubes
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::SwapAllItemSkeletalMeshesToCubes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SwapAllItemSkeletalMeshesToCubes");
		
		AReadyOrNotPlayerController_SwapAllItemSkeletalMeshesToCubes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.StreamInSession
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBlueprintSessionResult                     SessionResult                                              (Parm, NativeAccessSpecifierPublic)
	 * 		class ULevelStreaming*                             OutStreamedLevel                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShouldCreateLoadingScreen                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotPlayerController::StreamInSession(const struct FBlueprintSessionResult& SessionResult, class ULevelStreaming** OutStreamedLevel, bool bShouldCreateLoadingScreen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.StreamInSession");
		
		AReadyOrNotPlayerController_StreamInSession_Params params {};
		params.SessionResult = SessionResult;
		params.bShouldCreateLoadingScreen = bShouldCreateLoadingScreen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutStreamedLevel != nullptr)
			*OutStreamedLevel = params.OutStreamedLevel;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.StreamInLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      NewLevel                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Options                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ULevelStreaming*                             OutStreamedLevel                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLevelStreamOptions                         LevelStreamOptions                                         (Parm, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotPlayerController::StreamInLevel(const class FString& NewLevel, const class FString& Options, class ULevelStreaming** OutStreamedLevel, const struct FLevelStreamOptions& LevelStreamOptions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.StreamInLevel");
		
		AReadyOrNotPlayerController_StreamInLevel_Params params {};
		params.NewLevel = NewLevel;
		params.Options = Options;
		params.LevelStreamOptions = LevelStreamOptions;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutStreamedLevel != nullptr)
			*OutStreamedLevel = params.OutStreamedLevel;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.StopVoteInput
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::StopVoteInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.StopVoteInput");
		
		AReadyOrNotPlayerController_StopVoteInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.StopSwatAutomation
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::StopSwatAutomation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.StopSwatAutomation");
		
		AReadyOrNotPlayerController_StopSwatAutomation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.StopSpeaking
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::StopSpeaking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.StopSpeaking");
		
		AReadyOrNotPlayerController_StopSpeaking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.StartSwatAutomation
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::StartSwatAutomation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.StartSwatAutomation");
		
		AReadyOrNotPlayerController_StartSwatAutomation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.StartSpeaking
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::StartSpeaking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.StartSpeaking");
		
		AReadyOrNotPlayerController_StartSpeaking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.StartBleeding
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::StartBleeding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.StartBleeding");
		
		AReadyOrNotPlayerController_StartBleeding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SpawnRandomAI
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::SpawnRandomAI(int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SpawnRandomAI");
		
		AReadyOrNotPlayerController_SpawnRandomAI_Params params {};
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SpawnBotsForGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            BotCount                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::SpawnBotsForGame(int32_t BotCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SpawnBotsForGame");
		
		AReadyOrNotPlayerController_SpawnBotsForGame_Params params {};
		params.BotCount = BotCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SpawnAIAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      TableName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        MoveLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::SpawnAIAtLocation(const class FString& TableName, const struct FCoreUObject_FVector& Location, const struct FCoreUObject_FVector& MoveLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SpawnAIAtLocation");
		
		AReadyOrNotPlayerController_SpawnAIAtLocation_Params params {};
		params.TableName = TableName;
		params.Location = Location;
		params.MoveLocation = MoveLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SpawnAI
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      TableName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::SpawnAI(const class FString& TableName, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SpawnAI");
		
		AReadyOrNotPlayerController_SpawnAI_Params params {};
		params.TableName = TableName;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SoftWinCoop
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::SoftWinCoop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SoftWinCoop");
		
		AReadyOrNotPlayerController_SoftWinCoop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ShowCoopScoreChangeWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ScoreChangeValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::ShowCoopScoreChangeWidget(float ScoreChangeValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ShowCoopScoreChangeWidget");
		
		AReadyOrNotPlayerController_ShowCoopScoreChangeWidget_Params params {};
		params.ScoreChangeValue = ScoreChangeValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SetTimelimit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::SetTimelimit(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SetTimelimit");
		
		AReadyOrNotPlayerController_SetTimelimit_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SetServerPasswordOnConnection
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Password                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::SetServerPasswordOnConnection(const class FString& Password)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SetServerPasswordOnConnection");
		
		AReadyOrNotPlayerController_SetServerPasswordOnConnection_Params params {};
		params.Password = Password;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SetScorelimit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::SetScorelimit(int32_t Score)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SetScorelimit");
		
		AReadyOrNotPlayerController_SetScorelimit_Params params {};
		params.Score = Score;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SetPreferredTeamUniqueNetIdOnConnection
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      UniqueId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::SetPreferredTeamUniqueNetIdOnConnection(const class FString& UniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SetPreferredTeamUniqueNetIdOnConnection");
		
		AReadyOrNotPlayerController_SetPreferredTeamUniqueNetIdOnConnection_Params params {};
		params.UniqueId = UniqueId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SetMousePosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              LocationX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LocationY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::SetMousePosition(float LocationX, float LocationY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SetMousePosition");
		
		AReadyOrNotPlayerController_SetMousePosition_Params params {};
		params.LocationX = LocationX;
		params.LocationY = LocationY;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SetHostMigrationComplete
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::SetHostMigrationComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SetHostMigrationComplete");
		
		AReadyOrNotPlayerController_SetHostMigrationComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SetClubMusicMasterVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::SetClubMusicMasterVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SetClubMusicMasterVolume");
		
		AReadyOrNotPlayerController_SetClubMusicMasterVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SetAllComponentsUseParentsBounds
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::SetAllComponentsUseParentsBounds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SetAllComponentsUseParentsBounds");
		
		AReadyOrNotPlayerController_SetAllComponentsUseParentsBounds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ServerStatFileStop
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ServerStatFileStop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ServerStatFileStop");
		
		AReadyOrNotPlayerController_ServerStatFileStop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ServerStatFileStart
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ServerStatFileStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ServerStatFileStart");
		
		AReadyOrNotPlayerController_ServerStatFileStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_SwapPlayersTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                ps                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_SwapPlayersTeam(class APlayerState* ps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_SwapPlayersTeam");
		
		AReadyOrNotPlayerController_Server_SwapPlayersTeam_Params params {};
		params.ps = ps;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_StatFile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bStartStatFile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_StatFile(bool bStartStatFile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_StatFile");
		
		AReadyOrNotPlayerController_Server_StatFile_Params params {};
		params.bStartStatFile = bStartStatFile;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_StartSpectating
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Server_StartSpectating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_StartSpectating");
		
		AReadyOrNotPlayerController_Server_StartSpectating_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_StartReferendum
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ReferendumClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_StartReferendum(class UClass* ReferendumClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_StartReferendum");
		
		AReadyOrNotPlayerController_Server_StartReferendum_Params params {};
		params.ReferendumClass = ReferendumClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_StartPlayerReferendum
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ReferendumClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotPlayerState*                      TargetPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_StartPlayerReferendum(class UClass* ReferendumClass, class AReadyOrNotPlayerState* TargetPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_StartPlayerReferendum");
		
		AReadyOrNotPlayerController_Server_StartPlayerReferendum_Params params {};
		params.ReferendumClass = ReferendumClass;
		params.TargetPlayer = TargetPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_StartMapReferendum
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ReferendumClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      MapURL                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_StartMapReferendum(class UClass* ReferendumClass, const class FString& MapURL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_StartMapReferendum");
		
		AReadyOrNotPlayerController_Server_StartMapReferendum_Params params {};
		params.ReferendumClass = ReferendumClass;
		params.MapURL = MapURL;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_SetTeamType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          NewTeam                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_SetTeamType(ETeamType NewTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_SetTeamType");
		
		AReadyOrNotPlayerController_Server_SetTeamType_Params params {};
		params.NewTeam = NewTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_SetSpawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          SpawnTeam                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESelectedSpawn                                     NewSpawnPoint                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_SetSpawn(ETeamType SpawnTeam, ESelectedSpawn NewSpawnPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_SetSpawn");
		
		AReadyOrNotPlayerController_Server_SetSpawn_Params params {};
		params.SpawnTeam = SpawnTeam;
		params.NewSpawnPoint = NewSpawnPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_SetHasFinishedLoading
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Server_SetHasFinishedLoading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_SetHasFinishedLoading");
		
		AReadyOrNotPlayerController_Server_SetHasFinishedLoading_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_SetDeployableDepot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewDepot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_SetDeployableDepot(int32_t NewDepot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_SetDeployableDepot");
		
		AReadyOrNotPlayerController_Server_SetDeployableDepot_Params params {};
		params.NewDepot = NewDepot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_SetChecksum
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Checksum                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_SetChecksum(int32_t Checksum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_SetChecksum");
		
		AReadyOrNotPlayerController_Server_SetChecksum_Params params {};
		params.Checksum = Checksum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_SendChatMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRChatMessage                               ChatMessage                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_SendChatMessage(const struct FRChatMessage& ChatMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_SendChatMessage");
		
		AReadyOrNotPlayerController_Server_SendChatMessage_Params params {};
		params.ChatMessage = ChatMessage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_RespawnAsLobby
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                     SpawnTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_RespawnAsLobby(class UClass* Class, const struct FTransform& SpawnTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_RespawnAsLobby");
		
		AReadyOrNotPlayerController_Server_RespawnAsLobby_Params params {};
		params.Class = Class;
		params.SpawnTransform = SpawnTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_RequestLoadoutChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSavedLoadout                               Loadout                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_RequestLoadoutChange(const struct FSavedLoadout& Loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_RequestLoadoutChange");
		
		AReadyOrNotPlayerController_Server_RequestLoadoutChange_Params params {};
		params.Loadout = Loadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_RemoveMarker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_RemoveMarker(int32_t ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_RemoveMarker");
		
		AReadyOrNotPlayerController_Server_RemoveMarker_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_RemoveLine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_RemoveLine(int32_t ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_RemoveLine");
		
		AReadyOrNotPlayerController_Server_RemoveLine_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_ReleaseVIP
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Server_ReleaseVIP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_ReleaseVIP");
		
		AReadyOrNotPlayerController_Server_ReleaseVIP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_ReferendumVoteYes
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Server_ReferendumVoteYes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_ReferendumVoteYes");
		
		AReadyOrNotPlayerController_Server_ReferendumVoteYes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_ReferendumVoteNo
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Server_ReferendumVoteNo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_ReferendumVoteNo");
		
		AReadyOrNotPlayerController_Server_ReferendumVoteNo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_LoginAsAdmin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Password                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_LoginAsAdmin(const class FString& Password)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_LoginAsAdmin");
		
		AReadyOrNotPlayerController_Server_LoginAsAdmin_Params params {};
		params.Password = Password;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_Equip
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ItemName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_Equip(const class FString& ItemName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_Equip");
		
		AReadyOrNotPlayerController_Server_Equip_Params params {};
		params.ItemName = ItemName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_EnablePersonnel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PersonnelNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MapPointNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_EnablePersonnel(int32_t PersonnelNum, int32_t MapPointNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_EnablePersonnel");
		
		AReadyOrNotPlayerController_Server_EnablePersonnel_Params params {};
		params.PersonnelNum = PersonnelNum;
		params.MapPointNum = MapPointNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_EnableDeployable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            DeployableNum                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_EnableDeployable(int32_t DeployableNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_EnableDeployable");
		
		AReadyOrNotPlayerController_Server_EnableDeployable_Params params {};
		params.DeployableNum = DeployableNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_DisablePersonnel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PersonnelNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_DisablePersonnel(int32_t PersonnelNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_DisablePersonnel");
		
		AReadyOrNotPlayerController_Server_DisablePersonnel_Params params {};
		params.PersonnelNum = PersonnelNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_DisableDeployable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            DeployableNum                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_DisableDeployable(int32_t DeployableNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_DisableDeployable");
		
		AReadyOrNotPlayerController_Server_DisableDeployable_Params params {};
		params.DeployableNum = DeployableNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_ClearDrawingPointData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bClearAll                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bClearAllFloors                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            FloorNum                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_ClearDrawingPointData(bool bClearAll, bool bClearAllFloors, int32_t FloorNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_ClearDrawingPointData");
		
		AReadyOrNotPlayerController_Server_ClearDrawingPointData_Params params {};
		params.bClearAll = bClearAll;
		params.bClearAllFloors = bClearAllFloors;
		params.FloorNum = FloorNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_BecomeVIP
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Server_BecomeVIP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_BecomeVIP");
		
		AReadyOrNotPlayerController_Server_BecomeVIP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminRestartServer
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Server_AdminRestartServer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminRestartServer");
		
		AReadyOrNotPlayerController_Server_AdminRestartServer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminRemoveMapFromRotationByIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Idx                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_AdminRemoveMapFromRotationByIndex(int32_t Idx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminRemoveMapFromRotationByIndex");
		
		AReadyOrNotPlayerController_Server_AdminRemoveMapFromRotationByIndex_Params params {};
		params.Idx = Idx;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminRemoveMapFromRotation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MapURL                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_AdminRemoveMapFromRotation(const class FString& MapURL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminRemoveMapFromRotation");
		
		AReadyOrNotPlayerController_Server_AdminRemoveMapFromRotation_Params params {};
		params.MapURL = MapURL;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminNextMap
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Server_AdminNextMap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminNextMap");
		
		AReadyOrNotPlayerController_Server_AdminNextMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminKickPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                KickingPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        ReasonOveride                                              (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_AdminKickPlayer(class APlayerState* KickingPlayerState, const class FText& ReasonOveride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminKickPlayer");
		
		AReadyOrNotPlayerController_Server_AdminKickPlayer_Params params {};
		params.KickingPlayerState = KickingPlayerState;
		params.ReasonOveride = ReasonOveride;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminBanPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerState*                                BanningPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_AdminBanPlayer(class APlayerState* BanningPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminBanPlayer");
		
		AReadyOrNotPlayerController_Server_AdminBanPlayer_Params params {};
		params.BanningPlayerState = BanningPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminAddMapToRotationAtIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MapURL                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Idx                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_AdminAddMapToRotationAtIndex(const class FString& MapURL, int32_t Idx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminAddMapToRotationAtIndex");
		
		AReadyOrNotPlayerController_Server_AdminAddMapToRotationAtIndex_Params params {};
		params.MapURL = MapURL;
		params.Idx = Idx;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminAddMapToRotation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MapURL                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_AdminAddMapToRotation(const class FString& MapURL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_AdminAddMapToRotation");
		
		AReadyOrNotPlayerController_Server_AdminAddMapToRotation_Params params {};
		params.MapURL = MapURL;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_AddMarker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlanningMarker                             Marker                                                     (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_AddMarker(const struct FPlanningMarker& Marker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_AddMarker");
		
		AReadyOrNotPlayerController_Server_AddMarker_Params params {};
		params.Marker = Marker;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_AddLine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlanningLine                               Line                                                       (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_AddLine(const struct FPlanningLine& Line)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_AddLine");
		
		AReadyOrNotPlayerController_Server_AddLine_Params params {};
		params.Line = Line;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Server_AddDrawingPointData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector2D                      DrawingPointData                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            FloorNum                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFreeDrawColor                                     Color                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNewPoint                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Server_AddDrawingPointData(const struct FCoreUObject_FVector2D& DrawingPointData, int32_t FloorNum, EFreeDrawColor Color, bool bNewPoint, float Thickness)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Server_AddDrawingPointData");
		
		AReadyOrNotPlayerController_Server_AddDrawingPointData_Params params {};
		params.DrawingPointData = DrawingPointData;
		params.FloorNum = FloorNum;
		params.Color = Color;
		params.bNewPoint = bNewPoint;
		params.Thickness = Thickness;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SendChatMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRChatMessage                               ChatMessage                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::SendChatMessage(const struct FRChatMessage& ChatMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SendChatMessage");
		
		AReadyOrNotPlayerController_SendChatMessage_Params params {};
		params.ChatMessage = ChatMessage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SaveFileToUserCloud
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      FullPath                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotPlayerController::SaveFileToUserCloud(const class FString& FullPath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SaveFileToUserCloud");
		
		AReadyOrNotPlayerController_SaveFileToUserCloud_Params params {};
		params.FullPath = FullPath;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.SaveChatMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRChatMessage                               Message                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::SaveChatMessage(const struct FRChatMessage& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.SaveChatMessage");
		
		AReadyOrNotPlayerController_SaveChatMessage_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.RetrieveChatLog
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRChatMessage>                       OutMessages                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::RetrieveChatLog(TArray<struct FRChatMessage>* OutMessages)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.RetrieveChatLog");
		
		AReadyOrNotPlayerController_RetrieveChatLog_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutMessages != nullptr)
			*OutMessages = params.OutMessages;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ResetKeybinds
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ResetKeybinds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ResetKeybinds");
		
		AReadyOrNotPlayerController_ResetKeybinds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ResetDoorLockStateKnowledge
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ResetDoorLockStateKnowledge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ResetDoorLockStateKnowledge");
		
		AReadyOrNotPlayerController_ResetDoorLockStateKnowledge_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ResetAI
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::ResetAI(float Range)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ResetAI");
		
		AReadyOrNotPlayerController_ResetAI_Params params {};
		params.Range = Range;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.RequestVoteInput
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVoteData                                   CurrentVoteData                                            (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::RequestVoteInput(const struct FVoteData& CurrentVoteData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.RequestVoteInput");
		
		AReadyOrNotPlayerController_RequestVoteInput_Params params {};
		params.CurrentVoteData = CurrentVoteData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ReportAllInstancedStaticMeshes
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ReportAllInstancedStaticMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ReportAllInstancedStaticMeshes");
		
		AReadyOrNotPlayerController_ReportAllInstancedStaticMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ReplicateMapListIfAdmin
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ReplicateMapListIfAdmin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ReplicateMapListIfAdmin");
		
		AReadyOrNotPlayerController_ReplicateMapListIfAdmin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.RemoveWeaponSkin
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::RemoveWeaponSkin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.RemoveWeaponSkin");
		
		AReadyOrNotPlayerController_RemoveWeaponSkin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.RemoveHUD
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::RemoveHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.RemoveHUD");
		
		AReadyOrNotPlayerController_RemoveHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.RemoveCharacterSkin
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::RemoveCharacterSkin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.RemoveCharacterSkin");
		
		AReadyOrNotPlayerController_RemoveCharacterSkin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ReleaseVIP
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ReleaseVIP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ReleaseVIP");
		
		AReadyOrNotPlayerController_ReleaseVIP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.PrintGPUBrand
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::PrintGPUBrand()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.PrintGPUBrand");
		
		AReadyOrNotPlayerController_PrintGPUBrand_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.PlayDeadAllEnemies
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::PlayDeadAllEnemies()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.PlayDeadAllEnemies");
		
		AReadyOrNotPlayerController_PlayDeadAllEnemies_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.PlayAnimationFromLookupTable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      AnimationRowName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::PlayAnimationFromLookupTable(const class FString& AnimationRowName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.PlayAnimationFromLookupTable");
		
		AReadyOrNotPlayerController_PlayAnimationFromLookupTable_Params params {};
		params.AnimationRowName = AnimationRowName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.PassMouseControlToValidWidget
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::PassMouseControlToValidWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.PassMouseControlToValidWidget");
		
		AReadyOrNotPlayerController_PassMouseControlToValidWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.OptimizeWorld
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::OptimizeWorld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.OptimizeWorld");
		
		AReadyOrNotPlayerController_OptimizeWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnVoiceChannelChanged__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::OnVoiceChannelChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnVoiceChannelChanged__DelegateSignature");
		
		AReadyOrNotPlayerController_OnVoiceChannelChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.OnStreamedLevelLoadedRemovingLoadingScreen
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::OnStreamedLevelLoadedRemovingLoadingScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.OnStreamedLevelLoadedRemovingLoadingScreen");
		
		AReadyOrNotPlayerController_OnStreamedLevelLoadedRemovingLoadingScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.OnStreamedLevelLoadedExecuteOpen
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::OnStreamedLevelLoadedExecuteOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.OnStreamedLevelLoadedExecuteOpen");
		
		AReadyOrNotPlayerController_OnStreamedLevelLoadedExecuteOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.OnStreamedLevelLoadedComplete
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::OnStreamedLevelLoadedComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.OnStreamedLevelLoadedComplete");
		
		AReadyOrNotPlayerController_OnStreamedLevelLoadedComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.OnSessionJoinSuccess
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::OnSessionJoinSuccess()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.OnSessionJoinSuccess");
		
		AReadyOrNotPlayerController_OnSessionJoinSuccess_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.OnSessionJoinFailed
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::OnSessionJoinFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.OnSessionJoinFailed");
		
		AReadyOrNotPlayerController_OnSessionJoinFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.OnSaveLoadout
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::OnSaveLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.OnSaveLoadout");
		
		AReadyOrNotPlayerController_OnSaveLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnRTXDMOChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bRTXOn                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::OnRTXDMOChanged__DelegateSignature(bool bRTXOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnRTXDMOChanged__DelegateSignature");
		
		AReadyOrNotPlayerController_OnRTXDMOChanged__DelegateSignature_Params params {};
		params.bRTXOn = bRTXOn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.OnRep_Maplist
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::OnRep_Maplist()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.OnRep_Maplist");
		
		AReadyOrNotPlayerController_OnRep_Maplist_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnPreClientTravel__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::OnPreClientTravel__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnPreClientTravel__DelegateSignature");
		
		AReadyOrNotPlayerController_OnPreClientTravel__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnPawnPossessed__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APawn*                                       PossessedPawn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::OnPawnPossessed__DelegateSignature(class APawn* PossessedPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnPawnPossessed__DelegateSignature");
		
		AReadyOrNotPlayerController_OnPawnPossessed__DelegateSignature_Params params {};
		params.PossessedPawn = PossessedPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnOutOfBoundsChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsOutOfBounds                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::OnOutOfBoundsChanged__DelegateSignature(bool bIsOutOfBounds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnOutOfBoundsChanged__DelegateSignature");
		
		AReadyOrNotPlayerController_OnOutOfBoundsChanged__DelegateSignature_Params params {};
		params.bIsOutOfBounds = bIsOutOfBounds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnMapListReplicated__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FString>                              MapList                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::OnMapListReplicated__DelegateSignature(TArray<class FString> MapList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnMapListReplicated__DelegateSignature");
		
		AReadyOrNotPlayerController_OnMapListReplicated__DelegateSignature_Params params {};
		params.MapList = MapList;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.OnlyCastLocalPlayerDynamicShadow
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::OnlyCastLocalPlayerDynamicShadow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.OnlyCastLocalPlayerDynamicShadow");
		
		AReadyOrNotPlayerController_OnlyCastLocalPlayerDynamicShadow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.OnLevelOpen
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::OnLevelOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.OnLevelOpen");
		
		AReadyOrNotPlayerController_OnLevelOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnHudWidgetsCleared__DelegateSignature
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::OnHudWidgetsCleared__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotPlayerController.OnHudWidgetsCleared__DelegateSignature");
		
		AReadyOrNotPlayerController_OnHudWidgetsCleared__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.NotifyRespawnTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              RespawnTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::NotifyRespawnTime(float RespawnTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.NotifyRespawnTime");
		
		AReadyOrNotPlayerController_NotifyRespawnTime_Params params {};
		params.RespawnTime = RespawnTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Multicast_SetPersonnelAtPoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PersonnelNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MapPointNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Multicast_SetPersonnelAtPoint(int32_t PersonnelNum, int32_t MapPointNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Multicast_SetPersonnelAtPoint");
		
		AReadyOrNotPlayerController_Multicast_SetPersonnelAtPoint_Params params {};
		params.PersonnelNum = PersonnelNum;
		params.MapPointNum = MapPointNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Multicast_RemovePersonnelAtPoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PersonnelNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Multicast_RemovePersonnelAtPoint(int32_t PersonnelNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Multicast_RemovePersonnelAtPoint");
		
		AReadyOrNotPlayerController_Multicast_RemovePersonnelAtPoint_Params params {};
		params.PersonnelNum = PersonnelNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Multicast_ForcePlanningRefresh
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Multicast_ForcePlanningRefresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Multicast_ForcePlanningRefresh");
		
		AReadyOrNotPlayerController_Multicast_ForcePlanningRefresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.MeshMergeEverything
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::MeshMergeEverything()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.MeshMergeEverything");
		
		AReadyOrNotPlayerController_MeshMergeEverything_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.MakeCrash
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::MakeCrash()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.MakeCrash");
		
		AReadyOrNotPlayerController_MakeCrash_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.KnockoutAllEnemies
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::KnockoutAllEnemies()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.KnockoutAllEnemies");
		
		AReadyOrNotPlayerController_KnockoutAllEnemies_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.KillSWATTeam
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::KillSWATTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.KillSWATTeam");
		
		AReadyOrNotPlayerController_KillSWATTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Kill
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Kill(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Kill");
		
		AReadyOrNotPlayerController_Kill_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.IsCameraFading
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotPlayerController::IsCameraFading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.IsCameraFading");
		
		AReadyOrNotPlayerController_IsCameraFading_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.HideAllWeaponAttachments
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::HideAllWeaponAttachments()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.HideAllWeaponAttachments");
		
		AReadyOrNotPlayerController_HideAllWeaponAttachments_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.HideAllSmallItemMeshes
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::HideAllSmallItemMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.HideAllSmallItemMeshes");
		
		AReadyOrNotPlayerController_HideAllSmallItemMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.HideAllItemMeshes
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::HideAllItemMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.HideAllItemMeshes");
		
		AReadyOrNotPlayerController_HideAllItemMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.GiveSWATRam
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::GiveSWATRam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.GiveSWATRam");
		
		AReadyOrNotPlayerController_GiveSWATRam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.GibAllComponents
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::GibAllComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.GibAllComponents");
		
		AReadyOrNotPlayerController_GibAllComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.GetVote
	 * 		Flags  -> ()
	 */
	EVoteState AReadyOrNotPlayerController::GetVote()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.GetVote");
		
		AReadyOrNotPlayerController_GetVote_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.GetTeamType
	 * 		Flags  -> ()
	 */
	ETeamType AReadyOrNotPlayerController::GetTeamType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.GetTeamType");
		
		AReadyOrNotPlayerController_GetTeamType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.GetRespawnTimeRemaining
	 * 		Flags  -> ()
	 */
	float AReadyOrNotPlayerController::GetRespawnTimeRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.GetRespawnTimeRemaining");
		
		AReadyOrNotPlayerController_GetRespawnTimeRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.GetReplicatedMapRotation
	 * 		Flags  -> ()
	 */
	TArray<class FString> AReadyOrNotPlayerController::GetReplicatedMapRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.GetReplicatedMapRotation");
		
		AReadyOrNotPlayerController_GetReplicatedMapRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.GetPrefferredTeamUniqueNetIdOnConnection
	 * 		Flags  -> ()
	 */
	class FString AReadyOrNotPlayerController::GetPrefferredTeamUniqueNetIdOnConnection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.GetPrefferredTeamUniqueNetIdOnConnection");
		
		AReadyOrNotPlayerController_GetPrefferredTeamUniqueNetIdOnConnection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.GetPasswordOnConnection
	 * 		Flags  -> ()
	 */
	class FString AReadyOrNotPlayerController::GetPasswordOnConnection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.GetPasswordOnConnection");
		
		AReadyOrNotPlayerController_GetPasswordOnConnection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.GetNetworkConnectionStatus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              AvgLag                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutLostPackets                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InLostPackets                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutLostPacketPrcnt                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InLostPacketPrcnt                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::GetNetworkConnectionStatus(float* AvgLag, int32_t* OutLostPackets, int32_t* InLostPackets, int32_t* OutLostPacketPrcnt, int32_t* InLostPacketPrcnt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.GetNetworkConnectionStatus");
		
		AReadyOrNotPlayerController_GetNetworkConnectionStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (AvgLag != nullptr)
			*AvgLag = params.AvgLag;
		if (OutLostPackets != nullptr)
			*OutLostPackets = params.OutLostPackets;
		if (InLostPackets != nullptr)
			*InLostPackets = params.InLostPackets;
		if (OutLostPacketPrcnt != nullptr)
			*OutLostPacketPrcnt = params.OutLostPacketPrcnt;
		if (InLostPacketPrcnt != nullptr)
			*InLostPacketPrcnt = params.InLostPacketPrcnt;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.FreeVIP
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::FreeVIP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.FreeVIP");
		
		AReadyOrNotPlayerController_FreeVIP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.FlushDeadBodies
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::FlushDeadBodies()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.FlushDeadBodies");
		
		AReadyOrNotPlayerController_FlushDeadBodies_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.EscapeMenu
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::EscapeMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.EscapeMenu");
		
		AReadyOrNotPlayerController_EscapeMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.EquipAndDropEvidence
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::EquipAndDropEvidence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.EquipAndDropEvidence");
		
		AReadyOrNotPlayerController_EquipAndDropEvidence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Equip
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ItemName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Equip(const class FString& ItemName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Equip");
		
		AReadyOrNotPlayerController_Equip_Params params {};
		params.ItemName = ItemName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.EndVote
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::EndVote()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.EndVote");
		
		AReadyOrNotPlayerController_EndVote_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.EnableWeaponFovShader
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::EnableWeaponFovShader()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.EnableWeaponFovShader");
		
		AReadyOrNotPlayerController_EnableWeaponFovShader_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.EnableScopeAlignmentTool
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::EnableScopeAlignmentTool()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.EnableScopeAlignmentTool");
		
		AReadyOrNotPlayerController_EnableScopeAlignmentTool_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.EnablePlayerInput
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::EnablePlayerInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.EnablePlayerInput");
		
		AReadyOrNotPlayerController_EnablePlayerInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DropAllSuspectWeapons
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DropAllSuspectWeapons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DropAllSuspectWeapons");
		
		AReadyOrNotPlayerController_DropAllSuspectWeapons_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DownloadBlacklistHashes
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DownloadBlacklistHashes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DownloadBlacklistHashes");
		
		AReadyOrNotPlayerController_DownloadBlacklistHashes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DisplayAllPlayingFMODEvents
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DisplayAllPlayingFMODEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DisplayAllPlayingFMODEvents");
		
		AReadyOrNotPlayerController_DisplayAllPlayingFMODEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DisableWeaponFovShader
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DisableWeaponFovShader()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DisableWeaponFovShader");
		
		AReadyOrNotPlayerController_DisableWeaponFovShader_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DisableSkeletalMeshShadowCasting
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DisableSkeletalMeshShadowCasting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DisableSkeletalMeshShadowCasting");
		
		AReadyOrNotPlayerController_DisableSkeletalMeshShadowCasting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DisableForceShowMouseCursor
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DisableForceShowMouseCursor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DisableForceShowMouseCursor");
		
		AReadyOrNotPlayerController_DisableForceShowMouseCursor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DisableAllMaterials
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DisableAllMaterials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DisableAllMaterials");
		
		AReadyOrNotPlayerController_DisableAllMaterials_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DisableAllItemTicks
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DisableAllItemTicks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DisableAllItemTicks");
		
		AReadyOrNotPlayerController_DisableAllItemTicks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DisableAllItemMaterials
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DisableAllItemMaterials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DisableAllItemMaterials");
		
		AReadyOrNotPlayerController_DisableAllItemMaterials_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroySwatTeam
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroySwatTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroySwatTeam");
		
		AReadyOrNotPlayerController_DestroySwatTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroySwatInventoryItems
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroySwatInventoryItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroySwatInventoryItems");
		
		AReadyOrNotPlayerController_DestroySwatInventoryItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroySwatControllers
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroySwatControllers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroySwatControllers");
		
		AReadyOrNotPlayerController_DestroySwatControllers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroySwatAnimation
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroySwatAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroySwatAnimation");
		
		AReadyOrNotPlayerController_DestroySwatAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroyEverything
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroyEverything()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroyEverything");
		
		AReadyOrNotPlayerController_DestroyEverything_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllWorldDynamicItems
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroyAllWorldDynamicItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllWorldDynamicItems");
		
		AReadyOrNotPlayerController_DestroyAllWorldDynamicItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllWidgets
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroyAllWidgets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllWidgets");
		
		AReadyOrNotPlayerController_DestroyAllWidgets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllSuspects
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroyAllSuspects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllSuspects");
		
		AReadyOrNotPlayerController_DestroyAllSuspects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllLights
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroyAllLights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllLights");
		
		AReadyOrNotPlayerController_DestroyAllLights_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllItems
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroyAllItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllItems");
		
		AReadyOrNotPlayerController_DestroyAllItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllItemMeshes
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroyAllItemMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllItemMeshes");
		
		AReadyOrNotPlayerController_DestroyAllItemMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllExceptClosestDoor
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroyAllExceptClosestDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllExceptClosestDoor");
		
		AReadyOrNotPlayerController_DestroyAllExceptClosestDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllExceptClosestCharacter
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroyAllExceptClosestCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllExceptClosestCharacter");
		
		AReadyOrNotPlayerController_DestroyAllExceptClosestCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllDynamicLights
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroyAllDynamicLights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllDynamicLights");
		
		AReadyOrNotPlayerController_DestroyAllDynamicLights_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllDecals
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroyAllDecals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllDecals");
		
		AReadyOrNotPlayerController_DestroyAllDecals_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllAI
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DestroyAllAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllAI");
		
		AReadyOrNotPlayerController_DestroyAllAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllActorsOfName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::DestroyAllActorsOfName(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DestroyAllActorsOfName");
		
		AReadyOrNotPlayerController_DestroyAllActorsOfName_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DeleteAnyNonMeshComponents
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DeleteAnyNonMeshComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DeleteAnyNonMeshComponents");
		
		AReadyOrNotPlayerController_DeleteAnyNonMeshComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DebugMigrateHost
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DebugMigrateHost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DebugMigrateHost");
		
		AReadyOrNotPlayerController_DebugMigrateHost_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.DebugClientStartHostMigration
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::DebugClientStartHostMigration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.DebugClientStartHostMigration");
		
		AReadyOrNotPlayerController_DebugClientStartHostMigration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ClientStartOnlineGame
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ClientStartOnlineGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ClientStartOnlineGame");
		
		AReadyOrNotPlayerController_ClientStartOnlineGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ClientSpawned
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ClientSpawned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ClientSpawned");
		
		AReadyOrNotPlayerController_ClientSpawned_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ClientSetSpectatorCamera
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        CameraLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FRotator                       CameraRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::ClientSetSpectatorCamera(const struct FCoreUObject_FVector& CameraLocation, const struct FCoreUObject_FRotator& CameraRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ClientSetSpectatorCamera");
		
		AReadyOrNotPlayerController_ClientSetSpectatorCamera_Params params {};
		params.CameraLocation = CameraLocation;
		params.CameraRotation = CameraRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ClientSetNetSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewNetSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::ClientSetNetSpeed(int32_t NewNetSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ClientSetNetSpeed");
		
		AReadyOrNotPlayerController_ClientSetNetSpeed_Params params {};
		params.NewNetSpeed = NewNetSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ClientJoinVoice
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      OnlineSessionId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TeamNum                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::ClientJoinVoice(const class FString& OnlineSessionId, int32_t TeamNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ClientJoinVoice");
		
		AReadyOrNotPlayerController_ClientJoinVoice_Params params {};
		params.OnlineSessionId = OnlineSessionId;
		params.TeamNum = TeamNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ClientEndOnlineGame
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ClientEndOnlineGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ClientEndOnlineGame");
		
		AReadyOrNotPlayerController_ClientEndOnlineGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Client_SetViewTargetWithBlend
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APawn*                                       NewViewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Client_SetViewTargetWithBlend(class APawn* NewViewTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Client_SetViewTargetWithBlend");
		
		AReadyOrNotPlayerController_Client_SetViewTargetWithBlend_Params params {};
		params.NewViewTarget = NewViewTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Client_SetControlRotation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FRotator                       NewControlRotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Client_SetControlRotation(const struct FCoreUObject_FRotator& NewControlRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Client_SetControlRotation");
		
		AReadyOrNotPlayerController_Client_SetControlRotation_Params params {};
		params.NewControlRotation = NewControlRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Client_RemoveWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Widget                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Client_RemoveWidget(class UClass* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Client_RemoveWidget");
		
		AReadyOrNotPlayerController_Client_RemoveWidget_Params params {};
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Client_PostLogin
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Client_PostLogin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Client_PostLogin");
		
		AReadyOrNotPlayerController_Client_PostLogin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Client_HideHUDWidgets
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Client_HideHUDWidgets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Client_HideHUDWidgets");
		
		AReadyOrNotPlayerController_Client_HideHUDWidgets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Client_GetStats
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Client_GetStats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Client_GetStats");
		
		AReadyOrNotPlayerController_Client_GetStats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Client_DisableUIMouse
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Client_DisableUIMouse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Client_DisableUIMouse");
		
		AReadyOrNotPlayerController_Client_DisableUIMouse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Client_CreateWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      WidgetName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceAddToWidgetStack                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsEscapeKey                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Client_CreateWidget(const class FString& WidgetName, bool bForceAddToWidgetStack, bool bIsEscapeKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Client_CreateWidget");
		
		AReadyOrNotPlayerController_Client_CreateWidget_Params params {};
		params.WidgetName = WidgetName;
		params.bForceAddToWidgetStack = bForceAddToWidgetStack;
		params.bIsEscapeKey = bIsEscapeKey;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Client_CreateMessageDisplay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MessageTxt                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ButtonTxt                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Client_CreateMessageDisplay(const class FString& MessageTxt, const class FString& ButtonTxt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Client_CreateMessageDisplay");
		
		AReadyOrNotPlayerController_Client_CreateMessageDisplay_Params params {};
		params.MessageTxt = MessageTxt;
		params.ButtonTxt = ButtonTxt;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Client_CreateLoadingScreen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Map                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Mode                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      SessionName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsSeamlessTravel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::Client_CreateLoadingScreen(const class FString& Map, const class FString& Mode, const class FString& SessionName, bool bIsSeamlessTravel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Client_CreateLoadingScreen");
		
		AReadyOrNotPlayerController_Client_CreateLoadingScreen_Params params {};
		params.Map = Map;
		params.Mode = Mode;
		params.SessionName = SessionName;
		params.bIsSeamlessTravel = bIsSeamlessTravel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.Client_ClearHUDWidgets
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::Client_ClearHUDWidgets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.Client_ClearHUDWidgets");
		
		AReadyOrNotPlayerController_Client_ClearHUDWidgets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.CanSetSpawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESelectedSpawn                                     NewSpawnPoint                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSameSpawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotPlayerController::CanSetSpawn(ETeamType Team, ESelectedSpawn NewSpawnPoint, bool bSameSpawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.CanSetSpawn");
		
		AReadyOrNotPlayerController_CanSetSpawn_Params params {};
		params.Team = Team;
		params.NewSpawnPoint = NewSpawnPoint;
		params.bSameSpawn = bSameSpawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.CanSetDepotTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            NewDepot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSameDepot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotPlayerController::CanSetDepotTo(int32_t NewDepot, bool bSameDepot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.CanSetDepotTo");
		
		AReadyOrNotPlayerController_CanSetDepotTo_Params params {};
		params.NewDepot = NewDepot;
		params.bSameDepot = bSameDepot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.CanEnablePersonnel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PersonnelNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MapPointNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotPlayerController::CanEnablePersonnel(int32_t PersonnelNum, int32_t MapPointNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.CanEnablePersonnel");
		
		AReadyOrNotPlayerController_CanEnablePersonnel_Params params {};
		params.PersonnelNum = PersonnelNum;
		params.MapPointNum = MapPointNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.CanEnableDeployable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            DeployableNum                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotPlayerController::CanEnableDeployable(int32_t DeployableNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.CanEnableDeployable");
		
		AReadyOrNotPlayerController_CanEnableDeployable_Params params {};
		params.DeployableNum = DeployableNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.CanDisablePersonnel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PersonnelNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotPlayerController::CanDisablePersonnel(int32_t PersonnelNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.CanDisablePersonnel");
		
		AReadyOrNotPlayerController_CanDisablePersonnel_Params params {};
		params.PersonnelNum = PersonnelNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.CanDisableDeployable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            DeployableNum                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotPlayerController::CanDisableDeployable(int32_t DeployableNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.CanDisableDeployable");
		
		AReadyOrNotPlayerController_CanDisableDeployable_Params params {};
		params.DeployableNum = DeployableNum;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.BP_ReturnToMenu
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        ReturnReason                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::BP_ReturnToMenu(const class FText& ReturnReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.BP_ReturnToMenu");
		
		AReadyOrNotPlayerController_BP_ReturnToMenu_Params params {};
		params.ReturnReason = ReturnReason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.BP_HandleMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRChatMessage                               ChatMessage                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::BP_HandleMessage(const struct FRChatMessage& ChatMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.BP_HandleMessage");
		
		AReadyOrNotPlayerController_BP_HandleMessage_Params params {};
		params.ChatMessage = ChatMessage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.BP_ClientWasKicked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        KickReason                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::BP_ClientWasKicked(const class FText& KickReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.BP_ClientWasKicked");
		
		AReadyOrNotPlayerController_BP_ClientWasKicked_Params params {};
		params.KickReason = KickReason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.BeginVote
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      reason                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Question                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               CanVoteNo                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::BeginVote(const class FString& reason, const class FString& Question, bool CanVoteNo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.BeginVote");
		
		AReadyOrNotPlayerController_BeginVote_Params params {};
		params.reason = reason;
		params.Question = Question;
		params.CanVoteNo = CanVoteNo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ArrestOne
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::ArrestOne()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ArrestOne");
		
		AReadyOrNotPlayerController_ArrestOne_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ApplyWeaponSkin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SkinName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::ApplyWeaponSkin(const class FString& SkinName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ApplyWeaponSkin");
		
		AReadyOrNotPlayerController_ApplyWeaponSkin_Params params {};
		params.SkinName = SkinName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.ApplyCharacterSkin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SkinName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::ApplyCharacterSkin(const class FString& SkinName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.ApplyCharacterSkin");
		
		AReadyOrNotPlayerController_ApplyCharacterSkin_Params params {};
		params.SkinName = SkinName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.AIStopHide
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::AIStopHide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.AIStopHide");
		
		AReadyOrNotPlayerController_AIStopHide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.AIHide
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::AIHide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.AIHide");
		
		AReadyOrNotPlayerController_AIHide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.AIEquipSecondary
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::AIEquipSecondary()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.AIEquipSecondary");
		
		AReadyOrNotPlayerController_AIEquipSecondary_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.AIEquipPrimary
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::AIEquipPrimary()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.AIEquipPrimary");
		
		AReadyOrNotPlayerController_AIEquipPrimary_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.AcknowledgeVote
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVoteData                                   CurrentVoteData                                            (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerController::AcknowledgeVote(const struct FVoteData& CurrentVoteData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.AcknowledgeVote");
		
		AReadyOrNotPlayerController_AcknowledgeVote_Params params {};
		params.CurrentVoteData = CurrentVoteData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerController.AbortCover
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerController::AbortCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerController.AbortCover");
		
		AReadyOrNotPlayerController_AbortCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotPlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotPlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotPlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.UpdateScore
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerState::UpdateScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.UpdateScore");
		
		AReadyOrNotPlayerState_UpdateScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.SetTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          NewTeam                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::SetTeam(ETeamType NewTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.SetTeam");
		
		AReadyOrNotPlayerState_SetTeam_Params params {};
		params.NewTeam = NewTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.SetReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsReady                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSavedLoadout                               NewLoadout                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::SetReady(bool bIsReady, const struct FSavedLoadout& NewLoadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.SetReady");
		
		AReadyOrNotPlayerState_SetReady_Params params {};
		params.bIsReady = bIsReady;
		params.NewLoadout = NewLoadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.SetIsTalking
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewTalking                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::SetIsTalking(bool bNewTalking)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.SetIsTalking");
		
		AReadyOrNotPlayerState_SetIsTalking_Params params {};
		params.bNewTalking = bNewTalking;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.ServerSetJoinedOnSquadLeader
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerState::ServerSetJoinedOnSquadLeader()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.ServerSetJoinedOnSquadLeader");
		
		AReadyOrNotPlayerState_ServerSetJoinedOnSquadLeader_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.Server_UpdatePlayerSpawnTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      NewTag                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::Server_UpdatePlayerSpawnTag(const class FString& NewTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.Server_UpdatePlayerSpawnTag");
		
		AReadyOrNotPlayerState_Server_UpdatePlayerSpawnTag_Params params {};
		params.NewTag = NewTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.Server_UpdateDrawing
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlanningDrawing                            Drawing                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::Server_UpdateDrawing(const struct FPlanningDrawing& Drawing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.Server_UpdateDrawing");
		
		AReadyOrNotPlayerState_Server_UpdateDrawing_Params params {};
		params.Drawing = Drawing;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.Server_SetVoiceType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EVoiceType                                         NewVoiceType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::Server_SetVoiceType(EVoiceType NewVoiceType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.Server_SetVoiceType");
		
		AReadyOrNotPlayerState_Server_SetVoiceType_Params params {};
		params.NewVoiceType = NewVoiceType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.Server_SetTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          NewTeam                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::Server_SetTeam(ETeamType NewTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.Server_SetTeam");
		
		AReadyOrNotPlayerState_Server_SetTeam_Params params {};
		params.NewTeam = NewTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.Server_SetReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsReady                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSavedLoadout                               NewLoadout                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::Server_SetReady(bool bIsReady, const struct FSavedLoadout& NewLoadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.Server_SetReady");
		
		AReadyOrNotPlayerState_Server_SetReady_Params params {};
		params.bIsReady = bIsReady;
		params.NewLoadout = NewLoadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.Server_SetPlayerName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        NewPlayerName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::Server_SetPlayerName(const class FName& NewPlayerName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.Server_SetPlayerName");
		
		AReadyOrNotPlayerState_Server_SetPlayerName_Params params {};
		params.NewPlayerName = NewPlayerName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.Server_SetLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSavedLoadout                               NewLoadout                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::Server_SetLoadout(const struct FSavedLoadout& NewLoadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.Server_SetLoadout");
		
		AReadyOrNotPlayerState_Server_SetLoadout_Params params {};
		params.NewLoadout = NewLoadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.Server_SetIsInGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewIsInGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::Server_SetIsInGame(bool bNewIsInGame)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.Server_SetIsInGame");
		
		AReadyOrNotPlayerState_Server_SetIsInGame_Params params {};
		params.bNewIsInGame = bNewIsInGame;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.Server_SendUnlockedDLC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDLC                                               Dlc                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::Server_SendUnlockedDLC(EDLC Dlc)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.Server_SendUnlockedDLC");
		
		AReadyOrNotPlayerState_Server_SendUnlockedDLC_Params params {};
		params.Dlc = Dlc;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.Server_FinishDrawing
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlanningDrawing                            Drawing                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::Server_FinishDrawing(const struct FPlanningDrawing& Drawing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.Server_FinishDrawing");
		
		AReadyOrNotPlayerState_Server_FinishDrawing_Params params {};
		params.Drawing = Drawing;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.ResetBulletsFired
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerState::ResetBulletsFired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.ResetBulletsFired");
		
		AReadyOrNotPlayerState_ResetBulletsFired_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.OnRep_UpdateServerSavedLoadout
	 * 		Flags  -> ()
	 */
	void AReadyOrNotPlayerState::OnRep_UpdateServerSavedLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.OnRep_UpdateServerSavedLoadout");
		
		AReadyOrNotPlayerState_OnRep_UpdateServerSavedLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.ReadyOrNotPlayerState.OnPlayerLoadoutChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSavedLoadout                               NewLoadout                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::OnPlayerLoadoutChanged__DelegateSignature(const struct FSavedLoadout& NewLoadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.ReadyOrNotPlayerState.OnPlayerLoadoutChanged__DelegateSignature");
		
		AReadyOrNotPlayerState_OnPlayerLoadoutChanged__DelegateSignature_Params params {};
		params.NewLoadout = NewLoadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.Notify_PendingChangeTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          NewTeamType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::Notify_PendingChangeTeam(ETeamType NewTeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.Notify_PendingChangeTeam");
		
		AReadyOrNotPlayerState_Notify_PendingChangeTeam_Params params {};
		params.NewTeamType = NewTeamType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.IsVipPlayerState
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotPlayerState::IsVipPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.IsVipPlayerState");
		
		AReadyOrNotPlayerState_IsVipPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.IsTalking
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotPlayerState::IsTalking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.IsTalking");
		
		AReadyOrNotPlayerState_IsTalking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.IsSquadLeader
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotPlayerState::IsSquadLeader()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.IsSquadLeader");
		
		AReadyOrNotPlayerState_IsSquadLeader_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.IsOwnerOfPlayerState
	 * 		Flags  -> ()
	 */
	bool AReadyOrNotPlayerState::IsOwnerOfPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.IsOwnerOfPlayerState");
		
		AReadyOrNotPlayerState_IsOwnerOfPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.IncrementBulletsFired
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::IncrementBulletsFired(class ABaseWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.IncrementBulletsFired");
		
		AReadyOrNotPlayerState_IncrementBulletsFired_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.HasEveryoneFinishedLoading
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            OutTotal                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutLoading                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutLoaded                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReadyOrNotPlayerState::HasEveryoneFinishedLoading(int32_t* OutTotal, int32_t* OutLoading, int32_t* OutLoaded)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.HasEveryoneFinishedLoading");
		
		AReadyOrNotPlayerState_HasEveryoneFinishedLoading_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTotal != nullptr)
			*OutTotal = params.OutTotal;
		if (OutLoading != nullptr)
			*OutLoading = params.OutLoading;
		if (OutLoaded != nullptr)
			*OutLoaded = params.OutLoaded;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.GetVoiceType
	 * 		Flags  -> ()
	 */
	EVoiceType AReadyOrNotPlayerState::GetVoiceType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.GetVoiceType");
		
		AReadyOrNotPlayerState_GetVoiceType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.GetTeam
	 * 		Flags  -> ()
	 */
	ETeamType AReadyOrNotPlayerState::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.GetTeam");
		
		AReadyOrNotPlayerState_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.GetPendingTeam
	 * 		Flags  -> ()
	 */
	ETeamType AReadyOrNotPlayerState::GetPendingTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.GetPendingTeam");
		
		AReadyOrNotPlayerState_GetPendingTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.GetNetworkStatus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              AvgLag                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotPlayerState::GetNetworkStatus(float* AvgLag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.GetNetworkStatus");
		
		AReadyOrNotPlayerState_GetNetworkStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (AvgLag != nullptr)
			*AvgLag = params.AvgLag;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.GetKillCount
	 * 		Flags  -> ()
	 */
	int32_t AReadyOrNotPlayerState::GetKillCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.GetKillCount");
		
		AReadyOrNotPlayerState_GetKillCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotPlayerState.GetDeathCount
	 * 		Flags  -> ()
	 */
	int32_t AReadyOrNotPlayerState::GetDeathCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotPlayerState.GetDeathCount");
		
		AReadyOrNotPlayerState_GetDeathCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotPlayerState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotPlayerState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotPlayerState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotProjectile.OnHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComp                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AReadyOrNotProjectile::OnHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotProjectile.OnHit");
		
		AReadyOrNotProjectile_OnHit_Params params {};
		params.HitComp = HitComp;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotProjectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotRecastNavMesh.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotRecastNavMesh::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotRecastNavMesh");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotReplicationDriver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotReplicationDriver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotReplicationDriver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReadyOrNotSignificanceManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReadyOrNotSignificanceManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotSignificanceManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotSpinTestController.StopProfiling
	 * 		Flags  -> ()
	 */
	void UReadyOrNotSpinTestController::StopProfiling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotSpinTestController.StopProfiling");
		
		UReadyOrNotSpinTestController_StopProfiling_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotSpinTestController.StartTesting
	 * 		Flags  -> ()
	 */
	void UReadyOrNotSpinTestController::StartTesting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotSpinTestController.StartTesting");
		
		UReadyOrNotSpinTestController_StartTesting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotSpinTestController.On60FPSTick
	 * 		Flags  -> ()
	 */
	void UReadyOrNotSpinTestController::On60FPSTick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotSpinTestController.On60FPSTick");
		
		UReadyOrNotSpinTestController_On60FPSTick_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotSpinTestController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotSpinTestController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotSpinTestController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotStatics.GetReadyOrNotSignificanceManager
	 * 		Flags  -> ()
	 */
	class AReadyOrNotSignificanceManager* UReadyOrNotStatics::GetReadyOrNotSignificanceManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotStatics.GetReadyOrNotSignificanceManager");
		
		UReadyOrNotStatics_GetReadyOrNotSignificanceManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotStatics.GetReadyOrNotPlayerController
	 * 		Flags  -> ()
	 */
	class AReadyOrNotPlayerController* UReadyOrNotStatics::GetReadyOrNotPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotStatics.GetReadyOrNotPlayerController");
		
		UReadyOrNotStatics_GetReadyOrNotPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotStatics.GetReadyOrNotLevelScript
	 * 		Flags  -> ()
	 */
	class AReadyOrNotLevelScript* UReadyOrNotStatics::GetReadyOrNotLevelScript()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotStatics.GetReadyOrNotLevelScript");
		
		UReadyOrNotStatics_GetReadyOrNotLevelScript_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotStatics.GetReadyOrNotGameState
	 * 		Flags  -> ()
	 */
	class AReadyOrNotGameState* UReadyOrNotStatics::GetReadyOrNotGameState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotStatics.GetReadyOrNotGameState");
		
		UReadyOrNotStatics_GetReadyOrNotGameState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotStatics.GetReadyOrNotGameMode
	 * 		Flags  -> ()
	 */
	class AReadyOrNotGameMode* UReadyOrNotStatics::GetReadyOrNotGameMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotStatics.GetReadyOrNotGameMode");
		
		UReadyOrNotStatics_GetReadyOrNotGameMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotStatics.GetReadyOrNotGameInstance
	 * 		Flags  -> ()
	 */
	class UReadyOrNotGameInstance* UReadyOrNotStatics::GetReadyOrNotGameInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotStatics.GetReadyOrNotGameInstance");
		
		UReadyOrNotStatics_GetReadyOrNotGameInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotStatics.GetConversationManager
	 * 		Flags  -> ()
	 */
	class AConversationManager* UReadyOrNotStatics::GetConversationManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotStatics.GetConversationManager");
		
		UReadyOrNotStatics_GetConversationManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotStatics.DoesMapExist
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Map                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReadyOrNotStatics::DoesMapExist(const class FString& Map)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotStatics.DoesMapExist");
		
		UReadyOrNotStatics_DoesMapExist_Params params {};
		params.Map = Map;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReadyOrNotVoiceConfig.Get
	 * 		Flags  -> ()
	 */
	class UReadyOrNotVoiceConfig* UReadyOrNotVoiceConfig::Get()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReadyOrNotVoiceConfig.Get");
		
		UReadyOrNotVoiceConfig_Get_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotVoiceConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotVoiceConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotVoiceConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReadyOrNotWeaponAnimData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReadyOrNotWeaponAnimData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReadyOrNotWeaponAnimData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RealtimeWidget.OnSynchronizeProperties
	 * 		Flags  -> ()
	 */
	void URealtimeWidget::OnSynchronizeProperties()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RealtimeWidget.OnSynchronizeProperties");
		
		URealtimeWidget_OnSynchronizeProperties_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URealtimeWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URealtimeWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RealtimeWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReceiveAISenseUpdates.OnAIPerceptionSense
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticController*                       InSenseController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAIStimulus                                 Stimulus                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OutOverrideSensedActor                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReceiveAISenseUpdates::OnAIPerceptionSense(class ACyberneticController* InSenseController, const struct FAIStimulus& Stimulus, class AActor** OutOverrideSensedActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReceiveAISenseUpdates.OnAIPerceptionSense");
		
		UReceiveAISenseUpdates_OnAIPerceptionSense_Params params {};
		params.InSenseController = InSenseController;
		params.Stimulus = Stimulus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutOverrideSensedActor != nullptr)
			*OutOverrideSensedActor = params.OutOverrideSensedActor;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReceiveAISenseUpdates.OnAIHearingSense
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticController*                       InSenseController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAIStimulus                                 Stimulus                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OutOverrideSensedActor                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReceiveAISenseUpdates::OnAIHearingSense(class ACyberneticController* InSenseController, const struct FAIStimulus& Stimulus, class AActor** OutOverrideSensedActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReceiveAISenseUpdates.OnAIHearingSense");
		
		UReceiveAISenseUpdates_OnAIHearingSense_Params params {};
		params.InSenseController = InSenseController;
		params.Stimulus = Stimulus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutOverrideSensedActor != nullptr)
			*OutOverrideSensedActor = params.OutOverrideSensedActor;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReceiveAISenseUpdates.OnAIDamageSense
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticController*                       InSenseController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAIStimulus                                 Stimulus                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OutOverrideSensedActor                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReceiveAISenseUpdates::OnAIDamageSense(class ACyberneticController* InSenseController, const struct FAIStimulus& Stimulus, class AActor** OutOverrideSensedActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReceiveAISenseUpdates.OnAIDamageSense");
		
		UReceiveAISenseUpdates_OnAIDamageSense_Params params {};
		params.InSenseController = InSenseController;
		params.Stimulus = Stimulus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutOverrideSensedActor != nullptr)
			*OutOverrideSensedActor = params.OutOverrideSensedActor;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReceiveAISenseUpdates.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReceiveAISenseUpdates::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReceiveAISenseUpdates");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReloadSafelyActivity.ReloadFinished
	 * 		Flags  -> ()
	 */
	void UReloadSafelyActivity::ReloadFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReloadSafelyActivity.ReloadFinished");
		
		UReloadSafelyActivity_ReloadFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReloadSafelyActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReloadSafelyActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReloadSafelyActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayCameraPawn.StopFollowingSpline
	 * 		Flags  -> ()
	 */
	void AReplayCameraPawn::StopFollowingSpline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayCameraPawn.StopFollowingSpline");
		
		AReplayCameraPawn_StopFollowingSpline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayCameraPawn.RemoveSplinePoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReplayCameraPawn::RemoveSplinePoint(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayCameraPawn.RemoveSplinePoint");
		
		AReplayCameraPawn_RemoveSplinePoint_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayCameraPawn.GetSplinePoints
	 * 		Flags  -> ()
	 */
	TArray<struct FSplinePoint> AReplayCameraPawn::GetSplinePoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayCameraPawn.GetSplinePoints");
		
		AReplayCameraPawn_GetSplinePoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayCameraPawn.GetBonesFromAttachableAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class FName> AReplayCameraPawn::GetBonesFromAttachableAction(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayCameraPawn.GetBonesFromAttachableAction");
		
		AReplayCameraPawn_GetBonesFromAttachableAction_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayCameraPawn.GetAttachableActors
	 * 		Flags  -> ()
	 */
	TArray<class AActor*> AReplayCameraPawn::GetAttachableActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayCameraPawn.GetAttachableActors");
		
		AReplayCameraPawn_GetAttachableActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayCameraPawn.ClearSplinePoints
	 * 		Flags  -> ()
	 */
	void AReplayCameraPawn::ClearSplinePoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayCameraPawn.ClearSplinePoints");
		
		AReplayCameraPawn_ClearSplinePoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayCameraPawn.BeginFollowingSpline
	 * 		Flags  -> ()
	 */
	void AReplayCameraPawn::BeginFollowingSpline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayCameraPawn.BeginFollowingSpline");
		
		AReplayCameraPawn_BeginFollowingSpline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayCameraPawn.AddSplinePoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FRotator                       Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AReplayCameraPawn::AddSplinePoint(const struct FCoreUObject_FVector& Location, const struct FCoreUObject_FRotator& Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayCameraPawn.AddSplinePoint");
		
		AReplayCameraPawn_AddSplinePoint_Params params {};
		params.Location = Location;
		params.Rotation = Rotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReplayCameraPawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReplayCameraPawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReplayCameraPawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayController.SetViewOverride
	 * 		Flags  -> ()
	 */
	void AReplayController::SetViewOverride()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayController.SetViewOverride");
		
		AReplayController_SetViewOverride_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayController.SetCurrentReplayTimeToSeconds
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReplayController::SetCurrentReplayTimeToSeconds(int32_t Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayController.SetCurrentReplayTimeToSeconds");
		
		AReplayController_SetCurrentReplayTimeToSeconds_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayController.SetCurrentReplayPlayRate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AReplayController::SetCurrentReplayPlayRate(float PlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayController.SetCurrentReplayPlayRate");
		
		AReplayController_SetCurrentReplayPlayRate_Params params {};
		params.PlayRate = PlayRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayController.SetCurrentReplayPausedState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bDoPause                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReplayController::SetCurrentReplayPausedState(bool bDoPause)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayController.SetCurrentReplayPausedState");
		
		AReplayController_SetCurrentReplayPausedState_Params params {};
		params.bDoPause = bDoPause;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayController.GetCurrentReplayTotalTimeInSeconds
	 * 		Flags  -> ()
	 */
	float AReplayController::GetCurrentReplayTotalTimeInSeconds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayController.GetCurrentReplayTotalTimeInSeconds");
		
		AReplayController_GetCurrentReplayTotalTimeInSeconds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayController.GetCurrentReplayCurrentTimeInSeconds
	 * 		Flags  -> ()
	 */
	float AReplayController::GetCurrentReplayCurrentTimeInSeconds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayController.GetCurrentReplayCurrentTimeInSeconds");
		
		AReplayController_GetCurrentReplayCurrentTimeInSeconds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReplayController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReplayController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReplayController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayControls.GetFollowCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AReadyOrNotCharacter* UReplayControls::GetFollowCharacter(const class FString& InName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayControls.GetFollowCharacter");
		
		UReplayControls_GetFollowCharacter_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReplayControls.GetAllFollowableCharacters
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FString>                              OutNames                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UReplayControls::GetAllFollowableCharacters(TArray<class FString>* OutNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReplayControls.GetAllFollowableCharacters");
		
		UReplayControls_GetAllFollowableCharacters_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutNames != nullptr)
			*OutNames = params.OutNames;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReplayControls.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReplayControls::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReplayControls");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReplaySplineActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReplaySplineActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReplaySplineActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Reportable.ReportToTOC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Reporter                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayAnimation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReportable::ReportToTOC(class AReadyOrNotCharacter* Reporter, bool bPlayAnimation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Reportable.ReportToTOC");
		
		UReportable_ReportToTOC_Params params {};
		params.Reporter = Reporter;
		params.bPlayAnimation = bPlayAnimation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Reportable.GetSpeechTypeForReport
	 * 		Flags  -> ()
	 */
	class FString UReportable::GetSpeechTypeForReport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Reportable.GetSpeechTypeForReport");
		
		UReportable_GetSpeechTypeForReport_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Reportable.CanReportNow
	 * 		Flags  -> ()
	 */
	bool UReportable::CanReportNow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Reportable.CanReportNow");
		
		UReportable_CanReportNow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReportable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReportable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Reportable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ReportReportableByTag.HasReportedReportableByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Tag                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AReportReportableByTag::HasReportedReportableByTag(const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ReportReportableByTag.HasReportedReportableByTag");
		
		AReportReportableByTag_HasReportedReportableByTag_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReportReportableByTag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReportReportableByTag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReportReportableByTag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReportTargetActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReportTargetActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ReportTargetActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARescueAllOfTheCivilians.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARescueAllOfTheCivilians::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RescueAllOfTheCivilians");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RescueCivilianByTag.HasNeutralizedCivilianByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Tag                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bArrested                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARescueCivilianByTag::HasNeutralizedCivilianByTag(const class FName& Tag, bool* bArrested)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RescueCivilianByTag.HasNeutralizedCivilianByTag");
		
		ARescueCivilianByTag_HasNeutralizedCivilianByTag_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bArrested != nullptr)
			*bArrested = params.bArrested;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARescueCivilianByTag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARescueCivilianByTag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RescueCivilianByTag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RespondToPlayerGaze.OnPlayerGazeStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Gazer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URespondToPlayerGaze::OnPlayerGazeStarted(class APlayerCharacter* Gazer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RespondToPlayerGaze.OnPlayerGazeStarted");
		
		URespondToPlayerGaze_OnPlayerGazeStarted_Params params {};
		params.Gazer = Gazer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RespondToPlayerGaze.OnPlayerGazeEnded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            Gazer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URespondToPlayerGaze::OnPlayerGazeEnded(class APlayerCharacter* Gazer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RespondToPlayerGaze.OnPlayerGazeEnded");
		
		URespondToPlayerGaze_OnPlayerGazeEnded_Params params {};
		params.Gazer = Gazer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URespondToPlayerGaze.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URespondToPlayerGaze::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RespondToPlayerGaze");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNAnimInstance_HumanBase.UpdateMoveStyleDataFromComp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URoNMoveStyleComponent*                      MoveStyleComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URoNAnimInstance_HumanBase::UpdateMoveStyleDataFromComp(class URoNMoveStyleComponent* MoveStyleComp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNAnimInstance_HumanBase.UpdateMoveStyleDataFromComp");
		
		URoNAnimInstance_HumanBase_UpdateMoveStyleDataFromComp_Params params {};
		params.MoveStyleComp = MoveStyleComp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNAnimInstance_HumanBase.UpdateGaitDataFromComp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URoNMoveStyleComponent*                      MoveStyleComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URoNAnimInstance_HumanBase::UpdateGaitDataFromComp(class URoNMoveStyleComponent* MoveStyleComp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNAnimInstance_HumanBase.UpdateGaitDataFromComp");
		
		URoNAnimInstance_HumanBase_UpdateGaitDataFromComp_Params params {};
		params.MoveStyleComp = MoveStyleComp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNAnimInstance_HumanBase.SetMoveStyleDataFromComp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URoNMoveStyleComponent*                      MoveStyleComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URoNAnimInstance_HumanBase::SetMoveStyleDataFromComp(class URoNMoveStyleComponent* MoveStyleComp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNAnimInstance_HumanBase.SetMoveStyleDataFromComp");
		
		URoNAnimInstance_HumanBase_SetMoveStyleDataFromComp_Params params {};
		params.MoveStyleComp = MoveStyleComp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNAnimInstance_HumanBase.GetLookAtRotation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FRotator URoNAnimInstance_HumanBase::GetLookAtRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNAnimInstance_HumanBase.GetLookAtRotation");
		
		URoNAnimInstance_HumanBase_GetLookAtRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URoNAnimInstance_HumanBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URoNAnimInstance_HumanBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RoNAnimInstance_HumanBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNAnimInstance_PlayerFP.OnReloadComplete
	 * 		Flags  -> ()
	 */
	void URoNAnimInstance_PlayerFP::OnReloadComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNAnimInstance_PlayerFP.OnReloadComplete");
		
		URoNAnimInstance_PlayerFP_OnReloadComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNAnimInstance_PlayerFP.OnHolsterComplete
	 * 		Flags  -> ()
	 */
	void URoNAnimInstance_PlayerFP::OnHolsterComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNAnimInstance_PlayerFP.OnHolsterComplete");
		
		URoNAnimInstance_PlayerFP_OnHolsterComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNAnimInstance_PlayerFP.OnC2Detonation
	 * 		Flags  -> ()
	 */
	void URoNAnimInstance_PlayerFP::OnC2Detonation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNAnimInstance_PlayerFP.OnC2Detonation");
		
		URoNAnimInstance_PlayerFP_OnC2Detonation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNAnimInstance_PlayerFP.GetPlayerBlendspace_FP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EBaseBlendspaces_FP                                BlendspaceName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBlendSpaceBase* URoNAnimInstance_PlayerFP::GetPlayerBlendspace_FP(EBaseBlendspaces_FP BlendspaceName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNAnimInstance_PlayerFP.GetPlayerBlendspace_FP");
		
		URoNAnimInstance_PlayerFP_GetPlayerBlendspace_FP_Params params {};
		params.BlendspaceName = BlendspaceName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNAnimInstance_PlayerFP.GetPlayerAnimation_FP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EBaseAnimType_FP                                   AnimName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimSequenceBase* URoNAnimInstance_PlayerFP::GetPlayerAnimation_FP(EBaseAnimType_FP AnimName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNAnimInstance_PlayerFP.GetPlayerAnimation_FP");
		
		URoNAnimInstance_PlayerFP_GetPlayerAnimation_FP_Params params {};
		params.AnimName = AnimName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URoNAnimInstance_PlayerFP.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URoNAnimInstance_PlayerFP::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RoNAnimInstance_PlayerFP");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNAnimInstance_PlayerTP.GetPlayerAnimation_TP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EBaseAnimType_TP                                   AnimName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimSequenceBase* URoNAnimInstance_PlayerTP::GetPlayerAnimation_TP(EBaseAnimType_TP AnimName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNAnimInstance_PlayerTP.GetPlayerAnimation_TP");
		
		URoNAnimInstance_PlayerTP_GetPlayerAnimation_TP_Params params {};
		params.AnimName = AnimName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URoNAnimInstance_PlayerTP.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URoNAnimInstance_PlayerTP::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RoNAnimInstance_PlayerTP");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARoNMoveStyleCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARoNMoveStyleCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RoNMoveStyleCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNMoveStyleComponent.SetOverrideMoveStyleByName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URoNMoveStyleComponent::SetOverrideMoveStyleByName(const class FName& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNMoveStyleComponent.SetOverrideMoveStyleByName");
		
		URoNMoveStyleComponent_SetOverrideMoveStyleByName_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNMoveStyleComponent.SetMovementStyleByName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URoNMoveStyleComponent::SetMovementStyleByName(const class FName& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNMoveStyleComponent.SetMovementStyleByName");
		
		URoNMoveStyleComponent_SetMovementStyleByName_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNMoveStyleComponent.SetMovementGaitByName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URoNMoveStyleComponent::SetMovementGaitByName(const class FName& Name, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNMoveStyleComponent.SetMovementGaitByName");
		
		URoNMoveStyleComponent_SetMovementGaitByName_Params params {};
		params.Name = Name;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNMoveStyleComponent.SetCharacterSpeedMultiplier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Multiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URoNMoveStyleComponent::SetCharacterSpeedMultiplier(float Multiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNMoveStyleComponent.SetCharacterSpeedMultiplier");
		
		URoNMoveStyleComponent_SetCharacterSpeedMultiplier_Params params {};
		params.Multiplier = Multiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNMoveStyleComponent.SetCharacterSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URoNMoveStyleComponent::SetCharacterSpeed(float Speed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNMoveStyleComponent.SetCharacterSpeed");
		
		URoNMoveStyleComponent_SetCharacterSpeed_Params params {};
		params.Speed = Speed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNMoveStyleComponent.SetCharacterAccelerationMultiplier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Multiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URoNMoveStyleComponent::SetCharacterAccelerationMultiplier(float Multiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNMoveStyleComponent.SetCharacterAccelerationMultiplier");
		
		URoNMoveStyleComponent_SetCharacterAccelerationMultiplier_Params params {};
		params.Multiplier = Multiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNMoveStyleComponent.SetCharacterAcceleration
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Acceleration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URoNMoveStyleComponent::SetCharacterAcceleration(float Acceleration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNMoveStyleComponent.SetCharacterAcceleration");
		
		URoNMoveStyleComponent_SetCharacterAcceleration_Params params {};
		params.Acceleration = Acceleration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNMoveStyleComponent.OnRep_MoveStyle
	 * 		Flags  -> ()
	 */
	void URoNMoveStyleComponent::OnRep_MoveStyle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNMoveStyleComponent.OnRep_MoveStyle");
		
		URoNMoveStyleComponent_OnRep_MoveStyle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNMoveStyleComponent.OnRep_IsStrafing
	 * 		Flags  -> ()
	 */
	void URoNMoveStyleComponent::OnRep_IsStrafing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNMoveStyleComponent.OnRep_IsStrafing");
		
		URoNMoveStyleComponent_OnRep_IsStrafing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNMoveStyleComponent.ClearOverrideMoveStyle
	 * 		Flags  -> ()
	 */
	void URoNMoveStyleComponent::ClearOverrideMoveStyle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNMoveStyleComponent.ClearOverrideMoveStyle");
		
		URoNMoveStyleComponent_ClearOverrideMoveStyle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URoNMoveStyleComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URoNMoveStyleComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RoNMoveStyleComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponSound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponSound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WeaponSound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDoorSound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDoorSound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.DoorSound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNWeaponAnimInstance.OnSpeedReloadMagazineEjected
	 * 		Flags  -> ()
	 */
	void URoNWeaponAnimInstance::OnSpeedReloadMagazineEjected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNWeaponAnimInstance.OnSpeedReloadMagazineEjected");
		
		URoNWeaponAnimInstance_OnSpeedReloadMagazineEjected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoNWeaponAnimInstance.OnDisassembleMagazineEjected
	 * 		Flags  -> ()
	 */
	void URoNWeaponAnimInstance::OnDisassembleMagazineEjected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoNWeaponAnimInstance.OnDisassembleMagazineEjected");
		
		URoNWeaponAnimInstance_OnDisassembleMagazineEjected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URoNWeaponAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URoNWeaponAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RoNWeaponAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARosterScenarioSpawner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARosterScenarioSpawner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RosterScenarioSpawner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.RoundEndWidget_PVP.OnGameModeRoundEnded
	 * 		Flags  -> ()
	 */
	void URoundEndWidget_PVP::OnGameModeRoundEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.RoundEndWidget_PVP.OnGameModeRoundEnded");
		
		URoundEndWidget_PVP_OnGameModeRoundEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URoundEndWidget_PVP.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URoundEndWidget_PVP::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.RoundEndWidget_PVP");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AScenarioCoverActivator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AScenarioCoverActivator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ScenarioCoverActivator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScenarioGenerator.SaveScenario
	 * 		Flags  -> ()
	 */
	void AScenarioGenerator::SaveScenario()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScenarioGenerator.SaveScenario");
		
		AScenarioGenerator_SaveScenario_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScenarioGenerator.LoadScenario
	 * 		Flags  -> ()
	 */
	void AScenarioGenerator::LoadScenario()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScenarioGenerator.LoadScenario");
		
		AScenarioGenerator_LoadScenario_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScenarioGenerator.LoadRandomScenario
	 * 		Flags  -> ()
	 */
	class FString AScenarioGenerator::LoadRandomScenario()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScenarioGenerator.LoadRandomScenario");
		
		AScenarioGenerator_LoadRandomScenario_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScenarioGenerator.GetLoadedScenarioList
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FString>                              OutScenarios                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AScenarioGenerator::GetLoadedScenarioList(TArray<class FString>* OutScenarios)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScenarioGenerator.GetLoadedScenarioList");
		
		AScenarioGenerator_GetLoadedScenarioList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutScenarios != nullptr)
			*OutScenarios = params.OutScenarios;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScenarioGenerator.DeleteScenario
	 * 		Flags  -> ()
	 */
	void AScenarioGenerator::DeleteScenario()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScenarioGenerator.DeleteScenario");
		
		AScenarioGenerator_DeleteScenario_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AScenarioGenerator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AScenarioGenerator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ScenarioGenerator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScopedWeaponAttachment.GetScopeMods
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FScopeModifications UScopedWeaponAttachment::GetScopeMods(class ABaseWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScopedWeaponAttachment.GetScopeMods");
		
		UScopedWeaponAttachment_GetScopeMods_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScopedWeaponAttachment.GetMeshspaceOffsetVertical
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UScopedWeaponAttachment::GetMeshspaceOffsetVertical(class ABaseWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScopedWeaponAttachment.GetMeshspaceOffsetVertical");
		
		UScopedWeaponAttachment_GetMeshspaceOffsetVertical_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScopedWeaponAttachment.GetMeshspaceOffsetHorizontal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UScopedWeaponAttachment::GetMeshspaceOffsetHorizontal(class ABaseWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScopedWeaponAttachment.GetMeshspaceOffsetHorizontal");
		
		UScopedWeaponAttachment_GetMeshspaceOffsetHorizontal_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScopedWeaponAttachment.GetMeshspaceOffsetDistance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UScopedWeaponAttachment::GetMeshspaceOffsetDistance(class ABaseWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScopedWeaponAttachment.GetMeshspaceOffsetDistance");
		
		UScopedWeaponAttachment_GetMeshspaceOffsetDistance_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScopedWeaponAttachment.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScopedWeaponAttachment::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ScopedWeaponAttachment");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringComponent.GetTotalScore
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOnlyEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyGiven                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UScoringComponent::GetTotalScore(bool bOnlyEnabled, bool bOnlyGiven)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringComponent.GetTotalScore");
		
		UScoringComponent_GetTotalScore_Params params {};
		params.bOnlyEnabled = bOnlyEnabled;
		params.bOnlyGiven = bOnlyGiven;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringComponent.GetScore
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ScoreName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UScoringComponent::GetScore(const class FString& ScoreName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringComponent.GetScore");
		
		UScoringComponent_GetScore_Params params {};
		params.ScoreName = ScoreName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScoringComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScoringComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ScoringComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringInterface.GetScoringComponent
	 * 		Flags  -> ()
	 */
	class UScoringComponent* UScoringInterface::GetScoringComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringInterface.GetScoringComponent");
		
		UScoringInterface_GetScoringComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScoringInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScoringInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ScoringInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.TakeScores
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FString>                              ScoreNames                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      TakeReason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisplayScoreOnHUD                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisableScores                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::TakeScores(class UScoringComponent* InScoringComponent, TArray<class FString> ScoreNames, const class FString& TakeReason, bool bDisplayScoreOnHUD, bool bDisableScores)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.TakeScores");
		
		AScoringManager_TakeScores_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.ScoreNames = ScoreNames;
		params.TakeReason = TakeReason;
		params.bDisplayScoreOnHUD = bDisplayScoreOnHUD;
		params.bDisableScores = bDisableScores;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.TakeScore
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ScoreName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      TakeReason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisplayScoreOnHUD                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisableScore                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::TakeScore(class UScoringComponent* InScoringComponent, const class FString& ScoreName, const class FString& TakeReason, bool bDisplayScoreOnHUD, bool bDisableScore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.TakeScore");
		
		AScoringManager_TakeScore_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.ScoreName = ScoreName;
		params.TakeReason = TakeReason;
		params.bDisplayScoreOnHUD = bDisplayScoreOnHUD;
		params.bDisableScore = bDisableScore;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.TakeAllScoresExcept
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FString>                              ScoreNames                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      TakeReason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisplayScoreOnHUD                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisableScores                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::TakeAllScoresExcept(class UScoringComponent* InScoringComponent, TArray<class FString> ScoreNames, const class FString& TakeReason, bool bDisplayScoreOnHUD, bool bDisableScores)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.TakeAllScoresExcept");
		
		AScoringManager_TakeAllScoresExcept_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.ScoreNames = ScoreNames;
		params.TakeReason = TakeReason;
		params.bDisplayScoreOnHUD = bDisplayScoreOnHUD;
		params.bDisableScores = bDisableScores;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.TakeAllScores
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      TakeReason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisplayScoreOnHUD                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisableScores                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::TakeAllScores(class UScoringComponent* InScoringComponent, const class FString& TakeReason, bool bDisplayScoreOnHUD, bool bDisableScores)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.TakeAllScores");
		
		AScoringManager_TakeAllScores_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.TakeReason = TakeReason;
		params.bDisplayScoreOnHUD = bDisplayScoreOnHUD;
		params.bDisableScores = bDisableScores;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.RevokePenalty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      PenaltyGroupName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::RevokePenalty(class UScoringComponent* InScoringComponent, const class FString& PenaltyGroupName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.RevokePenalty");
		
		AScoringManager_RevokePenalty_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.PenaltyGroupName = PenaltyGroupName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.RevokeAllPenalties
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::RevokeAllPenalties(class UScoringComponent* InScoringComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.RevokeAllPenalties");
		
		AScoringManager_RevokeAllPenalties_Params params {};
		params.InScoringComponent = InScoringComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.Multicast_DisplayScore
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        ScoreText                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGive                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::Multicast_DisplayScore(const class FText& ScoreText, int32_t Score, bool bGive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.Multicast_DisplayScore");
		
		AScoringManager_Multicast_DisplayScore_Params params {};
		params.ScoreText = ScoreText;
		params.Score = Score;
		params.bGive = bGive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.IsOfficialScoring
	 * 		Flags  -> ()
	 */
	bool AScoringManager::IsOfficialScoring()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.IsOfficialScoring");
		
		AScoringManager_IsOfficialScoring_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.HasClearedMission
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHasClearedMission                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSoftClearedMission                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMissionFailed                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::HasClearedMission(bool* bHasClearedMission, bool* bSoftClearedMission, bool* bMissionFailed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.HasClearedMission");
		
		AScoringManager_HasClearedMission_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bHasClearedMission != nullptr)
			*bHasClearedMission = params.bHasClearedMission;
		if (bSoftClearedMission != nullptr)
			*bSoftClearedMission = params.bSoftClearedMission;
		if (bMissionFailed != nullptr)
			*bMissionFailed = params.bMissionFailed;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GiveScores
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FString>                              ScoreNames                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisplayScoreOnHUD                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ScoreText                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DisplayOnHUDDelay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CustomScoreOnHUD                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GiveScores(class UScoringComponent* InScoringComponent, TArray<class FString> ScoreNames, bool bDisplayScoreOnHUD, const class FString& ScoreText, float DisplayOnHUDDelay, int32_t CustomScoreOnHUD)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GiveScores");
		
		AScoringManager_GiveScores_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.ScoreNames = ScoreNames;
		params.bDisplayScoreOnHUD = bDisplayScoreOnHUD;
		params.ScoreText = ScoreText;
		params.DisplayOnHUDDelay = DisplayOnHUDDelay;
		params.CustomScoreOnHUD = CustomScoreOnHUD;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GiveScore
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ScoreName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisplayScoreOnHUD                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ScoreText                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DisplayOnHUDDelay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CustomScoreOnHUD                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GiveScore(class UScoringComponent* InScoringComponent, const class FString& ScoreName, bool bDisplayScoreOnHUD, const class FString& ScoreText, float DisplayOnHUDDelay, int32_t CustomScoreOnHUD)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GiveScore");
		
		AScoringManager_GiveScore_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.ScoreName = ScoreName;
		params.bDisplayScoreOnHUD = bDisplayScoreOnHUD;
		params.ScoreText = ScoreText;
		params.DisplayOnHUDDelay = DisplayOnHUDDelay;
		params.CustomScoreOnHUD = CustomScoreOnHUD;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GivePenalty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      PenaltyGroupName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisplayScoreOnHUD                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ScoreText                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DisplayOnHUDDelay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CustomScoreOnHUD                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GivePenalty(class UScoringComponent* InScoringComponent, const class FString& PenaltyGroupName, bool bDisplayScoreOnHUD, const class FString& ScoreText, float DisplayOnHUDDelay, int32_t CustomScoreOnHUD)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GivePenalty");
		
		AScoringManager_GivePenalty_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.PenaltyGroupName = PenaltyGroupName;
		params.bDisplayScoreOnHUD = bDisplayScoreOnHUD;
		params.ScoreText = ScoreText;
		params.DisplayOnHUDDelay = DisplayOnHUDDelay;
		params.CustomScoreOnHUD = CustomScoreOnHUD;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GiveFakeScore
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ScoreName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisplayScoreOnHUD                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ScoreText                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DisplayOnHUDDelay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CustomScoreOnHUD                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GiveFakeScore(class UScoringComponent* InScoringComponent, const class FString& ScoreName, bool bDisplayScoreOnHUD, const class FString& ScoreText, float DisplayOnHUDDelay, int32_t CustomScoreOnHUD)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GiveFakeScore");
		
		AScoringManager_GiveFakeScore_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.ScoreName = ScoreName;
		params.bDisplayScoreOnHUD = bDisplayScoreOnHUD;
		params.ScoreText = ScoreText;
		params.DisplayOnHUDDelay = DisplayOnHUDDelay;
		params.CustomScoreOnHUD = CustomScoreOnHUD;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GiveCustomPenalty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      PenaltyGroupName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PenaltyScore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisplayScoreOnHUD                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DisplayOnHUDDelay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GiveCustomPenalty(const class FString& PenaltyGroupName, int32_t PenaltyScore, bool bDisplayScoreOnHUD, float DisplayOnHUDDelay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GiveCustomPenalty");
		
		AScoringManager_GiveCustomPenalty_Params params {};
		params.PenaltyGroupName = PenaltyGroupName;
		params.PenaltyScore = PenaltyScore;
		params.bDisplayScoreOnHUD = bDisplayScoreOnHUD;
		params.DisplayOnHUDDelay = DisplayOnHUDDelay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GiveAllScores
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyEnabledScore                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisplayScoreOnHUD                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ScoreText                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DisplayOnHUDDelay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CustomScoreOnHUD                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GiveAllScores(class UScoringComponent* InScoringComponent, bool bOnlyEnabledScore, bool bDisplayScoreOnHUD, const class FString& ScoreText, float DisplayOnHUDDelay, int32_t CustomScoreOnHUD)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GiveAllScores");
		
		AScoringManager_GiveAllScores_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.bOnlyEnabledScore = bOnlyEnabledScore;
		params.bDisplayScoreOnHUD = bDisplayScoreOnHUD;
		params.ScoreText = ScoreText;
		params.DisplayOnHUDDelay = DisplayOnHUDDelay;
		params.CustomScoreOnHUD = CustomScoreOnHUD;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetTotalScorePool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            MaxScore                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GetTotalScorePool(int32_t* MaxScore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetTotalScorePool");
		
		AScoringManager_GetTotalScorePool_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MaxScore != nullptr)
			*MaxScore = params.MaxScore;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetTotalScoreFromArray
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FScoreData>                          InScoreDataArray                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	int32_t AScoringManager::GetTotalScoreFromArray(TArray<struct FScoreData> InScoreDataArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetTotalScoreFromArray");
		
		AScoringManager_GetTotalScoreFromArray_Params params {};
		params.InScoreDataArray = InScoreDataArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetTotalScoreCountFromArray
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FScoreData>                          InScoreDataArray                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeHiddenScores                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AScoringManager::GetTotalScoreCountFromArray(TArray<struct FScoreData> InScoreDataArray, bool bIncludeHiddenScores)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetTotalScoreCountFromArray");
		
		AScoringManager_GetTotalScoreCountFromArray_Params params {};
		params.InScoreDataArray = InScoreDataArray;
		params.bIncludeHiddenScores = bIncludeHiddenScores;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetTotalScore
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            TotalScore                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludePrimaryScores                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GetTotalScore(int32_t* TotalScore, bool bIncludePrimaryScores)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetTotalScore");
		
		AScoringManager_GetTotalScore_Params params {};
		params.bIncludePrimaryScores = bIncludePrimaryScores;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TotalScore != nullptr)
			*TotalScore = params.TotalScore;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetTotalNonGivenScoresFromArray
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FScoreData>                          InScoreDataArray                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	int32_t AScoringManager::GetTotalNonGivenScoresFromArray(TArray<struct FScoreData> InScoreDataArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetTotalNonGivenScoresFromArray");
		
		AScoringManager_GetTotalNonGivenScoresFromArray_Params params {};
		params.InScoreDataArray = InScoreDataArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetTotalGivenScoresFromArray
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FScoreData>                          InScoreDataArray                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeHiddenScores                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AScoringManager::GetTotalGivenScoresFromArray(TArray<struct FScoreData> InScoreDataArray, bool bIncludeHiddenScores)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetTotalGivenScoresFromArray");
		
		AScoringManager_GetTotalGivenScoresFromArray_Params params {};
		params.InScoreDataArray = InScoreDataArray;
		params.bIncludeHiddenScores = bIncludeHiddenScores;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetTotalActorsTrackingScore
	 * 		Flags  -> ()
	 */
	int32_t AScoringManager::GetTotalActorsTrackingScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetTotalActorsTrackingScore");
		
		AScoringManager_GetTotalActorsTrackingScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetSuspectCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            OutReported                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutArrested                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutKilled                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutTotal                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GetSuspectCount(int32_t* OutReported, int32_t* OutArrested, int32_t* OutKilled, int32_t* OutTotal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetSuspectCount");
		
		AScoringManager_GetSuspectCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutReported != nullptr)
			*OutReported = params.OutReported;
		if (OutArrested != nullptr)
			*OutArrested = params.OutArrested;
		if (OutKilled != nullptr)
			*OutKilled = params.OutKilled;
		if (OutTotal != nullptr)
			*OutTotal = params.OutTotal;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetScoreGroups
	 * 		Flags  -> ()
	 */
	TArray<struct FScoreGroup> AScoringManager::GetScoreGroups()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetScoreGroups");
		
		AScoringManager_GetScoreGroups_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetScoreCountFromGroup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InGroupName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutScoresGiven                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutTotalScores                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRequiredOnly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GetScoreCountFromGroup(const class FString& InGroupName, int32_t* OutScoresGiven, int32_t* OutTotalScores, bool bRequiredOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetScoreCountFromGroup");
		
		AScoringManager_GetScoreCountFromGroup_Params params {};
		params.InGroupName = InGroupName;
		params.bRequiredOnly = bRequiredOnly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutScoresGiven != nullptr)
			*OutScoresGiven = params.OutScoresGiven;
		if (OutTotalScores != nullptr)
			*OutTotalScores = params.OutTotalScores;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetReportCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ReportedCount                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TotalReports                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GetReportCount(int32_t* ReportedCount, int32_t* TotalReports)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetReportCount");
		
		AScoringManager_GetReportCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ReportedCount != nullptr)
			*ReportedCount = params.ReportedCount;
		if (TotalReports != nullptr)
			*TotalReports = params.TotalReports;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetPenaltyScoreGroups
	 * 		Flags  -> ()
	 */
	TArray<struct FScorePenaltyData> AScoringManager::GetPenaltyScoreGroups()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetPenaltyScoreGroups");
		
		AScoringManager_GetPenaltyScoreGroups_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetObjectiveCompletionStatus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ObjectivesComplete                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ObjectivesFailed                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TotalObjectives                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GetObjectiveCompletionStatus(int32_t* ObjectivesComplete, int32_t* ObjectivesFailed, int32_t* TotalObjectives)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetObjectiveCompletionStatus");
		
		AScoringManager_GetObjectiveCompletionStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ObjectivesComplete != nullptr)
			*ObjectivesComplete = params.ObjectivesComplete;
		if (ObjectivesFailed != nullptr)
			*ObjectivesFailed = params.ObjectivesFailed;
		if (TotalObjectives != nullptr)
			*TotalObjectives = params.TotalObjectives;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetNonGivenScoreCountFromGroup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FScoreGroup>                         InScoreGroupArray                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	int32_t AScoringManager::GetNonGivenScoreCountFromGroup(TArray<struct FScoreGroup> InScoreGroupArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetNonGivenScoreCountFromGroup");
		
		AScoringManager_GetNonGivenScoreCountFromGroup_Params params {};
		params.InScoreGroupArray = InScoreGroupArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetNonGivenScoreCountFromArray
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FScoreData>                          InScoreDataArray                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AScoringManager::GetNonGivenScoreCountFromArray(TArray<struct FScoreData> InScoreDataArray, bool bOnlyEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetNonGivenScoreCountFromArray");
		
		AScoringManager_GetNonGivenScoreCountFromArray_Params params {};
		params.InScoreDataArray = InScoreDataArray;
		params.bOnlyEnabled = bOnlyEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetGivenScoreCountFromGroup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FScoreGroup>                         InScoreGroupArray                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	int32_t AScoringManager::GetGivenScoreCountFromGroup(TArray<struct FScoreGroup> InScoreGroupArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetGivenScoreCountFromGroup");
		
		AScoringManager_GetGivenScoreCountFromGroup_Params params {};
		params.InScoreGroupArray = InScoreGroupArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetGivenScoreCountFromArray
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FScoreData>                          InScoreDataArray                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeHiddenScores                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AScoringManager::GetGivenScoreCountFromArray(TArray<struct FScoreData> InScoreDataArray, bool bIncludeHiddenScores)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetGivenScoreCountFromArray");
		
		AScoringManager_GetGivenScoreCountFromArray_Params params {};
		params.InScoreDataArray = InScoreDataArray;
		params.bIncludeHiddenScores = bIncludeHiddenScores;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetEvidenceCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            EvidenceCollected                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TotalEvidence                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GetEvidenceCount(int32_t* EvidenceCollected, int32_t* TotalEvidence)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetEvidenceCount");
		
		AScoringManager_GetEvidenceCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (EvidenceCollected != nullptr)
			*EvidenceCollected = params.EvidenceCollected;
		if (TotalEvidence != nullptr)
			*TotalEvidence = params.TotalEvidence;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetCurrentScoreAsPercentage
	 * 		Flags  -> ()
	 */
	float AScoringManager::GetCurrentScoreAsPercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetCurrentScoreAsPercentage");
		
		AScoringManager_GetCurrentScoreAsPercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.GetCivilianCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            OutReported                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutInjured                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutKilled                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutArrested                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutTotal                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::GetCivilianCount(int32_t* OutReported, int32_t* OutInjured, int32_t* OutKilled, int32_t* OutArrested, int32_t* OutTotal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.GetCivilianCount");
		
		AScoringManager_GetCivilianCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutReported != nullptr)
			*OutReported = params.OutReported;
		if (OutInjured != nullptr)
			*OutInjured = params.OutInjured;
		if (OutKilled != nullptr)
			*OutKilled = params.OutKilled;
		if (OutArrested != nullptr)
			*OutArrested = params.OutArrested;
		if (OutTotal != nullptr)
			*OutTotal = params.OutTotal;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.Get
	 * 		Flags  -> ()
	 */
	class AScoringManager* AScoringManager::Get()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.Get");
		
		AScoringManager_Get_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.DisplayPenalties
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCondensed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ScoreTextOverride                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::DisplayPenalties(class UScoringComponent* InScoringComponent, bool bCondensed, const class FString& ScoreTextOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.DisplayPenalties");
		
		AScoringManager_DisplayPenalties_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.bCondensed = bCondensed;
		params.ScoreTextOverride = ScoreTextOverride;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.DisplayBonusesAndPenalties
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCondensed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ScoreTextOverride                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::DisplayBonusesAndPenalties(class UScoringComponent* InScoringComponent, bool bCondensed, const class FString& ScoreTextOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.DisplayBonusesAndPenalties");
		
		AScoringManager_DisplayBonusesAndPenalties_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.bCondensed = bCondensed;
		params.ScoreTextOverride = ScoreTextOverride;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.DisplayBonuses
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCondensed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ScoreTextOverride                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::DisplayBonuses(class UScoringComponent* InScoringComponent, bool bCondensed, const class FString& ScoreTextOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.DisplayBonuses");
		
		AScoringManager_DisplayBonuses_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.bCondensed = bCondensed;
		params.ScoreTextOverride = ScoreTextOverride;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.ChangeScoreGroup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UScoringComponent*                           InScoringComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      NewGroupName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AScoringManager::ChangeScoreGroup(class UScoringComponent* InScoringComponent, const class FString& NewGroupName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.ChangeScoreGroup");
		
		AScoringManager_ChangeScoreGroup_Params params {};
		params.InScoringComponent = InScoringComponent;
		params.NewGroupName = NewGroupName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.CalculateGradeLetterFromScore
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString AScoringManager::CalculateGradeLetterFromScore(int32_t Score)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.CalculateGradeLetterFromScore");
		
		AScoringManager_CalculateGradeLetterFromScore_Params params {};
		params.Score = Score;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.CalculateGradeLetterFromPlayerScore
	 * 		Flags  -> ()
	 */
	class FString AScoringManager::CalculateGradeLetterFromPlayerScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.CalculateGradeLetterFromPlayerScore");
		
		AScoringManager_CalculateGradeLetterFromPlayerScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.CalculateGradeLetterFromPercentage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ScorePercentage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString AScoringManager::CalculateGradeLetterFromPercentage(float ScorePercentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.CalculateGradeLetterFromPercentage");
		
		AScoringManager_CalculateGradeLetterFromPercentage_Params params {};
		params.ScorePercentage = ScorePercentage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.AnyScoresGiven
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FScoreBonus>                         InScoreBonusArray                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool AScoringManager::AnyScoresGiven(TArray<struct FScoreBonus> InScoreBonusArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.AnyScoresGiven");
		
		AScoringManager_AnyScoresGiven_Params params {};
		params.InScoreBonusArray = InScoreBonusArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.AllScoresGiven
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FScoreBonus>                         InScoreBonusArray                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool AScoringManager::AllScoresGiven(TArray<struct FScoreBonus> InScoreBonusArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.AllScoresGiven");
		
		AScoringManager_AllScoresGiven_Params params {};
		params.InScoreBonusArray = InScoreBonusArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScoringManager.AllRequiredScoresGiven
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FScoreBonus>                         InScoreBonusArray                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool AScoringManager::AllRequiredScoresGiven(TArray<struct FScoreBonus> InScoreBonusArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScoringManager.AllRequiredScoresGiven");
		
		AScoringManager_AllRequiredScoresGiven_Params params {};
		params.InScoreBonusArray = InScoreBonusArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AScoringManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AScoringManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ScoringManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScriptedLevelEvents.ScriptedStopAimingAtEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScriptedLevelEvents::ScriptedStopAimingAtEvent(class ACyberneticController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScriptedLevelEvents.ScriptedStopAimingAtEvent");
		
		UScriptedLevelEvents_ScriptedStopAimingAtEvent_Params params {};
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScriptedLevelEvents.ScriptedShootAtEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            ForcedShootAtTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseActivity* UScriptedLevelEvents::ScriptedShootAtEvent(class ACyberneticController* Controller, class APlayerCharacter* ForcedShootAtTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScriptedLevelEvents.ScriptedShootAtEvent");
		
		UScriptedLevelEvents_ScriptedShootAtEvent_Params params {};
		params.Controller = Controller;
		params.ForcedShootAtTarget = ForcedShootAtTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScriptedLevelEvents.ScriptedAimAtEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            ForcedLookAtTarget                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBaseActivity* UScriptedLevelEvents::ScriptedAimAtEvent(class ACyberneticController* Controller, class APlayerCharacter* ForcedLookAtTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScriptedLevelEvents.ScriptedAimAtEvent");
		
		UScriptedLevelEvents_ScriptedAimAtEvent_Params params {};
		params.Controller = Controller;
		params.ForcedLookAtTarget = ForcedLookAtTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScriptedLevelEvents.GiveWorldBuildingActivityByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACyberneticController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              TimeDoingActivity                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScriptedLevelEvents::GiveWorldBuildingActivityByTag(class ACyberneticController* Controller, const class FName& Tag, float TimeDoingActivity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScriptedLevelEvents.GiveWorldBuildingActivityByTag");
		
		UScriptedLevelEvents_GiveWorldBuildingActivityByTag_Params params {};
		params.Controller = Controller;
		params.Tag = Tag;
		params.TimeDoingActivity = TimeDoingActivity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScriptedLevelEvents.GetPlayerCharacterByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APlayerCharacter* UScriptedLevelEvents::GetPlayerCharacterByTag(const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScriptedLevelEvents.GetPlayerCharacterByTag");
		
		UScriptedLevelEvents_GetPlayerCharacterByTag_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScriptedLevelEvents.GetCyberneticsControllerByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ACyberneticController* UScriptedLevelEvents::GetCyberneticsControllerByTag(const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScriptedLevelEvents.GetCyberneticsControllerByTag");
		
		UScriptedLevelEvents_GetCyberneticsControllerByTag_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ScriptedLevelEvents.GetCyberneticsCharacterByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ACyberneticCharacter* UScriptedLevelEvents::GetCyberneticsCharacterByTag(const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ScriptedLevelEvents.GetCyberneticsCharacterByTag");
		
		UScriptedLevelEvents_GetCyberneticsCharacterByTag_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScriptedLevelEvents.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScriptedLevelEvents::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ScriptedLevelEvents");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SearchAndDestroyGM.GetNumberOfActivePlayersOnTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ASearchAndDestroyGM::GetNumberOfActivePlayersOnTeam(ETeamType Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SearchAndDestroyGM.GetNumberOfActivePlayersOnTeam");
		
		ASearchAndDestroyGM_GetNumberOfActivePlayersOnTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASearchAndDestroyGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASearchAndDestroyGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SearchAndDestroyGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASearchAndDestroyGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASearchAndDestroyGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SearchAndDestroyGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UShellRackShellComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UShellRackShellComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ShellRackShellComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ShotDetectionVolume.OnShotFired
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ABaseWeapon*                                 FiringWeapon                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            FiringPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AShotDetectionVolume::OnShotFired(class ABaseWeapon* FiringWeapon, class APlayerCharacter* FiringPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ShotDetectionVolume.OnShotFired");
		
		AShotDetectionVolume_OnShotFired_Params params {};
		params.FiringWeapon = FiringWeapon;
		params.FiringPlayer = FiringPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ShotDetectionVolume.OnGrenadeDetonated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class ABaseGrenade*                                TriggeringGrenade                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        OwningPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AShotDetectionVolume::OnGrenadeDetonated(const struct FHitResult& Hit, class ABaseGrenade* TriggeringGrenade, class AReadyOrNotCharacter* OwningPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ShotDetectionVolume.OnGrenadeDetonated");
		
		AShotDetectionVolume_OnGrenadeDetonated_Params params {};
		params.Hit = Hit;
		params.TriggeringGrenade = TriggeringGrenade;
		params.OwningPlayer = OwningPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AShotDetectionVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AShotDetectionVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ShotDetectionVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASingleplayerGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASingleplayerGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SingleplayerGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASingleplayerGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASingleplayerGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SingleplayerGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SkinComponent.ResetSkin
	 * 		Flags  -> ()
	 */
	void USkinComponent::ResetSkin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SkinComponent.ResetSkin");
		
		USkinComponent_ResetSkin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SkinComponent.IsFactorySkin
	 * 		Flags  -> ()
	 */
	bool USkinComponent::IsFactorySkin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SkinComponent.IsFactorySkin");
		
		USkinComponent_IsFactorySkin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SkinComponent.HasDLCUnlocked
	 * 		Flags  -> ()
	 */
	bool USkinComponent::HasDLCUnlocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SkinComponent.HasDLCUnlocked");
		
		USkinComponent_HasDLCUnlocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SkinComponent.GetClassDefaultIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      SkinComponent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* USkinComponent::GetClassDefaultIcon(class UClass* SkinComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SkinComponent.GetClassDefaultIcon");
		
		USkinComponent_GetClassDefaultIcon_Params params {};
		params.SkinComponent = SkinComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USkinComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USkinComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SkinComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SlomoBarWidget.SetDuration
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NewDuration                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USlomoBarWidget::SetDuration(float NewDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SlomoBarWidget.SetDuration");
		
		USlomoBarWidget_SetDuration_Params params {};
		params.NewDuration = NewDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SlomoBarWidget.ProgressBarFinished
	 * 		Flags  -> ()
	 */
	void USlomoBarWidget::ProgressBarFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SlomoBarWidget.ProgressBarFinished");
		
		USlomoBarWidget_ProgressBarFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SlomoBarWidget.GetDuration
	 * 		Flags  -> ()
	 */
	float USlomoBarWidget::GetDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SlomoBarWidget.GetDuration");
		
		USlomoBarWidget_GetDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USlomoBarWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USlomoBarWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SlomoBarWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SlowDownVolume.OnOverlapEndComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASlowDownVolume::OnOverlapEndComponent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SlowDownVolume.OnOverlapEndComponent");
		
		ASlowDownVolume_OnOverlapEndComponent_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SlowDownVolume.OnOverlapEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASlowDownVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SlowDownVolume.OnOverlapEnd");
		
		ASlowDownVolume_OnOverlapEnd_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SlowDownVolume.OnOverlapBeginComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ASlowDownVolume::OnOverlapBeginComponent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SlowDownVolume.OnOverlapBeginComponent");
		
		ASlowDownVolume_OnOverlapBeginComponent_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SlowDownVolume.OnOverlapBegin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASlowDownVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SlowDownVolume.OnOverlapBegin");
		
		ASlowDownVolume_OnOverlapBegin_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASlowDownVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASlowDownVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SlowDownVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SniperCharacter.ExitControl
	 * 		Flags  -> ()
	 */
	void ASniperCharacter::ExitControl()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SniperCharacter.ExitControl");
		
		ASniperCharacter_ExitControl_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASniperCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASniperCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SniperCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SniperSpawn.SpawnSpotterHere
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Designation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASniperSpawn::SpawnSpotterHere(int32_t Designation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SniperSpawn.SpawnSpotterHere");
		
		ASniperSpawn_SpawnSpotterHere_Params params {};
		params.Designation = Designation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SniperSpawn.SpawnSniperHere
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Designation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASniperSpawn::SpawnSniperHere(int32_t Designation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SniperSpawn.SpawnSniperHere");
		
		ASniperSpawn_SpawnSniperHere_Params params {};
		params.Designation = Designation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SniperSpawn.SpawnPersonnelOfClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      CharacterClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Designation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASniperSpawn::SpawnPersonnelOfClass(class UClass* CharacterClass, int32_t Designation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SniperSpawn.SpawnPersonnelOfClass");
		
		ASniperSpawn_SpawnPersonnelOfClass_Params params {};
		params.CharacterClass = CharacterClass;
		params.Designation = Designation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SniperSpawn.SpawnMarksmanHere
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Designation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASniperSpawn::SpawnMarksmanHere(int32_t Designation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SniperSpawn.SpawnMarksmanHere");
		
		ASniperSpawn_SpawnMarksmanHere_Params params {};
		params.Designation = Designation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASniperSpawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASniperSpawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SniperSpawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoftCoverCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoftCoverCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SoftCoverCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SoundData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SoundNodeVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SoundPropagator.OnPropagationExitOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ASoundPropagator::OnPropagationExitOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SoundPropagator.OnPropagationExitOverlap");
		
		ASoundPropagator_OnPropagationExitOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SoundPropagator.OnPropagationEnterOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ASoundPropagator::OnPropagationEnterOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SoundPropagator.OnPropagationEnterOverlap");
		
		ASoundPropagator_OnPropagationEnterOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASoundPropagator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASoundPropagator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SoundPropagator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpawnGenerator.UpdatePlayerStartTags
	 * 		Flags  -> ()
	 */
	void ASpawnGenerator::UpdatePlayerStartTags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpawnGenerator.UpdatePlayerStartTags");
		
		ASpawnGenerator_UpdatePlayerStartTags_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpawnGenerator.SelectAll
	 * 		Flags  -> ()
	 */
	void ASpawnGenerator::SelectAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpawnGenerator.SelectAll");
		
		ASpawnGenerator_SelectAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpawnGenerator.RefreshSpawns
	 * 		Flags  -> ()
	 */
	void ASpawnGenerator::RefreshSpawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpawnGenerator.RefreshSpawns");
		
		ASpawnGenerator_RefreshSpawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpawnGenerator.GetSpawnTeam
	 * 		Flags  -> ()
	 */
	ETeamType ASpawnGenerator::GetSpawnTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpawnGenerator.GetSpawnTeam");
		
		ASpawnGenerator_GetSpawnTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpawnGenerator.GetNodes
	 * 		Flags  -> ()
	 */
	TArray<struct FCoreUObject_FVector> ASpawnGenerator::GetNodes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpawnGenerator.GetNodes");
		
		ASpawnGenerator_GetNodes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpawnGenerator.GetAllPlayerStarts
	 * 		Flags  -> ()
	 */
	TArray<class APlayerStart*> ASpawnGenerator::GetAllPlayerStarts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpawnGenerator.GetAllPlayerStarts");
		
		ASpawnGenerator_GetAllPlayerStarts_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpawnGenerator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpawnGenerator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SpawnGenerator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpawnSkeletalMeshAnimNotifyState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpawnSkeletalMeshAnimNotifyState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SpawnSkeletalMeshAnimNotifyState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpawnStaticMeshAnimNotifyState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpawnStaticMeshAnimNotifyState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SpawnStaticMeshAnimNotifyState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpectateHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpectateHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SpectateHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatePawn.SpectatePreviousPlayer
	 * 		Flags  -> ()
	 */
	void ASpectatePawn::SpectatePreviousPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatePawn.SpectatePreviousPlayer");
		
		ASpectatePawn_SpectatePreviousPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatePawn.SpectateNextPlayer
	 * 		Flags  -> ()
	 */
	void ASpectatePawn::SpectateNextPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatePawn.SpectateNextPlayer");
		
		ASpectatePawn_SpectateNextPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatePawn.SetViewTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpectatePawn::SetViewTarget(class APlayerCharacter* InCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatePawn.SetViewTarget");
		
		ASpectatePawn_SetViewTarget_Params params {};
		params.InCharacter = InCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatePawn.SetSpectatorCharacterWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USpectatorCharacterHUD*                      NewHud                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpectatePawn::SetSpectatorCharacterWidget(class USpectatorCharacterHUD* NewHud)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatePawn.SetSpectatorCharacterWidget");
		
		ASpectatePawn_SetSpectatorCharacterWidget_Params params {};
		params.NewHud = NewHud;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatePawn.OnTeamChatPressed
	 * 		Flags  -> ()
	 */
	void ASpectatePawn::OnTeamChatPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatePawn.OnTeamChatPressed");
		
		ASpectatePawn_OnTeamChatPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatePawn.OnChatPressed
	 * 		Flags  -> ()
	 */
	void ASpectatePawn::OnChatPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatePawn.OnChatPressed");
		
		ASpectatePawn_OnChatPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatePawn.GetTeam
	 * 		Flags  -> ()
	 */
	ETeamType ASpectatePawn::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatePawn.GetTeam");
		
		ASpectatePawn_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatePawn.EscapeMenu
	 * 		Flags  -> ()
	 */
	void ASpectatePawn::EscapeMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatePawn.EscapeMenu");
		
		ASpectatePawn_EscapeMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatePawn.CleanUpOldPlayer
	 * 		Flags  -> ()
	 */
	void ASpectatePawn::CleanUpOldPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatePawn.CleanUpOldPlayer");
		
		ASpectatePawn_CleanUpOldPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatePawn.CenterPrint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpectatePawn::CenterPrint(const class FName& Type, float Duration, class APlayerCharacter* Other)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatePawn.CenterPrint");
		
		ASpectatePawn_CenterPrint_Params params {};
		params.Type = Type;
		params.Duration = Duration;
		params.Other = Other;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpectatePawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpectatePawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SpectatePawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpinTestHeatmapVolume.VisualizeHeatMapIfExists
	 * 		Flags  -> ()
	 */
	void ASpinTestHeatmapVolume::VisualizeHeatMapIfExists()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpinTestHeatmapVolume.VisualizeHeatMapIfExists");
		
		ASpinTestHeatmapVolume_VisualizeHeatMapIfExists_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpinTestHeatmapVolume.FlushVisualization
	 * 		Flags  -> ()
	 */
	void ASpinTestHeatmapVolume::FlushVisualization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpinTestHeatmapVolume.FlushVisualization");
		
		ASpinTestHeatmapVolume_FlushVisualization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpinTestHeatmapVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpinTestHeatmapVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SpinTestHeatmapVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SplineTrigger.ToggleDrawDebug
	 * 		Flags  -> ()
	 */
	void ASplineTrigger::ToggleDrawDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SplineTrigger.ToggleDrawDebug");
		
		ASplineTrigger_ToggleDrawDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.SplineTrigger.OnSplineEnclosureExited__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASplineTrigger::OnSplineEnclosureExited__DelegateSignature(class APlayerCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.SplineTrigger.OnSplineEnclosureExited__DelegateSignature");
		
		ASplineTrigger_OnSplineEnclosureExited__DelegateSignature_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SplineTrigger.OnSplineEnclosureExited
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASplineTrigger::OnSplineEnclosureExited(class APlayerCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SplineTrigger.OnSplineEnclosureExited");
		
		ASplineTrigger_OnSplineEnclosureExited_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.SplineTrigger.OnSplineEnclosureEntered__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASplineTrigger::OnSplineEnclosureEntered__DelegateSignature(class APlayerCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.SplineTrigger.OnSplineEnclosureEntered__DelegateSignature");
		
		ASplineTrigger_OnSplineEnclosureEntered__DelegateSignature_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SplineTrigger.OnSplineEnclosureEntered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASplineTrigger::OnSplineEnclosureEntered(class APlayerCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SplineTrigger.OnSplineEnclosureEntered");
		
		ASplineTrigger_OnSplineEnclosureEntered_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SplineTrigger.IsOutsideSplineEnclosure
	 * 		Flags  -> ()
	 */
	bool ASplineTrigger::IsOutsideSplineEnclosure()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SplineTrigger.IsOutsideSplineEnclosure");
		
		ASplineTrigger_IsOutsideSplineEnclosure_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SplineTrigger.IsInsideSplineEnclosure
	 * 		Flags  -> ()
	 */
	bool ASplineTrigger::IsInsideSplineEnclosure()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SplineTrigger.IsInsideSplineEnclosure");
		
		ASplineTrigger_IsInsideSplineEnclosure_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SplineTrigger.IsActorOutsideSplineEnclosure
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASplineTrigger::IsActorOutsideSplineEnclosure(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SplineTrigger.IsActorOutsideSplineEnclosure");
		
		ASplineTrigger_IsActorOutsideSplineEnclosure_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SplineTrigger.IsActorInsideSplineEnclosure
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASplineTrigger::IsActorInsideSplineEnclosure(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SplineTrigger.IsActorInsideSplineEnclosure");
		
		ASplineTrigger_IsActorInsideSplineEnclosure_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SplineTrigger.EnableTrigger
	 * 		Flags  -> ()
	 */
	void ASplineTrigger::EnableTrigger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SplineTrigger.EnableTrigger");
		
		ASplineTrigger_EnableTrigger_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SplineTrigger.DisableTrigger
	 * 		Flags  -> ()
	 */
	void ASplineTrigger::DisableTrigger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SplineTrigger.DisableTrigger");
		
		ASplineTrigger_DisableTrigger_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASplineTrigger.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASplineTrigger::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SplineTrigger");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASplineTrigger_Incrimination.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASplineTrigger_Incrimination::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SplineTrigger_Incrimination");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USquadReadyStatus.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USquadReadyStatus::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SquadReadyStatus");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamActivityProxy.HasTeamReachedLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Tolerance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTeamActivityProxy::HasTeamReachedLocation(float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamActivityProxy.HasTeamReachedLocation");
		
		UTeamActivityProxy_HasTeamReachedLocation_Params params {};
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamActivityProxy.HasSquadPositionReachedLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     InSquadPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Tolerance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTeamActivityProxy::HasSquadPositionReachedLocation(ESquadPosition InSquadPosition, float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamActivityProxy.HasSquadPositionReachedLocation");
		
		UTeamActivityProxy_HasSquadPositionReachedLocation_Params params {};
		params.InSquadPosition = InSquadPosition;
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamActivityProxy.HasSquadPositionReachedDestination
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     InSquadPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTeamActivityProxy::HasSquadPositionReachedDestination(ESquadPosition InSquadPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamActivityProxy.HasSquadPositionReachedDestination");
		
		UTeamActivityProxy_HasSquadPositionReachedDestination_Params params {};
		params.InSquadPosition = InSquadPosition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamActivityProxy.HasAnySquadSquadPositionGotLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTeamBaseActivity*                           RequestingActivity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        InTestLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Tolerance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTeamActivityProxy::HasAnySquadSquadPositionGotLocation(class UTeamBaseActivity* RequestingActivity, const struct FCoreUObject_FVector& InTestLocation, float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamActivityProxy.HasAnySquadSquadPositionGotLocation");
		
		UTeamActivityProxy_HasAnySquadSquadPositionGotLocation_Params params {};
		params.RequestingActivity = RequestingActivity;
		params.InTestLocation = InTestLocation;
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamActivityProxy.GetDistanceToDestinationForSquadPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     InSquadPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UTeamActivityProxy::GetDistanceToDestinationForSquadPosition(ESquadPosition InSquadPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamActivityProxy.GetDistanceToDestinationForSquadPosition");
		
		UTeamActivityProxy_GetDistanceToDestinationForSquadPosition_Params params {};
		params.InSquadPosition = InSquadPosition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamActivityProxy.GetDistanceToCommandLocationForSquadPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     InSquadPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UTeamActivityProxy::GetDistanceToCommandLocationForSquadPosition(ESquadPosition InSquadPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamActivityProxy.GetDistanceToCommandLocationForSquadPosition");
		
		UTeamActivityProxy_GetDistanceToCommandLocationForSquadPosition_Params params {};
		params.InSquadPosition = InSquadPosition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamActivityProxy.GetDestinationLocationAtSquadPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     InSquadPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FCoreUObject_FVector UTeamActivityProxy::GetDestinationLocationAtSquadPosition(ESquadPosition InSquadPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamActivityProxy.GetDestinationLocationAtSquadPosition");
		
		UTeamActivityProxy_GetDestinationLocationAtSquadPosition_Params params {};
		params.InSquadPosition = InSquadPosition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamActivityProxy.GetCharacterClosestToLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        InTestLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ACyberneticCharacter* UTeamActivityProxy::GetCharacterClosestToLocation(const struct FCoreUObject_FVector& InTestLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamActivityProxy.GetCharacterClosestToLocation");
		
		UTeamActivityProxy_GetCharacterClosestToLocation_Params params {};
		params.InTestLocation = InTestLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamActivityProxy.GetCharacterAtSquadPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     InSquadPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ACyberneticCharacter* UTeamActivityProxy::GetCharacterAtSquadPosition(ESquadPosition InSquadPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamActivityProxy.GetCharacterAtSquadPosition");
		
		UTeamActivityProxy_GetCharacterAtSquadPosition_Params params {};
		params.InSquadPosition = InSquadPosition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamActivityProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamActivityProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamActivityProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.StackUpActivityProxy.FindDoorChecker
	 * 		Flags  -> ()
	 */
	class ACyberneticCharacter* UStackUpActivityProxy::FindDoorChecker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.StackUpActivityProxy.FindDoorChecker");
		
		UStackUpActivityProxy_FindDoorChecker_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStackUpActivityProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStackUpActivityProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.StackUpActivityProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AStackUpActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AStackUpActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.StackUpActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AStaticReportable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AStaticReportable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.StaticReportable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SteamworksIntegration.IsDLCInstalledEnum
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDLC                                               Dlc                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USteamworksIntegration::IsDLCInstalledEnum(EDLC Dlc)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SteamworksIntegration.IsDLCInstalledEnum");
		
		USteamworksIntegration_IsDLCInstalledEnum_Params params {};
		params.Dlc = Dlc;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SteamworksIntegration.IsDLCInstalled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            AppId                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USteamworksIntegration::IsDLCInstalled(int32_t AppId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SteamworksIntegration.IsDLCInstalled");
		
		USteamworksIntegration_IsDLCInstalled_Params params {};
		params.AppId = AppId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USteamworksIntegration.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USteamworksIntegration::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SteamworksIntegration");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStingerDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStingerDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.StingerDamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.StrideWarpingLibrary.UpdateStrideWarping
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Velocity                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              VelocityInterpTime                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CurrentAnimationSpeed                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayrateMaxAdjustment                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              StrideScaling                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayRate                                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        VelocitySmoothed                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStrideWarpingLibrary::UpdateStrideWarping(float DeltaTime, const struct FCoreUObject_FVector& Velocity, float VelocityInterpTime, float CurrentAnimationSpeed, float PlayrateMaxAdjustment, float* StrideScaling, float* PlayRate, struct FCoreUObject_FVector* VelocitySmoothed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.StrideWarpingLibrary.UpdateStrideWarping");
		
		UStrideWarpingLibrary_UpdateStrideWarping_Params params {};
		params.DeltaTime = DeltaTime;
		params.Velocity = Velocity;
		params.VelocityInterpTime = VelocityInterpTime;
		params.CurrentAnimationSpeed = CurrentAnimationSpeed;
		params.PlayrateMaxAdjustment = PlayrateMaxAdjustment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (StrideScaling != nullptr)
			*StrideScaling = params.StrideScaling;
		if (PlayRate != nullptr)
			*PlayRate = params.PlayRate;
		if (VelocitySmoothed != nullptr)
			*VelocitySmoothed = params.VelocitySmoothed;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStrideWarpingLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStrideWarpingLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.StrideWarpingLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USuppressionCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USuppressionCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SuppressionCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASuspectCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASuspectCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SuspectCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USuspectCombatActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USuspectCombatActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SuspectCombatActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASuspectController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASuspectController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SuspectController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SuspectsAndCivilianManager.Server_PlaySharedBarkOrStartConversation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SpeechRow                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticCharacter*                        Speaker                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Cooldown                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASuspectsAndCivilianManager::Server_PlaySharedBarkOrStartConversation(const class FString& SpeechRow, class ACyberneticCharacter* Speaker, float Cooldown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SuspectsAndCivilianManager.Server_PlaySharedBarkOrStartConversation");
		
		ASuspectsAndCivilianManager_Server_PlaySharedBarkOrStartConversation_Params params {};
		params.SpeechRow = SpeechRow;
		params.Speaker = Speaker;
		params.Cooldown = Cooldown;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SuspectsAndCivilianManager.GetNumActiveSuspects
	 * 		Flags  -> ()
	 */
	int32_t ASuspectsAndCivilianManager::GetNumActiveSuspects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SuspectsAndCivilianManager.GetNumActiveSuspects");
		
		ASuspectsAndCivilianManager_GetNumActiveSuspects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SuspectsAndCivilianManager.GetNumActiveCivilians
	 * 		Flags  -> ()
	 */
	int32_t ASuspectsAndCivilianManager::GetNumActiveCivilians()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SuspectsAndCivilianManager.GetNumActiveCivilians");
		
		ASuspectsAndCivilianManager_GetNumActiveCivilians_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SuspectsAndCivilianManager.Get
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASuspectsAndCivilianManager* ASuspectsAndCivilianManager::Get(class UWorld* World)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SuspectsAndCivilianManager.Get");
		
		ASuspectsAndCivilianManager_Get_Params params {};
		params.World = World;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASuspectsAndCivilianManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASuspectsAndCivilianManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SuspectsAndCivilianManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArmourMaterial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArmourMaterial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ArmourMaterial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASWATArmour.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASWATArmour::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SWATArmour");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASwatAutomationManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASwatAutomationManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SwatAutomationManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATCharacter.PlayOnShotDialogue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsFriendly                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATCharacter::PlayOnShotDialogue(bool bIsFriendly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATCharacter.PlayOnShotDialogue");
		
		ASWATCharacter_PlayOnShotDialogue_Params params {};
		params.bIsFriendly = bIsFriendly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASWATCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASWATCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SWATCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USwatCombatActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USwatCombatActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SwatCombatActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.RespondToSWATCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSwatCommand                                Command                                                    (Parm, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  CommandContextualData                                      (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void USwatCommandWidget::RespondToSWATCommand(const struct FSwatCommand& Command, ETeamType TeamType, const struct FHitResult& CommandContextualData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.RespondToSWATCommand");
		
		USwatCommandWidget_RespondToSWATCommand_Params params {};
		params.Command = Command;
		params.TeamType = TeamType;
		params.CommandContextualData = CommandContextualData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.SwatCommandWidget.OnSwatCommandIssued__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESwatCommand                                       SwatCommand                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USwatCommandWidget::OnSwatCommandIssued__DelegateSignature(ESwatCommand SwatCommand, ETeamType TeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.SwatCommandWidget.OnSwatCommandIssued__DelegateSignature");
		
		USwatCommandWidget_OnSwatCommandIssued__DelegateSignature_Params params {};
		params.SwatCommand = SwatCommand;
		params.TeamType = TeamType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.SwatCommandWidget.OnPostUpdateSwatCommands__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USwatCommandWidget*                          Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FSwatCommand>                        SwatCommands                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void USwatCommandWidget::OnPostUpdateSwatCommands__DelegateSignature(class USwatCommandWidget* Widget, TArray<struct FSwatCommand>* SwatCommands)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.SwatCommandWidget.OnPostUpdateSwatCommands__DelegateSignature");
		
		USwatCommandWidget_OnPostUpdateSwatCommands__DelegateSignature_Params params {};
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SwatCommands != nullptr)
			*SwatCommands = params.SwatCommands;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.OnPageViewUpdate
	 * 		Flags  -> ()
	 */
	void USwatCommandWidget::OnPageViewUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.OnPageViewUpdate");
		
		USwatCommandWidget_OnPageViewUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.HasQueuedCommandForTeam
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USwatCommandWidget::HasQueuedCommandForTeam(ETeamType TeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.HasQueuedCommandForTeam");
		
		USwatCommandWidget_HasQueuedCommandForTeam_Params params {};
		params.TeamType = TeamType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.HasQueuedCommandForActiveTeam
	 * 		Flags  -> ()
	 */
	bool USwatCommandWidget::HasQueuedCommandForActiveTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.HasQueuedCommandForActiveTeam");
		
		USwatCommandWidget_HasQueuedCommandForActiveTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.GetSubCommands
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSwatCommand                                Command                                                    (Parm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FSwatCommand>                        OutSubCommands                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool USwatCommandWidget::GetSubCommands(const struct FSwatCommand& Command, TArray<struct FSwatCommand>* OutSubCommands)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.GetSubCommands");
		
		USwatCommandWidget_GetSubCommands_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSubCommands != nullptr)
			*OutSubCommands = params.OutSubCommands;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.GetInputTwo
	 * 		Flags  -> ()
	 */
	struct FKey USwatCommandWidget::GetInputTwo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.GetInputTwo");
		
		USwatCommandWidget_GetInputTwo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.GetInputThree
	 * 		Flags  -> ()
	 */
	struct FKey USwatCommandWidget::GetInputThree()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.GetInputThree");
		
		USwatCommandWidget_GetInputThree_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.GetInputSix
	 * 		Flags  -> ()
	 */
	struct FKey USwatCommandWidget::GetInputSix()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.GetInputSix");
		
		USwatCommandWidget_GetInputSix_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.GetInputSeven
	 * 		Flags  -> ()
	 */
	struct FKey USwatCommandWidget::GetInputSeven()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.GetInputSeven");
		
		USwatCommandWidget_GetInputSeven_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.GetInputOne
	 * 		Flags  -> ()
	 */
	struct FKey USwatCommandWidget::GetInputOne()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.GetInputOne");
		
		USwatCommandWidget_GetInputOne_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.GetInputNine
	 * 		Flags  -> ()
	 */
	struct FKey USwatCommandWidget::GetInputNine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.GetInputNine");
		
		USwatCommandWidget_GetInputNine_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.GetInputFour
	 * 		Flags  -> ()
	 */
	struct FKey USwatCommandWidget::GetInputFour()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.GetInputFour");
		
		USwatCommandWidget_GetInputFour_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.GetInputFive
	 * 		Flags  -> ()
	 */
	struct FKey USwatCommandWidget::GetInputFive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.GetInputFive");
		
		USwatCommandWidget_GetInputFive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.GetInputEight
	 * 		Flags  -> ()
	 */
	struct FKey USwatCommandWidget::GetInputEight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.GetInputEight");
		
		USwatCommandWidget_GetInputEight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.GetInputBack
	 * 		Flags  -> ()
	 */
	struct FKey USwatCommandWidget::GetInputBack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.GetInputBack");
		
		USwatCommandWidget_GetInputBack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SwatCommandWidget.DoCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSwatCommand                                Command                                                    (Parm, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromQueue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          ActiveTeamOverride                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  ContextualDataOverride                                     (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bOverrideContextualData                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USwatCommandWidget::DoCommand(const struct FSwatCommand& Command, bool bFromQueue, ETeamType ActiveTeamOverride, const struct FHitResult& ContextualDataOverride, bool bOverrideContextualData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SwatCommandWidget.DoCommand");
		
		USwatCommandWidget_DoCommand_Params params {};
		params.Command = Command;
		params.bFromQueue = bFromQueue;
		params.ActiveTeamOverride = ActiveTeamOverride;
		params.ContextualDataOverride = ContextualDataOverride;
		params.bOverrideContextualData = bOverrideContextualData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USwatCommandWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USwatCommandWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SwatCommandWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASWATController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASWATController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SWATController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASwatCrouchVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASwatCrouchVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SwatCrouchVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USwatDuelingCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USwatDuelingCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SwatDuelingCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.RemoveHoldCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::RemoveHoldCommand(ETeamType TeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.RemoveHoldCommand");
		
		ASWATManager_RemoveHoldCommand_Params params {};
		params.TeamType = TeamType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.PlaySwatCommandVoiceLine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      VoiceLine                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OverrideSpearkerName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::PlaySwatCommandVoiceLine(const class FString& VoiceLine, const class FString& OverrideSpearkerName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.PlaySwatCommandVoiceLine");
		
		ASWATManager_PlaySwatCommandVoiceLine_Params params {};
		params.VoiceLine = VoiceLine;
		params.OverrideSpearkerName = OverrideSpearkerName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.IsSWATTeamDead
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASWATManager::IsSWATTeamDead(ETeamType Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.IsSWATTeamDead");
		
		ASWATManager_IsSWATTeamDead_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.IsPlayerAKnownEnemy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASWATManager::IsPlayerAKnownEnemy(class APlayerCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.IsPlayerAKnownEnemy");
		
		ASWATManager_IsPlayerAKnownEnemy_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveWedgeDoorCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandNormal                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveWedgeDoorCommand(class AActor* Target, ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation, const struct FCoreUObject_FVector& CommandNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveWedgeDoorCommand");
		
		ASWATManager_GiveWedgeDoorCommand_Params params {};
		params.Target = Target;
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		params.CommandNormal = CommandNormal;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveWaitingForCommand
	 * 		Flags  -> ()
	 */
	void ASWATManager::GiveWaitingForCommand()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveWaitingForCommand");
		
		ASWATManager_GiveWaitingForCommand_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveStackUpCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandNormal                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCheckDoor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveStackUpCommand(class AActor* Target, ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation, const struct FCoreUObject_FVector& CommandNormal, bool bCheckDoor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveStackUpCommand");
		
		ASWATManager_GiveStackUpCommand_Params params {};
		params.Target = Target;
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		params.CommandNormal = CommandNormal;
		params.bCheckDoor = bCheckDoor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveRestrainCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveRestrainCommand(class AActor* Target, ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveRestrainCommand");
		
		ASWATManager_GiveRestrainCommand_Params params {};
		params.Target = Target;
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveReportTargetCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveReportTargetCommand(class AActor* Target, ETeamType TeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveReportTargetCommand");
		
		ASWATManager_GiveReportTargetCommand_Params params {};
		params.Target = Target;
		params.TeamType = TeamType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveRemoveWedgeCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandNormal                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveRemoveWedgeCommand(class AActor* Target, ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation, const struct FCoreUObject_FVector& CommandNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveRemoveWedgeCommand");
		
		ASWATManager_GiveRemoveWedgeCommand_Params params {};
		params.Target = Target;
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		params.CommandNormal = CommandNormal;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GivePickLockCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GivePickLockCommand(class AActor* Target, ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GivePickLockCommand");
		
		ASWATManager_GivePickLockCommand_Params params {};
		params.Target = Target;
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveOpenDoorCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveOpenDoorCommand(class AActor* Target, ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveOpenDoorCommand");
		
		ASWATManager_GiveOpenDoorCommand_Params params {};
		params.Target = Target;
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveMoveCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandNormal                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMoveToCover                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveMoveCommand(ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation, const struct FCoreUObject_FVector& CommandNormal, float Delay, bool bMoveToCover)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveMoveCommand");
		
		ASWATManager_GiveMoveCommand_Params params {};
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		params.CommandNormal = CommandNormal;
		params.Delay = Delay;
		params.bMoveToCover = bMoveToCover;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveHoldCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveHoldCommand(ETeamType TeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveHoldCommand");
		
		ASWATManager_GiveHoldCommand_Params params {};
		params.TeamType = TeamType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveFallInCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveFallInCommand(ETeamType TeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveFallInCommand");
		
		ASWATManager_GiveFallInCommand_Params params {};
		params.TeamType = TeamType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveDropChemlightAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveDropChemlightAtLocation(ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveDropChemlightAtLocation");
		
		ASWATManager_GiveDropChemlightAtLocation_Params params {};
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveDisarmTrapOnDoorCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandNormal                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWaitForNextCommand                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveDisarmTrapOnDoorCommand(class AActor* Target, ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation, const struct FCoreUObject_FVector& CommandNormal, bool bWaitForNextCommand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveDisarmTrapOnDoorCommand");
		
		ASWATManager_GiveDisarmTrapOnDoorCommand_Params params {};
		params.Target = Target;
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		params.CommandNormal = CommandNormal;
		params.bWaitForNextCommand = bWaitForNextCommand;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveDisarmStandaloneTrapCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveDisarmStandaloneTrapCommand(class AActor* Target, ETeamType TeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveDisarmStandaloneTrapCommand");
		
		ASWATManager_GiveDisarmStandaloneTrapCommand_Params params {};
		params.Target = Target;
		params.TeamType = TeamType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveDeployShield
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveDeployShield(ETeamType TeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveDeployShield");
		
		ASWATManager_GiveDeployShield_Params params {};
		params.TeamType = TeamType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveDeployGrenadeAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Grenade                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveDeployGrenadeAtLocation(ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation, class UClass* Grenade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveDeployGrenadeAtLocation");
		
		ASWATManager_GiveDeployGrenadeAtLocation_Params params {};
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		params.Grenade = Grenade;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveCollectEvidenceCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveCollectEvidenceCommand(class AActor* Target, ETeamType TeamType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveCollectEvidenceCommand");
		
		ASWATManager_GiveCollectEvidenceCommand_Params params {};
		params.Target = Target;
		params.TeamType = TeamType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveCloseDoorCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveCloseDoorCommand(class AActor* Target, ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveCloseDoorCommand");
		
		ASWATManager_GiveCloseDoorCommand_Params params {};
		params.Target = Target;
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveCheckForTrapsCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandNormal                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveCheckForTrapsCommand(class AActor* Target, ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation, const struct FCoreUObject_FVector& CommandNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveCheckForTrapsCommand");
		
		ASWATManager_GiveCheckForTrapsCommand_Params params {};
		params.Target = Target;
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		params.CommandNormal = CommandNormal;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveCheckForContactsCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandNormal                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveCheckForContactsCommand(class AActor* Target, ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation, const struct FCoreUObject_FVector& CommandNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveCheckForContactsCommand");
		
		ASWATManager_GiveCheckForContactsCommand_Params params {};
		params.Target = Target;
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		params.CommandNormal = CommandNormal;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GiveBreachAndClearCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDoorBreachType                                    DoorBreachType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          TeamType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        CommandNormal                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DoorBreachItemClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DoorUseItemClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      InCustomBreachAndClearActivityClass                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASWATManager::GiveBreachAndClearCommand(class ADoor* Door, EDoorBreachType DoorBreachType, ETeamType TeamType, const struct FCoreUObject_FVector& CommandLocation, const struct FCoreUObject_FVector& CommandNormal, class UClass* DoorBreachItemClass, class UClass* DoorUseItemClass, class UClass* InCustomBreachAndClearActivityClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GiveBreachAndClearCommand");
		
		ASWATManager_GiveBreachAndClearCommand_Params params {};
		params.Door = Door;
		params.DoorBreachType = DoorBreachType;
		params.TeamType = TeamType;
		params.CommandLocation = CommandLocation;
		params.CommandNormal = CommandNormal;
		params.DoorBreachItemClass = DoorBreachItemClass;
		params.DoorUseItemClass = DoorUseItemClass;
		params.InCustomBreachAndClearActivityClass = InCustomBreachAndClearActivityClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GetSwatTeam
	 * 		Flags  -> ()
	 */
	TArray<class ASWATCharacter*> ASWATManager::GetSwatTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GetSwatTeam");
		
		ASWATManager_GetSwatTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GetSWATSortedByDistanceToLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          FilterTeam                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ADoor*                                       StackUpDoor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAscendingOrder                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class ASWATCharacter*> ASWATManager::GetSWATSortedByDistanceToLocation(const struct FCoreUObject_FVector& Location, ETeamType FilterTeam, class ADoor* StackUpDoor, bool bAscendingOrder)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GetSWATSortedByDistanceToLocation");
		
		ASWATManager_GetSWATSortedByDistanceToLocation_Params params {};
		params.Location = Location;
		params.FilterTeam = FilterTeam;
		params.StackUpDoor = StackUpDoor;
		params.bAscendingOrder = bAscendingOrder;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GetSWATManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASWATManager* ASWATManager::GetSWATManager(class UWorld* World)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GetSWATManager");
		
		ASWATManager_GetSWATManager_Params params {};
		params.World = World;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GetSwatCharacterAtSquadPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     InSquadPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASWATCharacter* ASWATManager::GetSwatCharacterAtSquadPosition(ESquadPosition InSquadPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GetSwatCharacterAtSquadPosition");
		
		ASWATManager_GetSwatCharacterAtSquadPosition_Params params {};
		params.InSquadPosition = InSquadPosition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GetQueuedSwatCommandForSquadPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     SquadPosition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ESwatCommand ASWATManager::GetQueuedSwatCommandForSquadPosition(ESquadPosition SquadPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GetQueuedSwatCommandForSquadPosition");
		
		ASWATManager_GetQueuedSwatCommandForSquadPosition_Params params {};
		params.SquadPosition = SquadPosition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.GetLeadCharacter
	 * 		Flags  -> ()
	 */
	class AReadyOrNotCharacter* ASWATManager::GetLeadCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.GetLeadCharacter");
		
		ASWATManager_GetLeadCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.CanGiveActivityToSWAT
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ASWATCharacter*                              SWAT                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamType                                          Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASWATManager::CanGiveActivityToSWAT(class ASWATCharacter* SWAT, ETeamType Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.CanGiveActivityToSWAT");
		
		ASWATManager_CanGiveActivityToSWAT_Params params {};
		params.SWAT = SWAT;
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SWATManager.CanDropItemContext
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASWATManager::CanDropItemContext(class UClass* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SWATManager.CanDropItemContext");
		
		ASWATManager_CanDropItemContext_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASWATManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASWATManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SWATManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATablet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATablet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Tablet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTabletDisplay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTabletDisplay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TabletDisplay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TableTennisMachine.StartGame
	 * 		Flags  -> ()
	 */
	void ATableTennisMachine::StartGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TableTennisMachine.StartGame");
		
		ATableTennisMachine_StartGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TableTennisMachine.SimulateGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDoLeftAI                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDoRightAI                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATableTennisMachine::SimulateGame(float DeltaTime, bool bDoLeftAI, bool bDoRightAI)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TableTennisMachine.SimulateGame");
		
		ATableTennisMachine_SimulateGame_Params params {};
		params.DeltaTime = DeltaTime;
		params.bDoLeftAI = bDoLeftAI;
		params.bDoRightAI = bDoRightAI;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TableTennisMachine.PlayBoop
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bRight                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATableTennisMachine::PlayBoop(bool bRight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TableTennisMachine.PlayBoop");
		
		ATableTennisMachine_PlayBoop_Params params {};
		params.bRight = bRight;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TableTennisMachine.DrawGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCanvas*                                     Canvas                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATableTennisMachine::DrawGame(class UCanvas* Canvas)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TableTennisMachine.DrawGame");
		
		ATableTennisMachine_DrawGame_Params params {};
		params.Canvas = Canvas;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATableTennisMachine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATableTennisMachine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TableTennisMachine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TacticalAuthorityCommandWidget.SetReportItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      NewReportItem                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTacticalAuthorityCommandWidget::SetReportItem(class AActor* NewReportItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TacticalAuthorityCommandWidget.SetReportItem");
		
		UTacticalAuthorityCommandWidget_SetReportItem_Params params {};
		params.NewReportItem = NewReportItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TacticalAuthorityCommandWidget.SetCommandActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      NewCommandActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTacticalAuthorityCommandWidget::SetCommandActor(class AActor* NewCommandActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TacticalAuthorityCommandWidget.SetCommandActor");
		
		UTacticalAuthorityCommandWidget_SetCommandActor_Params params {};
		params.NewCommandActor = NewCommandActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TacticalAuthorityCommandWidget.OnSecondaryUseReleased
	 * 		Flags  -> ()
	 */
	void UTacticalAuthorityCommandWidget::OnSecondaryUseReleased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TacticalAuthorityCommandWidget.OnSecondaryUseReleased");
		
		UTacticalAuthorityCommandWidget_OnSecondaryUseReleased_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TacticalAuthorityCommandWidget.OnSecondaryUsePressed
	 * 		Flags  -> ()
	 */
	void UTacticalAuthorityCommandWidget::OnSecondaryUsePressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TacticalAuthorityCommandWidget.OnSecondaryUsePressed");
		
		UTacticalAuthorityCommandWidget_OnSecondaryUsePressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TacticalAuthorityCommandWidget.MapDeltaToTacticalAuthorityVoice
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaX                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaY                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTacticalAuthorityCommandWidget::MapDeltaToTacticalAuthorityVoice(float DeltaX, float DeltaY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TacticalAuthorityCommandWidget.MapDeltaToTacticalAuthorityVoice");
		
		UTacticalAuthorityCommandWidget_MapDeltaToTacticalAuthorityVoice_Params params {};
		params.DeltaX = DeltaX;
		params.DeltaY = DeltaY;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTacticalAuthorityCommandWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTacticalAuthorityCommandWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TacticalAuthorityCommandWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.TickMoveToCoverState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverActivity::TickMoveToCoverState(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.TickMoveToCoverState");
		
		UTakeCoverActivity_TickMoveToCoverState_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.TickCoverState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverActivity::TickCoverState(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.TickCoverState");
		
		UTakeCoverActivity_TickCoverState_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.TickCoverFireState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverActivity::TickCoverFireState(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.TickCoverFireState");
		
		UTakeCoverActivity_TickCoverFireState_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.OnTakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverActivity::OnTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.OnTakeDamage");
		
		UTakeCoverActivity_OnTakeDamage_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.OnStunned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverActivity::OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.OnStunned");
		
		UTakeCoverActivity_OnStunned_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.TakeCoverActivity.OnEnteredCover__DelegateSignature
	 * 		Flags  -> ()
	 */
	void UTakeCoverActivity::OnEnteredCover__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.TakeCoverActivity.OnEnteredCover__DelegateSignature");
		
		UTakeCoverActivity_OnEnteredCover__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.OnEnemyWeaponFire
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseMagazineWeapon*                         Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        fireDirection                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverActivity::OnEnemyWeaponFire(class AReadyOrNotCharacter* Character, class ABaseMagazineWeapon* Weapon, const struct FCoreUObject_FVector& fireDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.OnEnemyWeaponFire");
		
		UTakeCoverActivity_OnEnemyWeaponFire_Params params {};
		params.Character = Character;
		params.Weapon = Weapon;
		params.fireDirection = fireDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.ExitCoverState
	 * 		Flags  -> ()
	 */
	void UTakeCoverActivity::ExitCoverState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.ExitCoverState");
		
		UTakeCoverActivity_ExitCoverState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.ExitCoverFireState
	 * 		Flags  -> ()
	 */
	void UTakeCoverActivity::ExitCoverFireState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.ExitCoverFireState");
		
		UTakeCoverActivity_ExitCoverFireState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.EnterMoveToCoverState
	 * 		Flags  -> ()
	 */
	void UTakeCoverActivity::EnterMoveToCoverState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.EnterMoveToCoverState");
		
		UTakeCoverActivity_EnterMoveToCoverState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.EnterCoverState
	 * 		Flags  -> ()
	 */
	void UTakeCoverActivity::EnterCoverState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.EnterCoverState");
		
		UTakeCoverActivity_EnterCoverState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.EnterCoverFireState
	 * 		Flags  -> ()
	 */
	void UTakeCoverActivity::EnterCoverFireState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.EnterCoverFireState");
		
		UTakeCoverActivity_EnterCoverFireState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.EnterCompleteState
	 * 		Flags  -> ()
	 */
	void UTakeCoverActivity::EnterCompleteState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.EnterCompleteState");
		
		UTakeCoverActivity_EnterCompleteState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.CanStopCoverFire
	 * 		Flags  -> ()
	 */
	bool UTakeCoverActivity::CanStopCoverFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.CanStopCoverFire");
		
		UTakeCoverActivity_CanStopCoverFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.CanFireFromCover
	 * 		Flags  -> ()
	 */
	bool UTakeCoverActivity::CanFireFromCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.CanFireFromCover");
		
		UTakeCoverActivity_CanFireFromCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.CanCover
	 * 		Flags  -> ()
	 */
	bool UTakeCoverActivity::CanCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.CanCover");
		
		UTakeCoverActivity_CanCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverActivity.CanCompleteCover
	 * 		Flags  -> ()
	 */
	bool UTakeCoverActivity::CanCompleteCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverActivity.CanCompleteCover");
		
		UTakeCoverActivity_CanCompleteCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTakeCoverActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTakeCoverActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TakeCoverActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.TickMoveToLandmarkState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverAtLandmarkActivity::TickMoveToLandmarkState(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.TickMoveToLandmarkState");
		
		UTakeCoverAtLandmarkActivity_TickMoveToLandmarkState_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.Tick_Wait_State
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverAtLandmarkActivity::Tick_Wait_State(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.Tick_Wait_State");
		
		UTakeCoverAtLandmarkActivity_Tick_Wait_State_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.Tick_ExitLandmark_State
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverAtLandmarkActivity::Tick_ExitLandmark_State(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.Tick_ExitLandmark_State");
		
		UTakeCoverAtLandmarkActivity_Tick_ExitLandmark_State_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.Tick_EnterLandmark_State
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverAtLandmarkActivity::Tick_EnterLandmark_State(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.Tick_EnterLandmark_State");
		
		UTakeCoverAtLandmarkActivity_Tick_EnterLandmark_State_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.Tick_AbruptExit_State
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverAtLandmarkActivity::Tick_AbruptExit_State(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.Tick_AbruptExit_State");
		
		UTakeCoverAtLandmarkActivity_Tick_AbruptExit_State_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.ShouldWait
	 * 		Flags  -> ()
	 */
	bool UTakeCoverAtLandmarkActivity::ShouldWait()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.ShouldWait");
		
		UTakeCoverAtLandmarkActivity_ShouldWait_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.OnTakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverAtLandmarkActivity::OnTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.OnTakeDamage");
		
		UTakeCoverAtLandmarkActivity_OnTakeDamage_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.OnStunned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverAtLandmarkActivity::OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.OnStunned");
		
		UTakeCoverAtLandmarkActivity_OnStunned_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.OnHeardYell
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Shouter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLOS                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverAtLandmarkActivity::OnHeardYell(class AReadyOrNotCharacter* Shouter, bool bLOS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.OnHeardYell");
		
		UTakeCoverAtLandmarkActivity_OnHeardYell_Params params {};
		params.Shouter = Shouter;
		params.bLOS = bLOS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.OnEnemyWeaponFire
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ABaseMagazineWeapon*                         Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        fireDirection                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeCoverAtLandmarkActivity::OnEnemyWeaponFire(class AReadyOrNotCharacter* Character, class ABaseMagazineWeapon* Weapon, const struct FCoreUObject_FVector& fireDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.OnEnemyWeaponFire");
		
		UTakeCoverAtLandmarkActivity_OnEnemyWeaponFire_Params params {};
		params.Character = Character;
		params.Weapon = Weapon;
		params.fireDirection = fireDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.EnterMoveToLandmarkState
	 * 		Flags  -> ()
	 */
	void UTakeCoverAtLandmarkActivity::EnterMoveToLandmarkState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.EnterMoveToLandmarkState");
		
		UTakeCoverAtLandmarkActivity_EnterMoveToLandmarkState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.Enter_Wait_State
	 * 		Flags  -> ()
	 */
	void UTakeCoverAtLandmarkActivity::Enter_Wait_State()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.Enter_Wait_State");
		
		UTakeCoverAtLandmarkActivity_Enter_Wait_State_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.Enter_ExitLandmark_State
	 * 		Flags  -> ()
	 */
	void UTakeCoverAtLandmarkActivity::Enter_ExitLandmark_State()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.Enter_ExitLandmark_State");
		
		UTakeCoverAtLandmarkActivity_Enter_ExitLandmark_State_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.Enter_EnterLandmark_State
	 * 		Flags  -> ()
	 */
	void UTakeCoverAtLandmarkActivity::Enter_EnterLandmark_State()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.Enter_EnterLandmark_State");
		
		UTakeCoverAtLandmarkActivity_Enter_EnterLandmark_State_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.Enter_AbruptExit_State
	 * 		Flags  -> ()
	 */
	void UTakeCoverAtLandmarkActivity::Enter_AbruptExit_State()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.Enter_AbruptExit_State");
		
		UTakeCoverAtLandmarkActivity_Enter_AbruptExit_State_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.CanExitLandmark
	 * 		Flags  -> ()
	 */
	bool UTakeCoverAtLandmarkActivity::CanExitLandmark()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.CanExitLandmark");
		
		UTakeCoverAtLandmarkActivity_CanExitLandmark_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.CanEnterLandmark
	 * 		Flags  -> ()
	 */
	bool UTakeCoverAtLandmarkActivity::CanEnterLandmark()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.CanEnterLandmark");
		
		UTakeCoverAtLandmarkActivity_CanEnterLandmark_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeCoverAtLandmarkActivity.CanAbruptlyExit
	 * 		Flags  -> ()
	 */
	bool UTakeCoverAtLandmarkActivity::CanAbruptlyExit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeCoverAtLandmarkActivity.CanAbruptlyExit");
		
		UTakeCoverAtLandmarkActivity_CanAbruptlyExit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTakeCoverAtLandmarkActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTakeCoverAtLandmarkActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TakeCoverAtLandmarkActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.TickTurnState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::TickTurnState(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.TickTurnState");
		
		UTakeHostageActivity_TickTurnState_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.TickTakingState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::TickTakingState(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.TickTakingState");
		
		UTakeHostageActivity_TickTakingState_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.TickMoveToState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::TickMoveToState(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.TickMoveToState");
		
		UTakeHostageActivity_TickMoveToState_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.TickEndHostageTakeState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::TickEndHostageTakeState(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.TickEndHostageTakeState");
		
		UTakeHostageActivity_TickEndHostageTakeState_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.TickBeginHostageTakeState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::TickBeginHostageTakeState(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.TickBeginHostageTakeState");
		
		UTakeHostageActivity_TickBeginHostageTakeState_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.ShouldTurn
	 * 		Flags  -> ()
	 */
	bool UTakeHostageActivity::ShouldTurn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.ShouldTurn");
		
		UTakeHostageActivity_ShouldTurn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.OnTakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        DamagedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HealthRemaining                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::OnTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.OnTakeDamage");
		
		UTakeHostageActivity_OnTakeDamage_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.DamagedCharacter = DamagedCharacter;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		params.HealthRemaining = HealthRemaining;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.OnStunned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.OnStunned");
		
		UTakeHostageActivity_OnStunned_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.OnSensedCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        SensedCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::OnSensedCharacter(class AReadyOrNotCharacter* SensedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.OnSensedCharacter");
		
		UTakeHostageActivity_OnSensedCharacter_Params params {};
		params.SensedCharacter = SensedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.OnHostageTakeTurnComplete_Slave
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::OnHostageTakeTurnComplete_Slave(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.OnHostageTakeTurnComplete_Slave");
		
		UTakeHostageActivity_OnHostageTakeTurnComplete_Slave_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.OnHostageTakeTurnComplete_Driver
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::OnHostageTakeTurnComplete_Driver(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.OnHostageTakeTurnComplete_Driver");
		
		UTakeHostageActivity_OnHostageTakeTurnComplete_Driver_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.OnHostageTakeStartComplete_Slave
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::OnHostageTakeStartComplete_Slave(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.OnHostageTakeStartComplete_Slave");
		
		UTakeHostageActivity_OnHostageTakeStartComplete_Slave_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.OnHostageTakeStartComplete_Driver
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::OnHostageTakeStartComplete_Driver(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.OnHostageTakeStartComplete_Driver");
		
		UTakeHostageActivity_OnHostageTakeStartComplete_Driver_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.OnHostageTakeKillComplete_Slave
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::OnHostageTakeKillComplete_Slave(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.OnHostageTakeKillComplete_Slave");
		
		UTakeHostageActivity_OnHostageTakeKillComplete_Slave_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.OnHostageTakeKillComplete_Driver
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::OnHostageTakeKillComplete_Driver(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.OnHostageTakeKillComplete_Driver");
		
		UTakeHostageActivity_OnHostageTakeKillComplete_Driver_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.OnHostageTakeEndComplete_Slave
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::OnHostageTakeEndComplete_Slave(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.OnHostageTakeEndComplete_Slave");
		
		UTakeHostageActivity_OnHostageTakeEndComplete_Slave_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.OnHostageTakeEndComplete_Driver
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::OnHostageTakeEndComplete_Driver(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.OnHostageTakeEndComplete_Driver");
		
		UTakeHostageActivity_OnHostageTakeEndComplete_Driver_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.OnHostageKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::OnHostageKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.OnHostageKilled");
		
		UTakeHostageActivity_OnHostageKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.OnHeardYell
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Shouter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLOS                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeHostageActivity::OnHeardYell(class AReadyOrNotCharacter* Shouter, bool bLOS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.OnHeardYell");
		
		UTakeHostageActivity_OnHeardYell_Params params {};
		params.Shouter = Shouter;
		params.bLOS = bLOS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.EnterTurnState
	 * 		Flags  -> ()
	 */
	void UTakeHostageActivity::EnterTurnState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.EnterTurnState");
		
		UTakeHostageActivity_EnterTurnState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.EnterTakingState
	 * 		Flags  -> ()
	 */
	void UTakeHostageActivity::EnterTakingState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.EnterTakingState");
		
		UTakeHostageActivity_EnterTakingState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.EnterMoveToState
	 * 		Flags  -> ()
	 */
	void UTakeHostageActivity::EnterMoveToState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.EnterMoveToState");
		
		UTakeHostageActivity_EnterMoveToState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.EnterEndHostageTakeState
	 * 		Flags  -> ()
	 */
	void UTakeHostageActivity::EnterEndHostageTakeState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.EnterEndHostageTakeState");
		
		UTakeHostageActivity_EnterEndHostageTakeState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.EnterBeginHostageTakeState
	 * 		Flags  -> ()
	 */
	void UTakeHostageActivity::EnterBeginHostageTakeState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.EnterBeginHostageTakeState");
		
		UTakeHostageActivity_EnterBeginHostageTakeState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.EndTakingState
	 * 		Flags  -> ()
	 */
	void UTakeHostageActivity::EndTakingState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.EndTakingState");
		
		UTakeHostageActivity_EndTakingState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.CanStartHostageTake
	 * 		Flags  -> ()
	 */
	bool UTakeHostageActivity::CanStartHostageTake()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.CanStartHostageTake");
		
		UTakeHostageActivity_CanStartHostageTake_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.CanIdle
	 * 		Flags  -> ()
	 */
	bool UTakeHostageActivity::CanIdle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.CanIdle");
		
		UTakeHostageActivity_CanIdle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TakeHostageActivity.CanEndHostageTake
	 * 		Flags  -> ()
	 */
	bool UTakeHostageActivity::CanEndHostageTake()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TakeHostageActivity.CanEndHostageTake");
		
		UTakeHostageActivity_CanEndHostageTake_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTakeHostageActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTakeHostageActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TakeHostageActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.ShareTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetingComponent::ShareTarget(class AReadyOrNotCharacter* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.ShareTarget");
		
		UTargetingComponent_ShareTarget_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.SetLastTrackedTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetingComponent::SetLastTrackedTarget(class AReadyOrNotCharacter* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.SetLastTrackedTarget");
		
		UTargetingComponent_SetLastTrackedTarget_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.RemoveKnownEnemy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Enemy                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetingComponent::RemoveKnownEnemy(class AReadyOrNotCharacter* Enemy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.RemoveKnownEnemy");
		
		UTargetingComponent_RemoveKnownEnemy_Params params {};
		params.Enemy = Enemy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.IsTrackingMontagePosition
	 * 		Flags  -> ()
	 */
	bool UTargetingComponent::IsTrackingMontagePosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.IsTrackingMontagePosition");
		
		UTargetingComponent_IsTrackingMontagePosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.IsTrackedInKnownNeutrals
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::IsTrackedInKnownNeutrals(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.IsTrackedInKnownNeutrals");
		
		UTargetingComponent_IsTrackedInKnownNeutrals_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.IsTrackedInKnownFriendlies
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::IsTrackedInKnownFriendlies(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.IsTrackedInKnownFriendlies");
		
		UTargetingComponent_IsTrackedInKnownFriendlies_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.IsTrackedInKnownEnemies
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        PlayerCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::IsTrackedInKnownEnemies(class AReadyOrNotCharacter* PlayerCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.IsTrackedInKnownEnemies");
		
		UTargetingComponent_IsTrackedInKnownEnemies_Params params {};
		params.PlayerCharacter = PlayerCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.IsTrackedByKnownFriendly
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::IsTrackedByKnownFriendly(class AReadyOrNotCharacter* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.IsTrackedByKnownFriendly");
		
		UTargetingComponent_IsTrackedByKnownFriendly_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.IsTargetingLastBoneZone
	 * 		Flags  -> ()
	 */
	bool UTargetingComponent::IsTargetingLastBoneZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.IsTargetingLastBoneZone");
		
		UTargetingComponent_IsTargetingLastBoneZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.IsLookingAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        InTargetLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::IsLookingAtLocation(const struct FCoreUObject_FVector& InTargetLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.IsLookingAtLocation");
		
		UTargetingComponent_IsLookingAtLocation_Params params {};
		params.InTargetLocation = InTargetLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.IsLookingAtFocalPoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Tolerance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::IsLookingAtFocalPoint(float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.IsLookingAtFocalPoint");
		
		UTargetingComponent_IsLookingAtFocalPoint_Params params {};
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.IsLocationCloseToKnownEnemies
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Tolerance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::IsLocationCloseToKnownEnemies(const struct FCoreUObject_FVector& Location, float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.IsLocationCloseToKnownEnemies");
		
		UTargetingComponent_IsLocationCloseToKnownEnemies_Params params {};
		params.Location = Location;
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.IsAnySwatLookingAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        InTargetLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::IsAnySwatLookingAtLocation(const struct FCoreUObject_FVector& InTargetLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.IsAnySwatLookingAtLocation");
		
		UTargetingComponent_IsAnySwatLookingAtLocation_Params params {};
		params.InTargetLocation = InTargetLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.HasSeenCharacterFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::HasSeenCharacterFor(class AReadyOrNotCharacter* InCharacter, float Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.HasSeenCharacterFor");
		
		UTargetingComponent_HasSeenCharacterFor_Params params {};
		params.InCharacter = InCharacter;
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.HasLineOfSightToTrackedTarget
	 * 		Flags  -> ()
	 */
	bool UTargetingComponent::HasLineOfSightToTrackedTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.HasLineOfSightToTrackedTarget");
		
		UTargetingComponent_HasLineOfSightToTrackedTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.HasLineOfSightToLastTrackedTarget
	 * 		Flags  -> ()
	 */
	bool UTargetingComponent::HasLineOfSightToLastTrackedTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.HasLineOfSightToLastTrackedTarget");
		
		UTargetingComponent_HasLineOfSightToLastTrackedTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.HasLineOfSightToLastKnownTargetPosition
	 * 		Flags  -> ()
	 */
	bool UTargetingComponent::HasLineOfSightToLastKnownTargetPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.HasLineOfSightToLastKnownTargetPosition");
		
		UTargetingComponent_HasLineOfSightToLastKnownTargetPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetVisibleKnownFriendlies
	 * 		Flags  -> ()
	 */
	int32_t UTargetingComponent::GetVisibleKnownFriendlies()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetVisibleKnownFriendlies");
		
		UTargetingComponent_GetVisibleKnownFriendlies_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetTrackingType
	 * 		Flags  -> ()
	 */
	ETargetingCompTracking UTargetingComponent::GetTrackingType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetTrackingType");
		
		UTargetingComponent_GetTrackingType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetTrackedTargetData
	 * 		Flags  -> ()
	 */
	struct FTargetData UTargetingComponent::GetTrackedTargetData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetTrackedTargetData");
		
		UTargetingComponent_GetTrackedTargetData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetTrackedTarget
	 * 		Flags  -> ()
	 */
	class AReadyOrNotCharacter* UTargetingComponent::GetTrackedTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetTrackedTarget");
		
		UTargetingComponent_GetTrackedTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetTimeTrackingTarget
	 * 		Flags  -> ()
	 */
	float UTargetingComponent::GetTimeTrackingTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetTimeTrackingTarget");
		
		UTargetingComponent_GetTimeTrackingTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetTimeTrackingHead
	 * 		Flags  -> ()
	 */
	float UTargetingComponent::GetTimeTrackingHead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetTimeTrackingHead");
		
		UTargetingComponent_GetTimeTrackingHead_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetTimeSinceLastSeenEnemy
	 * 		Flags  -> ()
	 */
	float UTargetingComponent::GetTimeSinceLastSeenEnemy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetTimeSinceLastSeenEnemy");
		
		UTargetingComponent_GetTimeSinceLastSeenEnemy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetThreatsFromLocationBeyondRadius
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AThreatAwarenessActor*>               InThreats                                                  (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinDistance                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class AThreatAwarenessActor*> UTargetingComponent::GetThreatsFromLocationBeyondRadius(TArray<class AThreatAwarenessActor*> InThreats, const struct FCoreUObject_FVector& Location, float MinDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetThreatsFromLocationBeyondRadius");
		
		UTargetingComponent_GetThreatsFromLocationBeyondRadius_Params params {};
		params.InThreats = InThreats;
		params.Location = Location;
		params.MinDistance = MinDistance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetThreatsForLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AThreatAwarenessActor*>               OutThreats                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinDistance                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRequireLOS                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetingComponent::GetThreatsForLocation(TArray<class AThreatAwarenessActor*>* OutThreats, const struct FCoreUObject_FVector& Location, float MinDistance, bool bRequireLOS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetThreatsForLocation");
		
		UTargetingComponent_GetThreatsForLocation_Params params {};
		params.Location = Location;
		params.MinDistance = MinDistance;
		params.bRequireLOS = bRequireLOS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutThreats != nullptr)
			*OutThreats = params.OutThreats;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetThreats
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AThreatAwarenessActor*>               OutThreats                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UTargetingComponent::GetThreats(TArray<class AThreatAwarenessActor*>* OutThreats)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetThreats");
		
		UTargetingComponent_GetThreats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutThreats != nullptr)
			*OutThreats = params.OutThreats;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetTargetedBone
	 * 		Flags  -> ()
	 */
	class FName UTargetingComponent::GetTargetedBone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetTargetedBone");
		
		UTargetingComponent_GetTargetedBone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetRequiredTrackingTime
	 * 		Flags  -> ()
	 */
	float UTargetingComponent::GetRequiredTrackingTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetRequiredTrackingTime");
		
		UTargetingComponent_GetRequiredTrackingTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetRecentlyVisibleKnownEnemies
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              TimeSinceLastSeen                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UTargetingComponent::GetRecentlyVisibleKnownEnemies(float TimeSinceLastSeen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetRecentlyVisibleKnownEnemies");
		
		UTargetingComponent_GetRecentlyVisibleKnownEnemies_Params params {};
		params.TimeSinceLastSeen = TimeSinceLastSeen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetNearestThreatToLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AThreatAwarenessActor* UTargetingComponent::GetNearestThreatToLocation(const struct FCoreUObject_FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetNearestThreatToLocation");
		
		UTargetingComponent_GetNearestThreatToLocation_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetNearestThreat
	 * 		Flags  -> ()
	 */
	class AThreatAwarenessActor* UTargetingComponent::GetNearestThreat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetNearestThreat");
		
		UTargetingComponent_GetNearestThreat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetNearestHighestThreat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AThreatAwarenessActor*>               InThreats                                                  (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AThreatAwarenessActor* UTargetingComponent::GetNearestHighestThreat(TArray<class AThreatAwarenessActor*> InThreats, const struct FCoreUObject_FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetNearestHighestThreat");
		
		UTargetingComponent_GetNearestHighestThreat_Params params {};
		params.InThreats = InThreats;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetLastTrackedTarget
	 * 		Flags  -> ()
	 */
	class AReadyOrNotCharacter* UTargetingComponent::GetLastTrackedTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetLastTrackedTarget");
		
		UTargetingComponent_GetLastTrackedTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetLastSeenKnownEnemyFrom
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector UTargetingComponent::GetLastSeenKnownEnemyFrom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetLastSeenKnownEnemyFrom");
		
		UTargetingComponent_GetLastSeenKnownEnemyFrom_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetLastKnownPositionActor
	 * 		Flags  -> ()
	 */
	class ALastKnownPositionActor* UTargetingComponent::GetLastKnownPositionActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetLastKnownPositionActor");
		
		UTargetingComponent_GetLastKnownPositionActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetLastKnownEnemyPosition
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector UTargetingComponent::GetLastKnownEnemyPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetLastKnownEnemyPosition");
		
		UTargetingComponent_GetLastKnownEnemyPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetLastKnownEnemy
	 * 		Flags  -> ()
	 */
	class AReadyOrNotCharacter* UTargetingComponent::GetLastKnownEnemy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetLastKnownEnemy");
		
		UTargetingComponent_GetLastKnownEnemy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetLastHeardNoiseLocation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector UTargetingComponent::GetLastHeardNoiseLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetLastHeardNoiseLocation");
		
		UTargetingComponent_GetLastHeardNoiseLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetLastHeardAggressiveNoiseLocation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector UTargetingComponent::GetLastHeardAggressiveNoiseLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetLastHeardAggressiveNoiseLocation");
		
		UTargetingComponent_GetLastHeardAggressiveNoiseLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetKnownNeutrals
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AReadyOrNotCharacter*>                OutNeutrals                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UTargetingComponent::GetKnownNeutrals(TArray<class AReadyOrNotCharacter*>* OutNeutrals)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetKnownNeutrals");
		
		UTargetingComponent_GetKnownNeutrals_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutNeutrals != nullptr)
			*OutNeutrals = params.OutNeutrals;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetKnownFriendlyCount
	 * 		Flags  -> ()
	 */
	int32_t UTargetingComponent::GetKnownFriendlyCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetKnownFriendlyCount");
		
		UTargetingComponent_GetKnownFriendlyCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetKnownFriendlies
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AReadyOrNotCharacter*>                OutFriendlies                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UTargetingComponent::GetKnownFriendlies(TArray<class AReadyOrNotCharacter*>* OutFriendlies)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetKnownFriendlies");
		
		UTargetingComponent_GetKnownFriendlies_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutFriendlies != nullptr)
			*OutFriendlies = params.OutFriendlies;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetKnownEnemies
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FTargetData>                         OutEnemies                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UTargetingComponent::GetKnownEnemies(TArray<struct FTargetData>* OutEnemies)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetKnownEnemies");
		
		UTargetingComponent_GetKnownEnemies_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutEnemies != nullptr)
			*OutEnemies = params.OutEnemies;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetFurthestHighestThreat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AThreatAwarenessActor*>               InThreats                                                  (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AThreatAwarenessActor* UTargetingComponent::GetFurthestHighestThreat(TArray<class AThreatAwarenessActor*> InThreats, const struct FCoreUObject_FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetFurthestHighestThreat");
		
		UTargetingComponent_GetFurthestHighestThreat_Params params {};
		params.InThreats = InThreats;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetCoverAreaLocation
	 * 		Flags  -> ()
	 */
	struct FCoreUObject_FVector UTargetingComponent::GetCoverAreaLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetCoverAreaLocation");
		
		UTargetingComponent_GetCoverAreaLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetClosestKnownNeutral
	 * 		Flags  -> ()
	 */
	class AReadyOrNotCharacter* UTargetingComponent::GetClosestKnownNeutral()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetClosestKnownNeutral");
		
		UTargetingComponent_GetClosestKnownNeutral_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetClosestKnownFriendly
	 * 		Flags  -> ()
	 */
	class AReadyOrNotCharacter* UTargetingComponent::GetClosestKnownFriendly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetClosestKnownFriendly");
		
		UTargetingComponent_GetClosestKnownFriendly_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetClosestKnownEnemy
	 * 		Flags  -> ()
	 */
	class AReadyOrNotCharacter* UTargetingComponent::GetClosestKnownEnemy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetClosestKnownEnemy");
		
		UTargetingComponent_GetClosestKnownEnemy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.GetClosestDistanceToKnownEnemies
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoreUObject_FVector                        Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UTargetingComponent::GetClosestDistanceToKnownEnemies(const struct FCoreUObject_FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.GetClosestDistanceToKnownEnemies");
		
		UTargetingComponent_GetClosestDistanceToKnownEnemies_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.ContainsThreatLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AThreatAwarenessActor*                       InThreat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<EThreatLevel>                               ThreatsLevels                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::ContainsThreatLevel(class AThreatAwarenessActor* InThreat, TArray<EThreatLevel> ThreatsLevels)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.ContainsThreatLevel");
		
		UTargetingComponent_ContainsThreatLevel_Params params {};
		params.InThreat = InThreat;
		params.ThreatsLevels = ThreatsLevels;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.CanSeeTrackedTarget
	 * 		Flags  -> ()
	 */
	bool UTargetingComponent::CanSeeTrackedTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.CanSeeTrackedTarget");
		
		UTargetingComponent_CanSeeTrackedTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.CanSeeLastTrackedTarget
	 * 		Flags  -> ()
	 */
	bool UTargetingComponent::CanSeeLastTrackedTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.CanSeeLastTrackedTarget");
		
		UTargetingComponent_CanSeeLastTrackedTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.CanCharacterBeSeen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinAge                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::CanCharacterBeSeen(class AReadyOrNotCharacter* InCharacter, float MinAge)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.CanCharacterBeSeen");
		
		UTargetingComponent_CanCharacterBeSeen_Params params {};
		params.InCharacter = InCharacter;
		params.MinAge = MinAge;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.CanActorBeSeen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::CanActorBeSeen(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.CanActorBeSeen");
		
		UTargetingComponent_CanActorBeSeen_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.AddKnownNeutral
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Neutral                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetingComponent::AddKnownNeutral(class AReadyOrNotCharacter* Neutral)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.AddKnownNeutral");
		
		UTargetingComponent_AddKnownNeutral_Params params {};
		params.Neutral = Neutral;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.AddKnownFriendly
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Friendly                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetingComponent::AddKnownFriendly(class AReadyOrNotCharacter* Friendly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.AddKnownFriendly");
		
		UTargetingComponent_AddKnownFriendly_Params params {};
		params.Friendly = Friendly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.AddKnownEnemy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Enemy                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetingComponent::AddKnownEnemy(class AReadyOrNotCharacter* Enemy, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.AddKnownEnemy");
		
		UTargetingComponent_AddKnownEnemy_Params params {};
		params.Enemy = Enemy;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TargetingComponent.AddCharacterToSeenMap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InCharacter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetingComponent::AddCharacterToSeenMap(class AReadyOrNotCharacter* InCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TargetingComponent.AddCharacterToSeenMap");
		
		UTargetingComponent_AddCharacterToSeenMap_Params params {};
		params.InCharacter = InCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTargetingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTargetingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TargetingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.Server_SetHoldingTaser
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewHold                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATaser::Server_SetHoldingTaser(bool bNewHold)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.Server_SetHoldingTaser");
		
		ATaser_Server_SetHoldingTaser_Params params {};
		params.bNewHold = bNewHold;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.Server_DetachProbes
	 * 		Flags  -> ()
	 */
	void ATaser::Server_DetachProbes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.Server_DetachProbes");
		
		ATaser_Server_DetachProbes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.Server_DeliverStunToAttachedTarget
	 * 		Flags  -> ()
	 */
	void ATaser::Server_DeliverStunToAttachedTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.Server_DeliverStunToAttachedTarget");
		
		ATaser_Server_DeliverStunToAttachedTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.OnRep_ProjectileReplicated
	 * 		Flags  -> ()
	 */
	void ATaser::OnRep_ProjectileReplicated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.OnRep_ProjectileReplicated");
		
		ATaser_OnRep_ProjectileReplicated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.Multicast_StopCrackleSoundEffect
	 * 		Flags  -> ()
	 */
	void ATaser::Multicast_StopCrackleSoundEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.Multicast_StopCrackleSoundEffect");
		
		ATaser_Multicast_StopCrackleSoundEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.Multicast_StartCrackleSoundEffect
	 * 		Flags  -> ()
	 */
	void ATaser::Multicast_StartCrackleSoundEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.Multicast_StartCrackleSoundEffect");
		
		ATaser_Multicast_StartCrackleSoundEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.Multicast_ResetDoors
	 * 		Flags  -> ()
	 */
	void ATaser::Multicast_ResetDoors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.Multicast_ResetDoors");
		
		ATaser_Multicast_ResetDoors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.Multicast_ResetCableAttachments
	 * 		Flags  -> ()
	 */
	void ATaser::Multicast_ResetCableAttachments()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.Multicast_ResetCableAttachments");
		
		ATaser_Multicast_ResetCableAttachments_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.Multicast_PlayTaserHitEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ATaser::Multicast_PlayTaserHitEffect(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.Multicast_PlayTaserHitEffect");
		
		ATaser_Multicast_PlayTaserHitEffect_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.Multicast_PlayFireEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bDryFire                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATaser::Multicast_PlayFireEffects(bool bDryFire)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.Multicast_PlayFireEffects");
		
		ATaser_Multicast_PlayFireEffects_Params params {};
		params.bDryFire = bDryFire;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.Multicast_PlayDetachEffect
	 * 		Flags  -> ()
	 */
	void ATaser::Multicast_PlayDetachEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.Multicast_PlayDetachEffect");
		
		ATaser_Multicast_PlayDetachEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.Multicast_HideCables
	 * 		Flags  -> ()
	 */
	void ATaser::Multicast_HideCables()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.Multicast_HideCables");
		
		ATaser_Multicast_HideCables_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.Multicast_DestroyProjectiles
	 * 		Flags  -> ()
	 */
	void ATaser::Multicast_DestroyProjectiles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.Multicast_DestroyProjectiles");
		
		ATaser_Multicast_DestroyProjectiles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.HandleMeleeDeffered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ATaser::HandleMeleeDeffered(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.HandleMeleeDeffered");
		
		ATaser_HandleMeleeDeffered_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Taser.DetachProbes
	 * 		Flags  -> ()
	 */
	void ATaser::DetachProbes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Taser.DetachProbes");
		
		ATaser_DetachProbes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATaser.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATaser::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Taser");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TaserReactionVolume.OnTaserStunDelivered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATaser*                                      Taser                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATaserReactionVolume::OnTaserStunDelivered(class AReadyOrNotCharacter* Character, class ATaser* Taser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TaserReactionVolume.OnTaserStunDelivered");
		
		ATaserReactionVolume_OnTaserStunDelivered_Params params {};
		params.Character = Character;
		params.Taser = Taser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATaserReactionVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATaserReactionVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TaserReactionVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamStackUpActivity.PerformStackUpStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTeamStackUpActivity::PerformStackUpStage(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamStackUpActivity.PerformStackUpStage");
		
		UTeamStackUpActivity_PerformStackUpStage_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamStackUpActivity.PerformCheckStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTeamStackUpActivity::PerformCheckStage(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamStackUpActivity.PerformCheckStage");
		
		UTeamStackUpActivity_PerformCheckStage_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamStackUpActivity.OnDoorOpened
	 * 		Flags  -> ()
	 */
	void UTeamStackUpActivity::OnDoorOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamStackUpActivity.OnDoorOpened");
		
		UTeamStackUpActivity_OnDoorOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamStackUpActivity.OnDoorChecked
	 * 		Flags  -> ()
	 */
	void UTeamStackUpActivity::OnDoorChecked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamStackUpActivity.OnDoorChecked");
		
		UTeamStackUpActivity_OnDoorChecked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamStackUpActivity.GetStackUpDoor
	 * 		Flags  -> ()
	 */
	class ADoor* UTeamStackUpActivity::GetStackUpDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamStackUpActivity.GetStackUpDoor");
		
		UTeamStackUpActivity_GetStackUpDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamStackUpActivity.GetDoorCheckResult
	 * 		Flags  -> ()
	 */
	EDoorCheckResult UTeamStackUpActivity::GetDoorCheckResult()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamStackUpActivity.GetDoorCheckResult");
		
		UTeamStackUpActivity_GetDoorCheckResult_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamStackUpActivity.GetCharacterAtSquadPositionInStackUpArea
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESquadPosition                                     SquadPosition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStackupGenArea                                    StackupArea                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ACyberneticCharacter* UTeamStackUpActivity::GetCharacterAtSquadPositionInStackUpArea(ESquadPosition SquadPosition, EStackupGenArea StackupArea)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamStackUpActivity.GetCharacterAtSquadPositionInStackUpArea");
		
		UTeamStackUpActivity_GetCharacterAtSquadPositionInStackUpArea_Params params {};
		params.SquadPosition = SquadPosition;
		params.StackupArea = StackupArea;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamStackUpActivity.ExitStackupStage
	 * 		Flags  -> ()
	 */
	void UTeamStackUpActivity::ExitStackupStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamStackUpActivity.ExitStackupStage");
		
		UTeamStackUpActivity_ExitStackupStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamStackUpActivity.ExitCheckStage
	 * 		Flags  -> ()
	 */
	void UTeamStackUpActivity::ExitCheckStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamStackUpActivity.ExitCheckStage");
		
		UTeamStackUpActivity_ExitCheckStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamStackUpActivity.EnterStackupStage
	 * 		Flags  -> ()
	 */
	void UTeamStackUpActivity::EnterStackupStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamStackUpActivity.EnterStackupStage");
		
		UTeamStackUpActivity_EnterStackupStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamStackUpActivity.EnterCheckStage
	 * 		Flags  -> ()
	 */
	void UTeamStackUpActivity::EnterCheckStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamStackUpActivity.EnterCheckStage");
		
		UTeamStackUpActivity_EnterCheckStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamStackUpActivity.CanPerformCheck
	 * 		Flags  -> ()
	 */
	bool UTeamStackUpActivity::CanPerformCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamStackUpActivity.CanPerformCheck");
		
		UTeamStackUpActivity_CanPerformCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamStackUpActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamStackUpActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamStackUpActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBreachAndClearActivity.PerformClearStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTeamBreachAndClearActivity::PerformClearStage(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBreachAndClearActivity.PerformClearStage");
		
		UTeamBreachAndClearActivity_PerformClearStage_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBreachAndClearActivity.PerformBreachStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTeamBreachAndClearActivity::PerformBreachStage(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBreachAndClearActivity.PerformBreachStage");
		
		UTeamBreachAndClearActivity_PerformBreachStage_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBreachAndClearActivity.OnDoorBreachFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               InActivity                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       InController                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTeamBreachAndClearActivity::OnDoorBreachFinished(class UBaseActivity* InActivity, class ACyberneticController* InController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBreachAndClearActivity.OnDoorBreachFinished");
		
		UTeamBreachAndClearActivity_OnDoorBreachFinished_Params params {};
		params.InActivity = InActivity;
		params.InController = InController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBreachAndClearActivity.OnDoorBreacherReady
	 * 		Flags  -> ()
	 */
	void UTeamBreachAndClearActivity::OnDoorBreacherReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBreachAndClearActivity.OnDoorBreacherReady");
		
		UTeamBreachAndClearActivity_OnDoorBreacherReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBreachAndClearActivity.OnDoorBreacherBreaching
	 * 		Flags  -> ()
	 */
	void UTeamBreachAndClearActivity::OnDoorBreacherBreaching()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBreachAndClearActivity.OnDoorBreacherBreaching");
		
		UTeamBreachAndClearActivity_OnDoorBreacherBreaching_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBreachAndClearActivity.IsFinishedClearing
	 * 		Flags  -> ()
	 */
	bool UTeamBreachAndClearActivity::IsFinishedClearing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBreachAndClearActivity.IsFinishedClearing");
		
		UTeamBreachAndClearActivity_IsFinishedClearing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBreachAndClearActivity.EnterClearStage
	 * 		Flags  -> ()
	 */
	void UTeamBreachAndClearActivity::EnterClearStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBreachAndClearActivity.EnterClearStage");
		
		UTeamBreachAndClearActivity_EnterClearStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBreachAndClearActivity.EnterClearedStage
	 * 		Flags  -> ()
	 */
	void UTeamBreachAndClearActivity::EnterClearedStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBreachAndClearActivity.EnterClearedStage");
		
		UTeamBreachAndClearActivity_EnterClearedStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBreachAndClearActivity.EnterBreachStage
	 * 		Flags  -> ()
	 */
	void UTeamBreachAndClearActivity::EnterBreachStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBreachAndClearActivity.EnterBreachStage");
		
		UTeamBreachAndClearActivity_EnterBreachStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBreachAndClearActivity.DeployChemlight
	 * 		Flags  -> ()
	 */
	void UTeamBreachAndClearActivity::DeployChemlight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBreachAndClearActivity.DeployChemlight");
		
		UTeamBreachAndClearActivity_DeployChemlight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBreachAndClearActivity.CanPerformClear
	 * 		Flags  -> ()
	 */
	bool UTeamBreachAndClearActivity::CanPerformClear()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBreachAndClearActivity.CanPerformClear");
		
		UTeamBreachAndClearActivity_CanPerformClear_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBreachAndClearActivity.CanPerformBreach
	 * 		Flags  -> ()
	 */
	bool UTeamBreachAndClearActivity::CanPerformBreach()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBreachAndClearActivity.CanPerformBreach");
		
		UTeamBreachAndClearActivity_CanPerformBreach_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamBreachAndClearActivity.CanOpenDoor
	 * 		Flags  -> ()
	 */
	bool UTeamBreachAndClearActivity::CanOpenDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamBreachAndClearActivity.CanOpenDoor");
		
		UTeamBreachAndClearActivity_CanOpenDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamBreachAndClearActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamBreachAndClearActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamBreachAndClearActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamCoverAreaActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamCoverAreaActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamCoverAreaActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATeamDeathmatchGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATeamDeathmatchGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamDeathmatchGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATeamDeathmatchGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATeamDeathmatchGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamDeathmatchGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamFallinActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamFallinActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamFallinActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamMoveToActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamMoveToActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamMoveToActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamPaperdollWidget.InitializeWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETeamType                                          InTeam                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTeamPaperdollWidget::InitializeWidget(ETeamType InTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamPaperdollWidget.InitializeWidget");
		
		UTeamPaperdollWidget_InitializeWidget_Params params {};
		params.InTeam = InTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamPaperdollWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamPaperdollWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamPaperdollWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamProgressScoreWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamProgressScoreWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamProgressScoreWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamSoftCoverCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamSoftCoverCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamSoftCoverCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamStatusWidget.InitializeTeam
	 * 		Flags  -> ()
	 */
	void UTeamStatusWidget::InitializeTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamStatusWidget.InitializeTeam");
		
		UTeamStatusWidget_InitializeTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamStatusWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamStatusWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamStatusWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TeamViewWidget.Tick_TeamViewOn
	 * 		Flags  -> ()
	 */
	void UTeamViewWidget::Tick_TeamViewOn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TeamViewWidget.Tick_TeamViewOn");
		
		UTeamViewWidget_Tick_TeamViewOn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamViewWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamViewWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TeamViewWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TelescopicLadder.Server_RemoveLadder
	 * 		Flags  -> ()
	 */
	void ATelescopicLadder::Server_RemoveLadder()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TelescopicLadder.Server_RemoveLadder");
		
		ATelescopicLadder_Server_RemoveLadder_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TelescopicLadder.Server_PlaceLadder
	 * 		Flags  -> ()
	 */
	void ATelescopicLadder::Server_PlaceLadder()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TelescopicLadder.Server_PlaceLadder");
		
		ATelescopicLadder_Server_PlaceLadder_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TelescopicLadder.Server_DeployLadderAtZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ALadderSnapZone*                             NewSnapZone                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATelescopicLadder::Server_DeployLadderAtZone(class ALadderSnapZone* NewSnapZone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TelescopicLadder.Server_DeployLadderAtZone");
		
		ATelescopicLadder_Server_DeployLadderAtZone_Params params {};
		params.NewSnapZone = NewSnapZone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TelescopicLadder.OnRep_Deployed
	 * 		Flags  -> ()
	 */
	void ATelescopicLadder::OnRep_Deployed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TelescopicLadder.OnRep_Deployed");
		
		ATelescopicLadder_OnRep_Deployed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TelescopicLadder.OnRep_CurrentSnapZone
	 * 		Flags  -> ()
	 */
	void ATelescopicLadder::OnRep_CurrentSnapZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TelescopicLadder.OnRep_CurrentSnapZone");
		
		ATelescopicLadder_OnRep_CurrentSnapZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TelescopicLadder.Multicast_PlaceLadder
	 * 		Flags  -> ()
	 */
	void ATelescopicLadder::Multicast_PlaceLadder()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TelescopicLadder.Multicast_PlaceLadder");
		
		ATelescopicLadder_Multicast_PlaceLadder_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TelescopicLadder.Multicast_DeployLadderAtZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ALadderSnapZone*                             NewSnapZone                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATelescopicLadder::Multicast_DeployLadderAtZone(class ALadderSnapZone* NewSnapZone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TelescopicLadder.Multicast_DeployLadderAtZone");
		
		ATelescopicLadder_Multicast_DeployLadderAtZone_Params params {};
		params.NewSnapZone = NewSnapZone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATelescopicLadder.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATelescopicLadder::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TelescopicLadder");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATestCases.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATestCases::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TestCases");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThreatAwarenessActor.ThisCalculateExits
	 * 		Flags  -> ()
	 */
	void AThreatAwarenessActor::ThisCalculateExits()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThreatAwarenessActor.ThisCalculateExits");
		
		AThreatAwarenessActor_ThisCalculateExits_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThreatAwarenessActor.RemoveAnyVisibleExits
	 * 		Flags  -> ()
	 */
	void AThreatAwarenessActor::RemoveAnyVisibleExits()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThreatAwarenessActor.RemoveAnyVisibleExits");
		
		AThreatAwarenessActor_RemoveAnyVisibleExits_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThreatAwarenessActor.IsFrontDoorThreat
	 * 		Flags  -> ()
	 */
	bool AThreatAwarenessActor::IsFrontDoorThreat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThreatAwarenessActor.IsFrontDoorThreat");
		
		AThreatAwarenessActor_IsFrontDoorThreat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThreatAwarenessActor.IsDoorThreat
	 * 		Flags  -> ()
	 */
	bool AThreatAwarenessActor::IsDoorThreat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThreatAwarenessActor.IsDoorThreat");
		
		AThreatAwarenessActor_IsDoorThreat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThreatAwarenessActor.HasSpecificExitDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AThreatAwarenessActor::HasSpecificExitDoor(class ADoor* Door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThreatAwarenessActor.HasSpecificExitDoor");
		
		AThreatAwarenessActor_HasSpecificExitDoor_Params params {};
		params.Door = Door;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThreatAwarenessActor.HasExit
	 * 		Flags  -> ()
	 */
	bool AThreatAwarenessActor::HasExit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThreatAwarenessActor.HasExit");
		
		AThreatAwarenessActor_HasExit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThreatAwarenessActor.GetUniqueExtis
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class ADoor*>                               OutDoors                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool AThreatAwarenessActor::GetUniqueExtis(TArray<class ADoor*>* OutDoors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThreatAwarenessActor.GetUniqueExtis");
		
		AThreatAwarenessActor_GetUniqueExtis_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDoors != nullptr)
			*OutDoors = params.OutDoors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThreatAwarenessActor.GetThreatLevel
	 * 		Flags  -> ()
	 */
	EThreatLevel AThreatAwarenessActor::GetThreatLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThreatAwarenessActor.GetThreatLevel");
		
		AThreatAwarenessActor_GetThreatLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThreatAwarenessActor.GetRandomExitDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AThreatAwarenessActor::GetRandomExitDoor(class ADoor** Door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThreatAwarenessActor.GetRandomExitDoor");
		
		AThreatAwarenessActor_GetRandomExitDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Door != nullptr)
			*Door = params.Door;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThreatAwarenessActor.GetAttachedDoor
	 * 		Flags  -> ()
	 */
	class ADoor* AThreatAwarenessActor::GetAttachedDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThreatAwarenessActor.GetAttachedDoor");
		
		AThreatAwarenessActor_GetAttachedDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThreatAwarenessActor.GenerateLookAtPoints
	 * 		Flags  -> ()
	 */
	void AThreatAwarenessActor::GenerateLookAtPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThreatAwarenessActor.GenerateLookAtPoints");
		
		AThreatAwarenessActor_GenerateLookAtPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AThreatAwarenessActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AThreatAwarenessActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ThreatAwarenessActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UThreatAwarenessSubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UThreatAwarenessSubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ThreatAwarenessSubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThrownItem.UpdateServerPath
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FVector_NetQuantize>                 Path                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Bounce1                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Bounce2                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Bounce3                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AThrownItem::UpdateServerPath(TArray<struct FVector_NetQuantize> Path, int32_t Bounce1, int32_t Bounce2, int32_t Bounce3)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThrownItem.UpdateServerPath");
		
		AThrownItem_UpdateServerPath_Params params {};
		params.Path = Path;
		params.Bounce1 = Bounce1;
		params.Bounce2 = Bounce2;
		params.Bounce3 = Bounce3;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThrownItem.OnRep_ThrowPath
	 * 		Flags  -> ()
	 */
	void AThrownItem::OnRep_ThrowPath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThrownItem.OnRep_ThrowPath");
		
		AThrownItem_OnRep_ThrowPath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThrownItem.OnHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AThrownItem::OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThrownItem.OnHit");
		
		AThrownItem_OnHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComponent = OtherComponent;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AThrownItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AThrownItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ThrownItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThrownChemlight.UpdateLightSourcePos
	 * 		Flags  -> ()
	 */
	void AThrownChemlight::UpdateLightSourcePos()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThrownChemlight.UpdateLightSourcePos");
		
		AThrownChemlight_UpdateLightSourcePos_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AThrownChemlight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AThrownChemlight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ThrownChemlight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ThrownEvidenceActor.OnBoxHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoreUObject_FVector                        NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AThrownEvidenceActor::OnBoxHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FCoreUObject_FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ThrownEvidenceActor.OnBoxHit");
		
		AThrownEvidenceActor_OnBoxHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AThrownEvidenceActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AThrownEvidenceActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ThrownEvidenceActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AThrownGrenade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AThrownGrenade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ThrownGrenade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TOCManager.StartTOCResponse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Line                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNetworked                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETOCPriority                                       Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATOCManager::StartTOCResponse(const class FString& Line, bool bIsNetworked, ETOCPriority Priority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TOCManager.StartTOCResponse");
		
		ATOCManager_StartTOCResponse_Params params {};
		params.Line = Line;
		params.bIsNetworked = bIsNetworked;
		params.Priority = Priority;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TOCManager.Multicast_PlayTOCSound2D
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filename                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATOCManager::Multicast_PlayTOCSound2D(const class FString& Filename)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TOCManager.Multicast_PlayTOCSound2D");
		
		ATOCManager_Multicast_PlayTOCSound2D_Params params {};
		params.Filename = Filename;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TOCManager.IterateTOCQueue
	 * 		Flags  -> ()
	 */
	void ATOCManager::IterateTOCQueue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TOCManager.IterateTOCQueue");
		
		ATOCManager_IterateTOCQueue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TOCManager.IsTOCSpeakingLine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Line                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ATOCManager::IsTOCSpeakingLine(const class FString& Line)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TOCManager.IsTOCSpeakingLine");
		
		ATOCManager_IsTOCSpeakingLine_Params params {};
		params.Line = Line;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TOCManager.IsTOCSpeaking
	 * 		Flags  -> ()
	 */
	bool ATOCManager::IsTOCSpeaking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TOCManager.IsTOCSpeaking");
		
		ATOCManager_IsTOCSpeaking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TOCManager.Get
	 * 		Flags  -> ()
	 */
	class ATOCManager* ATOCManager::Get()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TOCManager.Get");
		
		ATOCManager_Get_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATOCManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATOCManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TOCManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTocSpeechData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTocSpeechData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TocSpeechData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UToggleDoorActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UToggleDoorActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ToggleDoorActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTrackingCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTrackingCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TrackingCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActivatee.OnTrapFired
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Triggerer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATrapActivator*                              Activator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActivatee::OnTrapFired(class AActor* Triggerer, class ATrapActivator* Activator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActivatee.OnTrapFired");
		
		ATrapActivatee_OnTrapFired_Params params {};
		params.Triggerer = Triggerer;
		params.Activator = Activator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActivatee.OnTrapDisarmed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Disarmer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActivatee::OnTrapDisarmed(class AActor* Disarmer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActivatee.OnTrapDisarmed");
		
		ATrapActivatee_OnTrapDisarmed_Params params {};
		params.Disarmer = Disarmer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActivatee.OnActivatorDisarmed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Disarmer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATrapActivator*                              Activator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActivatee::OnActivatorDisarmed(class AActor* Disarmer, class ATrapActivator* Activator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActivatee.OnActivatorDisarmed");
		
		ATrapActivatee_OnActivatorDisarmed_Params params {};
		params.Disarmer = Disarmer;
		params.Activator = Activator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActivatee.FireTrap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ActivatingActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATrapActivator*                              Activator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActivatee::FireTrap(class AActor* ActivatingActor, class ATrapActivator* Activator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActivatee.FireTrap");
		
		ATrapActivatee_FireTrap_Params params {};
		params.ActivatingActor = ActivatingActor;
		params.Activator = Activator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActivatee.DisarmTrap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Disarmer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActivatee::DisarmTrap(class AActor* Disarmer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActivatee.DisarmTrap");
		
		ATrapActivatee_DisarmTrap_Params params {};
		params.Disarmer = Disarmer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActivatee.DisarmedActivator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Disarmer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATrapActivator*                              Activator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActivatee::DisarmedActivator(class AActor* Disarmer, class ATrapActivator* Activator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActivatee.DisarmedActivator");
		
		ATrapActivatee_DisarmedActivator_Params params {};
		params.Disarmer = Disarmer;
		params.Activator = Activator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATrapActivatee.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATrapActivatee::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TrapActivatee");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActivator.ShouldFireTrap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OutTrapActivator                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ATrapActivator::ShouldFireTrap(float DeltaTime, class AActor** OutTrapActivator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActivator.ShouldFireTrap");
		
		ATrapActivator_ShouldFireTrap_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTrapActivator != nullptr)
			*OutTrapActivator = params.OutTrapActivator;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActivator.OnTrapDisarmed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Disarmer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActivator::OnTrapDisarmed(class AActor* Disarmer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActivator.OnTrapDisarmed");
		
		ATrapActivator_OnTrapDisarmed_Params params {};
		params.Disarmer = Disarmer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActivator.OnTrapActivated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Activator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActivator::OnTrapActivated(class AActor* Activator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActivator.OnTrapActivated");
		
		ATrapActivator_OnTrapActivated_Params params {};
		params.Activator = Activator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActivator.FireTrap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Activator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActivator::FireTrap(class AActor* Activator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActivator.FireTrap");
		
		ATrapActivator_FireTrap_Params params {};
		params.Activator = Activator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActivator.DisarmTrap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Disarmer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActivator::DisarmTrap(class AActor* Disarmer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActivator.DisarmTrap");
		
		ATrapActivator_DisarmTrap_Params params {};
		params.Disarmer = Disarmer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATrapActivator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATrapActivator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TrapActivator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.TrapActor.TrapTriggeredDelegate__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ATrapActor*                                  Trap                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        TriggeredBy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActor::TrapTriggeredDelegate__DelegateSignature(class ATrapActor* Trap, class AReadyOrNotCharacter* TriggeredBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.TrapActor.TrapTriggeredDelegate__DelegateSignature");
		
		ATrapActor_TrapTriggeredDelegate__DelegateSignature_Params params {};
		params.Trap = Trap;
		params.TriggeredBy = TriggeredBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActor.TrapInit
	 * 		Flags  -> ()
	 */
	void ATrapActor::TrapInit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActor.TrapInit");
		
		ATrapActor_TrapInit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActor.TrapDeInit
	 * 		Flags  -> ()
	 */
	void ATrapActor::TrapDeInit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActor.TrapDeInit");
		
		ATrapActor_TrapDeInit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActor.Server_OnTrapTriggered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        TriggeredBy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActor::Server_OnTrapTriggered(class AReadyOrNotCharacter* TriggeredBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActor.Server_OnTrapTriggered");
		
		ATrapActor_Server_OnTrapTriggered_Params params {};
		params.TriggeredBy = TriggeredBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActor.Server_OnTrapDisarmed
	 * 		Flags  -> ()
	 */
	void ATrapActor::Server_OnTrapDisarmed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActor.Server_OnTrapDisarmed");
		
		ATrapActor_Server_OnTrapDisarmed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActor.OnTrapTriggered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        TriggeredBy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActor::OnTrapTriggered(class AReadyOrNotCharacter* TriggeredBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActor.OnTrapTriggered");
		
		ATrapActor_OnTrapTriggered_Params params {};
		params.TriggeredBy = TriggeredBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActor.OnTrapDisarmed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        DisarmedBy                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActor::OnTrapDisarmed(class AReadyOrNotCharacter* DisarmedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActor.OnTrapDisarmed");
		
		ATrapActor_OnTrapDisarmed_Params params {};
		params.DisarmedBy = DisarmedBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActor.OnTrapAttached
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTrapSpawnComponent*                         SpawningComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActor::OnTrapAttached(class UTrapSpawnComponent* SpawningComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActor.OnTrapAttached");
		
		ATrapActor_OnTrapAttached_Params params {};
		params.SpawningComponent = SpawningComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActor.Multicast_OnTrapTriggered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        TriggeredBy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActor::Multicast_OnTrapTriggered(class AReadyOrNotCharacter* TriggeredBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActor.Multicast_OnTrapTriggered");
		
		ATrapActor_Multicast_OnTrapTriggered_Params params {};
		params.TriggeredBy = TriggeredBy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActor.Multicast_OnTrapDisarmed
	 * 		Flags  -> ()
	 */
	void ATrapActor::Multicast_OnTrapDisarmed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActor.Multicast_OnTrapDisarmed");
		
		ATrapActor_Multicast_OnTrapDisarmed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActor.EnableOutline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActorOutlineType                                  OutlineType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapActor::EnableOutline(EActorOutlineType OutlineType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActor.EnableOutline");
		
		ATrapActor_EnableOutline_Params params {};
		params.OutlineType = OutlineType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapActor.DisableOutline
	 * 		Flags  -> ()
	 */
	void ATrapActor::DisableOutline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapActor.DisableOutline");
		
		ATrapActor_DisableOutline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATrapActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATrapActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TrapActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATrapActorAttachedToDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATrapActorAttachedToDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TrapActorAttachedToDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTrapDamage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTrapDamage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TrapDamage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapSpawnComponent.OnSpawnSelected
	 * 		Flags  -> ()
	 */
	void UTrapSpawnComponent::OnSpawnSelected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapSpawnComponent.OnSpawnSelected");
		
		UTrapSpawnComponent_OnSpawnSelected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapSpawnComponent.FinishTrapSpawning
	 * 		Flags  -> ()
	 */
	void UTrapSpawnComponent::FinishTrapSpawning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapSpawnComponent.FinishTrapSpawning");
		
		UTrapSpawnComponent_FinishTrapSpawning_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTrapSpawnComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTrapSpawnComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TrapSpawnComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapSpawnPoint.OnTrapSpawned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTrapSpawnComponent*                         TrapSpawnPoint                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapSpawnPoint::OnTrapSpawned(class UTrapSpawnComponent* TrapSpawnPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapSpawnPoint.OnTrapSpawned");
		
		ATrapSpawnPoint_OnTrapSpawned_Params params {};
		params.TrapSpawnPoint = TrapSpawnPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapSpawnPoint.FinishTrapSpawningFromRoster
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTrapSpawnComponent*                         Spawner                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATrapSpawnPoint::FinishTrapSpawningFromRoster(class UTrapSpawnComponent* Spawner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapSpawnPoint.FinishTrapSpawningFromRoster");
		
		ATrapSpawnPoint_FinishTrapSpawningFromRoster_Params params {};
		params.Spawner = Spawner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TrapSpawnPoint.CheckForTrapDespawning
	 * 		Flags  -> ()
	 */
	void ATrapSpawnPoint::CheckForTrapDespawning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TrapSpawnPoint.CheckForTrapDespawning");
		
		ATrapSpawnPoint_CheckForTrapDespawning_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATrapSpawnPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATrapSpawnPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TrapSpawnPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TraverseHoleActivity.Tick_MoveToHole_State
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTraverseHoleActivity::Tick_MoveToHole_State(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TraverseHoleActivity.Tick_MoveToHole_State");
		
		UTraverseHoleActivity_Tick_MoveToHole_State_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TraverseHoleActivity.Tick_Move_State
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTraverseHoleActivity::Tick_Move_State(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TraverseHoleActivity.Tick_Move_State");
		
		UTraverseHoleActivity_Tick_Move_State_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TraverseHoleActivity.Tick_ExitHole_State
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTraverseHoleActivity::Tick_ExitHole_State(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TraverseHoleActivity.Tick_ExitHole_State");
		
		UTraverseHoleActivity_Tick_ExitHole_State_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TraverseHoleActivity.Tick_EnterHole_State
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Uptime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTraverseHoleActivity::Tick_EnterHole_State(float DeltaTime, float Uptime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TraverseHoleActivity.Tick_EnterHole_State");
		
		UTraverseHoleActivity_Tick_EnterHole_State_Params params {};
		params.DeltaTime = DeltaTime;
		params.Uptime = Uptime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TraverseHoleActivity.ShouldMove
	 * 		Flags  -> ()
	 */
	bool UTraverseHoleActivity::ShouldMove()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TraverseHoleActivity.ShouldMove");
		
		UTraverseHoleActivity_ShouldMove_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TraverseHoleActivity.Enter_MoveToHole_State
	 * 		Flags  -> ()
	 */
	void UTraverseHoleActivity::Enter_MoveToHole_State()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TraverseHoleActivity.Enter_MoveToHole_State");
		
		UTraverseHoleActivity_Enter_MoveToHole_State_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TraverseHoleActivity.Enter_Move_State
	 * 		Flags  -> ()
	 */
	void UTraverseHoleActivity::Enter_Move_State()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TraverseHoleActivity.Enter_Move_State");
		
		UTraverseHoleActivity_Enter_Move_State_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TraverseHoleActivity.Enter_ExitHole_State
	 * 		Flags  -> ()
	 */
	void UTraverseHoleActivity::Enter_ExitHole_State()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TraverseHoleActivity.Enter_ExitHole_State");
		
		UTraverseHoleActivity_Enter_ExitHole_State_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TraverseHoleActivity.Enter_EnterHole_State
	 * 		Flags  -> ()
	 */
	void UTraverseHoleActivity::Enter_EnterHole_State()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TraverseHoleActivity.Enter_EnterHole_State");
		
		UTraverseHoleActivity_Enter_EnterHole_State_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TraverseHoleActivity.CanExitHole
	 * 		Flags  -> ()
	 */
	bool UTraverseHoleActivity::CanExitHole()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TraverseHoleActivity.CanExitHole");
		
		UTraverseHoleActivity_CanExitHole_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TraverseHoleActivity.CanEnterHole
	 * 		Flags  -> ()
	 */
	bool UTraverseHoleActivity::CanEnterHole()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TraverseHoleActivity.CanEnterHole");
		
		UTraverseHoleActivity_CanEnterHole_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTraverseHoleActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTraverseHoleActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TraverseHoleActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TugOfWarButton.OnInfluencerStunned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            StunnedCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStunType                                          StunType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATugOfWarButton::OnInfluencerStunned(class APlayerCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TugOfWarButton.OnInfluencerStunned");
		
		ATugOfWarButton_OnInfluencerStunned_Params params {};
		params.StunnedCharacter = StunnedCharacter;
		params.Duration = Duration;
		params.StunType = StunType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TugOfWarButton.OnInfluencerKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Causer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class APlayerState*                                LastPlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATugOfWarButton::OnInfluencerKilled(class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* KilledCharacter, const struct FDamageEvent& DamageEvent, class APlayerState* LastPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TugOfWarButton.OnInfluencerKilled");
		
		ATugOfWarButton_OnInfluencerKilled_Params params {};
		params.Causer = Causer;
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		params.DamageEvent = DamageEvent;
		params.LastPlayerState = LastPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TugOfWarButton.OnInfluencerArrested
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            ArrestedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATugOfWarButton::OnInfluencerArrested(class APlayerCharacter* ArrestedCharacter, class APlayerCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TugOfWarButton.OnInfluencerArrested");
		
		ATugOfWarButton_OnInfluencerArrested_Params params {};
		params.ArrestedCharacter = ArrestedCharacter;
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATugOfWarButton.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATugOfWarButton::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TugOfWarButton");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATugOfWarGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATugOfWarGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TugOfWarGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATugOfWarGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATugOfWarGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TugOfWarGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATugOfWarMover.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATugOfWarMover::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TugOfWarMover");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TugOfWarZone.OnOverlapEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATugOfWarZone::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TugOfWarZone.OnOverlapEnd");
		
		ATugOfWarZone_OnOverlapEnd_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TugOfWarZone.OnOverlapBegin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ATugOfWarZone::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TugOfWarZone.OnOverlapBegin");
		
		ATugOfWarZone_OnOverlapBegin_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TugOfWarZone.OnInfluencerKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Causer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class APlayerState*                                LastPlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATugOfWarZone::OnInfluencerKilled(class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* KilledCharacter, const struct FDamageEvent& DamageEvent, class APlayerState* LastPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TugOfWarZone.OnInfluencerKilled");
		
		ATugOfWarZone_OnInfluencerKilled_Params params {};
		params.Causer = Causer;
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		params.DamageEvent = DamageEvent;
		params.LastPlayerState = LastPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TugOfWarZone.OnInfluencerArrested
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            ArrestedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATugOfWarZone::OnInfluencerArrested(class APlayerCharacter* ArrestedCharacter, class APlayerCharacter* InstigatorCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TugOfWarZone.OnInfluencerArrested");
		
		ATugOfWarZone_OnInfluencerArrested_Params params {};
		params.ArrestedCharacter = ArrestedCharacter;
		params.InstigatorCharacter = InstigatorCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATugOfWarZone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATugOfWarZone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TugOfWarZone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TutorialGS.SetCurrentTutorialData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTutorialMissionData                        TutorialData                                               (Parm, NativeAccessSpecifierPublic)
	 */
	void ATutorialGS::SetCurrentTutorialData(const struct FTutorialMissionData& TutorialData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TutorialGS.SetCurrentTutorialData");
		
		ATutorialGS_SetCurrentTutorialData_Params params {};
		params.TutorialData = TutorialData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TutorialGS.OnPostUpdateSwatCommands
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USwatCommandWidget*                          Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FSwatCommand>                        SwatCommands                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ATutorialGS::OnPostUpdateSwatCommands(class USwatCommandWidget* Widget, TArray<struct FSwatCommand>* SwatCommands)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TutorialGS.OnPostUpdateSwatCommands");
		
		ATutorialGS_OnPostUpdateSwatCommands_Params params {};
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SwatCommands != nullptr)
			*SwatCommands = params.SwatCommands;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TutorialGS.GetCurrentTutorialStreamedLevel
	 * 		Flags  -> ()
	 */
	void ATutorialGS::GetCurrentTutorialStreamedLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TutorialGS.GetCurrentTutorialStreamedLevel");
		
		ATutorialGS_GetCurrentTutorialStreamedLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATutorialGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATutorialGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TutorialGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTutorialMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTutorialMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TutorialMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TutorialMessageVolume.TutorialBoxEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ThisActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATutorialMessageVolume::TutorialBoxEndOverlap(class AActor* ThisActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TutorialMessageVolume.TutorialBoxEndOverlap");
		
		ATutorialMessageVolume_TutorialBoxEndOverlap_Params params {};
		params.ThisActor = ThisActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TutorialMessageVolume.TutorialBoxBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      ThisActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATutorialMessageVolume::TutorialBoxBeginOverlap(class AActor* ThisActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TutorialMessageVolume.TutorialBoxBeginOverlap");
		
		ATutorialMessageVolume_TutorialBoxBeginOverlap_Params params {};
		params.ThisActor = ThisActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.TutorialMessageVolume.GenerateMessageContent
	 * 		Flags  -> ()
	 */
	void ATutorialMessageVolume::GenerateMessageContent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.TutorialMessageVolume.GenerateMessageContent");
		
		ATutorialMessageVolume_GenerateMessageContent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATutorialMessageVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATutorialMessageVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TutorialMessageVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTutorialTextPrompt_Widget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTutorialTextPrompt_Widget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.TutorialTextPrompt_Widget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUnlockDoorQuestNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUnlockDoorQuestNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.UnlockDoorQuestNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUnlockDoorTeamQuestNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUnlockDoorTeamQuestNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.UnlockDoorTeamQuestNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AUObjectListener.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AUObjectListener::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.UObjectListener");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.OnFocusLost
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InteractInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseabilityInterface::OnFocusLost(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.OnFocusLost");
		
		UUseabilityInterface_OnFocusLost_Params params {};
		params.InteractInstigator = InteractInstigator;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.OnFocusGain
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InteractInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseabilityInterface::OnFocusGain(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.OnFocusGain");
		
		UUseabilityInterface_OnFocusGain_Params params {};
		params.InteractInstigator = InteractInstigator;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.MeleeInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InteractInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseabilityInterface::MeleeInteract(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.MeleeInteract");
		
		UUseabilityInterface_MeleeInteract_Params params {};
		params.InteractInstigator = InteractInstigator;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.Interact
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InteractInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseabilityInterface::Interact(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.Interact");
		
		UUseabilityInterface_Interact_Params params {};
		params.InteractInstigator = InteractInstigator;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.GetInteractableComponent
	 * 		Flags  -> ()
	 */
	class UInteractableComponent* UUseabilityInterface::GetInteractableComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.GetInteractableComponent");
		
		UUseabilityInterface_GetInteractableComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.Fire
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InteractInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseabilityInterface::Fire(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.Fire");
		
		UUseabilityInterface_Fire_Params params {};
		params.InteractInstigator = InteractInstigator;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.EndInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InteractInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseabilityInterface::EndInteract(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.EndInteract");
		
		UUseabilityInterface_EndInteract_Params params {};
		params.InteractInstigator = InteractInstigator;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.EndFire
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InteractInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseabilityInterface::EndFire(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.EndFire");
		
		UUseabilityInterface_EndFire_Params params {};
		params.InteractInstigator = InteractInstigator;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.DoubleTapInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InteractInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInteractableComponent*                      InInteractableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseabilityInterface::DoubleTapInteract(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.DoubleTapInteract");
		
		UUseabilityInterface_DoubleTapInteract_Params params {};
		params.InteractInstigator = InteractInstigator;
		params.InInteractableComponent = InInteractableComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.DetermineInteractionDistance
	 * 		Flags  -> ()
	 */
	float UUseabilityInterface::DetermineInteractionDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.DetermineInteractionDistance");
		
		UUseabilityInterface_DetermineInteractionDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.DetermineInputEvent
	 * 		Flags  -> ()
	 */
	EInputEvent UUseabilityInterface::DetermineInputEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.DetermineInputEvent");
		
		UUseabilityInterface_DetermineInputEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.DetermineCurrentProgress
	 * 		Flags  -> ()
	 */
	float UUseabilityInterface::DetermineCurrentProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.DetermineCurrentProgress");
		
		UUseabilityInterface_DetermineCurrentProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.DetermineAnimatedIcon
	 * 		Flags  -> ()
	 */
	class FName UUseabilityInterface::DetermineAnimatedIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.DetermineAnimatedIcon");
		
		UUseabilityInterface_DetermineAnimatedIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.DetermineActionText
	 * 		Flags  -> ()
	 */
	class FText UUseabilityInterface::DetermineActionText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.DetermineActionText");
		
		UUseabilityInterface_DetermineActionText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.CanInteractThroughHitActors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UUseabilityInterface::CanInteractThroughHitActors(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.CanInteractThroughHitActors");
		
		UUseabilityInterface_CanInteractThroughHitActors_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.UseabilityInterface.CanInteract
	 * 		Flags  -> ()
	 */
	bool UUseabilityInterface::CanInteract()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.UseabilityInterface.CanInteract");
		
		UUseabilityInterface_CanInteract_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUseabilityInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUseabilityInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.UseabilityInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Vent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.VIPEscortGM.VIPKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVIPEscortGM::VIPKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.VIPEscortGM.VIPKilled");
		
		AVIPEscortGM_VIPKilled_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.VIPEscortGM.VIPFreed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACharacter*                                  Freed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  Freer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVIPEscortGM::VIPFreed(class ACharacter* Freed, class ACharacter* Freer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.VIPEscortGM.VIPFreed");
		
		AVIPEscortGM_VIPFreed_Params params {};
		params.Freed = Freed;
		params.Freer = Freer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.VIPEscortGM.OnVIPKilledSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        InstigatorCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AReadyOrNotCharacter*                        KilledCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVIPEscortGM::OnVIPKilledSignature__DelegateSignature(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.VIPEscortGM.OnVIPKilledSignature__DelegateSignature");
		
		AVIPEscortGM_OnVIPKilledSignature__DelegateSignature_Params params {};
		params.InstigatorCharacter = InstigatorCharacter;
		params.KilledCharacter = KilledCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction ReadyOrNot.VIPEscortGM.OnVIPFreedSignature__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ACharacter*                                  Freed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACharacter*                                  Freer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVIPEscortGM::OnVIPFreedSignature__DelegateSignature(class ACharacter* Freed, class ACharacter* Freer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction ReadyOrNot.VIPEscortGM.OnVIPFreedSignature__DelegateSignature");
		
		AVIPEscortGM_OnVIPFreedSignature__DelegateSignature_Params params {};
		params.Freed = Freed;
		params.Freer = Freer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.VIPEscortGM.IsVIPDead
	 * 		Flags  -> ()
	 */
	bool AVIPEscortGM::IsVIPDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.VIPEscortGM.IsVIPDead");
		
		AVIPEscortGM_IsVIPDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.VIPEscortGM.IsVIPArrested
	 * 		Flags  -> ()
	 */
	bool AVIPEscortGM::IsVIPArrested()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.VIPEscortGM.IsVIPArrested");
		
		AVIPEscortGM_IsVIPArrested_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.VIPEscortGM.IsVIPAlive
	 * 		Flags  -> ()
	 */
	bool AVIPEscortGM::IsVIPAlive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.VIPEscortGM.IsVIPAlive");
		
		AVIPEscortGM_IsVIPAlive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.VIPEscortGM.GetVIPCharacter
	 * 		Flags  -> ()
	 */
	class APlayerCharacter* AVIPEscortGM::GetVIPCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.VIPEscortGM.GetVIPCharacter");
		
		AVIPEscortGM_GetVIPCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.VIPEscortGM.GetCurrentVIPTeam
	 * 		Flags  -> ()
	 */
	ETeamType AVIPEscortGM::GetCurrentVIPTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.VIPEscortGM.GetCurrentVIPTeam");
		
		AVIPEscortGM_GetCurrentVIPTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVIPEscortGM.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVIPEscortGM::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.VIPEscortGM");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.VIPEscortGS.OnRep_VIPKilled
	 * 		Flags  -> ()
	 */
	void AVIPEscortGS::OnRep_VIPKilled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.VIPEscortGS.OnRep_VIPKilled");
		
		AVIPEscortGS_OnRep_VIPKilled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.VIPEscortGS.OnRep_VIPArrested
	 * 		Flags  -> ()
	 */
	void AVIPEscortGS::OnRep_VIPArrested()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.VIPEscortGS.OnRep_VIPArrested");
		
		AVIPEscortGS_OnRep_VIPArrested_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVIPEscortGS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVIPEscortGS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.VIPEscortGS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.VIPTriggerBox.IsVIPInTriggerBox
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            OutVIPCharacter                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AVIPTriggerBox::IsVIPInTriggerBox(class APlayerCharacter** OutVIPCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.VIPTriggerBox.IsVIPInTriggerBox");
		
		AVIPTriggerBox_IsVIPInTriggerBox_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutVIPCharacter != nullptr)
			*OutVIPCharacter = params.OutVIPCharacter;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVIPTriggerBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVIPTriggerBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.VIPTriggerBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVisibilityBlockingVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVisibilityBlockingVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.VisibilityBlockingVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.VOIPTalkerEntryWidget.GetVoiceTypeText
	 * 		Flags  -> ()
	 */
	class FText UVOIPTalkerEntryWidget::GetVoiceTypeText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.VOIPTalkerEntryWidget.GetVoiceTypeText");
		
		UVOIPTalkerEntryWidget_GetVoiceTypeText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.VOIPTalkerEntryWidget.GetVoiceTypeColor
	 * 		Flags  -> ()
	 */
	struct FSlateColor UVOIPTalkerEntryWidget::GetVoiceTypeColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.VOIPTalkerEntryWidget.GetVoiceTypeColor");
		
		UVOIPTalkerEntryWidget_GetVoiceTypeColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVOIPTalkerEntryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVOIPTalkerEntryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.VOIPTalkerEntryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWaitActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWaitActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WaitActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWaitingCombatMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWaitingCombatMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WaitingCombatMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WallHoleTraversal.TestForMeshes
	 * 		Flags  -> ()
	 */
	void AWallHoleTraversal::TestForMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WallHoleTraversal.TestForMeshes");
		
		AWallHoleTraversal_TestForMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WallHoleTraversal.IsCooldownActiveFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AController*                                 InController                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AWallHoleTraversal::IsCooldownActiveFor(class AController* InController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WallHoleTraversal.IsCooldownActiveFor");
		
		AWallHoleTraversal_IsCooldownActiveFor_Params params {};
		params.InController = InController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WallHoleTraversal.AddCooldownFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AController*                                 InController                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InCooldownTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AWallHoleTraversal::AddCooldownFor(class AController* InController, float InCooldownTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WallHoleTraversal.AddCooldownFor");
		
		AWallHoleTraversal_AddCooldownFor_Params params {};
		params.InController = InController;
		params.InCooldownTime = InCooldownTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWallHoleTraversal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWallHoleTraversal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WallHoleTraversal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WeaponCacheActor.GetRandomAvailableWeapon
	 * 		Flags  -> ()
	 */
	class UClass* AWeaponCacheActor::GetRandomAvailableWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WeaponCacheActor.GetRandomAvailableWeapon");
		
		AWeaponCacheActor_GetRandomAvailableWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWeaponCacheActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWeaponCacheActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WeaponCacheActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponWheel_ItemStat_Base.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponWheel_ItemStat_Base::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WeaponWheel_ItemStat_Base");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponWheelScript.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponWheelScript::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WeaponWheelScript");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WeaponWheelWidget.RemoveNullItemsFromCategory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        WeaponWheelCategoryName                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UWeaponWheelWidget::RemoveNullItemsFromCategory(const class FName& WeaponWheelCategoryName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WeaponWheelWidget.RemoveNullItemsFromCategory");
		
		UWeaponWheelWidget_RemoveNullItemsFromCategory_Params params {};
		params.WeaponWheelCategoryName = WeaponWheelCategoryName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WeaponWheelWidget.RemoveNullItemsFromAllCategories
	 * 		Flags  -> ()
	 */
	bool UWeaponWheelWidget::RemoveNullItemsFromAllCategories()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WeaponWheelWidget.RemoveNullItemsFromAllCategories");
		
		UWeaponWheelWidget_RemoveNullItemsFromAllCategories_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponWheelWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponWheelWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WeaponWheelWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVisualEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVisualEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.VisualEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatorCharacterHUD.TeamChatPressed
	 * 		Flags  -> ()
	 */
	void USpectatorCharacterHUD::TeamChatPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatorCharacterHUD.TeamChatPressed");
		
		USpectatorCharacterHUD_TeamChatPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatorCharacterHUD.OnNewCharacterViewed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class APlayerCharacter*                            NewViewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USpectatorCharacterHUD::OnNewCharacterViewed(class APlayerCharacter* NewViewTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatorCharacterHUD.OnNewCharacterViewed");
		
		USpectatorCharacterHUD_OnNewCharacterViewed_Params params {};
		params.NewViewTarget = NewViewTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatorCharacterHUD.ChatPressed
	 * 		Flags  -> ()
	 */
	void USpectatorCharacterHUD::ChatPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatorCharacterHUD.ChatPressed");
		
		USpectatorCharacterHUD_ChatPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.SpectatorCharacterHUD.CenterPrint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        MessageType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USpectatorCharacterHUD::CenterPrint(const class FName& MessageType, float Duration, class APlayerCharacter* Other)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.SpectatorCharacterHUD.CenterPrint");
		
		USpectatorCharacterHUD_CenterPrint_Params params {};
		params.MessageType = MessageType;
		params.Duration = Duration;
		params.Other = Other;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpectatorCharacterHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpectatorCharacterHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.SpectatorCharacterHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveWidget.SetObjectiveType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerObjectiveMarkerType                         NewType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveWidget::SetObjectiveType(EPlayerObjectiveMarkerType NewType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveWidget.SetObjectiveType");
		
		UObjectiveWidget_SetObjectiveType_Params params {};
		params.NewType = NewType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ObjectiveWidget.SetObjectiveText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        NewText                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UObjectiveWidget::SetObjectiveText(const class FText& NewText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ObjectiveWidget.SetObjectiveText");
		
		UObjectiveWidget_SetObjectiveText_Params params {};
		params.NewText = NewText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectiveWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectiveWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ObjectiveWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.UpdateMedicalHealWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              CurrentHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD::UpdateMedicalHealWidget(float CurrentHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.UpdateMedicalHealWidget");
		
		UHumanCharacterHUD_UpdateMedicalHealWidget_Params params {};
		params.CurrentHealth = CurrentHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.UpdateMagBeforeReload
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD::UpdateMagBeforeReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.UpdateMagBeforeReload");
		
		UHumanCharacterHUD_UpdateMagBeforeReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.TeamChatPressed
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD::TeamChatPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.TeamChatPressed");
		
		UHumanCharacterHUD_TeamChatPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.StopShowingScopeMask
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD::StopShowingScopeMask()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.StopShowingScopeMask");
		
		UHumanCharacterHUD_StopShowingScopeMask_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.StartShowingScopeMask
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTexture2D*                                  ScopeReticle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD::StartShowingScopeMask(class UTexture2D* ScopeReticle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.StartShowingScopeMask");
		
		UHumanCharacterHUD_StartShowingScopeMask_Params params {};
		params.ScopeReticle = ScopeReticle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.ShowNewMagazine
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD::ShowNewMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.ShowNewMagazine");
		
		UHumanCharacterHUD_ShowNewMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.ShowMedicalHealWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMedicalHealScreen                                 HealScreen                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        InHealerName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        InHealeeName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InCurrentHealth                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InMinHealth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InMaxHealth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD::ShowMedicalHealWidget(EMedicalHealScreen HealScreen, const class FName& InHealerName, const class FName& InHealeeName, float InCurrentHealth, float InMinHealth, float InMaxHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.ShowMedicalHealWidget");
		
		UHumanCharacterHUD_ShowMedicalHealWidget_Params params {};
		params.HealScreen = HealScreen;
		params.InHealerName = InHealerName;
		params.InHealeeName = InHealeeName;
		params.InCurrentHealth = InCurrentHealth;
		params.InMinHealth = InMinHealth;
		params.InMaxHealth = InMaxHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.ShowMagDiscarded
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD::ShowMagDiscarded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.ShowMagDiscarded");
		
		UHumanCharacterHUD_ShowMagDiscarded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.ShowMagCheck
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD::ShowMagCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.ShowMagCheck");
		
		UHumanCharacterHUD_ShowMagCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.ShowMagAfterReload
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD::ShowMagAfterReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.ShowMagAfterReload");
		
		UHumanCharacterHUD_ShowMagAfterReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.ShowFireModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EFireMode                                          newFireMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD::ShowFireModeChanged(EFireMode newFireMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.ShowFireModeChanged");
		
		UHumanCharacterHUD_ShowFireModeChanged_Params params {};
		params.newFireMode = newFireMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.ShowBatteringRamIcon
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD::ShowBatteringRamIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.ShowBatteringRamIcon");
		
		UHumanCharacterHUD_ShowBatteringRamIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.SetHudAlpha
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD::SetHudAlpha(float Alpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.SetHudAlpha");
		
		UHumanCharacterHUD_SetHudAlpha_Params params {};
		params.Alpha = Alpha;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.OnReceivedHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHeadHit                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTorsoHit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeftArmHit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRightArmHit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeftLegHit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRightLegHit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD::OnReceivedHit(bool bHeadHit, bool bTorsoHit, bool bLeftArmHit, bool bRightArmHit, bool bLeftLegHit, bool bRightLegHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.OnReceivedHit");
		
		UHumanCharacterHUD_OnReceivedHit_Params params {};
		params.bHeadHit = bHeadHit;
		params.bTorsoHit = bTorsoHit;
		params.bLeftArmHit = bLeftArmHit;
		params.bRightArmHit = bRightArmHit;
		params.bLeftLegHit = bLeftLegHit;
		params.bRightLegHit = bRightLegHit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.OnPlayerHealed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHeadHealed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTorsoHealed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeftArmHealed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRightArmHealed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeftLegHealed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRightLegHealed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD::OnPlayerHealed(bool bHeadHealed, bool bTorsoHealed, bool bLeftArmHealed, bool bRightArmHealed, bool bLeftLegHealed, bool bRightLegHealed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.OnPlayerHealed");
		
		UHumanCharacterHUD_OnPlayerHealed_Params params {};
		params.bHeadHealed = bHeadHealed;
		params.bTorsoHealed = bTorsoHealed;
		params.bLeftArmHealed = bLeftArmHealed;
		params.bRightArmHealed = bRightArmHealed;
		params.bLeftLegHealed = bLeftLegHealed;
		params.bRightLegHealed = bRightLegHealed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.OnLimbBroken
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHeadBroken                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeftArmBroken                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRightArmBroken                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeftLegBroken                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRightLegBroken                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD::OnLimbBroken(bool bHeadBroken, bool bLeftArmBroken, bool bRightArmBroken, bool bLeftLegBroken, bool bRightLegBroken)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.OnLimbBroken");
		
		UHumanCharacterHUD_OnLimbBroken_Params params {};
		params.bHeadBroken = bHeadBroken;
		params.bLeftArmBroken = bLeftArmBroken;
		params.bRightArmBroken = bRightArmBroken;
		params.bLeftLegBroken = bLeftLegBroken;
		params.bRightLegBroken = bRightLegBroken;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.OnActionCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECompletedActionType                               Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD::OnActionCompleted(ECompletedActionType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.OnActionCompleted");
		
		UHumanCharacterHUD_OnActionCompleted_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.HideMedicalHealWidget
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD::HideMedicalHealWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.HideMedicalHealWidget");
		
		UHumanCharacterHUD_HideMedicalHealWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.HideMagCheck
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD::HideMagCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.HideMagCheck");
		
		UHumanCharacterHUD_HideMagCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.HideBatteringRamIcon
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD::HideBatteringRamIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.HideBatteringRamIcon");
		
		UHumanCharacterHUD_HideBatteringRamIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.FadeHudAlpha
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              FadeFrom                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FadeTo                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD::FadeHudAlpha(float FadeFrom, float FadeTo, float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.FadeHudAlpha");
		
		UHumanCharacterHUD_FadeHudAlpha_Params params {};
		params.FadeFrom = FadeFrom;
		params.FadeTo = FadeTo;
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.CompleteMedicalHealWidget
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD::CompleteMedicalHealWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.CompleteMedicalHealWidget");
		
		UHumanCharacterHUD_CompleteMedicalHealWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.ChatPressed
	 * 		Flags  -> ()
	 */
	void UHumanCharacterHUD::ChatPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.ChatPressed");
		
		UHumanCharacterHUD_ChatPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.HumanCharacterHUD.CenterPrint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        MessageType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerCharacter*                            Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHumanCharacterHUD::CenterPrint(const class FName& MessageType, float Duration, class APlayerCharacter* Other)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.HumanCharacterHUD.CenterPrint");
		
		UHumanCharacterHUD_CenterPrint_Params params {};
		params.MessageType = MessageType;
		params.Duration = Duration;
		params.Other = Other;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHumanCharacterHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHumanCharacterHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.HumanCharacterHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWidgetsData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWidgetsData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WidgetsData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingPlacementActor.OnWorldBuildingActivityFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UBaseActivity*                               InActivity                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACyberneticController*                       CyberneticController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AWorldBuildingPlacementActor::OnWorldBuildingActivityFinished(class UBaseActivity* InActivity, class ACyberneticController* CyberneticController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingPlacementActor.OnWorldBuildingActivityFinished");
		
		AWorldBuildingPlacementActor_OnWorldBuildingActivityFinished_Params params {};
		params.InActivity = InActivity;
		params.CyberneticController = CyberneticController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldBuildingPlacementActor.IsInUseByController
	 * 		Flags  -> ()
	 */
	bool AWorldBuildingPlacementActor::IsInUseByController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldBuildingPlacementActor.IsInUseByController");
		
		AWorldBuildingPlacementActor_IsInUseByController_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWorldBuildingPlacementActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWorldBuildingPlacementActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WorldBuildingPlacementActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWorldGenSave.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWorldGenSave::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WorldGenSave");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.VerifyWorldBuildingActivities
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::VerifyWorldBuildingActivities()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.VerifyWorldBuildingActivities");
		
		AWorldDataGenerator_VerifyWorldBuildingActivities_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.UnblockAllDoorways
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::UnblockAllDoorways()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.UnblockAllDoorways");
		
		AWorldDataGenerator_UnblockAllDoorways_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.SortAndTrimMaxVisibleThreats
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::SortAndTrimMaxVisibleThreats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.SortAndTrimMaxVisibleThreats");
		
		AWorldDataGenerator_SortAndTrimMaxVisibleThreats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.SetSpawnerSavedData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSpawnerSavedData                           InSpawnerSavedData                                         (Parm, NativeAccessSpecifierPublic)
	 */
	void AWorldDataGenerator::SetSpawnerSavedData(const struct FSpawnerSavedData& InSpawnerSavedData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.SetSpawnerSavedData");
		
		AWorldDataGenerator_SetSpawnerSavedData_Params params {};
		params.InSpawnerSavedData = InSpawnerSavedData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.SaveCullDistanceSettings
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::SaveCullDistanceSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.SaveCullDistanceSettings");
		
		AWorldDataGenerator_SaveCullDistanceSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.SaveAllScenarios
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::SaveAllScenarios()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.SaveAllScenarios");
		
		AWorldDataGenerator_SaveAllScenarios_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.ReportAllUnreachableSpawnsAndCoverToLog
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::ReportAllUnreachableSpawnsAndCoverToLog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.ReportAllUnreachableSpawnsAndCoverToLog");
		
		AWorldDataGenerator_ReportAllUnreachableSpawnsAndCoverToLog_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.ReplaceAllDoors
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::ReplaceAllDoors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.ReplaceAllDoors");
		
		AWorldDataGenerator_ReplaceAllDoors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.RemoveAllUnreachableThreats
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::RemoveAllUnreachableThreats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.RemoveAllUnreachableThreats");
		
		AWorldDataGenerator_RemoveAllUnreachableThreats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.RemoveAllUnreachableStacks
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::RemoveAllUnreachableStacks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.RemoveAllUnreachableStacks");
		
		AWorldDataGenerator_RemoveAllUnreachableStacks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.RemoveAllUnreachableSpawns
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::RemoveAllUnreachableSpawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.RemoveAllUnreachableSpawns");
		
		AWorldDataGenerator_RemoveAllUnreachableSpawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.RemoveAllUnreachableCover
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::RemoveAllUnreachableCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.RemoveAllUnreachableCover");
		
		AWorldDataGenerator_RemoveAllUnreachableCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.RemoveAllStackups
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::RemoveAllStackups()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.RemoveAllStackups");
		
		AWorldDataGenerator_RemoveAllStackups_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.RemoveAllOverlappingThreats
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::RemoveAllOverlappingThreats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.RemoveAllOverlappingThreats");
		
		AWorldDataGenerator_RemoveAllOverlappingThreats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.PushThreatsAwayFromWalls
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::PushThreatsAwayFromWalls()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.PushThreatsAwayFromWalls");
		
		AWorldDataGenerator_PushThreatsAwayFromWalls_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.PlacePatrolPointsOnAllThreats
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::PlacePatrolPointsOnAllThreats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.PlacePatrolPointsOnAllThreats");
		
		AWorldDataGenerator_PlacePatrolPointsOnAllThreats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.PlacePatrolPointsOnAllDoors
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::PlacePatrolPointsOnAllDoors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.PlacePatrolPointsOnAllDoors");
		
		AWorldDataGenerator_PlacePatrolPointsOnAllDoors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.NextBrokenDoor
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::NextBrokenDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.NextBrokenDoor");
		
		AWorldDataGenerator_NextBrokenDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.MultiplyAllCullDistances
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::MultiplyAllCullDistances()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.MultiplyAllCullDistances");
		
		AWorldDataGenerator_MultiplyAllCullDistances_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.LoadCullDistanceSettings
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::LoadCullDistanceSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.LoadCullDistanceSettings");
		
		AWorldDataGenerator_LoadCullDistanceSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.LinkSubdoors
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::LinkSubdoors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.LinkSubdoors");
		
		AWorldDataGenerator_LinkSubdoors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.GetSpawnerSavedData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSpawnerSavedData                           OutSpawnerSavedData                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void AWorldDataGenerator::GetSpawnerSavedData(struct FSpawnerSavedData* OutSpawnerSavedData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.GetSpawnerSavedData");
		
		AWorldDataGenerator_GetSpawnerSavedData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSpawnerSavedData != nullptr)
			*OutSpawnerSavedData = params.OutSpawnerSavedData;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.GenerateWorldThreatAwarenessActors
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::GenerateWorldThreatAwarenessActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.GenerateWorldThreatAwarenessActors");
		
		AWorldDataGenerator_GenerateWorldThreatAwarenessActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.GenerateWorld
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::GenerateWorld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.GenerateWorld");
		
		AWorldDataGenerator_GenerateWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.GenerateWebbedBreachPoints
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::GenerateWebbedBreachPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.GenerateWebbedBreachPoints");
		
		AWorldDataGenerator_GenerateWebbedBreachPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.GenerateSwatLookAtPointsForEachThreat
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::GenerateSwatLookAtPointsForEachThreat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.GenerateSwatLookAtPointsForEachThreat");
		
		AWorldDataGenerator_GenerateSwatLookAtPointsForEachThreat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.GenerateStackUpPoints
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::GenerateStackUpPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.GenerateStackUpPoints");
		
		AWorldDataGenerator_GenerateStackUpPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.GenerateSpawnHidingSpots
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::GenerateSpawnHidingSpots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.GenerateSpawnHidingSpots");
		
		AWorldDataGenerator_GenerateSpawnHidingSpots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.GenerateInstancedStaticMesh
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::GenerateInstancedStaticMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.GenerateInstancedStaticMesh");
		
		AWorldDataGenerator_GenerateInstancedStaticMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.GenerateCullDistances
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::GenerateCullDistances()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.GenerateCullDistances");
		
		AWorldDataGenerator_GenerateCullDistances_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.GenerateAllDoorThreatAwarenessActors
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::GenerateAllDoorThreatAwarenessActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.GenerateAllDoorThreatAwarenessActors");
		
		AWorldDataGenerator_GenerateAllDoorThreatAwarenessActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.GenerateAllDoorClearPoints
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::GenerateAllDoorClearPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.GenerateAllDoorClearPoints");
		
		AWorldDataGenerator_GenerateAllDoorClearPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.FixCachedCullDistance
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::FixCachedCullDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.FixCachedCullDistance");
		
		AWorldDataGenerator_FixCachedCullDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.DetermineAutomaticTrapOrientation
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::DetermineAutomaticTrapOrientation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.DetermineAutomaticTrapOrientation");
		
		AWorldDataGenerator_DetermineAutomaticTrapOrientation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.DestroyAllThreats
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::DestroyAllThreats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.DestroyAllThreats");
		
		AWorldDataGenerator_DestroyAllThreats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.DestroyAllPatrolPoints
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::DestroyAllPatrolPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.DestroyAllPatrolPoints");
		
		AWorldDataGenerator_DestroyAllPatrolPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.CleanUpOverlappingThreats
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::CleanUpOverlappingThreats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.CleanUpOverlappingThreats");
		
		AWorldDataGenerator_CleanUpOverlappingThreats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.CapMaxCullDistanceByBoundsMultiplier
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::CapMaxCullDistanceByBoundsMultiplier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.CapMaxCullDistanceByBoundsMultiplier");
		
		AWorldDataGenerator_CapMaxCullDistanceByBoundsMultiplier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.CalculateAllExits
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::CalculateAllExits()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.CalculateAllExits");
		
		AWorldDataGenerator_CalculateAllExits_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WorldDataGenerator.BlockAllDoorways
	 * 		Flags  -> ()
	 */
	void AWorldDataGenerator::BlockAllDoorways()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WorldDataGenerator.BlockAllDoorways");
		
		AWorldDataGenerator_BlockAllDoorways_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWorldDataGenerator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWorldDataGenerator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WorldDataGenerator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.WoundMeshActor.OnParentDestroyed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Parent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AWoundMeshActor::OnParentDestroyed(class AActor* Parent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.WoundMeshActor.OnParentDestroyed");
		
		AWoundMeshActor_OnParentDestroyed_Params params {};
		params.Parent = Parent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWoundMeshActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWoundMeshActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.WoundMeshActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ZeuzMatchmakingWidget.TryConnectServer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ConnectIp                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UZeuzMatchmakingWidget::TryConnectServer(const class FString& ConnectIp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ZeuzMatchmakingWidget.TryConnectServer");
		
		UZeuzMatchmakingWidget_TryConnectServer_Params params {};
		params.ConnectIp = ConnectIp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ZeuzMatchmakingWidget.StopPartyMatchmaking
	 * 		Flags  -> ()
	 */
	void UZeuzMatchmakingWidget::StopPartyMatchmaking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ZeuzMatchmakingWidget.StopPartyMatchmaking");
		
		UZeuzMatchmakingWidget_StopPartyMatchmaking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ZeuzMatchmakingWidget.StopMatchmaking
	 * 		Flags  -> ()
	 */
	void UZeuzMatchmakingWidget::StopMatchmaking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ZeuzMatchmakingWidget.StopMatchmaking");
		
		UZeuzMatchmakingWidget_StopMatchmaking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ZeuzMatchmakingWidget.StartPartyMatchmaking
	 * 		Flags  -> ()
	 */
	void UZeuzMatchmakingWidget::StartPartyMatchmaking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ZeuzMatchmakingWidget.StartPartyMatchmaking");
		
		UZeuzMatchmakingWidget_StartPartyMatchmaking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ZeuzMatchmakingWidget.StartMatchmaking
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Region                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UZeuzMatchmakingWidget::StartMatchmaking(const class FString& Region)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ZeuzMatchmakingWidget.StartMatchmaking");
		
		UZeuzMatchmakingWidget_StartMatchmaking_Params params {};
		params.Region = Region;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ZeuzMatchmakingWidget.ResetMatchmaking
	 * 		Flags  -> ()
	 */
	void UZeuzMatchmakingWidget::ResetMatchmaking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ZeuzMatchmakingWidget.ResetMatchmaking");
		
		UZeuzMatchmakingWidget_ResetMatchmaking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ZeuzMatchmakingWidget.OnZeuzMatchmakingUpdate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FZeuzMatchMakingStatus                      Status                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      Error                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UZeuzMatchmakingWidget::OnZeuzMatchmakingUpdate(const struct FZeuzMatchMakingStatus& Status, const class FString& Error)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ZeuzMatchmakingWidget.OnZeuzMatchmakingUpdate");
		
		UZeuzMatchmakingWidget_OnZeuzMatchmakingUpdate_Params params {};
		params.Status = Status;
		params.Error = Error;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ZeuzMatchmakingWidget.OnZeuzMatchmakingCreate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FZeuzMatchMakingStatus                      Status                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      Error                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UZeuzMatchmakingWidget::OnZeuzMatchmakingCreate(const struct FZeuzMatchMakingStatus& Status, const class FString& Error)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ZeuzMatchmakingWidget.OnZeuzMatchmakingCreate");
		
		UZeuzMatchmakingWidget_OnZeuzMatchmakingCreate_Params params {};
		params.Status = Status;
		params.Error = Error;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.ZeuzMatchmakingWidget.MatchmakingUpdate
	 * 		Flags  -> ()
	 */
	void UZeuzMatchmakingWidget::MatchmakingUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.ZeuzMatchmakingWidget.MatchmakingUpdate");
		
		UZeuzMatchmakingWidget_MatchmakingUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UZeuzMatchmakingWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UZeuzMatchmakingWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.ZeuzMatchmakingWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Zipcuffs.Server_ArrestStart
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        TargetedChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AZipcuffs::Server_ArrestStart(class AReadyOrNotCharacter* TargetedChar)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Zipcuffs.Server_ArrestStart");
		
		AZipcuffs_Server_ArrestStart_Params params {};
		params.TargetedChar = TargetedChar;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Zipcuffs.Server_ArrestComplete
	 * 		Flags  -> ()
	 */
	void AZipcuffs::Server_ArrestComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Zipcuffs.Server_ArrestComplete");
		
		AZipcuffs_Server_ArrestComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Zipcuffs.Server_ArrestCancelled
	 * 		Flags  -> ()
	 */
	void AZipcuffs::Server_ArrestCancelled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Zipcuffs.Server_ArrestCancelled");
		
		AZipcuffs_Server_ArrestCancelled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Zipcuffs.OnRagdollArrestInteractionStarted
	 * 		Flags  -> ()
	 */
	void AZipcuffs::OnRagdollArrestInteractionStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Zipcuffs.OnRagdollArrestInteractionStarted");
		
		AZipcuffs_OnRagdollArrestInteractionStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Zipcuffs.OnRagdollArrestComplete_Slave
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Slave                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AZipcuffs::OnRagdollArrestComplete_Slave(class AActor* Slave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Zipcuffs.OnRagdollArrestComplete_Slave");
		
		AZipcuffs_OnRagdollArrestComplete_Slave_Params params {};
		params.Slave = Slave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Zipcuffs.OnRagdollArrestComplete_Driver
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Driver                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AZipcuffs::OnRagdollArrestComplete_Driver(class AActor* Driver)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Zipcuffs.OnRagdollArrestComplete_Driver");
		
		AZipcuffs_OnRagdollArrestComplete_Driver_Params params {};
		params.Driver = Driver;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Zipcuffs.Multicast_OnRagdollArrestStart
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AReadyOrNotCharacter*                        ArrestTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AZipcuffs::Multicast_OnRagdollArrestStart(class AReadyOrNotCharacter* ArrestTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Zipcuffs.Multicast_OnRagdollArrestStart");
		
		AZipcuffs_Multicast_OnRagdollArrestStart_Params params {};
		params.ArrestTarget = ArrestTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function ReadyOrNot.Zipcuffs.Client_ArrestComplete
	 * 		Flags  -> ()
	 */
	void AZipcuffs::Client_ArrestComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function ReadyOrNot.Zipcuffs.Client_ArrestComplete");
		
		AZipcuffs_Client_ArrestComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AZipcuffs.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AZipcuffs::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class ReadyOrNot.Zipcuffs");
		return ptr;
	}

}


