/**
 * Name: TRIALS
 * Version: FINAL
 */

#include <../SDK.h>

namespace CG
{
	// --------------------------------------------------
	// # Structs Functions
	// --------------------------------------------------
	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.AlignedWrapBox.SetInnerSlotPadding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector2D                                   InPadding                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBox::SetInnerSlotPadding(const struct FVector2D& InPadding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.AlignedWrapBox.SetInnerSlotPadding");
		
		UAlignedWrapBox_SetInnerSlotPadding_Params params {};
		params.InPadding = InPadding;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.AlignedWrapBox.SetHorizontalAlignment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHorizontalAlignment                               InHorizontalAlignment                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBox::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.AlignedWrapBox.SetHorizontalAlignment");
		
		UAlignedWrapBox_SetHorizontalAlignment_Params params {};
		params.InHorizontalAlignment = InHorizontalAlignment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.AlignedWrapBox.AddChildWrapBox
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     Content                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAlignedWrapBoxSlot* UAlignedWrapBox::AddChildWrapBox(class UWidget* Content)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.AlignedWrapBox.AddChildWrapBox");
		
		UAlignedWrapBox_AddChildWrapBox_Params params {};
		params.Content = Content;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAlignedWrapBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAlignedWrapBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.AlignedWrapBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.AlignedWrapBoxSlot.SetVerticalAlignment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EVerticalAlignment                                 InVerticalAlignment                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBoxSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.AlignedWrapBoxSlot.SetVerticalAlignment");
		
		UAlignedWrapBoxSlot_SetVerticalAlignment_Params params {};
		params.InVerticalAlignment = InVerticalAlignment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.AlignedWrapBoxSlot.SetPadding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FMargin                                     InPadding                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBoxSlot::SetPadding(const struct FMargin& InPadding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.AlignedWrapBoxSlot.SetPadding");
		
		UAlignedWrapBoxSlot_SetPadding_Params params {};
		params.InPadding = InPadding;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.AlignedWrapBoxSlot.SetHorizontalAlignment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHorizontalAlignment                               InHorizontalAlignment                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBoxSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.AlignedWrapBoxSlot.SetHorizontalAlignment");
		
		UAlignedWrapBoxSlot_SetHorizontalAlignment_Params params {};
		params.InHorizontalAlignment = InHorizontalAlignment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.AlignedWrapBoxSlot.SetFillSpanWhenLessThan
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InFillSpanWhenLessThan                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBoxSlot::SetFillSpanWhenLessThan(float InFillSpanWhenLessThan)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.AlignedWrapBoxSlot.SetFillSpanWhenLessThan");
		
		UAlignedWrapBoxSlot_SetFillSpanWhenLessThan_Params params {};
		params.InFillSpanWhenLessThan = InFillSpanWhenLessThan;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.AlignedWrapBoxSlot.SetFillEmptySpace
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               InbFillEmptySpace                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBoxSlot::SetFillEmptySpace(bool InbFillEmptySpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.AlignedWrapBoxSlot.SetFillEmptySpace");
		
		UAlignedWrapBoxSlot_SetFillEmptySpace_Params params {};
		params.InbFillEmptySpace = InbFillEmptySpace;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAlignedWrapBoxSlot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAlignedWrapBoxSlot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.AlignedWrapBoxSlot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOPPEngine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOPPEngine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.OPPEngine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUserWidget.RemoveFromGameViewport
	 * 		Flags  -> ()
	 */
	void URBUserWidget::RemoveFromGameViewport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUserWidget.RemoveFromGameViewport");
		
		URBUserWidget_RemoveFromGameViewport_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUserWidget.Event_InputSourceChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsGamepad                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUserWidget::Event_InputSourceChanged(bool bIsGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUserWidget.Event_InputSourceChanged");
		
		URBUserWidget_Event_InputSourceChanged_Params params {};
		params.bIsGamepad = bIsGamepad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUserWidget.BP_SplitMessageToMultipleLines
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<class FText> URBUserWidget::BP_SplitMessageToMultipleLines(const class FText& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUserWidget.BP_SplitMessageToMultipleLines");
		
		URBUserWidget_BP_SplitMessageToMultipleLines_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUserWidget.BP_IsUsingGamepad
	 * 		Flags  -> ()
	 */
	bool URBUserWidget::BP_IsUsingGamepad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUserWidget.BP_IsUsingGamepad");
		
		URBUserWidget_BP_IsUsingGamepad_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUserWidget.AddToGameViewport
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            ZOrder                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUserWidget::AddToGameViewport(int32_t ZOrder)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUserWidget.AddToGameViewport");
		
		URBUserWidget_AddToGameViewport_Params params {};
		params.ZOrder = ZOrder;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBUserWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBUserWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBUserWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.IsMenuFocused
	 * 		Flags  -> ()
	 */
	bool URBMenuWidget::IsMenuFocused()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.IsMenuFocused");
		
		URBMenuWidget_IsMenuFocused_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.Event_OnUnfocusMenu
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldHide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuWidget::Event_OnUnfocusMenu(bool bShouldHide)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.Event_OnUnfocusMenu");
		
		URBMenuWidget_Event_OnUnfocusMenu_Params params {};
		params.bShouldHide = bShouldHide;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.Event_OnPush
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::Event_OnPush()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.Event_OnPush");
		
		URBMenuWidget_Event_OnPush_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.Event_OnPop
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::Event_OnPop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.Event_OnPop");
		
		URBMenuWidget_Event_OnPop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.Event_OnMenuTutorialSeen
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::Event_OnMenuTutorialSeen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.Event_OnMenuTutorialSeen");
		
		URBMenuWidget_Event_OnMenuTutorialSeen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.Event_OnMenuSettingsModified
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::Event_OnMenuSettingsModified()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.Event_OnMenuSettingsModified");
		
		URBMenuWidget_Event_OnMenuSettingsModified_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.Event_OnHide
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::Event_OnHide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.Event_OnHide");
		
		URBMenuWidget_Event_OnHide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.Event_OnFocusMenu
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::Event_OnFocusMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.Event_OnFocusMenu");
		
		URBMenuWidget_Event_OnFocusMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.Event_MenuTabRight_Pressed
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::Event_MenuTabRight_Pressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.Event_MenuTabRight_Pressed");
		
		URBMenuWidget_Event_MenuTabRight_Pressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.Event_MenuTabLeft_Pressed
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::Event_MenuTabLeft_Pressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.Event_MenuTabLeft_Pressed");
		
		URBMenuWidget_Event_MenuTabLeft_Pressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.Event_MenuRightPage_Pressed
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::Event_MenuRightPage_Pressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.Event_MenuRightPage_Pressed");
		
		URBMenuWidget_Event_MenuRightPage_Pressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.Event_MenuLeftPage_Pressed
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::Event_MenuLeftPage_Pressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.Event_MenuLeftPage_Pressed");
		
		URBMenuWidget_Event_MenuLeftPage_Pressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.Event_MenuConfirm_Pressed
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::Event_MenuConfirm_Pressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.Event_MenuConfirm_Pressed");
		
		URBMenuWidget_Event_MenuConfirm_Pressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.Event_MenuCancel_Pressed
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::Event_MenuCancel_Pressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.Event_MenuCancel_Pressed");
		
		URBMenuWidget_Event_MenuCancel_Pressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.BP_SetFocusedWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     WidgetToFocus                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuWidget::BP_SetFocusedWidget(class UWidget* WidgetToFocus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.BP_SetFocusedWidget");
		
		URBMenuWidget_BP_SetFocusedWidget_Params params {};
		params.WidgetToFocus = WidgetToFocus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.BP_PushAndClearTransitionStack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bDoTransition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuWidget::BP_PushAndClearTransitionStack(bool bDoTransition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.BP_PushAndClearTransitionStack");
		
		URBMenuWidget_BP_PushAndClearTransitionStack_Params params {};
		params.bDoTransition = bDoTransition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.BP_Push
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::BP_Push()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.BP_Push");
		
		URBMenuWidget_BP_Push_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.BP_Pop
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::BP_Pop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.BP_Pop");
		
		URBMenuWidget_BP_Pop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.BP_MenuHidden
	 * 		Flags  -> ()
	 */
	void URBMenuWidget::BP_MenuHidden()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.BP_MenuHidden");
		
		URBMenuWidget_BP_MenuHidden_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWidget.BP_GetFocusedWidget
	 * 		Flags  -> ()
	 */
	class UWidget* URBMenuWidget::BP_GetFocusedWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWidget.BP_GetFocusedWidget");
		
		URBMenuWidget_BP_GetFocusedWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAccountUpgradeMenuWidget.PlaySolo
	 * 		Flags  -> ()
	 */
	void URBAccountUpgradeMenuWidget::PlaySolo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAccountUpgradeMenuWidget.PlaySolo");
		
		URBAccountUpgradeMenuWidget_PlaySolo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAccountUpgradeMenuWidget.PlayMultiplayer
	 * 		Flags  -> ()
	 */
	void URBAccountUpgradeMenuWidget::PlayMultiplayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAccountUpgradeMenuWidget.PlayMultiplayer");
		
		URBAccountUpgradeMenuWidget_PlayMultiplayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAccountUpgradeMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAccountUpgradeMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAccountUpgradeMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.OnRep_IsInCooldown
	 * 		Flags  -> ()
	 */
	void ARBActiveSkill::OnRep_IsInCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.OnRep_IsInCooldown");
		
		ARBActiveSkill_OnRep_IsInCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.OnRep_IsActive
	 * 		Flags  -> ()
	 */
	void ARBActiveSkill::OnRep_IsActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.OnRep_IsActive");
		
		ARBActiveSkill_OnRep_IsActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.OnActiveSkillCooldownChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBActiveSkill::OnActiveSkillCooldownChanged(float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.OnActiveSkillCooldownChanged");
		
		ARBActiveSkill_OnActiveSkillCooldownChanged_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.GetCooldownTimeRemaining
	 * 		Flags  -> ()
	 */
	float ARBActiveSkill::GetCooldownTimeRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.GetCooldownTimeRemaining");
		
		ARBActiveSkill_GetCooldownTimeRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.GetCooldownRatio
	 * 		Flags  -> ()
	 */
	float ARBActiveSkill::GetCooldownRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.GetCooldownRatio");
		
		ARBActiveSkill_GetCooldownRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.GetControllerItem
	 * 		Flags  -> ()
	 */
	class ARBActiveSkillController* ARBActiveSkill::GetControllerItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.GetControllerItem");
		
		ARBActiveSkill_GetControllerItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.Event_OnPlayerInitReplicated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBActiveSkill::Event_OnPlayerInitReplicated(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.Event_OnPlayerInitReplicated");
		
		ARBActiveSkill_Event_OnPlayerInitReplicated_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.Event_OnIsInCooldownChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               isInCooldown                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBActiveSkill::Event_OnIsInCooldownChanged(bool isInCooldown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.Event_OnIsInCooldownChanged");
		
		ARBActiveSkill_Event_OnIsInCooldownChanged_Params params {};
		params.isInCooldown = isInCooldown;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.Event_OnIsActiveChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsActive                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBActiveSkill::Event_OnIsActiveChanged(bool IsActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.Event_OnIsActiveChanged");
		
		ARBActiveSkill_Event_OnIsActiveChanged_Params params {};
		params.IsActive = IsActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.Event_OnForceDeactivatedEffectTriggered
	 * 		Flags  -> ()
	 */
	void ARBActiveSkill::Event_OnForceDeactivatedEffectTriggered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.Event_OnForceDeactivatedEffectTriggered");
		
		ARBActiveSkill_Event_OnForceDeactivatedEffectTriggered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.Event_OnExitSkillLimiterZone
	 * 		Flags  -> ()
	 */
	void ARBActiveSkill::Event_OnExitSkillLimiterZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.Event_OnExitSkillLimiterZone");
		
		ARBActiveSkill_Event_OnExitSkillLimiterZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.Event_OnEnterSkillLimiterZone
	 * 		Flags  -> ()
	 */
	void ARBActiveSkill::Event_OnEnterSkillLimiterZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.Event_OnEnterSkillLimiterZone");
		
		ARBActiveSkill_Event_OnEnterSkillLimiterZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.Event_DisplayDebugInfo
	 * 		Flags  -> ()
	 */
	void ARBActiveSkill::Event_DisplayDebugInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.Event_DisplayDebugInfo");
		
		ARBActiveSkill_Event_DisplayDebugInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.BP_IsSkillUsageDisabled
	 * 		Flags  -> ()
	 */
	bool ARBActiveSkill::BP_IsSkillUsageDisabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.BP_IsSkillUsageDisabled");
		
		ARBActiveSkill_BP_IsSkillUsageDisabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.BP_GetTotalCooldownTime
	 * 		Flags  -> ()
	 */
	float ARBActiveSkill::BP_GetTotalCooldownTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.BP_GetTotalCooldownTime");
		
		ARBActiveSkill_BP_GetTotalCooldownTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.BP_GetEffectDuration
	 * 		Flags  -> ()
	 */
	float ARBActiveSkill::BP_GetEffectDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.BP_GetEffectDuration");
		
		ARBActiveSkill_BP_GetEffectDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkill.BP_CanUseSkillInLocation
	 * 		Flags  -> ()
	 */
	bool ARBActiveSkill::BP_CanUseSkillInLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkill.BP_CanUseSkillInLocation");
		
		ARBActiveSkill_BP_CanUseSkillInLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBActiveSkill.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBActiveSkill::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBActiveSkill");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnRep_PickupTransform
	 * 		Flags  -> ()
	 */
	void ARBPickup::OnRep_PickupTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnRep_PickupTransform");
		
		ARBPickup_OnRep_PickupTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnRep_PawnOwner
	 * 		Flags  -> ()
	 */
	void ARBPickup::OnRep_PawnOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnRep_PawnOwner");
		
		ARBPickup_OnRep_PawnOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnRep_OwnerInventorySlot
	 * 		Flags  -> ()
	 */
	void ARBPickup::OnRep_OwnerInventorySlot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnRep_OwnerInventorySlot");
		
		ARBPickup_OnRep_OwnerInventorySlot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnRep_IsDuplicatedToPersistent
	 * 		Flags  -> ()
	 */
	void ARBPickup::OnRep_IsDuplicatedToPersistent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnRep_IsDuplicatedToPersistent");
		
		ARBPickup_OnRep_IsDuplicatedToPersistent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnRep_IsConsumed
	 * 		Flags  -> ()
	 */
	void ARBPickup::OnRep_IsConsumed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnRep_IsConsumed");
		
		ARBPickup_OnRep_IsConsumed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnRep_HasBeenPickedUp
	 * 		Flags  -> ()
	 */
	void ARBPickup::OnRep_HasBeenPickedUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnRep_HasBeenPickedUp");
		
		ARBPickup_OnRep_HasBeenPickedUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnRep_DoubleDoseUsedOnce
	 * 		Flags  -> ()
	 */
	void ARBPickup::OnRep_DoubleDoseUsedOnce()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnRep_DoubleDoseUsedOnce");
		
		ARBPickup_OnRep_DoubleDoseUsedOnce_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnRep_ContainerPickupTransform
	 * 		Flags  -> ()
	 */
	void ARBPickup::OnRep_ContainerPickupTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnRep_ContainerPickupTransform");
		
		ARBPickup_OnRep_ContainerPickupTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnRep_Container
	 * 		Flags  -> ()
	 */
	void ARBPickup::OnRep_Container()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnRep_Container");
		
		ARBPickup_OnRep_Container_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnRep_ConsumeOutcomeProcessed
	 * 		Flags  -> ()
	 */
	void ARBPickup::OnRep_ConsumeOutcomeProcessed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnRep_ConsumeOutcomeProcessed");
		
		ARBPickup_OnRep_ConsumeOutcomeProcessed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnPickupTransformChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::OnPickupTransformChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnPickupTransformChangedCallback");
		
		ARBPickup_OnPickupTransformChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnPawnOwnerChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::OnPawnOwnerChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnPawnOwnerChangedCallback");
		
		ARBPickup_OnPawnOwnerChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnOwnerInventorySlotChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::OnOwnerInventorySlotChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnOwnerInventorySlotChangedCallback");
		
		ARBPickup_OnOwnerInventorySlotChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnIsConsumedChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::OnIsConsumedChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnIsConsumedChangedCallback");
		
		ARBPickup_OnIsConsumedChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnDoubleDoseUsedOnceChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::OnDoubleDoseUsedOnceChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnDoubleDoseUsedOnceChangedCallback");
		
		ARBPickup_OnDoubleDoseUsedOnceChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnConsumeItemStartNotify
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::OnConsumeItemStartNotify(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnConsumeItemStartNotify");
		
		ARBPickup_OnConsumeItemStartNotify_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnConsumeItemNotify
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::OnConsumeItemNotify(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnConsumeItemNotify");
		
		ARBPickup_OnConsumeItemNotify_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.OnConsumeItemCancelledNotify
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::OnConsumeItemCancelledNotify(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.OnConsumeItemCancelledNotify");
		
		ARBPickup_OnConsumeItemCancelledNotify_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.Multicast_OnDropped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Transform                                                  (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bPredicted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::Multicast_OnDropped(class ARBPawn* Pawn, const struct FTransform& Transform, bool bPredicted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.Multicast_OnDropped");
		
		ARBPickup_Multicast_OnDropped_Params params {};
		params.Pawn = Pawn;
		params.Transform = Transform;
		params.bPredicted = bPredicted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.IsItemHeldInHand
	 * 		Flags  -> ()
	 */
	bool ARBPickup::IsItemHeldInHand()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.IsItemHeldInHand");
		
		ARBPickup_IsItemHeldInHand_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.IsConsumed
	 * 		Flags  -> ()
	 */
	bool ARBPickup::IsConsumed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.IsConsumed");
		
		ARBPickup_IsConsumed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.GetPawnOwner
	 * 		Flags  -> ()
	 */
	class ARBPawn* ARBPickup::GetPawnOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.GetPawnOwner");
		
		ARBPickup_GetPawnOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.GetDisplayMesh
	 * 		Flags  -> ()
	 */
	class UMeshComponent* ARBPickup::GetDisplayMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.GetDisplayMesh");
		
		ARBPickup_GetDisplayMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.GetContainer
	 * 		Flags  -> ()
	 */
	class ARBContainer* ARBPickup::GetContainer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.GetContainer");
		
		ARBPickup_GetContainer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.Event_SnapToState
	 * 		Flags  -> ()
	 */
	void ARBPickup::Event_SnapToState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.Event_SnapToState");
		
		ARBPickup_Event_SnapToState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.Event_OnUpdateVisibility
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldBeHidden                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::Event_OnUpdateVisibility(bool bShouldBeHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.Event_OnUpdateVisibility");
		
		ARBPickup_Event_OnUpdateVisibility_Params params {};
		params.bShouldBeHidden = bShouldBeHidden;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.Event_OnPickedUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::Event_OnPickedUp(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.Event_OnPickedUp");
		
		ARBPickup_Event_OnPickedUp_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.Event_OnItemHeldInHandChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHeldInHand                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::Event_OnItemHeldInHandChanged(bool bHeldInHand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.Event_OnItemHeldInHandChanged");
		
		ARBPickup_Event_OnItemHeldInHandChanged_Params params {};
		params.bHeldInHand = bHeldInHand;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.Event_OnContainerChanged
	 * 		Flags  -> ()
	 */
	void ARBPickup::Event_OnContainerChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.Event_OnContainerChanged");
		
		ARBPickup_Event_OnContainerChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.CanSwapBetweenItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   otherItem                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBPickup::CanSwapBetweenItem(class ARBPickup* otherItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.CanSwapBetweenItem");
		
		ARBPickup_CanSwapBetweenItem_Params params {};
		params.otherItem = otherItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.BP_UpdateDisplayMesh
	 * 		Flags  -> ()
	 */
	void ARBPickup::BP_UpdateDisplayMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.BP_UpdateDisplayMesh");
		
		ARBPickup_BP_UpdateDisplayMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.BP_TickItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBPickup::BP_TickItem(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.BP_TickItem");
		
		ARBPickup_BP_TickItem_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.BP_SetIsInteractible
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               interactible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::BP_SetIsInteractible(bool interactible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.BP_SetIsInteractible");
		
		ARBPickup_BP_SetIsInteractible_Params params {};
		params.interactible = interactible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.BP_OnInitializeRecycledItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   originalItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::BP_OnInitializeRecycledItem(class ARBPickup* originalItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.BP_OnInitializeRecycledItem");
		
		ARBPickup_BP_OnInitializeRecycledItem_Params params {};
		params.originalItem = originalItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.BP_OnDropItemToFloor
	 * 		Flags  -> ()
	 */
	void ARBPickup::BP_OnDropItemToFloor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.BP_OnDropItemToFloor");
		
		ARBPickup_BP_OnDropItemToFloor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.BP_OnConsumeItemAnimNotify
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickup::BP_OnConsumeItemAnimNotify(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.BP_OnConsumeItemAnimNotify");
		
		ARBPickup_BP_OnConsumeItemAnimNotify_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.BP_IsCurrentlyEquipped
	 * 		Flags  -> ()
	 */
	bool ARBPickup::BP_IsCurrentlyEquipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.BP_IsCurrentlyEquipped");
		
		ARBPickup_BP_IsCurrentlyEquipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickup.BP_GetPlayerOwner
	 * 		Flags  -> ()
	 */
	class ARBPlayer* ARBPickup::BP_GetPlayerOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickup.BP_GetPlayerOwner");
		
		ARBPickup_BP_GetPlayerOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPickup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPickup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPickup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkillController.IsSkillActive
	 * 		Flags  -> ()
	 */
	bool ARBActiveSkillController::IsSkillActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkillController.IsSkillActive");
		
		ARBActiveSkillController_IsSkillActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkillController.Event_OnSkillActiveChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsActive                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBActiveSkillController::Event_OnSkillActiveChanged(bool IsActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkillController.Event_OnSkillActiveChanged");
		
		ARBActiveSkillController_Event_OnSkillActiveChanged_Params params {};
		params.IsActive = IsActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBActiveSkillController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBActiveSkillController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBActiveSkillController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBVolumeGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBVolumeGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVolumeGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkillLimiterZone.SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBActiveSkillLimiterZone::SetEnabled(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkillLimiterZone.SetEnabled");
		
		ARBActiveSkillLimiterZone_SetEnabled_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkillLimiterZone.OnRep_Enabled
	 * 		Flags  -> ()
	 */
	void ARBActiveSkillLimiterZone::OnRep_Enabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkillLimiterZone.OnRep_Enabled");
		
		ARBActiveSkillLimiterZone_OnRep_Enabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkillLimiterZone.OnActorExitZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBActiveSkillLimiterZone::OnActorExitZone(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkillLimiterZone.OnActorExitZone");
		
		ARBActiveSkillLimiterZone_OnActorExitZone_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkillLimiterZone.OnActorEnterZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBActiveSkillLimiterZone::OnActorEnterZone(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkillLimiterZone.OnActorEnterZone");
		
		ARBActiveSkillLimiterZone_OnActorEnterZone_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBActiveSkillLimiterZone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBActiveSkillLimiterZone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBActiveSkillLimiterZone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkillVisionComponent.Event_OnSeeThroughWallChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBActiveSkillVisionComponent::Event_OnSeeThroughWallChanged(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkillVisionComponent.Event_OnSeeThroughWallChanged");
		
		URBActiveSkillVisionComponent_Event_OnSeeThroughWallChanged_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActiveSkillVisionComponent.Event_OnActiveSkillChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBActiveSkillVisionComponent::Event_OnActiveSkillChanged(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActiveSkillVisionComponent.Event_OnActiveSkillChanged");
		
		URBActiveSkillVisionComponent_Event_OnActiveSkillChanged_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBActiveSkillVisionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBActiveSkillVisionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBActiveSkillVisionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTaskMenuWidgetBase.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBTaskMenuWidgetBase::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTaskMenuWidgetBase.Event_Refresh");
		
		URBTaskMenuWidgetBase_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTaskMenuWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTaskMenuWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTaskMenuWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBActiveTaskListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBActiveTaskListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBActiveTaskListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActorGroup.SelectLinkedActors
	 * 		Flags  -> ()
	 */
	void ARBActorGroup::SelectLinkedActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActorGroup.SelectLinkedActors");
		
		ARBActorGroup_SelectLinkedActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActorGroup.GetActors
	 * 		Flags  -> ()
	 */
	TArray<class AActor*> ARBActorGroup::GetActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActorGroup.GetActors");
		
		ARBActorGroup_GetActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActorGroup.CenterOnLinkedActors
	 * 		Flags  -> ()
	 */
	void ARBActorGroup::CenterOnLinkedActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActorGroup.CenterOnLinkedActors");
		
		ARBActorGroup_CenterOnLinkedActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActorGroup.AddSelectedActors
	 * 		Flags  -> ()
	 */
	void ARBActorGroup::AddSelectedActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActorGroup.AddSelectedActors");
		
		ARBActorGroup_AddSelectedActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBActorGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBActorGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBActorGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActorPrevisComponent.OnRep_RuntimeChildActor
	 * 		Flags  -> ()
	 */
	void URBActorPrevisComponent::OnRep_RuntimeChildActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActorPrevisComponent.OnRep_RuntimeChildActor");
		
		URBActorPrevisComponent_OnRep_RuntimeChildActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActorPrevisComponent.BP_SpawnRuntimeChildActor
	 * 		Flags  -> ()
	 */
	void URBActorPrevisComponent::BP_SpawnRuntimeChildActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActorPrevisComponent.BP_SpawnRuntimeChildActor");
		
		URBActorPrevisComponent_BP_SpawnRuntimeChildActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActorPrevisComponent.BP_ForceUpdateVisibility
	 * 		Flags  -> ()
	 */
	void URBActorPrevisComponent::BP_ForceUpdateVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActorPrevisComponent.BP_ForceUpdateVisibility");
		
		URBActorPrevisComponent_BP_ForceUpdateVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBActorPrevisComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBActorPrevisComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBActorPrevisComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActorProximityDetectionComponent.OnPawnUnregistered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     RBPawn                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBActorProximityDetectionComponent::OnPawnUnregistered(class ARBPawn* RBPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActorProximityDetectionComponent.OnPawnUnregistered");
		
		URBActorProximityDetectionComponent_OnPawnUnregistered_Params params {};
		params.RBPawn = RBPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActorProximityDetectionComponent.OnPawnRegistered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     RBPawn                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBActorProximityDetectionComponent::OnPawnRegistered(class ARBPawn* RBPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActorProximityDetectionComponent.OnPawnRegistered");
		
		URBActorProximityDetectionComponent_OnPawnRegistered_Params params {};
		params.RBPawn = RBPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActorProximityDetectionComponent.Event_OnActorExitProximity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBActorProximityDetectionComponent::Event_OnActorExitProximity(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActorProximityDetectionComponent.Event_OnActorExitProximity");
		
		URBActorProximityDetectionComponent_Event_OnActorExitProximity_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBActorProximityDetectionComponent.Event_OnActorEnterProximity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBActorProximityDetectionComponent::Event_OnActorEnterProximity(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBActorProximityDetectionComponent.Event_OnActorEnterProximity");
		
		URBActorProximityDetectionComponent_Event_OnActorEnterProximity_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBActorProximityDetectionComponent.ActorProximityDetectionComponentEvent__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBActorProximityDetectionComponent::ActorProximityDetectionComponentEvent__DelegateSignature(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBActorProximityDetectionComponent.ActorProximityDetectionComponentEvent__DelegateSignature");
		
		URBActorProximityDetectionComponent_ActorProximityDetectionComponentEvent__DelegateSignature_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBActorProximityDetectionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBActorProximityDetectionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBActorProximityDetectionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.ShowProfile
	 * 		Flags  -> ()
	 */
	void URBAddFriendWidget::ShowProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.ShowProfile");
		
		URBAddFriendWidget_ShowProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.SendPlatformFriendRequest
	 * 		Flags  -> ()
	 */
	void URBAddFriendWidget::SendPlatformFriendRequest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.SendPlatformFriendRequest");
		
		URBAddFriendWidget_SendPlatformFriendRequest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.SendFriendRequest
	 * 		Flags  -> ()
	 */
	void URBAddFriendWidget::SendFriendRequest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.SendFriendRequest");
		
		URBAddFriendWidget_SendFriendRequest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.ResolveProfile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      friendCode                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAddFriendWidget::ResolveProfile(const class FString& friendCode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.ResolveProfile");
		
		URBAddFriendWidget_ResolveProfile_Params params {};
		params.friendCode = friendCode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.IsOperationPending
	 * 		Flags  -> ()
	 */
	bool URBAddFriendWidget::IsOperationPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.IsOperationPending");
		
		URBAddFriendWidget_IsOperationPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.IsInitialDataPending
	 * 		Flags  -> ()
	 */
	bool URBAddFriendWidget::IsInitialDataPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.IsInitialDataPending");
		
		URBAddFriendWidget_IsInitialDataPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.Init
	 * 		Flags  -> ()
	 */
	void URBAddFriendWidget::Init()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.Init");
		
		URBAddFriendWidget_Init_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.HasProfile
	 * 		Flags  -> ()
	 */
	bool URBAddFriendWidget::HasProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.HasProfile");
		
		URBAddFriendWidget_HasProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.GetProfilePlatform
	 * 		Flags  -> ()
	 */
	EProfilePlatform URBAddFriendWidget::GetProfilePlatform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.GetProfilePlatform");
		
		URBAddFriendWidget_GetProfilePlatform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.GetName
	 * 		Flags  -> ()
	 */
	class FString URBAddFriendWidget::GetName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.GetName");
		
		URBAddFriendWidget_GetName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.GetFriendCode
	 * 		Flags  -> ()
	 */
	class FString URBAddFriendWidget::GetFriendCode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.GetFriendCode");
		
		URBAddFriendWidget_GetFriendCode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.FilterFriendCodeInputText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      inputText                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBAddFriendWidget::FilterFriendCodeInputText(const class FString& inputText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.FilterFriendCodeInputText");
		
		URBAddFriendWidget_FilterFriendCodeInputText_Params params {};
		params.inputText = inputText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.Event_ResolveCompleted
	 * 		Flags  -> ()
	 */
	void URBAddFriendWidget::Event_ResolveCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.Event_ResolveCompleted");
		
		URBAddFriendWidget_Event_ResolveCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBAddFriendWidget::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.Event_Refresh");
		
		URBAddFriendWidget_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.Event_OnError
	 * 		Flags  -> ()
	 */
	void URBAddFriendWidget::Event_OnError()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.Event_OnError");
		
		URBAddFriendWidget_Event_OnError_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.Event_Init
	 * 		Flags  -> ()
	 */
	void URBAddFriendWidget::Event_Init()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.Event_Init");
		
		URBAddFriendWidget_Event_Init_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.Event_Done
	 * 		Flags  -> ()
	 */
	void URBAddFriendWidget::Event_Done()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.Event_Done");
		
		URBAddFriendWidget_Event_Done_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.CopyFriendCode
	 * 		Flags  -> ()
	 */
	void URBAddFriendWidget::CopyFriendCode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.CopyFriendCode");
		
		URBAddFriendWidget_CopyFriendCode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.CanShowProfile
	 * 		Flags  -> ()
	 */
	bool URBAddFriendWidget::CanShowProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.CanShowProfile");
		
		URBAddFriendWidget_CanShowProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.CanSendPlatformFriendRequest
	 * 		Flags  -> ()
	 */
	bool URBAddFriendWidget::CanSendPlatformFriendRequest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.CanSendPlatformFriendRequest");
		
		URBAddFriendWidget_CanSendPlatformFriendRequest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAddFriendWidget.CanSendFriendRequest
	 * 		Flags  -> ()
	 */
	bool URBAddFriendWidget::CanSendFriendRequest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAddFriendWidget.CanSendFriendRequest");
		
		URBAddFriendWidget_CanSendFriendRequest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAddFriendWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAddFriendWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAddFriendWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIActivity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIActivity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIActivity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIActivityChase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIActivityChase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIActivityChase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIActivityInvestigate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIActivityInvestigate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIActivityInvestigate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIActivityInvestigateAggressive.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIActivityInvestigateAggressive::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIActivityInvestigateAggressive");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIAwarenessState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIAwarenessState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIAwarenessState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIAmbientAwarenessState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIAmbientAwarenessState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIAmbientAwarenessState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIScriptedState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIScriptedState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIScriptedState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIUnawareState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIUnawareState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIUnawareState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAISuspiciousState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAISuspiciousState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAISuspiciousState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIAlertedState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIAlertedState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIAlertedState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.ZoneDefense
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              zonePatrolPoints                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      fallbackLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBZoneDefenseMarker*                        defensiveSpline                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBAIConditionSet                           ExitConditions                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanAttack                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::ZoneDefense(class ARBBot* bot, TArray<class AActor*> zonePatrolPoints, class AActor* fallbackLocation, class ARBZoneDefenseMarker* defensiveSpline, const struct FRBAIConditionSet& ExitConditions, bool bCanAttack)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.ZoneDefense");
		
		URBAIBlueprintLibrary_ZoneDefense_Params params {};
		params.bot = bot;
		params.zonePatrolPoints = zonePatrolPoints;
		params.fallbackLocation = fallbackLocation;
		params.defensiveSpline = defensiveSpline;
		params.ExitConditions = ExitConditions;
		params.bCanAttack = bCanAttack;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.WakeUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bScream                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::WakeUp(class ARBBot* bot, bool bScream)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.WakeUp");
		
		URBAIBlueprintLibrary_WakeUp_Params params {};
		params.bot = bot;
		params.bScream = bScream;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.WaitForAIConditions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRBAIConditionSet                           conditionSet                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::WaitForAIConditions(class ARBBot* bot, const struct FLatentActionInfo& LatentInfo, const struct FRBAIConditionSet& conditionSet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.WaitForAIConditions");
		
		URBAIBlueprintLibrary_WaitForAIConditions_Params params {};
		params.bot = bot;
		params.LatentInfo = LatentInfo;
		params.conditionSet = conditionSet;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.TryPlayAttackType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAttackType                                        AttackType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MovementSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::TryPlayAttackType(class ARBBot* bot, EAttackType AttackType, float MovementSpeed, class AActor* TargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.TryPlayAttackType");
		
		URBAIBlueprintLibrary_TryPlayAttackType_Params params {};
		params.bot = bot;
		params.AttackType = AttackType;
		params.MovementSpeed = MovementSpeed;
		params.TargetActor = TargetActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.TriggerStimulusFromPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETriggeringStimulusType                            StimulusType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::TriggerStimulusFromPlayer(ETriggeringStimulusType StimulusType, class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.TriggerStimulusFromPlayer");
		
		URBAIBlueprintLibrary_TriggerStimulusFromPlayer_Params params {};
		params.StimulusType = StimulusType;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.TriggerStimulus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETriggeringStimulusType                            StimulusType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      SourceActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::TriggerStimulus(ETriggeringStimulusType StimulusType, const struct FVector& Location, class AActor* SourceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.TriggerStimulus");
		
		URBAIBlueprintLibrary_TriggerStimulus_Params params {};
		params.StimulusType = StimulusType;
		params.Location = Location;
		params.SourceActor = SourceActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.TriggerDoubleSidedStimulusFromPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETriggeringStimulusType                            StimulusType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     baseLocation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     offsetWS                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::TriggerDoubleSidedStimulusFromPlayer(ETriggeringStimulusType StimulusType, class ARBPlayer* Player, const struct FVector& baseLocation, const struct FVector& offsetWS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.TriggerDoubleSidedStimulusFromPlayer");
		
		URBAIBlueprintLibrary_TriggerDoubleSidedStimulusFromPlayer_Params params {};
		params.StimulusType = StimulusType;
		params.Player = Player;
		params.baseLocation = baseLocation;
		params.offsetWS = offsetWS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.TriggerDoubleSidedStimulus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETriggeringStimulusType                            StimulusType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      SourceActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     baseLocation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     offsetWS                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::TriggerDoubleSidedStimulus(ETriggeringStimulusType StimulusType, class AActor* SourceActor, const struct FVector& baseLocation, const struct FVector& offsetWS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.TriggerDoubleSidedStimulus");
		
		URBAIBlueprintLibrary_TriggerDoubleSidedStimulus_Params params {};
		params.StimulusType = StimulusType;
		params.SourceActor = SourceActor;
		params.baseLocation = baseLocation;
		params.offsetWS = offsetWS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.TriggerCustomHighPriorityStimulusFromPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              fullLoudnessRange                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxHearingDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::TriggerCustomHighPriorityStimulusFromPlayer(class ARBPlayer* Player, float fullLoudnessRange, float MaxHearingDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.TriggerCustomHighPriorityStimulusFromPlayer");
		
		URBAIBlueprintLibrary_TriggerCustomHighPriorityStimulusFromPlayer_Params params {};
		params.Player = Player;
		params.fullLoudnessRange = fullLoudnessRange;
		params.MaxHearingDistance = MaxHearingDistance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.TriggerCustomHighPriorityStimulus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     NoiseLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              fullLoudnessRange                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              maxBotDistance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::TriggerCustomHighPriorityStimulus(const struct FVector& NoiseLocation, class AActor* Source, float fullLoudnessRange, float maxBotDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.TriggerCustomHighPriorityStimulus");
		
		URBAIBlueprintLibrary_TriggerCustomHighPriorityStimulus_Params params {};
		params.NoiseLocation = NoiseLocation;
		params.Source = Source;
		params.fullLoudnessRange = fullLoudnessRange;
		params.maxBotDistance = maxBotDistance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.TestAIConditions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAIBoolCommandResult                               operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBAIConditionSet                           conditionSet                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::TestAIConditions(class ARBBot* bot, EAIBoolCommandResult* operationResult, const struct FRBAIConditionSet& conditionSet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.TestAIConditions");
		
		URBAIBlueprintLibrary_TestAIConditions_Params params {};
		params.bot = bot;
		params.conditionSet = conditionSet;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SummonNPC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENPCType                                           NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialBotInitialBehavior                         initialBehavior                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMonsterClosetSelectionMode                        closetSelectionMethod                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   TargetPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBMonsterCloset*                            specificMonsterCloset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinBotLifetime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBBot*                                      spawnedBot                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBNPC*                                      spawnedPawn                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SummonNPC(ENPCType NPCType, ESpecialBotInitialBehavior initialBehavior, EMonsterClosetSelectionMode closetSelectionMethod, class ARBPlayer* TargetPlayer, class ARBMonsterCloset* specificMonsterCloset, float MinBotLifetime, class ARBBot** spawnedBot, class ARBNPC** spawnedPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SummonNPC");
		
		URBAIBlueprintLibrary_SummonNPC_Params params {};
		params.NPCType = NPCType;
		params.initialBehavior = initialBehavior;
		params.closetSelectionMethod = closetSelectionMethod;
		params.TargetPlayer = TargetPlayer;
		params.specificMonsterCloset = specificMonsterCloset;
		params.MinBotLifetime = MinBotLifetime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (spawnedBot != nullptr)
			*spawnedBot = params.spawnedBot;
		if (spawnedPawn != nullptr)
			*spawnedPawn = params.spawnedPawn;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.StartPatrolInvestigateVolumeGroup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAICommandResult                                   operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bSetLeashWithVolumes                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::StartPatrolInvestigateVolumeGroup(class ARBBot* bot, EAICommandResult* operationResult, const struct FLatentActionInfo& LatentInfo, bool bSetLeashWithVolumes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.StartPatrolInvestigateVolumeGroup");
		
		URBAIBlueprintLibrary_StartPatrolInvestigateVolumeGroup_Params params {};
		params.bot = bot;
		params.LatentInfo = LatentInfo;
		params.bSetLeashWithVolumes = bSetLeashWithVolumes;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.StartPatrolInvestigateSoft
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAICommandResult                                   operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bSetLeashWithVolumes                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::StartPatrolInvestigateSoft(class ARBBot* bot, EAICommandResult* operationResult, const struct FLatentActionInfo& LatentInfo, bool bSetLeashWithVolumes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.StartPatrolInvestigateSoft");
		
		URBAIBlueprintLibrary_StartPatrolInvestigateSoft_Params params {};
		params.bot = bot;
		params.LatentInfo = LatentInfo;
		params.bSetLeashWithVolumes = bSetLeashWithVolumes;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.StartPatrolInvestigate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAICommandResult                                   operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class AVolume*>                             RestrictedVolumes                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bSetLeashWithVolumes                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::StartPatrolInvestigate(class ARBBot* bot, EAICommandResult* operationResult, const struct FLatentActionInfo& LatentInfo, TArray<class AVolume*> RestrictedVolumes, bool bSetLeashWithVolumes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.StartPatrolInvestigate");
		
		URBAIBlueprintLibrary_StartPatrolInvestigate_Params params {};
		params.bot = bot;
		params.LatentInfo = LatentInfo;
		params.RestrictedVolumes = RestrictedVolumes;
		params.bSetLeashWithVolumes = bSetLeashWithVolumes;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.StartPatrol
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAICommandResult                                   operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class ARBWaypoint*>                         WaypointList                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EPatrolWaypointSelectionMode                       Mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              overrideSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForced                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::StartPatrol(class ARBBot* bot, EAICommandResult* operationResult, const struct FLatentActionInfo& LatentInfo, TArray<class ARBWaypoint*> WaypointList, EPatrolWaypointSelectionMode Mode, float overrideSpeed, bool bForced)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.StartPatrol");
		
		URBAIBlueprintLibrary_StartPatrol_Params params {};
		params.bot = bot;
		params.LatentInfo = LatentInfo;
		params.WaypointList = WaypointList;
		params.Mode = Mode;
		params.overrideSpeed = overrideSpeed;
		params.bForced = bForced;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SpawnPouncers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AVolume*>                             allowedVolumes                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            minPouncers                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxPouncers                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBAIConfig*                                 configOverride                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SpawnPouncers(TArray<class AVolume*> allowedVolumes, const struct FLatentActionInfo& LatentInfo, int32_t minPouncers, int32_t maxPouncers, class URBAIConfig* configOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SpawnPouncers");
		
		URBAIBlueprintLibrary_SpawnPouncers_Params params {};
		params.allowedVolumes = allowedVolumes;
		params.LatentInfo = LatentInfo;
		params.minPouncers = minPouncers;
		params.maxPouncers = maxPouncers;
		params.configOverride = configOverride;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SpawnPouncer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      hidespot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBAIConfig*                                 configOverride                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBBot*                                      spawnedBot                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBNPC*                                      spawnedPawn                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SpawnPouncer(class AActor* hidespot, class URBAIConfig* configOverride, class ARBBot** spawnedBot, class ARBNPC** spawnedPawn, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SpawnPouncer");
		
		URBAIBlueprintLibrary_SpawnPouncer_Params params {};
		params.hidespot = hidespot;
		params.configOverride = configOverride;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (spawnedBot != nullptr)
			*spawnedBot = params.spawnedBot;
		if (spawnedPawn != nullptr)
			*spawnedPawn = params.spawnedPawn;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SpawnAISync
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      PawnClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBAIConfig*                                 configAsset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAIConfigData                               ConfigOverrides                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class URBPartialAIConfig*>                  AdditionalConfigs                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class URBVOMapping*                                VOMappingOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      spawnPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBBot*                                      spawnedBot                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBNPC*                                      spawnedPawn                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SpawnAISync(class UClass* PawnClass, class URBAIConfig* configAsset, const struct FAIConfigData& ConfigOverrides, TArray<class URBPartialAIConfig*> AdditionalConfigs, class URBVOMapping* VOMappingOverride, class AActor* spawnPoint, class ARBBot** spawnedBot, class ARBNPC** spawnedPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SpawnAISync");
		
		URBAIBlueprintLibrary_SpawnAISync_Params params {};
		params.PawnClass = PawnClass;
		params.configAsset = configAsset;
		params.ConfigOverrides = ConfigOverrides;
		params.AdditionalConfigs = AdditionalConfigs;
		params.VOMappingOverride = VOMappingOverride;
		params.spawnPoint = spawnPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (spawnedBot != nullptr)
			*spawnedBot = params.spawnedBot;
		if (spawnedPawn != nullptr)
			*spawnedPawn = params.spawnedPawn;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SpawnAIArchetype
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENPCType                                           NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ENPCFlavor                                         Flavor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAIConfigData                               ConfigOverrides                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class URBPartialAIConfig*>                  AdditionalConfigs                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class URBVOMapping*                                VOMappingOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      spawnPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBBot*                                      spawnedBot                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBNPC*                                      spawnedPawn                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SpawnAIArchetype(ENPCType NPCType, ENPCFlavor Flavor, const struct FAIConfigData& ConfigOverrides, TArray<class URBPartialAIConfig*> AdditionalConfigs, class URBVOMapping* VOMappingOverride, class AActor* spawnPoint, class ARBBot** spawnedBot, class ARBNPC** spawnedPawn, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SpawnAIArchetype");
		
		URBAIBlueprintLibrary_SpawnAIArchetype_Params params {};
		params.NPCType = NPCType;
		params.Flavor = Flavor;
		params.ConfigOverrides = ConfigOverrides;
		params.AdditionalConfigs = AdditionalConfigs;
		params.VOMappingOverride = VOMappingOverride;
		params.spawnPoint = spawnPoint;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (spawnedBot != nullptr)
			*spawnedBot = params.spawnedBot;
		if (spawnedPawn != nullptr)
			*spawnedPawn = params.spawnedPawn;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SpawnAI
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      PawnClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBAIConfig*                                 configAsset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAIConfigData                               ConfigOverrides                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class URBPartialAIConfig*>                  AdditionalConfigs                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class URBVOMapping*                                VOMappingOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      spawnPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBBot*                                      spawnedBot                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBNPC*                                      spawnedPawn                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SpawnAI(class UClass* PawnClass, class URBAIConfig* configAsset, const struct FAIConfigData& ConfigOverrides, TArray<class URBPartialAIConfig*> AdditionalConfigs, class URBVOMapping* VOMappingOverride, class AActor* spawnPoint, class ARBBot** spawnedBot, class ARBNPC** spawnedPawn, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SpawnAI");
		
		URBAIBlueprintLibrary_SpawnAI_Params params {};
		params.PawnClass = PawnClass;
		params.configAsset = configAsset;
		params.ConfigOverrides = ConfigOverrides;
		params.AdditionalConfigs = AdditionalConfigs;
		params.VOMappingOverride = VOMappingOverride;
		params.spawnPoint = spawnPoint;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (spawnedBot != nullptr)
			*spawnedBot = params.spawnedBot;
		if (spawnedPawn != nullptr)
			*spawnedPawn = params.spawnedPawn;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetVOMapOverrides
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBVOMappingOverride*                        voOverrides                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetVOMapOverrides(class ARBBot* bot, class URBVOMappingOverride* voOverrides)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetVOMapOverrides");
		
		URBAIBlueprintLibrary_SetVOMapOverrides_Params params {};
		params.bot = bot;
		params.voOverrides = voOverrides;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetupAmbush
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBHidespotComponent*                        hidespot                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bImmediate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetupAmbush(class ARBBot* bot, class URBHidespotComponent* hidespot, bool bImmediate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetupAmbush");
		
		URBAIBlueprintLibrary_SetupAmbush_Params params {};
		params.bot = bot;
		params.hidespot = hidespot;
		params.bImmediate = bImmediate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetupAIDirectorForOpenedSections
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBAIDirectorConfig*                         directorConfig                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetupAIDirectorForOpenedSections(class URBAIDirectorConfig* directorConfig)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetupAIDirectorForOpenedSections");
		
		URBAIBlueprintLibrary_SetupAIDirectorForOpenedSections_Params params {};
		params.directorConfig = directorConfig;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetupAIDirector
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBAIDirectorConfig*                         directorConfig                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetupAIDirector(class URBAIDirectorConfig* directorConfig)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetupAIDirector");
		
		URBAIBlueprintLibrary_SetupAIDirector_Params params {};
		params.directorConfig = directorConfig;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetSpecificTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   TargetPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetSpecificTarget(class ARBBot* bot, class ARBPlayer* TargetPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetSpecificTarget");
		
		URBAIBlueprintLibrary_SetSpecificTarget_Params params {};
		params.bot = bot;
		params.TargetPlayer = TargetPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetSnipingSplines
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ARBSplineActor*>                      splineMarkers                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetSnipingSplines(class ARBBot* bot, TArray<class ARBSplineActor*> splineMarkers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetSnipingSplines");
		
		URBAIBlueprintLibrary_SetSnipingSplines_Params params {};
		params.bot = bot;
		params.splineMarkers = splineMarkers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetLeashes
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ARBLeashMarker*>                      leashMarkers                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetLeashes(class ARBBot* bot, TArray<class ARBLeashMarker*> leashMarkers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetLeashes");
		
		URBAIBlueprintLibrary_SetLeashes_Params params {};
		params.bot = bot;
		params.leashMarkers = leashMarkers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetLeashByVolumesSoft
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetLeashByVolumesSoft(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetLeashByVolumesSoft");
		
		URBAIBlueprintLibrary_SetLeashByVolumesSoft_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetLeashByVolumes
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AVolume*>                             RestrictedVolumes                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetLeashByVolumes(class ARBBot* bot, TArray<class AVolume*> RestrictedVolumes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetLeashByVolumes");
		
		URBAIBlueprintLibrary_SetLeashByVolumes_Params params {};
		params.bot = bot;
		params.RestrictedVolumes = RestrictedVolumes;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetLeashByVolumeGroups
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetLeashByVolumeGroups(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetLeashByVolumeGroups");
		
		URBAIBlueprintLibrary_SetLeashByVolumeGroups_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetLeash
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBLeashMarker*                              leashMarker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetLeash(class ARBBot* bot, class ARBLeashMarker* leashMarker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetLeash");
		
		URBAIBlueprintLibrary_SetLeash_Params params {};
		params.bot = bot;
		params.leashMarker = leashMarker;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetGuard
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      guardAnchor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBAIConditionSet                           ExitConditions                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanAttack                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              lateralBlockingDistance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetGuard(class ARBBot* bot, class AActor* guardAnchor, const struct FRBAIConditionSet& ExitConditions, bool bCanAttack, float lateralBlockingDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetGuard");
		
		URBAIBlueprintLibrary_SetGuard_Params params {};
		params.bot = bot;
		params.guardAnchor = guardAnchor;
		params.ExitConditions = ExitConditions;
		params.bCanAttack = bCanAttack;
		params.lateralBlockingDistance = lateralBlockingDistance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetFixedAnimPose
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               AnimToPlay                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              animTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetFixedAnimPose(class ARBBot* bot, class UAnimSequence* AnimToPlay, float animTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetFixedAnimPose");
		
		URBAIBlueprintLibrary_SetFixedAnimPose_Params params {};
		params.bot = bot;
		params.AnimToPlay = AnimToPlay;
		params.animTime = animTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetConditionalAIConfig
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBAIConditionSet                           conditionSet                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FAIConfigData                               ConfigOverrides                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bStayActivated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetConditionalAIConfig(class ARBBot* bot, const struct FRBAIConditionSet& conditionSet, const struct FAIConfigData& ConfigOverrides, bool bStayActivated)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetConditionalAIConfig");
		
		URBAIBlueprintLibrary_SetConditionalAIConfig_Params params {};
		params.bot = bot;
		params.conditionSet = conditionSet;
		params.ConfigOverrides = ConfigOverrides;
		params.bStayActivated = bStayActivated;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetAvailableAmbientActivityMarkers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ARBAmbientActivityMarker*>            ambientMarkers                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetAvailableAmbientActivityMarkers(class ARBBot* bot, TArray<class ARBAmbientActivityMarker*> ambientMarkers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetAvailableAmbientActivityMarkers");
		
		URBAIBlueprintLibrary_SetAvailableAmbientActivityMarkers_Params params {};
		params.bot = bot;
		params.ambientMarkers = ambientMarkers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SetAIConfig
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBAIConfig*                                 configAsset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class URBPartialAIConfig*>                  AdditionalConfigs                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FAIConfigData                               ConfigOverrides                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bSetAsDefault                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bResetAwarenessState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SetAIConfig(class ARBBot* bot, class URBAIConfig* configAsset, TArray<class URBPartialAIConfig*> AdditionalConfigs, const struct FAIConfigData& ConfigOverrides, bool bSetAsDefault, bool bResetAwarenessState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SetAIConfig");
		
		URBAIBlueprintLibrary_SetAIConfig_Params params {};
		params.bot = bot;
		params.configAsset = configAsset;
		params.AdditionalConfigs = AdditionalConfigs;
		params.ConfigOverrides = ConfigOverrides;
		params.bSetAsDefault = bSetAsDefault;
		params.bResetAwarenessState = bResetAwarenessState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.SeekRetirement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPriorityOverActiveBehaviors                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::SeekRetirement(class ARBBot* bot, bool bPriorityOverActiveBehaviors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.SeekRetirement");
		
		URBAIBlueprintLibrary_SeekRetirement_Params params {};
		params.bot = bot;
		params.bPriorityOverActiveBehaviors = bPriorityOverActiveBehaviors;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.RetirePouncersInVolumes
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AVolume*>                             allowedVolumes                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::RetirePouncersInVolumes(TArray<class AVolume*> allowedVolumes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.RetirePouncersInVolumes");
		
		URBAIBlueprintLibrary_RetirePouncersInVolumes_Params params {};
		params.allowedVolumes = allowedVolumes;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.ResetAIConfig
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::ResetAIConfig(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.ResetAIConfig");
		
		URBAIBlueprintLibrary_ResetAIConfig_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.RequestPatrol
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ARBWaypoint*>                         WaypointList                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EPatrolWaypointSelectionMode                       Mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              overrideSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForced                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::RequestPatrol(class ARBBot* bot, TArray<class ARBWaypoint*> WaypointList, EPatrolWaypointSelectionMode Mode, float overrideSpeed, bool bForced)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.RequestPatrol");
		
		URBAIBlueprintLibrary_RequestPatrol_Params params {};
		params.bot = bot;
		params.WaypointList = WaypointList;
		params.Mode = Mode;
		params.overrideSpeed = overrideSpeed;
		params.bForced = bForced;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.RequestInvestigatePoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              pointList                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EInvestigationPointSelectionMode                   SelectionMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAware                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bContinueInvestigatingWhenDone                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxNumberOfPoints                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlySpecifiedPoints                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::RequestInvestigatePoints(class ARBBot* bot, TArray<class AActor*> pointList, EInvestigationPointSelectionMode SelectionMode, bool bAware, bool bContinueInvestigatingWhenDone, int32_t maxNumberOfPoints, bool bOnlySpecifiedPoints)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.RequestInvestigatePoints");
		
		URBAIBlueprintLibrary_RequestInvestigatePoints_Params params {};
		params.bot = bot;
		params.pointList = pointList;
		params.SelectionMode = SelectionMode;
		params.bAware = bAware;
		params.bContinueInvestigatingWhenDone = bContinueInvestigatingWhenDone;
		params.maxNumberOfPoints = maxNumberOfPoints;
		params.bOnlySpecifiedPoints = bOnlySpecifiedPoints;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.RequestInvestigatePoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InvestigationPoint                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAware                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bContinueInvestigatingWhenDone                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::RequestInvestigatePoint(class ARBBot* bot, class AActor* InvestigationPoint, bool bAware, bool bContinueInvestigatingWhenDone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.RequestInvestigatePoint");
		
		URBAIBlueprintLibrary_RequestInvestigatePoint_Params params {};
		params.bot = bot;
		params.InvestigationPoint = InvestigationPoint;
		params.bAware = bAware;
		params.bContinueInvestigatingWhenDone = bContinueInvestigatingWhenDone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.RequestInvestigateLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     investigationLoc                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAware                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bContinueInvestigatingWhenDone                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::RequestInvestigateLocation(class ARBBot* bot, const struct FVector& investigationLoc, bool bAware, bool bContinueInvestigatingWhenDone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.RequestInvestigateLocation");
		
		URBAIBlueprintLibrary_RequestInvestigateLocation_Params params {};
		params.bot = bot;
		params.investigationLoc = investigationLoc;
		params.bAware = bAware;
		params.bContinueInvestigatingWhenDone = bContinueInvestigatingWhenDone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.RequestInvestigate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAware                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::RequestInvestigate(class ARBBot* bot, bool bAware)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.RequestInvestigate");
		
		URBAIBlueprintLibrary_RequestInvestigate_Params params {};
		params.bot = bot;
		params.bAware = bAware;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.RequestGotoAmbientMarker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ambientLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::RequestGotoAmbientMarker(class ARBBot* bot, class AActor* ambientLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.RequestGotoAmbientMarker");
		
		URBAIBlueprintLibrary_RequestGotoAmbientMarker_Params params {};
		params.bot = bot;
		params.ambientLocation = ambientLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.RequestGoto
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Destination                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              overrideSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTurnToRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              distanceBuffer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForced                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::RequestGoto(class ARBBot* bot, class AActor* Destination, float overrideSpeed, bool bTurnToRotation, float distanceBuffer, bool bForced)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.RequestGoto");
		
		URBAIBlueprintLibrary_RequestGoto_Params params {};
		params.bot = bot;
		params.Destination = Destination;
		params.overrideSpeed = overrideSpeed;
		params.bTurnToRotation = bTurnToRotation;
		params.distanceBuffer = distanceBuffer;
		params.bForced = bForced;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.PlaySingleShotAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAICommandResult                                   operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               AnimSeq                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::PlaySingleShotAnim(class ARBBot* bot, EAICommandResult* operationResult, const struct FLatentActionInfo& LatentInfo, class UAnimSequence* AnimSeq)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.PlaySingleShotAnim");
		
		URBAIBlueprintLibrary_PlaySingleShotAnim_Params params {};
		params.bot = bot;
		params.LatentInfo = LatentInfo;
		params.AnimSeq = AnimSeq;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.PlayScriptedVO
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               AudioEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVOPriority                                        VOPriority                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::PlayScriptedVO(class ARBBot* bot, class UAkAudioEvent* AudioEvent, EVOPriority VOPriority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.PlayScriptedVO");
		
		URBAIBlueprintLibrary_PlayScriptedVO_Params params {};
		params.bot = bot;
		params.AudioEvent = AudioEvent;
		params.VOPriority = VOPriority;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.PlayLoopingIdle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAICommandResult                                   operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               IdleAnim                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnorePlayers                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBAIConditionSet                           specificExitConditions                                     (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               specificExitAnim                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::PlayLoopingIdle(class ARBBot* bot, EAICommandResult* operationResult, const struct FLatentActionInfo& LatentInfo, class UAnimSequence* IdleAnim, bool bIgnorePlayers, const struct FRBAIConditionSet& specificExitConditions, class UAnimSequence* specificExitAnim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.PlayLoopingIdle");
		
		URBAIBlueprintLibrary_PlayLoopingIdle_Params params {};
		params.bot = bot;
		params.LatentInfo = LatentInfo;
		params.IdleAnim = IdleAnim;
		params.bIgnorePlayers = bIgnorePlayers;
		params.specificExitConditions = specificExitConditions;
		params.specificExitAnim = specificExitAnim;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.PlayHitReaction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ENPCHitReactionType                                ReactionType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     impactSourceLocation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayEffects                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::PlayHitReaction(class ARBBot* bot, ENPCHitReactionType ReactionType, const struct FVector& impactSourceLocation, bool bPlayEffects)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.PlayHitReaction");
		
		URBAIBlueprintLibrary_PlayHitReaction_Params params {};
		params.bot = bot;
		params.ReactionType = ReactionType;
		params.impactSourceLocation = impactSourceLocation;
		params.bPlayEffects = bPlayEffects;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.PlayContextualVO
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVOContext                                         Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::PlayContextualVO(class ARBBot* bot, EVOContext Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.PlayContextualVO");
		
		URBAIBlueprintLibrary_PlayContextualVO_Params params {};
		params.bot = bot;
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.OverrideBotAnims
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBAnimReferences*                           AnimRefsAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::OverrideBotAnims(class ARBBot* bot, class URBAnimReferences* AnimRefsAsset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.OverrideBotAnims");
		
		URBAIBlueprintLibrary_OverrideBotAnims_Params params {};
		params.bot = bot;
		params.AnimRefsAsset = AnimRefsAsset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.KillBot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::KillBot(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.KillBot");
		
		URBAIBlueprintLibrary_KillBot_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.KillAllBots
	 * 		Flags  -> ()
	 */
	void URBAIBlueprintLibrary::KillAllBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.KillAllBots");
		
		URBAIBlueprintLibrary_KillAllBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.IsAnyBotOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENPCType                                           NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBAIBlueprintLibrary::IsAnyBotOfType(ENPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.IsAnyBotOfType");
		
		URBAIBlueprintLibrary_IsAnyBotOfType_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.InvestigatePoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAICommandResult                                   operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              pointList                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EInvestigationPointSelectionMode                   SelectionMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAware                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bContinueInvestigatingWhenDone                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxNumberOfPoints                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlySpecifiedPoints                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::InvestigatePoints(class ARBBot* bot, EAICommandResult* operationResult, const struct FLatentActionInfo& LatentInfo, TArray<class AActor*> pointList, EInvestigationPointSelectionMode SelectionMode, bool bAware, bool bContinueInvestigatingWhenDone, int32_t maxNumberOfPoints, bool bOnlySpecifiedPoints)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.InvestigatePoints");
		
		URBAIBlueprintLibrary_InvestigatePoints_Params params {};
		params.bot = bot;
		params.LatentInfo = LatentInfo;
		params.pointList = pointList;
		params.SelectionMode = SelectionMode;
		params.bAware = bAware;
		params.bContinueInvestigatingWhenDone = bContinueInvestigatingWhenDone;
		params.maxNumberOfPoints = maxNumberOfPoints;
		params.bOnlySpecifiedPoints = bOnlySpecifiedPoints;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.InvestigatePoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAICommandResult                                   operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InvestigationPoint                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAware                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bContinueInvestigatingWhenDone                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::InvestigatePoint(class ARBBot* bot, EAICommandResult* operationResult, const struct FLatentActionInfo& LatentInfo, class AActor* InvestigationPoint, bool bAware, bool bContinueInvestigatingWhenDone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.InvestigatePoint");
		
		URBAIBlueprintLibrary_InvestigatePoint_Params params {};
		params.bot = bot;
		params.LatentInfo = LatentInfo;
		params.InvestigationPoint = InvestigationPoint;
		params.bAware = bAware;
		params.bContinueInvestigatingWhenDone = bContinueInvestigatingWhenDone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.InvestigateLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAICommandResult                                   operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     investigationLoc                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAware                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bContinueInvestigatingWhenDone                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::InvestigateLocation(class ARBBot* bot, EAICommandResult* operationResult, const struct FLatentActionInfo& LatentInfo, const struct FVector& investigationLoc, bool bAware, bool bContinueInvestigatingWhenDone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.InvestigateLocation");
		
		URBAIBlueprintLibrary_InvestigateLocation_Params params {};
		params.bot = bot;
		params.LatentInfo = LatentInfo;
		params.investigationLoc = investigationLoc;
		params.bAware = bAware;
		params.bContinueInvestigatingWhenDone = bContinueInvestigatingWhenDone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.Investigate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAICommandResult                                   operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bAware                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::Investigate(class ARBBot* bot, EAICommandResult* operationResult, const struct FLatentActionInfo& LatentInfo, bool bAware)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.Investigate");
		
		URBAIBlueprintLibrary_Investigate_Params params {};
		params.bot = bot;
		params.LatentInfo = LatentInfo;
		params.bAware = bAware;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.IgnoreAllPlayers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBotIgnoreAllPlayers                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::IgnoreAllPlayers(class ARBBot* bot, bool bBotIgnoreAllPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.IgnoreAllPlayers");
		
		URBAIBlueprintLibrary_IgnoreAllPlayers_Params params {};
		params.bot = bot;
		params.bBotIgnoreAllPlayers = bBotIgnoreAllPlayers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GotoSabotage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      sabotageTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::GotoSabotage(class ARBBot* bot, class AActor* sabotageTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GotoSabotage");
		
		URBAIBlueprintLibrary_GotoSabotage_Params params {};
		params.bot = bot;
		params.sabotageTarget = sabotageTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GotoLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAICommandResult                                   operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Destination                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              overrideSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTurnToRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              distanceBuffer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForced                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::GotoLocation(class ARBBot* bot, EAICommandResult* operationResult, const struct FLatentActionInfo& LatentInfo, class AActor* Destination, float overrideSpeed, bool bTurnToRotation, float distanceBuffer, bool bForced)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GotoLocation");
		
		URBAIBlueprintLibrary_GotoLocation_Params params {};
		params.bot = bot;
		params.LatentInfo = LatentInfo;
		params.Destination = Destination;
		params.overrideSpeed = overrideSpeed;
		params.bTurnToRotation = bTurnToRotation;
		params.distanceBuffer = distanceBuffer;
		params.bForced = bForced;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GotoHidingSpot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      hidespot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::GotoHidingSpot(class ARBBot* bot, class AActor* hidespot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GotoHidingSpot");
		
		URBAIBlueprintLibrary_GotoHidingSpot_Params params {};
		params.bot = bot;
		params.hidespot = hidespot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GotoAmbientMarker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ambientLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAICommandResult                                   operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::GotoAmbientMarker(class ARBBot* bot, class AActor* ambientLocation, EAICommandResult* operationResult, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GotoAmbientMarker");
		
		URBAIBlueprintLibrary_GotoAmbientMarker_Params params {};
		params.bot = bot;
		params.ambientLocation = ambientLocation;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GoRetireInCloset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBMonsterCloset*                            Closet                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPriorityOverActiveBehaviors                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::GoRetireInCloset(class ARBBot* bot, class ARBMonsterCloset* Closet, bool bPriorityOverActiveBehaviors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GoRetireInCloset");
		
		URBAIBlueprintLibrary_GoRetireInCloset_Params params {};
		params.bot = bot;
		params.Closet = Closet;
		params.bPriorityOverActiveBehaviors = bPriorityOverActiveBehaviors;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GlobalIgnoreAllPlayers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIgnoreAllPlayers                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::GlobalIgnoreAllPlayers(bool bIgnoreAllPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GlobalIgnoreAllPlayers");
		
		URBAIBlueprintLibrary_GlobalIgnoreAllPlayers_Params params {};
		params.bIgnoreAllPlayers = bIgnoreAllPlayers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GetNumberOfBotsByType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENPCType                                           NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBAIBlueprintLibrary::GetNumberOfBotsByType(ENPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GetNumberOfBotsByType");
		
		URBAIBlueprintLibrary_GetNumberOfBotsByType_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GetNumberOfBotsAroundInActivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EAIActivity                                        Activity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Point                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     excludedPawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBAIBlueprintLibrary::GetNumberOfBotsAroundInActivity(EAIActivity Activity, const struct FVector& Point, float Radius, class ARBPawn* excludedPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GetNumberOfBotsAroundInActivity");
		
		URBAIBlueprintLibrary_GetNumberOfBotsAroundInActivity_Params params {};
		params.Activity = Activity;
		params.Point = Point;
		params.Radius = Radius;
		params.excludedPawn = excludedPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GetNumberOfBotsAround
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Point                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     excludedPawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBAIBlueprintLibrary::GetNumberOfBotsAround(const struct FVector& Point, float Radius, class ARBPawn* excludedPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GetNumberOfBotsAround");
		
		URBAIBlueprintLibrary_GetNumberOfBotsAround_Params params {};
		params.Point = Point;
		params.Radius = Radius;
		params.excludedPawn = excludedPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GetNumberOfBots
	 * 		Flags  -> ()
	 */
	int32_t URBAIBlueprintLibrary::GetNumberOfBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GetNumberOfBots");
		
		URBAIBlueprintLibrary_GetNumberOfBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GetNPCByType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENPCType                                           NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBNPC* URBAIBlueprintLibrary::GetNPCByType(ENPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GetNPCByType");
		
		URBAIBlueprintLibrary_GetNPCByType_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GetNPCByClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      NPCClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBNPC* URBAIBlueprintLibrary::GetNPCByClass(class UClass* NPCClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GetNPCByClass");
		
		URBAIBlueprintLibrary_GetNPCByClass_Params params {};
		params.NPCClass = NPCClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GetBotsByType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENPCType                                           NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ARBBot*>                              bots                                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::GetBotsByType(ENPCType NPCType, TArray<class ARBBot*>* bots)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GetBotsByType");
		
		URBAIBlueprintLibrary_GetBotsByType_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bots != nullptr)
			*bots = params.bots;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GetBotsByClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      NPCClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ARBBot*>                              bots                                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::GetBotsByClass(class UClass* NPCClass, TArray<class ARBBot*>* bots)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GetBotsByClass");
		
		URBAIBlueprintLibrary_GetBotsByClass_Params params {};
		params.NPCClass = NPCClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bots != nullptr)
			*bots = params.bots;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GetBotByType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENPCType                                           NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBBot* URBAIBlueprintLibrary::GetBotByType(ENPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GetBotByType");
		
		URBAIBlueprintLibrary_GetBotByType_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.GetBotByClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      NPCClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBBot* URBAIBlueprintLibrary::GetBotByClass(class UClass* NPCClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.GetBotByClass");
		
		URBAIBlueprintLibrary_GetBotByClass_Params params {};
		params.NPCClass = NPCClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.ForcePlayStartleAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStartleType                                       startledType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStartleSpeed                                      startledSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              wsYaw                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::ForcePlayStartleAnimation(class ARBBot* bot, EStartleType startledType, EStartleSpeed startledSpeed, float wsYaw)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.ForcePlayStartleAnimation");
		
		URBAIBlueprintLibrary_ForcePlayStartleAnimation_Params params {};
		params.bot = bot;
		params.startledType = startledType;
		params.startledSpeed = startledSpeed;
		params.wsYaw = wsYaw;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.ForceGasGroupAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::ForceGasGroupAttack(class ARBBot* bot, const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.ForceGasGroupAttack");
		
		URBAIBlueprintLibrary_ForceGasGroupAttack_Params params {};
		params.bot = bot;
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.ForceExecute
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::ForceExecute(class ARBBot* bot, class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.ForceExecute");
		
		URBAIBlueprintLibrary_ForceExecute_Params params {};
		params.bot = bot;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.ForceChaseUntilContact
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   TargetPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::ForceChaseUntilContact(class ARBBot* bot, class ARBPlayer* TargetPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.ForceChaseUntilContact");
		
		URBAIBlueprintLibrary_ForceChaseUntilContact_Params params {};
		params.bot = bot;
		params.TargetPlayer = TargetPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.ForceAttackSequence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               forcedAnimSequence                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::ForceAttackSequence(class ARBBot* bot, class UAnimSequence* forcedAnimSequence)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.ForceAttackSequence");
		
		URBAIBlueprintLibrary_ForceAttackSequence_Params params {};
		params.bot = bot;
		params.forcedAnimSequence = forcedAnimSequence;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.ExitHidingSpot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::ExitHidingSpot(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.ExitHidingSpot");
		
		URBAIBlueprintLibrary_ExitHidingSpot_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.DisableAIDirector
	 * 		Flags  -> ()
	 */
	void URBAIBlueprintLibrary::DisableAIDirector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.DisableAIDirector");
		
		URBAIBlueprintLibrary_DisableAIDirector_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.DetachFromScriptedAnimStation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::DetachFromScriptedAnimStation(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.DetachFromScriptedAnimStation");
		
		URBAIBlueprintLibrary_DetachFromScriptedAnimStation_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.ClearVOMapOverrides
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::ClearVOMapOverrides(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.ClearVOMapOverrides");
		
		URBAIBlueprintLibrary_ClearVOMapOverrides_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.ClearSpecificTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::ClearSpecificTarget(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.ClearSpecificTarget");
		
		URBAIBlueprintLibrary_ClearSpecificTarget_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.ClearScriptedCommands
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::ClearScriptedCommands(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.ClearScriptedCommands");
		
		URBAIBlueprintLibrary_ClearScriptedCommands_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.ClearLeash
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::ClearLeash(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.ClearLeash");
		
		URBAIBlueprintLibrary_ClearLeash_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAIBlueprintLibrary.AttachToScriptedAnimStation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAICommandResult                                   operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ARBScriptedAnimStation*                      Station                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMeshComponent*                      MeshTarget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnorePlayers                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBAIConditionSet                           specificExitConditions                                     (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              StartDelay                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAIBlueprintLibrary::AttachToScriptedAnimStation(class ARBBot* bot, EAICommandResult* operationResult, const struct FLatentActionInfo& LatentInfo, class ARBScriptedAnimStation* Station, class USkeletalMeshComponent* MeshTarget, bool bIgnorePlayers, const struct FRBAIConditionSet& specificExitConditions, float StartDelay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAIBlueprintLibrary.AttachToScriptedAnimStation");
		
		URBAIBlueprintLibrary_AttachToScriptedAnimStation_Params params {};
		params.bot = bot;
		params.LatentInfo = LatentInfo;
		params.Station = Station;
		params.MeshTarget = MeshTarget;
		params.bIgnorePlayers = bIgnorePlayers;
		params.specificExitConditions = specificExitConditions;
		params.StartDelay = StartDelay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIChaseAwarenessState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIChaseAwarenessState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIChaseAwarenessState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAISneakChaseAwarenessState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAISneakChaseAwarenessState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAISneakChaseAwarenessState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIAlwaysChaseAwarenessState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIAlwaysChaseAwarenessState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIAlwaysChaseAwarenessState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_AllOfSubConditions.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_AllOfSubConditions::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_AllOfSubConditions");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_AnyOfSubConditions.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_AnyOfSubConditions::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_AnyOfSubConditions");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_AnyPlayerInVolumes.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_AnyPlayerInVolumes::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_AnyPlayerInVolumes");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_IsInVolumes.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_IsInVolumes::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_IsInVolumes");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_IsInRoom.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_IsInRoom::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_IsInRoom");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_IsInRoomGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_IsInRoomGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_IsInRoomGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_AnyPlayerInSight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_AnyPlayerInSight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_AnyPlayerInSight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_IsBotInStation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_IsBotInStation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_IsBotInStation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_AnyPlayerCloseToPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_AnyPlayerCloseToPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_AnyPlayerCloseToPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_AnyBotCloseToPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_AnyBotCloseToPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_AnyBotCloseToPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_IsIdle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_IsIdle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_IsIdle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_IsInvestigating.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_IsInvestigating::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_IsInvestigating");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_IsPatrolling.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_IsPatrolling::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_IsPatrolling");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_IsChasing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_IsChasing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_IsChasing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_FasterThan.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_FasterThan::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_FasterThan");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_CloseToPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_CloseToPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_CloseToPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_CloseToAnyPlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_CloseToAnyPlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_CloseToAnyPlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_CloseToAnotherBot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_CloseToAnotherBot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_CloseToAnotherBot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_HasDealtDamage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_HasDealtDamage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_HasDealtDamage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_HasTakenDamage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_HasTakenDamage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_HasTakenDamage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_HasChasedAPlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_HasChasedAPlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_HasChasedAPlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_HasSeenAPlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_HasSeenAPlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_HasSeenAPlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_HasBeenDisturbed.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_HasBeenDisturbed::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_HasBeenDisturbed");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_HasKilledPlayers.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_HasKilledPlayers::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_HasKilledPlayers");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_IsAtSpawnLocation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_IsAtSpawnLocation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_IsAtSpawnLocation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_IsInDarkness.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_IsInDarkness::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_IsInDarkness");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_TimeSinceSpawned.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_TimeSinceSpawned::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_TimeSinceSpawned");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_SummonedByAIDirector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_SummonedByAIDirector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_SummonedByAIDirector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAICondition_Blueprint.Event_EvaluateCondition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBAICondition_Blueprint::Event_EvaluateCondition(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAICondition_Blueprint.Event_EvaluateCondition");
		
		URBAICondition_Blueprint_Event_EvaluateCondition_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_Blueprint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_Blueprint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_Blueprint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_MinimumHealthyPlayers.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_MinimumHealthyPlayers::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_MinimumHealthyPlayers");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_MaxActiveBots.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_MaxActiveBots::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_MaxActiveBots");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_MaxBotsByType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_MaxBotsByType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_MaxBotsByType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_MaxBotsByTags.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_MaxBotsByTags::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_MaxBotsByTags");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_MaxParaspecialists.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_MaxParaspecialists::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_MaxParaspecialists");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_MaxPrimeAssets.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_MaxPrimeAssets::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_MaxPrimeAssets");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_StageTime.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_StageTime::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_StageTime");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_MinimumGameDifficulty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_MinimumGameDifficulty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_MinimumGameDifficulty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAICondition_Adversity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAICondition_Adversity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAICondition_Adversity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPartialAIConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPartialAIConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPartialAIConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIDirector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIDirector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIDirector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAimAssistComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAimAssistComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAimAssistComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIPlayerManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIPlayerManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIPlayerManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAISleeperUnawareState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAISleeperUnawareState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAISleeperUnawareState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAISleeperAlertedState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAISleeperAlertedState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAISleeperAlertedState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAISneakAwarenessState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAISneakAwarenessState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAISneakAwarenessState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAISpawner.BP_SpawnBotSpecific
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      specificPawnClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBAIConfig*                                 specificConfig                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBBot* ARBAISpawner::BP_SpawnBotSpecific(class UClass* specificPawnClass, class URBAIConfig* specificConfig)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAISpawner.BP_SpawnBotSpecific");
		
		ARBAISpawner_BP_SpawnBotSpecific_Params params {};
		params.specificPawnClass = specificPawnClass;
		params.specificConfig = specificConfig;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAISpawner.BP_SpawnBotAsync
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBNPC*                                      spawnedPawn                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBAISpawner::BP_SpawnBotAsync(class ARBBot** bot, class ARBNPC** spawnedPawn, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAISpawner.BP_SpawnBotAsync");
		
		ARBAISpawner_BP_SpawnBotAsync_Params params {};
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bot != nullptr)
			*bot = params.bot;
		if (spawnedPawn != nullptr)
			*spawnedPawn = params.spawnedPawn;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAISpawner.BP_SpawnBot
	 * 		Flags  -> ()
	 */
	class ARBBot* ARBAISpawner::BP_SpawnBot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAISpawner.BP_SpawnBot");
		
		ARBAISpawner_BP_SpawnBot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBAISpawner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBAISpawner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAISpawner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIStalkerTargetAlertedState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIStalkerTargetAlertedState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIStalkerTargetAlertedState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBAIVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBAIVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAlarmDoorComponent.OnRep_Alerted
	 * 		Flags  -> ()
	 */
	void URBAlarmDoorComponent::OnRep_Alerted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAlarmDoorComponent.OnRep_Alerted");
		
		URBAlarmDoorComponent_OnRep_Alerted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAlarmDoorComponent.OnDoorOpened
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBDoor*                                     door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAlarmDoorComponent::OnDoorOpened(class ARBDoor* door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAlarmDoorComponent.OnDoorOpened");
		
		URBAlarmDoorComponent_OnDoorOpened_Params params {};
		params.door = door;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAlarmDoorComponent.BP_OnAlerted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsAlerted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAlarmDoorComponent::BP_OnAlerted(bool bIsAlerted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAlarmDoorComponent.BP_OnAlerted");
		
		URBAlarmDoorComponent_BP_OnAlerted_Params params {};
		params.bIsAlerted = bIsAlerted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAlarmDoorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAlarmDoorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAlarmDoorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAmbientActivityMarker.Event_OnReached
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBAmbientActivityMarker::Event_OnReached(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAmbientActivityMarker.Event_OnReached");
		
		ARBAmbientActivityMarker_Event_OnReached_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAmbientActivityMarker.Event_OnLeft
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBAmbientActivityMarker::Event_OnLeft(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAmbientActivityMarker.Event_OnLeft");
		
		ARBAmbientActivityMarker_Event_OnLeft_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBAmbientActivityMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBAmbientActivityMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAmbientActivityMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAmbientSound.StopAmbientSound
	 * 		Flags  -> ()
	 */
	void ARBAmbientSound::StopAmbientSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAmbientSound.StopAmbientSound");
		
		ARBAmbientSound_StopAmbientSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAmbientSound.StartAmbientSound
	 * 		Flags  -> ()
	 */
	void ARBAmbientSound::StartAmbientSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAmbientSound.StartAmbientSound");
		
		ARBAmbientSound_StartAmbientSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBAmbientSound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBAmbientSound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAmbientSound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBAmbientSoundMovable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBAmbientSoundMovable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAmbientSoundMovable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAmbientConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAmbientConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAmbientConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAmbientStationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAmbientStationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAmbientStationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimAnchorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimAnchorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimAnchorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBAnimatedProp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBAnimatedProp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimatedProp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomSpecialMoveInteractableActor.Multicast_OnPlayerInteractionCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCustomSpecialMoveInteractableActor::Multicast_OnPlayerInteractionCompleted(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomSpecialMoveInteractableActor.Multicast_OnPlayerInteractionCompleted");
		
		ARBCustomSpecialMoveInteractableActor_Multicast_OnPlayerInteractionCompleted_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomSpecialMoveInteractableActor.Multicast_OnPlayerInteracted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCustomSpecialMoveInteractableActor::Multicast_OnPlayerInteracted(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomSpecialMoveInteractableActor.Multicast_OnPlayerInteracted");
		
		ARBCustomSpecialMoveInteractableActor_Multicast_OnPlayerInteracted_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomSpecialMoveInteractableActor.Event_OnLocalPlayerInteractionCompleted
	 * 		Flags  -> ()
	 */
	void ARBCustomSpecialMoveInteractableActor::Event_OnLocalPlayerInteractionCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomSpecialMoveInteractableActor.Event_OnLocalPlayerInteractionCompleted");
		
		ARBCustomSpecialMoveInteractableActor_Event_OnLocalPlayerInteractionCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomSpecialMoveInteractableActor.Event_OnLocalPlayerInteracted
	 * 		Flags  -> ()
	 */
	void ARBCustomSpecialMoveInteractableActor::Event_OnLocalPlayerInteracted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomSpecialMoveInteractableActor.Event_OnLocalPlayerInteracted");
		
		ARBCustomSpecialMoveInteractableActor_Event_OnLocalPlayerInteracted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomSpecialMoveInteractableActor.CompleteInteractionForPlayer_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCustomSpecialMoveInteractableActor::CompleteInteractionForPlayer_Server(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomSpecialMoveInteractableActor.CompleteInteractionForPlayer_Server");
		
		ARBCustomSpecialMoveInteractableActor_CompleteInteractionForPlayer_Server_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomSpecialMoveInteractableActor.CompleteInteractionForPlayer_Client
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCustomSpecialMoveInteractableActor::CompleteInteractionForPlayer_Client(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomSpecialMoveInteractableActor.CompleteInteractionForPlayer_Client");
		
		ARBCustomSpecialMoveInteractableActor_CompleteInteractionForPlayer_Client_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomSpecialMoveInteractableActor.CompleteInteraction_Server
	 * 		Flags  -> ()
	 */
	void ARBCustomSpecialMoveInteractableActor::CompleteInteraction_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomSpecialMoveInteractableActor.CompleteInteraction_Server");
		
		ARBCustomSpecialMoveInteractableActor_CompleteInteraction_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomSpecialMoveInteractableActor.CompleteInteraction_Client
	 * 		Flags  -> ()
	 */
	void ARBCustomSpecialMoveInteractableActor::CompleteInteraction_Client()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomSpecialMoveInteractableActor.CompleteInteraction_Client");
		
		ARBCustomSpecialMoveInteractableActor_CompleteInteraction_Client_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBCustomSpecialMoveInteractableActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBCustomSpecialMoveInteractableActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCustomSpecialMoveInteractableActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBQuestGiver.PlayAkEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVOContext                                         VOContext                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVOPriority                                        VOPriority                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBQuestGiver::PlayAkEvent(class UAkAudioEvent* akEvent, EVOContext VOContext, EVOPriority VOPriority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBQuestGiver.PlayAkEvent");
		
		ARBQuestGiver_PlayAkEvent_Params params {};
		params.akEvent = akEvent;
		params.VOContext = VOContext;
		params.VOPriority = VOPriority;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBQuestGiver.GetMetaNPCType
	 * 		Flags  -> ()
	 */
	EMetaNPCType ARBQuestGiver::GetMetaNPCType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBQuestGiver.GetMetaNPCType");
		
		ARBQuestGiver_GetMetaNPCType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBQuestGiver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBQuestGiver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBQuestGiver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimatedQuestGiver.TryPlayFacialAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      lineId                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBAnimatedQuestGiver::TryPlayFacialAnim(const class FString& lineId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimatedQuestGiver.TryPlayFacialAnim");
		
		ARBAnimatedQuestGiver_TryPlayFacialAnim_Params params {};
		params.lineId = lineId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimatedQuestGiver.StopFacialAnim
	 * 		Flags  -> ()
	 */
	void ARBAnimatedQuestGiver::StopFacialAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimatedQuestGiver.StopFacialAnim");
		
		ARBAnimatedQuestGiver_StopFacialAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimatedQuestGiver.GetFaceFXSkeletalMeshComponent
	 * 		Flags  -> ()
	 */
	class USkeletalMeshComponent* ARBAnimatedQuestGiver::GetFaceFXSkeletalMeshComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimatedQuestGiver.GetFaceFXSkeletalMeshComponent");
		
		ARBAnimatedQuestGiver_GetFaceFXSkeletalMeshComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBAnimatedQuestGiver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBAnimatedQuestGiver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimatedQuestGiver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstance.SetIsPlayingSpecialMoveAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               in_IsPlayingSpecialMoveAnimation                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAnimInstance::SetIsPlayingSpecialMoveAnimation(bool in_IsPlayingSpecialMoveAnimation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstance.SetIsPlayingSpecialMoveAnimation");
		
		URBAnimInstance_SetIsPlayingSpecialMoveAnimation_Params params {};
		params.in_IsPlayingSpecialMoveAnimation = in_IsPlayingSpecialMoveAnimation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstance.SetHoldingItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Force                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAnimInstance::SetHoldingItem(bool Value, bool Force)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstance.SetHoldingItem");
		
		URBAnimInstance_SetHoldingItem_Params params {};
		params.Value = Value;
		params.Force = Force;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstance.OnTraversalSlideDone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHitWall                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAnimInstance::OnTraversalSlideDone(bool bHitWall)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstance.OnTraversalSlideDone");
		
		URBAnimInstance_OnTraversalSlideDone_Params params {};
		params.bHitWall = bHitWall;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstance.GetIsPlayingSpecialMoveAnimation
	 * 		Flags  -> ()
	 */
	bool URBAnimInstance::GetIsPlayingSpecialMoveAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstance.GetIsPlayingSpecialMoveAnimation");
		
		URBAnimInstance_GetIsPlayingSpecialMoveAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstance.GetIsLeftFootDown
	 * 		Flags  -> ()
	 */
	bool URBAnimInstance::GetIsLeftFootDown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstance.GetIsLeftFootDown");
		
		URBAnimInstance_GetIsLeftFootDown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimInstanceBackgroundCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimInstanceBackgroundCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimInstanceBackgroundCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstanceNPC.IsPlayingSpecialAnimState
	 * 		Flags  -> ()
	 */
	bool URBAnimInstanceNPC::IsPlayingSpecialAnimState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstanceNPC.IsPlayingSpecialAnimState");
		
		URBAnimInstanceNPC_IsPlayingSpecialAnimState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstanceNPC.Event_OnInDarknessChanged
	 * 		Flags  -> ()
	 */
	void URBAnimInstanceNPC::Event_OnInDarknessChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstanceNPC.Event_OnInDarknessChanged");
		
		URBAnimInstanceNPC_Event_OnInDarknessChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimInstanceNPC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimInstanceNPC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimInstanceNPC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimInstanceNPCBig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimInstanceNPCBig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimInstanceNPCBig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstancePlayer.UpdateItemAnimData
	 * 		Flags  -> ()
	 */
	void URBAnimInstancePlayer::UpdateItemAnimData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstancePlayer.UpdateItemAnimData");
		
		URBAnimInstancePlayer_UpdateItemAnimData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstancePlayer.SwapInventoryItemAnimationsToNextItem
	 * 		Flags  -> ()
	 */
	void URBAnimInstancePlayer::SwapInventoryItemAnimationsToNextItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstancePlayer.SwapInventoryItemAnimationsToNextItem");
		
		URBAnimInstancePlayer_SwapInventoryItemAnimationsToNextItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstancePlayer.SetNextInventoryMontageTime
	 * 		Flags  -> ()
	 */
	void URBAnimInstancePlayer::SetNextInventoryMontageTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstancePlayer.SetNextInventoryMontageTime");
		
		URBAnimInstancePlayer_SetNextInventoryMontageTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstancePlayer.OnWantsNightVisionChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOn                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAnimInstancePlayer::OnWantsNightVisionChanged(bool bOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstancePlayer.OnWantsNightVisionChanged");
		
		URBAnimInstancePlayer_OnWantsNightVisionChanged_Params params {};
		params.bOn = bOn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstancePlayer.HideSwappedItems
	 * 		Flags  -> ()
	 */
	void URBAnimInstancePlayer::HideSwappedItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstancePlayer.HideSwappedItems");
		
		URBAnimInstancePlayer_HideSwappedItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstancePlayer.GetItemHeld
	 * 		Flags  -> ()
	 */
	class ARBPickup* URBAnimInstancePlayer::GetItemHeld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstancePlayer.GetItemHeld");
		
		URBAnimInstancePlayer_GetItemHeld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstancePlayer.ForceNoNetCombiningThisFrame
	 * 		Flags  -> ()
	 */
	void URBAnimInstancePlayer::ForceNoNetCombiningThisFrame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstancePlayer.ForceNoNetCombiningThisFrame");
		
		URBAnimInstancePlayer_ForceNoNetCombiningThisFrame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstancePlayer.ClearNightVisionAnimation
	 * 		Flags  -> ()
	 */
	void URBAnimInstancePlayer::ClearNightVisionAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstancePlayer.ClearNightVisionAnimation");
		
		URBAnimInstancePlayer_ClearNightVisionAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnimInstancePlayer.ClearItemAnimData
	 * 		Flags  -> ()
	 */
	void URBAnimInstancePlayer::ClearItemAnimData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnimInstancePlayer.ClearItemAnimData");
		
		URBAnimInstancePlayer_ClearItemAnimData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimInstancePlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimInstancePlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimInstancePlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimInstancePlayer3P.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimInstancePlayer3P::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimInstancePlayer3P");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_Traversal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_Traversal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_Traversal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_SpecialMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_SpecialMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_SpecialMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_Footstep.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_Footstep::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_Footstep");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_FootDown.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_FootDown::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_FootDown");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_AttackDamage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_AttackDamage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_AttackDamage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotifyState_ContinuousAttackDamage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotifyState_ContinuousAttackDamage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotifyState_ContinuousAttackDamage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_PlayWeaponAnim.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_PlayWeaponAnim::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_PlayWeaponAnim");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_DamageWindow.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_DamageWindow::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_DamageWindow");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_GrabWindow.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_GrabWindow::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_GrabWindow");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_SpecialAttackWindow.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_SpecialAttackWindow::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_SpecialAttackWindow");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_ThirdPersonView.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_ThirdPersonView::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_ThirdPersonView");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_ThirdPersonViewWindow.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_ThirdPersonViewWindow::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_ThirdPersonViewWindow");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_AttachInteractionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_AttachInteractionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_AttachInteractionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_DrugTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_DrugTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_DrugTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_FoleySound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_FoleySound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_FoleySound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_AkEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_AkEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_AkEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_InteractionSoundEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_InteractionSoundEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_InteractionSoundEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_VO.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_VO::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_VO");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotifyState_AttachNewObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotifyState_AttachNewObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotifyState_AttachNewObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_AttachObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_AttachObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_AttachObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_DetachPairedPawnCollision.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_DetachPairedPawnCollision::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_DetachPairedPawnCollision");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_PlayLargeObjectSequence.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_PlayLargeObjectSequence::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_PlayLargeObjectSequence");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_SwapItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_SwapItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_SwapItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotifyState_HideItemInHand.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotifyState_HideItemInHand::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotifyState_HideItemInHand");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotifyState_PlayerDepthRenderOverride.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotifyState_PlayerDepthRenderOverride::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotifyState_PlayerDepthRenderOverride");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_BlendOutControlState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_BlendOutControlState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_BlendOutControlState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_NPCBlendOut.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_NPCBlendOut::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_NPCBlendOut");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_NPCCompleteSpecialMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_NPCCompleteSpecialMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_NPCCompleteSpecialMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotifyState_ProceduralAdjustment.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotifyState_ProceduralAdjustment::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotifyState_ProceduralAdjustment");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotifyState_EyeClosedEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotifyState_EyeClosedEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotifyState_EyeClosedEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotifyState_WeaponVFXControl.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotifyState_WeaponVFXControl::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotifyState_WeaponVFXControl");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_DoorAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_DoorAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_DoorAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_DamagePlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_DamagePlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_DamagePlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_DisablePlayerMovement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_DisablePlayerMovement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_DisablePlayerMovement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_AttackDistanceMeasureFrame.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_AttackDistanceMeasureFrame::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_AttackDistanceMeasureFrame");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_ImportantRootMotionDone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_ImportantRootMotionDone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_ImportantRootMotionDone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_MinimumStopDistance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_MinimumStopDistance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_MinimumStopDistance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_AdjustmentLimit.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_AdjustmentLimit::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_AdjustmentLimit");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_StartleFailsafe.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_StartleFailsafe::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_StartleFailsafe");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_StartleInterruptible.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_StartleInterruptible::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_StartleInterruptible");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_BranchPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_BranchPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_BranchPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_PlayItemSequence.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_PlayItemSequence::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_PlayItemSequence");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_PlayRigSequence.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_PlayRigSequence::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_PlayRigSequence");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_HideWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_HideWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_HideWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_UnhideWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_UnhideWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_UnhideWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_ActivateWeaponEffects.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_ActivateWeaponEffects::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_ActivateWeaponEffects");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_DeactivateWeaponEffects.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_DeactivateWeaponEffects::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_DeactivateWeaponEffects");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_GhostEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_GhostEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_GhostEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_PlayerCamera.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_PlayerCamera::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_PlayerCamera");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_LoopingAkEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_LoopingAkEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_LoopingAkEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_StingerAkEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_StingerAkEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_StingerAkEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_NightVision.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_NightVision::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_NightVision");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_Stamina.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_Stamina::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_Stamina");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_ScrubbingAkEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_ScrubbingAkEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_ScrubbingAkEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_PlayUnderwaterEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_PlayUnderwaterEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_PlayUnderwaterEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_InterruptibleState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_InterruptibleState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_InterruptibleState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_HitReactionState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_HitReactionState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_HitReactionState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_Death.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_Death::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_Death");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimNotify_GrabbedZOffset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimNotify_GrabbedZOffset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimNotify_GrabbedZOffset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemAnimRef.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemAnimRef::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.ItemAnimRef");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAnimReferences.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAnimReferences::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnimReferences");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAnnouncer.Multicast_PlayVO
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVOBehavior                                        Behavior                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              prePlayQueueDelay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBAnnouncer::Multicast_PlayVO(class UAkAudioEvent* akEvent, EVOBehavior Behavior, float prePlayQueueDelay, uint32_t RandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAnnouncer.Multicast_PlayVO");
		
		ARBAnnouncer_Multicast_PlayVO_Params params {};
		params.akEvent = akEvent;
		params.Behavior = Behavior;
		params.prePlayQueueDelay = prePlayQueueDelay;
		params.RandomSeed = RandomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBAnnouncer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBAnnouncer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAnnouncer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractionZoneComponent.OnRep_CurrentlyEnabled
	 * 		Flags  -> ()
	 */
	void URBInteractionZoneComponent::OnRep_CurrentlyEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractionZoneComponent.OnRep_CurrentlyEnabled");
		
		URBInteractionZoneComponent_OnRep_CurrentlyEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractionZoneComponent.NotifySpecialMoveCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       completedMove                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInteractionZoneComponent::NotifySpecialMoveCompleted(class ARBPawn* Pawn, ESpecialMove completedMove, bool bInterrupted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractionZoneComponent.NotifySpecialMoveCompleted");
		
		URBInteractionZoneComponent_NotifySpecialMoveCompleted_Params params {};
		params.Pawn = Pawn;
		params.completedMove = completedMove;
		params.bInterrupted = bInterrupted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractionZoneComponent.MeetRequirements
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   interactor                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBInteractionZoneComponent::MeetRequirements(class ARBPlayer* interactor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractionZoneComponent.MeetRequirements");
		
		URBInteractionZoneComponent_MeetRequirements_Params params {};
		params.interactor = interactor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractionZoneComponent.IsEnabled
	 * 		Flags  -> ()
	 */
	bool URBInteractionZoneComponent::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractionZoneComponent.IsEnabled");
		
		URBInteractionZoneComponent_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractionZoneComponent.GetInteractableSafe
	 * 		Flags  -> ()
	 */
	class UObject* URBInteractionZoneComponent::GetInteractableSafe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractionZoneComponent.GetInteractableSafe");
		
		URBInteractionZoneComponent_GetInteractableSafe_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractionZoneComponent.Event_OnEnabledChanged
	 * 		Flags  -> ()
	 */
	void URBInteractionZoneComponent::Event_OnEnabledChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractionZoneComponent.Event_OnEnabledChanged");
		
		URBInteractionZoneComponent_Event_OnEnabledChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractionZoneComponent.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInteractible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInteractionZoneComponent::BP_SetEnabled(bool bInteractible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractionZoneComponent.BP_SetEnabled");
		
		URBInteractionZoneComponent_BP_SetEnabled_Params params {};
		params.bInteractible = bInteractible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractionZoneComponent.AddCompletedObjectiveRequirement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBaseObjectiveCoordinator*                 coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        requirementText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBInteractionZoneComponent::AddCompletedObjectiveRequirement(class ARBBaseObjectiveCoordinator* coordinator, const class FText& requirementText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractionZoneComponent.AddCompletedObjectiveRequirement");
		
		URBInteractionZoneComponent_AddCompletedObjectiveRequirement_Params params {};
		params.coordinator = coordinator;
		params.requirementText = requirementText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBInteractionZoneComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBInteractionZoneComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInteractionZoneComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBInteractibleComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBInteractibleComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInteractibleComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.TryNotifyInteractorReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInteractiblePanelComponent::TryNotifyInteractorReady(class ARBPlayer* interactor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.TryNotifyInteractorReady");
		
		URBInteractiblePanelComponent_TryNotifyInteractorReady_Params params {};
		params.interactor = interactor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.ShouldBPTick
	 * 		Flags  -> ()
	 */
	bool URBInteractiblePanelComponent::ShouldBPTick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.ShouldBPTick");
		
		URBInteractiblePanelComponent_ShouldBPTick_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.SetPanelInUse_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInPanelInUse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInteractiblePanelComponent::SetPanelInUse_Server(bool bInPanelInUse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.SetPanelInUse_Server");
		
		URBInteractiblePanelComponent_SetPanelInUse_Server_Params params {};
		params.bInPanelInUse = bInPanelInUse;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.OnRep_PawnInteracting
	 * 		Flags  -> ()
	 */
	void URBInteractiblePanelComponent::OnRep_PawnInteracting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.OnRep_PawnInteracting");
		
		URBInteractiblePanelComponent_OnRep_PawnInteracting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.OnRep_PanelStarted
	 * 		Flags  -> ()
	 */
	void URBInteractiblePanelComponent::OnRep_PanelStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.OnRep_PanelStarted");
		
		URBInteractiblePanelComponent_OnRep_PanelStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.OnRep_PanelActive
	 * 		Flags  -> ()
	 */
	void URBInteractiblePanelComponent::OnRep_PanelActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.OnRep_PanelActive");
		
		URBInteractiblePanelComponent_OnRep_PanelActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.OnPawnInteractingChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInteractiblePanelComponent::OnPawnInteractingChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.OnPawnInteractingChangedCallback");
		
		URBInteractiblePanelComponent_OnPawnInteractingChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.NotifyInteractorReady_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInteractiblePanelComponent::NotifyInteractorReady_Server(class ARBPlayer* interactor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.NotifyInteractorReady_Server");
		
		URBInteractiblePanelComponent_NotifyInteractorReady_Server_Params params {};
		params.interactor = interactor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.IsPanelActive
	 * 		Flags  -> ()
	 */
	bool URBInteractiblePanelComponent::IsPanelActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.IsPanelActive");
		
		URBInteractiblePanelComponent_IsPanelActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.GetPlayerInteracting
	 * 		Flags  -> ()
	 */
	class ARBPlayer* URBInteractiblePanelComponent::GetPlayerInteracting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.GetPlayerInteracting");
		
		URBInteractiblePanelComponent_GetPlayerInteracting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.GetPawnInteracting
	 * 		Flags  -> ()
	 */
	class ARBPawn* URBInteractiblePanelComponent::GetPawnInteracting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.GetPawnInteracting");
		
		URBInteractiblePanelComponent_GetPawnInteracting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.GetInteractionProgressRatio
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBInteractiblePanelComponent::GetInteractionProgressRatio(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.GetInteractionProgressRatio");
		
		URBInteractiblePanelComponent_GetInteractionProgressRatio_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.BP_PanelGameplayDone
	 * 		Flags  -> ()
	 */
	void URBInteractiblePanelComponent::BP_PanelGameplayDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.BP_PanelGameplayDone");
		
		URBInteractiblePanelComponent_BP_PanelGameplayDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractiblePanelComponent.BP_OnPawnInteractingChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     newPawnInteracting                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInteractiblePanelComponent::BP_OnPawnInteractingChanged(class ARBPawn* newPawnInteracting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractiblePanelComponent.BP_OnPawnInteractingChanged");
		
		URBInteractiblePanelComponent_BP_OnPawnInteractingChanged_Params params {};
		params.newPawnInteracting = newPawnInteracting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBInteractiblePanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBInteractiblePanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInteractiblePanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.UpdatePlayerCameraLimits
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBArmWreslingTable*                         Table                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBArmWreslingPanelComponent::UpdatePlayerCameraLimits(class ARBArmWreslingTable* Table)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.UpdatePlayerCameraLimits");
		
		URBArmWreslingPanelComponent_UpdatePlayerCameraLimits_Params params {};
		params.Table = Table;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.UpdateEndZone
	 * 		Flags  -> ()
	 */
	void URBArmWreslingPanelComponent::UpdateEndZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.UpdateEndZone");
		
		URBArmWreslingPanelComponent_UpdateEndZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.OnRep_SuccessZoneOffset
	 * 		Flags  -> ()
	 */
	void URBArmWreslingPanelComponent::OnRep_SuccessZoneOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.OnRep_SuccessZoneOffset");
		
		URBArmWreslingPanelComponent_OnRep_SuccessZoneOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.OnRep_HitZoneIndex
	 * 		Flags  -> ()
	 */
	void URBArmWreslingPanelComponent::OnRep_HitZoneIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.OnRep_HitZoneIndex");
		
		URBArmWreslingPanelComponent_OnRep_HitZoneIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.OnLinkedTableChange
	 * 		Flags  -> ()
	 */
	void URBArmWreslingPanelComponent::OnLinkedTableChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.OnLinkedTableChange");
		
		URBArmWreslingPanelComponent_OnLinkedTableChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.Multicast_TauntEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBArmWreslingPanelComponent::Multicast_TauntEvent(class ARBPlayer* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.Multicast_TauntEvent");
		
		URBArmWreslingPanelComponent_Multicast_TauntEvent_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.IsPredictedPlayer
	 * 		Flags  -> ()
	 */
	bool URBArmWreslingPanelComponent::IsPredictedPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.IsPredictedPlayer");
		
		URBArmWreslingPanelComponent_IsPredictedPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.IsPlayer1
	 * 		Flags  -> ()
	 */
	bool URBArmWreslingPanelComponent::IsPlayer1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.IsPlayer1");
		
		URBArmWreslingPanelComponent_IsPlayer1_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.IsArmWreslingTableCompleted
	 * 		Flags  -> ()
	 */
	bool URBArmWreslingPanelComponent::IsArmWreslingTableCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.IsArmWreslingTableCompleted");
		
		URBArmWreslingPanelComponent_IsArmWreslingTableCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.IsArmWreslingRoundInProgress
	 * 		Flags  -> ()
	 */
	bool URBArmWreslingPanelComponent::IsArmWreslingRoundInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.IsArmWreslingRoundInProgress");
		
		URBArmWreslingPanelComponent_IsArmWreslingRoundInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.GetIsInputInProgress
	 * 		Flags  -> ()
	 */
	bool URBArmWreslingPanelComponent::GetIsInputInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.GetIsInputInProgress");
		
		URBArmWreslingPanelComponent_GetIsInputInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.GetInputStartPosition
	 * 		Flags  -> ()
	 */
	float URBArmWreslingPanelComponent::GetInputStartPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.GetInputStartPosition");
		
		URBArmWreslingPanelComponent_GetInputStartPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.GetElapsedMatchTime
	 * 		Flags  -> ()
	 */
	float URBArmWreslingPanelComponent::GetElapsedMatchTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.GetElapsedMatchTime");
		
		URBArmWreslingPanelComponent_GetElapsedMatchTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.GetCursorPosition
	 * 		Flags  -> ()
	 */
	float URBArmWreslingPanelComponent::GetCursorPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.GetCursorPosition");
		
		URBArmWreslingPanelComponent_GetCursorPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingPanelComponent.Debug_ForcePlayerExit
	 * 		Flags  -> ()
	 */
	void URBArmWreslingPanelComponent::Debug_ForcePlayerExit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingPanelComponent.Debug_ForcePlayerExit");
		
		URBArmWreslingPanelComponent_Debug_ForcePlayerExit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBArmWreslingPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBArmWreslingPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBArmWreslingPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingSpectatorPanelComponent.Multicast_PlayerTaunt
	 * 		Flags  -> ()
	 */
	void URBArmWreslingSpectatorPanelComponent::Multicast_PlayerTaunt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingSpectatorPanelComponent.Multicast_PlayerTaunt");
		
		URBArmWreslingSpectatorPanelComponent_Multicast_PlayerTaunt_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBArmWreslingSpectatorPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBArmWreslingSpectatorPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBArmWreslingSpectatorPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.OnRep_Stats
	 * 		Flags  -> ()
	 */
	void ARBArmWreslingTable::OnRep_Stats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.OnRep_Stats");
		
		ARBArmWreslingTable_OnRep_Stats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.Multicast_PlayerInputEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FArmWreslingPlayerRoundData                 PlayerData                                                 (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBArmWreslingTable::Multicast_PlayerInputEvent(const struct FArmWreslingPlayerRoundData& PlayerData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.Multicast_PlayerInputEvent");
		
		ARBArmWreslingTable_Multicast_PlayerInputEvent_Params params {};
		params.PlayerData = PlayerData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.Multicast_OnRoundEnded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FArmWreslingPlayerRoundData                 player1Data                                                (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FArmWreslingPlayerRoundData                 player2Data                                                (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBArmWreslingTable::Multicast_OnRoundEnded(const struct FArmWreslingPlayerRoundData& player1Data, const struct FArmWreslingPlayerRoundData& player2Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.Multicast_OnRoundEnded");
		
		ARBArmWreslingTable_Multicast_OnRoundEnded_Params params {};
		params.player1Data = player1Data;
		params.player2Data = player2Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.Multicast_OnResetMatch
	 * 		Flags  -> ()
	 */
	void ARBArmWreslingTable::Multicast_OnResetMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.Multicast_OnResetMatch");
		
		ARBArmWreslingTable_Multicast_OnResetMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.Multicast_BroadcastMatchStartMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   player1Ptr                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   player2Ptr                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBArmWreslingTable::Multicast_BroadcastMatchStartMessage(class ARBPlayer* player1Ptr, class ARBPlayer* player2Ptr)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.Multicast_BroadcastMatchStartMessage");
		
		ARBArmWreslingTable_Multicast_BroadcastMatchStartMessage_Params params {};
		params.player1Ptr = player1Ptr;
		params.player2Ptr = player2Ptr;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.Multicast_BroadcastMatchEndMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   winnerPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   loserPlayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               gameTied_value                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBArmWreslingTable::Multicast_BroadcastMatchEndMessage(class ARBPlayer* winnerPlayer, class ARBPlayer* loserPlayer, bool gameTied_value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.Multicast_BroadcastMatchEndMessage");
		
		ARBArmWreslingTable_Multicast_BroadcastMatchEndMessage_Params params {};
		params.winnerPlayer = winnerPlayer;
		params.loserPlayer = loserPlayer;
		params.gameTied_value = gameTied_value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.IsMatchStartedOrCompleted
	 * 		Flags  -> ()
	 */
	bool ARBArmWreslingTable::IsMatchStartedOrCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.IsMatchStartedOrCompleted");
		
		ARBArmWreslingTable_IsMatchStartedOrCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.IsMatchInProgress
	 * 		Flags  -> ()
	 */
	bool ARBArmWreslingTable::IsMatchInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.IsMatchInProgress");
		
		ARBArmWreslingTable_IsMatchInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.GetTableState
	 * 		Flags  -> ()
	 */
	EArmWreslingTableState ARBArmWreslingTable::GetTableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.GetTableState");
		
		ARBArmWreslingTable_GetTableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.GetRating
	 * 		Flags  -> ()
	 */
	int32_t ARBArmWreslingTable::GetRating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.GetRating");
		
		ARBArmWreslingTable_GetRating_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.GetOpposingWatchedPanel
	 * 		Flags  -> ()
	 */
	class URBArmWreslingPanelComponent* ARBArmWreslingTable::GetOpposingWatchedPanel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.GetOpposingWatchedPanel");
		
		ARBArmWreslingTable_GetOpposingWatchedPanel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.GetOpponentRating
	 * 		Flags  -> ()
	 */
	int32_t ARBArmWreslingTable::GetOpponentRating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.GetOpponentRating");
		
		ARBArmWreslingTable_GetOpponentRating_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.GetOpponentMatchesWon
	 * 		Flags  -> ()
	 */
	int32_t ARBArmWreslingTable::GetOpponentMatchesWon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.GetOpponentMatchesWon");
		
		ARBArmWreslingTable_GetOpponentMatchesWon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.GetOpponentMatchesLost
	 * 		Flags  -> ()
	 */
	int32_t ARBArmWreslingTable::GetOpponentMatchesLost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.GetOpponentMatchesLost");
		
		ARBArmWreslingTable_GetOpponentMatchesLost_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.GetMatchesWon
	 * 		Flags  -> ()
	 */
	int32_t ARBArmWreslingTable::GetMatchesWon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.GetMatchesWon");
		
		ARBArmWreslingTable_GetMatchesWon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.GetMatchesLost
	 * 		Flags  -> ()
	 */
	int32_t ARBArmWreslingTable::GetMatchesLost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.GetMatchesLost");
		
		ARBArmWreslingTable_GetMatchesLost_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.GetLocallyWatchedPanel
	 * 		Flags  -> ()
	 */
	class URBArmWreslingPanelComponent* ARBArmWreslingTable::GetLocallyWatchedPanel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.GetLocallyWatchedPanel");
		
		ARBArmWreslingTable_GetLocallyWatchedPanel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.GetElapsedRoundTime
	 * 		Flags  -> ()
	 */
	float ARBArmWreslingTable::GetElapsedRoundTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.GetElapsedRoundTime");
		
		ARBArmWreslingTable_GetElapsedRoundTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.Event_OnWinningRatioPerPointChanged
	 * 		Flags  -> ()
	 */
	void ARBArmWreslingTable::Event_OnWinningRatioPerPointChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.Event_OnWinningRatioPerPointChanged");
		
		ARBArmWreslingTable_Event_OnWinningRatioPerPointChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.Event_OnTableStateChanged
	 * 		Flags  -> ()
	 */
	void ARBArmWreslingTable::Event_OnTableStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.Event_OnTableStateChanged");
		
		ARBArmWreslingTable_Event_OnTableStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.Event_OnRoundEnded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FArmWreslingPlayerRoundData                 player1Data                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FArmWreslingPlayerRoundData                 player2Data                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBArmWreslingTable::Event_OnRoundEnded(const struct FArmWreslingPlayerRoundData& player1Data, const struct FArmWreslingPlayerRoundData& player2Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.Event_OnRoundEnded");
		
		ARBArmWreslingTable_Event_OnRoundEnded_Params params {};
		params.player1Data = player1Data;
		params.player2Data = player2Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.Event_OnPlayerDisconnected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBArmWreslingPanelComponent*                panelComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBArmWreslingTable::Event_OnPlayerDisconnected(class URBArmWreslingPanelComponent* panelComponent, class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.Event_OnPlayerDisconnected");
		
		ARBArmWreslingTable_Event_OnPlayerDisconnected_Params params {};
		params.panelComponent = panelComponent;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBArmWreslingTable.Event_OnPlayerConnected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBArmWreslingPanelComponent*                panelComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBArmWreslingTable::Event_OnPlayerConnected(class URBArmWreslingPanelComponent* panelComponent, class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBArmWreslingTable.Event_OnPlayerConnected");
		
		ARBArmWreslingTable_Event_OnPlayerConnected_Params params {};
		params.panelComponent = panelComponent;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBArmWreslingTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBArmWreslingTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBArmWreslingTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAttackDummy.Event_OnHit
	 * 		Flags  -> ()
	 */
	void ARBAttackDummy::Event_OnHit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAttackDummy.Event_OnHit");
		
		ARBAttackDummy_Event_OnHit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAttackDummy.BP_SetLocationFromTimeline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     NewLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBAttackDummy::BP_SetLocationFromTimeline(const struct FVector& NewLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAttackDummy.BP_SetLocationFromTimeline");
		
		ARBAttackDummy_BP_SetLocationFromTimeline_Params params {};
		params.NewLocation = NewLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAttackDummy.BP_ResetAttackDummy
	 * 		Flags  -> ()
	 */
	void ARBAttackDummy::BP_ResetAttackDummy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAttackDummy.BP_ResetAttackDummy");
		
		ARBAttackDummy_BP_ResetAttackDummy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBAttackDummy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBAttackDummy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAttackDummy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAudioManager.ExitAllVolumes
	 * 		Flags  -> ()
	 */
	void URBAudioManager::ExitAllVolumes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAudioManager.ExitAllVolumes");
		
		URBAudioManager_ExitAllVolumes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAudioManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAudioManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAudioManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAudioSettingsWidget.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBAudioSettingsWidget::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAudioSettingsWidget.Event_Refresh");
		
		URBAudioSettingsWidget_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAudioSettingsWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAudioSettingsWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAudioSettingsWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBFunctionalTestAgent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBFunctionalTestAgent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFunctionalTestAgent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutoCompleteStageTestAgent.OnStageReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBAutoCompleteStageTestAgent::OnStageReady(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutoCompleteStageTestAgent.OnStageReady");
		
		URBAutoCompleteStageTestAgent_OnStageReady_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutoCompleteStageTestAgent.OnStageEnded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bisReset                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAutoCompleteStageTestAgent::OnStageEnded(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, bool bisReset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutoCompleteStageTestAgent.OnStageEnded");
		
		URBAutoCompleteStageTestAgent_OnStageEnded_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		params.bisReset = bisReset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutoCompleteStageTestAgent.OnMatchReady
	 * 		Flags  -> ()
	 */
	void URBAutoCompleteStageTestAgent::OnMatchReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutoCompleteStageTestAgent.OnMatchReady");
		
		URBAutoCompleteStageTestAgent_OnMatchReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutoCompleteStageTestAgent.OnGamePhaseUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGamePhase                                         gamePhase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAutoCompleteStageTestAgent::OnGamePhaseUpdated(EGamePhase gamePhase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutoCompleteStageTestAgent.OnGamePhaseUpdated");
		
		URBAutoCompleteStageTestAgent_OnGamePhaseUpdated_Params params {};
		params.gamePhase = gamePhase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutoCompleteStageTestAgent.OnFindHubCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bPending                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSucceeded                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAutoCompleteStageTestAgent::OnFindHubCompleted(bool bPending, bool bSucceeded)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutoCompleteStageTestAgent.OnFindHubCompleted");
		
		URBAutoCompleteStageTestAgent_OnFindHubCompleted_Params params {};
		params.bPending = bPending;
		params.bSucceeded = bSucceeded;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAutoCompleteStageTestAgent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAutoCompleteStageTestAgent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAutoCompleteStageTestAgent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.SnapToState_Implementation
	 * 		Flags  -> ()
	 */
	void ARBInteractible::SnapToState_Implementation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.SnapToState_Implementation");
		
		ARBInteractible_SnapToState_Implementation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.ShouldAlignToGround
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactorPawn                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBInteractible::ShouldAlignToGround(class ARBPawn* interactorPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.ShouldAlignToGround");
		
		ARBInteractible_ShouldAlignToGround_Params params {};
		params.interactorPawn = interactorPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.OnRep_IsInteractive
	 * 		Flags  -> ()
	 */
	void ARBInteractible::OnRep_IsInteractive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.OnRep_IsInteractive");
		
		ARBInteractible_OnRep_IsInteractive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.OnRep_DesiredInteractorPawnTime
	 * 		Flags  -> ()
	 */
	void ARBInteractible::OnRep_DesiredInteractorPawnTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.OnRep_DesiredInteractorPawnTime");
		
		ARBInteractible_OnRep_DesiredInteractorPawnTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.OnRep_DesiredInteractorPawns
	 * 		Flags  -> ()
	 */
	void ARBInteractible::OnRep_DesiredInteractorPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.OnRep_DesiredInteractorPawns");
		
		ARBInteractible_OnRep_DesiredInteractorPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.NotifySpecialMoveStartedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractible::NotifySpecialMoveStartedEvent(class ARBPawn* Pawn, ESpecialMove specialMove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.NotifySpecialMoveStartedEvent");
		
		ARBInteractible_NotifySpecialMoveStartedEvent_Params params {};
		params.Pawn = Pawn;
		params.specialMove = specialMove;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.NotifySpecialMoveCompletedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractible::NotifySpecialMoveCompletedEvent(class ARBPawn* Pawn, ESpecialMove specialMove, bool bInterrupted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.NotifySpecialMoveCompletedEvent");
		
		ARBInteractible_NotifySpecialMoveCompletedEvent_Params params {};
		params.Pawn = Pawn;
		params.specialMove = specialMove;
		params.bInterrupted = bInterrupted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.Multicast_OnStopInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractible::Multicast_OnStopInteract(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.Multicast_OnStopInteract");
		
		ARBInteractible_Multicast_OnStopInteract_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.Multicast_OnStartInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractible::Multicast_OnStartInteract(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.Multicast_OnStartInteract");
		
		ARBInteractible_Multicast_OnStartInteract_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.IsInteractiveChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractible::IsInteractiveChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.IsInteractiveChangedCallback");
		
		ARBInteractible_IsInteractiveChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.IncrementNumberOfInteract
	 * 		Flags  -> ()
	 */
	void ARBInteractible::IncrementNumberOfInteract()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.IncrementNumberOfInteract");
		
		ARBInteractible_IncrementNumberOfInteract_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.GetStartsInteractible
	 * 		Flags  -> ()
	 */
	bool ARBInteractible::GetStartsInteractible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.GetStartsInteractible");
		
		ARBInteractible_GetStartsInteractible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.GetNumberOfInteract
	 * 		Flags  -> ()
	 */
	int32_t ARBInteractible::GetNumberOfInteract()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.GetNumberOfInteract");
		
		ARBInteractible_GetNumberOfInteract_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.GetInteractionActionCollisionCheck
	 * 		Flags  -> ()
	 */
	bool ARBInteractible::GetInteractionActionCollisionCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.GetInteractionActionCollisionCheck");
		
		ARBInteractible_GetInteractionActionCollisionCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.GetAnimLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactorPawn                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector ARBInteractible::GetAnimLocation(class ARBPawn* interactorPawn, ESpecialMove specialMove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.GetAnimLocation");
		
		ARBInteractible_GetAnimLocation_Params params {};
		params.interactorPawn = interactorPawn;
		params.specialMove = specialMove;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.GetAnimForward
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactorPawn                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector ARBInteractible::GetAnimForward(class ARBPawn* interactorPawn, ESpecialMove specialMove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.GetAnimForward");
		
		ARBInteractible_GetAnimForward_Params params {};
		params.interactorPawn = interactorPawn;
		params.specialMove = specialMove;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.Event_SnapToState
	 * 		Flags  -> ()
	 */
	void ARBInteractible::Event_SnapToState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.Event_SnapToState");
		
		ARBInteractible_Event_SnapToState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.Event_OnInteractorsChangedEvent
	 * 		Flags  -> ()
	 */
	void ARBInteractible::Event_OnInteractorsChangedEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.Event_OnInteractorsChangedEvent");
		
		ARBInteractible_Event_OnInteractorsChangedEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.Event_OnInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractible::Event_OnInteract(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.Event_OnInteract");
		
		ARBInteractible_Event_OnInteract_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.Event_DoAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractible::Event_DoAction(class ARBPawn* interactor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.Event_DoAction");
		
		ARBInteractible_Event_DoAction_Params params {};
		params.interactor = interactor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.BP_StopAllCurrentInteractions
	 * 		Flags  -> ()
	 */
	void ARBInteractible::BP_StopAllCurrentInteractions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.BP_StopAllCurrentInteractions");
		
		ARBInteractible_BP_StopAllCurrentInteractions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.BP_SetShowInDebug
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowInDebugValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractible::BP_SetShowInDebug(bool bShowInDebugValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.BP_SetShowInDebug");
		
		ARBInteractible_BP_SetShowInDebug_Params params {};
		params.bShowInDebugValue = bShowInDebugValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.BP_SetIsInteractible
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInteractibleValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractible::BP_SetIsInteractible(bool bInteractibleValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.BP_SetIsInteractible");
		
		ARBInteractible_BP_SetIsInteractible_Params params {};
		params.bInteractibleValue = bInteractibleValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.BP_OnIsInteractibleChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInteractibleValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractible::BP_OnIsInteractibleChanged(bool bInteractibleValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.BP_OnIsInteractibleChanged");
		
		ARBInteractible_BP_OnIsInteractibleChanged_Params params {};
		params.bInteractibleValue = bInteractibleValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.BP_IsInteractible
	 * 		Flags  -> ()
	 */
	bool ARBInteractible::BP_IsInteractible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.BP_IsInteractible");
		
		ARBInteractible_BP_IsInteractible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.BP_GetInteractorPawns
	 * 		Flags  -> ()
	 */
	TArray<class ARBPawn*> ARBInteractible::BP_GetInteractorPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.BP_GetInteractorPawns");
		
		ARBInteractible_BP_GetInteractorPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.BP_GetInteractionMeshRelativeTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      interactibleClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform ARBInteractible::BP_GetInteractionMeshRelativeTransform(class UClass* interactibleClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.BP_GetInteractionMeshRelativeTransform");
		
		ARBInteractible_BP_GetInteractionMeshRelativeTransform_Params params {};
		params.interactibleClass = interactibleClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractible.ApplyDesiredInteractorPawns
	 * 		Flags  -> ()
	 */
	void ARBInteractible::ApplyDesiredInteractorPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractible.ApplyDesiredInteractorPawns");
		
		ARBInteractible_ApplyDesiredInteractorPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBInteractible.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBInteractible::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInteractible");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.OnRep_IsDenyInteraction
	 * 		Flags  -> ()
	 */
	void ARBOperatable::OnRep_IsDenyInteraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.OnRep_IsDenyInteraction");
		
		ARBOperatable_OnRep_IsDenyInteraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.OnRep_ForceDesiredOperateTime
	 * 		Flags  -> ()
	 */
	void ARBOperatable::OnRep_ForceDesiredOperateTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.OnRep_ForceDesiredOperateTime");
		
		ARBOperatable_OnRep_ForceDesiredOperateTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.OnRep_CurrentOperateTime_Callback
	 * 		Flags  -> ()
	 */
	void ARBOperatable::OnRep_CurrentOperateTime_Callback()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.OnRep_CurrentOperateTime_Callback");
		
		ARBOperatable_OnRep_CurrentOperateTime_Callback_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.OnRep_CurrentOperateTime
	 * 		Flags  -> ()
	 */
	void ARBOperatable::OnRep_CurrentOperateTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.OnRep_CurrentOperateTime");
		
		ARBOperatable_OnRep_CurrentOperateTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.OnRep_Completed_Callback
	 * 		Flags  -> ()
	 */
	void ARBOperatable::OnRep_Completed_Callback()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.OnRep_Completed_Callback");
		
		ARBOperatable_OnRep_Completed_Callback_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.OnRep_Completed
	 * 		Flags  -> ()
	 */
	void ARBOperatable::OnRep_Completed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.OnRep_Completed");
		
		ARBOperatable_OnRep_Completed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.OnRep_bStateOn_Callback
	 * 		Flags  -> ()
	 */
	void ARBOperatable::OnRep_bStateOn_Callback()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.OnRep_bStateOn_Callback");
		
		ARBOperatable_OnRep_bStateOn_Callback_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.OnRep_bStateOn
	 * 		Flags  -> ()
	 */
	void ARBOperatable::OnRep_bStateOn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.OnRep_bStateOn");
		
		ARBOperatable_OnRep_bStateOn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Multicast_ResetCompletedState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              oldProgression                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::Multicast_ResetCompletedState(float oldProgression)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Multicast_ResetCompletedState");
		
		ARBOperatable_Multicast_ResetCompletedState_Params params {};
		params.oldProgression = oldProgression;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Multicast_OnTimedReset
	 * 		Flags  -> ()
	 */
	void ARBOperatable::Multicast_OnTimedReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Multicast_OnTimedReset");
		
		ARBOperatable_Multicast_OnTimedReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Multicast_OnStopInteractOperatable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Server_CurrentOperateOnStop                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::Multicast_OnStopInteractOperatable(class ARBPawn* Pawn, float Server_CurrentOperateOnStop)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Multicast_OnStopInteractOperatable");
		
		ARBOperatable_Multicast_OnStopInteractOperatable_Params params {};
		params.Pawn = Pawn;
		params.Server_CurrentOperateOnStop = Server_CurrentOperateOnStop;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Multicast_OnCompletedOperation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              oldProgression                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ARBPawn*>                             completedByPawnListValue                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::Multicast_OnCompletedOperation(float oldProgression, TArray<class ARBPawn*> completedByPawnListValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Multicast_OnCompletedOperation");
		
		ARBOperatable_Multicast_OnCompletedOperation_Params params {};
		params.oldProgression = oldProgression;
		params.completedByPawnListValue = completedByPawnListValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Multicast_ForceState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              oldProgression                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForcedState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::Multicast_ForceState(float oldProgression, bool bForcedState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Multicast_ForceState");
		
		ARBOperatable_Multicast_ForceState_Params params {};
		params.oldProgression = oldProgression;
		params.bForcedState = bForcedState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Multicast_ForceCompletion
	 * 		Flags  -> ()
	 */
	void ARBOperatable::Multicast_ForceCompletion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Multicast_ForceCompletion");
		
		ARBOperatable_Multicast_ForceCompletion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.IsCurrentlyBeingOperated
	 * 		Flags  -> ()
	 */
	bool ARBOperatable::IsCurrentlyBeingOperated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.IsCurrentlyBeingOperated");
		
		ARBOperatable_IsCurrentlyBeingOperated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.IsCompleted
	 * 		Flags  -> ()
	 */
	bool ARBOperatable::IsCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.IsCompleted");
		
		ARBOperatable_IsCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Event_OnTriggerableDeactivated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBTriggerable*                              triggerable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::Event_OnTriggerableDeactivated(class ARBTriggerable* triggerable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Event_OnTriggerableDeactivated");
		
		ARBOperatable_Event_OnTriggerableDeactivated_Params params {};
		params.triggerable = triggerable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Event_OnTriggerableActivated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBTriggerable*                              triggerable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::Event_OnTriggerableActivated(class ARBTriggerable* triggerable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Event_OnTriggerableActivated");
		
		ARBOperatable_Event_OnTriggerableActivated_Params params {};
		params.triggerable = triggerable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Event_OnTimedReset
	 * 		Flags  -> ()
	 */
	void ARBOperatable::Event_OnTimedReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Event_OnTimedReset");
		
		ARBOperatable_Event_OnTimedReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Event_OnStopOperating
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::Event_OnStopOperating(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Event_OnStopOperating");
		
		ARBOperatable_Event_OnStopOperating_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Event_OnStateOnChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bStateOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::Event_OnStateOnChanged(bool bStateOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Event_OnStateOnChanged");
		
		ARBOperatable_Event_OnStateOnChanged_Params params {};
		params.bStateOn = bStateOn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Event_OnStartOperating
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::Event_OnStartOperating(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Event_OnStartOperating");
		
		ARBOperatable_Event_OnStartOperating_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Event_OnResetCompletedState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              oldProgression                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::Event_OnResetCompletedState(float oldProgression)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Event_OnResetCompletedState");
		
		ARBOperatable_Event_OnResetCompletedState_Params params {};
		params.oldProgression = oldProgression;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Event_OnOperationProgressChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              currentProgressRatio                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::Event_OnOperationProgressChanged(float currentProgressRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Event_OnOperationProgressChanged");
		
		ARBOperatable_Event_OnOperationProgressChanged_Params params {};
		params.currentProgressRatio = currentProgressRatio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Event_OnIsDenyInteractionChanged
	 * 		Flags  -> ()
	 */
	void ARBOperatable::Event_OnIsDenyInteractionChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Event_OnIsDenyInteractionChanged");
		
		ARBOperatable_Event_OnIsDenyInteractionChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.Event_OnCompletedOperation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class ARBPawn*>                             pawns                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::Event_OnCompletedOperation(TArray<class ARBPawn*> pawns)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.Event_OnCompletedOperation");
		
		ARBOperatable_Event_OnCompletedOperation_Params params {};
		params.pawns = pawns;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.DefaultTestPhysicsClearance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactorPawn                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBOperatable::DefaultTestPhysicsClearance(class ARBPawn* interactorPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.DefaultTestPhysicsClearance");
		
		ARBOperatable_DefaultTestPhysicsClearance_Params params {};
		params.interactorPawn = interactorPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.BP_SetIsDenyInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bDeny                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::BP_SetIsDenyInteraction(bool bDeny)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.BP_SetIsDenyInteraction");
		
		ARBOperatable_BP_SetIsDenyInteraction_Params params {};
		params.bDeny = bDeny;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.BP_ResetCompletedState
	 * 		Flags  -> ()
	 */
	void ARBOperatable::BP_ResetCompletedState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.BP_ResetCompletedState");
		
		ARBOperatable_BP_ResetCompletedState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.BP_GetCurrentProgressionRatio
	 * 		Flags  -> ()
	 */
	float ARBOperatable::BP_GetCurrentProgressionRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.BP_GetCurrentProgressionRatio");
		
		ARBOperatable_BP_GetCurrentProgressionRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.BP_ForceState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bForcedState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::BP_ForceState(bool bForcedState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.BP_ForceState");
		
		ARBOperatable_BP_ForceState_Params params {};
		params.bForcedState = bForcedState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.BP_ForceInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bBypassCompletion                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::BP_ForceInteraction(bool bBypassCompletion)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.BP_ForceInteraction");
		
		ARBOperatable_BP_ForceInteraction_Params params {};
		params.bBypassCompletion = bBypassCompletion;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.BP_ForceDesiredProgression
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              desiredProgression                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              progressionSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatable::BP_ForceDesiredProgression(float desiredProgression, float progressionSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.BP_ForceDesiredProgression");
		
		ARBOperatable_BP_ForceDesiredProgression_Params params {};
		params.desiredProgression = desiredProgression;
		params.progressionSpeed = progressionSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.BP_ForceCompletion
	 * 		Flags  -> ()
	 */
	void ARBOperatable::BP_ForceCompletion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.BP_ForceCompletion");
		
		ARBOperatable_BP_ForceCompletion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.BP_CanOperateWith
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBOperatable::BP_CanOperateWith(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.BP_CanOperateWith");
		
		ARBOperatable_BP_CanOperateWith_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatable.BP_CancelTimedReset
	 * 		Flags  -> ()
	 */
	void ARBOperatable::BP_CancelTimedReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatable.BP_CancelTimedReset");
		
		ARBOperatable_BP_CancelTimedReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBOperatable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBOperatable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBOperatable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.SlamClosedRepulsionDone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBRepulsionComponent*                       repulsionComponentDone                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::SlamClosedRepulsionDone(class URBRepulsionComponent* repulsionComponentDone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.SlamClosedRepulsionDone");
		
		ARBDoor_SlamClosedRepulsionDone_Params params {};
		params.repulsionComponentDone = repulsionComponentDone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.SlamClosed_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERepulsionDirectionFlags                           Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ARBPawn*>                             specificPawnsPushed                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::SlamClosed_Server(ERepulsionDirectionFlags Direction, TArray<class ARBPawn*> specificPawnsPushed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.SlamClosed_Server");
		
		ARBDoor_SlamClosed_Server_Params params {};
		params.Direction = Direction;
		params.specificPawnsPushed = specificPawnsPushed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.SetupDynamicComponentVisibilityId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::SetupDynamicComponentVisibilityId(class USceneComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.SetupDynamicComponentVisibilityId");
		
		ARBDoor_SetupDynamicComponentVisibilityId_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.SetupDynamicActorVisibilityId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::SetupDynamicActorVisibilityId(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.SetupDynamicActorVisibilityId");
		
		ARBDoor_SetupDynamicActorVisibilityId_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.SetLinkedDoubleDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBDoor*                                     linkedDoor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::SetLinkedDoubleDoor(class ARBDoor* linkedDoor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.SetLinkedDoubleDoor");
		
		ARBDoor_SetLinkedDoubleDoor_Params params {};
		params.linkedDoor = linkedDoor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnRep_Unhinged
	 * 		Flags  -> ()
	 */
	void ARBDoor::OnRep_Unhinged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnRep_Unhinged");
		
		ARBDoor_OnRep_Unhinged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnRep_SpawnedTrap
	 * 		Flags  -> ()
	 */
	void ARBDoor::OnRep_SpawnedTrap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnRep_SpawnedTrap");
		
		ARBDoor_OnRep_SpawnedTrap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnRep_RewardLockingOperatables
	 * 		Flags  -> ()
	 */
	void ARBDoor::OnRep_RewardLockingOperatables()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnRep_RewardLockingOperatables");
		
		ARBDoor_OnRep_RewardLockingOperatables_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnRep_RandomStaticBlockingActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      oldActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::OnRep_RandomStaticBlockingActor(class AActor* oldActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnRep_RandomStaticBlockingActor");
		
		ARBDoor_OnRep_RandomStaticBlockingActor_Params params {};
		params.oldActor = oldActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnRep_NumberOfRewardUnlockActive
	 * 		Flags  -> ()
	 */
	void ARBDoor::OnRep_NumberOfRewardUnlockActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnRep_NumberOfRewardUnlockActive");
		
		ARBDoor_OnRep_NumberOfRewardUnlockActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnRep_LockPanel
	 * 		Flags  -> ()
	 */
	void ARBDoor::OnRep_LockPanel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnRep_LockPanel");
		
		ARBDoor_OnRep_LockPanel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnRep_DynamicallyReplaced
	 * 		Flags  -> ()
	 */
	void ARBDoor::OnRep_DynamicallyReplaced()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnRep_DynamicallyReplaced");
		
		ARBDoor_OnRep_DynamicallyReplaced_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnRep_DesiredDoorAngle
	 * 		Flags  -> ()
	 */
	void ARBDoor::OnRep_DesiredDoorAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnRep_DesiredDoorAngle");
		
		ARBDoor_OnRep_DesiredDoorAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnRep_BlockingActors
	 * 		Flags  -> ()
	 */
	void ARBDoor::OnRep_BlockingActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnRep_BlockingActors");
		
		ARBDoor_OnRep_BlockingActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnRep_BarLocked
	 * 		Flags  -> ()
	 */
	void ARBDoor::OnRep_BarLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnRep_BarLocked");
		
		ARBDoor_OnRep_BarLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnLockPanelUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               lockPanel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::OnLockPanelUnlocked(class URBInteractiblePanelComponent* lockPanel, class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnLockPanelUnlocked");
		
		ARBDoor_OnLockPanelUnlocked_Params params {};
		params.lockPanel = lockPanel;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnDoorRepulsionDone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBRepulsionComponent*                       repulsionComponentDone                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::OnDoorRepulsionDone(class URBRepulsionComponent* repulsionComponentDone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnDoorRepulsionDone");
		
		ARBDoor_OnDoorRepulsionDone_Params params {};
		params.repulsionComponentDone = repulsionComponentDone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnDesiredDoorAngleChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::OnDesiredDoorAngleChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnDesiredDoorAngleChangedCallback");
		
		ARBDoor_OnDesiredDoorAngleChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnCoopOperatableOperatingStartedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBOperatableComponent*                      Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::OnCoopOperatableOperatingStartedEvent(class URBOperatableComponent* Component, class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnCoopOperatableOperatingStartedEvent");
		
		ARBDoor_OnCoopOperatableOperatingStartedEvent_Params params {};
		params.Component = Component;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnCoopOperatableOperatingFinishedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBOperatableComponent*                      Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::OnCoopOperatableOperatingFinishedEvent(class URBOperatableComponent* Component, class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnCoopOperatableOperatingFinishedEvent");
		
		ARBDoor_OnCoopOperatableOperatingFinishedEvent_Params params {};
		params.Component = Component;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnComponentEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnComponentEndOverlap");
		
		ARBDoor_OnComponentEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.OnComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.OnComponentBeginOverlap");
		
		ARBDoor_OnComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.Multicast_OnRewardDoorUnlocked
	 * 		Flags  -> ()
	 */
	void ARBDoor::Multicast_OnRewardDoorUnlocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.Multicast_OnRewardDoorUnlocked");
		
		ARBDoor_Multicast_OnRewardDoorUnlocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.Multicast_OnDoorInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newDoorDesiredAngle                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              newDoorAngleSpeedRatio                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::Multicast_OnDoorInteract(float newDoorDesiredAngle, float newDoorAngleSpeedRatio, class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.Multicast_OnDoorInteract");
		
		ARBDoor_Multicast_OnDoorInteract_Params params {};
		params.newDoorDesiredAngle = newDoorDesiredAngle;
		params.newDoorAngleSpeedRatio = newDoorAngleSpeedRatio;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.LockingPanelActiveChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     pawnInteracting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::LockingPanelActiveChanged(class URBInteractiblePanelComponent* panel, class ARBPawn* pawnInteracting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.LockingPanelActiveChanged");
		
		ARBDoor_LockingPanelActiveChanged_Params params {};
		params.panel = panel;
		params.pawnInteracting = pawnInteracting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.LockBars_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bLocked                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::LockBars_Server(bool bLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.LockBars_Server");
		
		ARBDoor_LockBars_Server_Params params {};
		params.bLocked = bLocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.GetSoundComponent
	 * 		Flags  -> ()
	 */
	class URBSoundComponent* ARBDoor::GetSoundComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.GetSoundComponent");
		
		ARBDoor_GetSoundComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.GetBlockableState
	 * 		Flags  -> ()
	 */
	EBlockableState ARBDoor::GetBlockableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.GetBlockableState");
		
		ARBDoor_GetBlockableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.Flip
	 * 		Flags  -> ()
	 */
	void ARBDoor::Flip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.Flip");
		
		ARBDoor_Flip_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.Editor_OnSelected
	 * 		Flags  -> ()
	 */
	void ARBDoor::Editor_OnSelected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.Editor_OnSelected");
		
		ARBDoor_Editor_OnSelected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.Editor_OnDeselected
	 * 		Flags  -> ()
	 */
	void ARBDoor::Editor_OnDeselected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.Editor_OnDeselected");
		
		ARBDoor_Editor_OnDeselected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_SetDynamicReplacement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      replacementClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShouldRemoveDoorFrame                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            randomID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AActor* ARBDoor::BP_SetDynamicReplacement(class UClass* replacementClass, bool bShouldRemoveDoorFrame, int32_t randomID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_SetDynamicReplacement");
		
		ARBDoor_BP_SetDynamicReplacement_Params params {};
		params.replacementClass = replacementClass;
		params.bShouldRemoveDoorFrame = bShouldRemoveDoorFrame;
		params.randomID = randomID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_Server_Unlock
	 * 		Flags  -> ()
	 */
	void ARBDoor::BP_Server_Unlock()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_Server_Unlock");
		
		ARBDoor_BP_Server_Unlock_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_Server_Lock
	 * 		Flags  -> ()
	 */
	void ARBDoor::BP_Server_Lock()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_Server_Lock");
		
		ARBDoor_BP_Server_Lock_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_Reset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bApplyForceRandomization                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::BP_Reset(bool bApplyForceRandomization)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_Reset");
		
		ARBDoor_BP_Reset_Params params {};
		params.bApplyForceRandomization = bApplyForceRandomization;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_RebuildInternalData
	 * 		Flags  -> ()
	 */
	void ARBDoor::BP_RebuildInternalData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_RebuildInternalData");
		
		ARBDoor_BP_RebuildInternalData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_Open
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFrontSide                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              speedRatio                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::BP_Open(bool bFrontSide, float speedRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_Open");
		
		ARBDoor_BP_Open_Params params {};
		params.bFrontSide = bFrontSide;
		params.speedRatio = speedRatio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_OnRewardDoorInitialization
	 * 		Flags  -> ()
	 */
	void ARBDoor::BP_OnRewardDoorInitialization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_OnRewardDoorInitialization");
		
		ARBDoor_BP_OnRewardDoorInitialization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_OnNumberOfRewardUnlockActiveChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            numberOfRewardUnlockActive                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::BP_OnNumberOfRewardUnlockActiveChanged(int32_t numberOfRewardUnlockActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_OnNumberOfRewardUnlockActiveChanged");
		
		ARBDoor_BP_OnNumberOfRewardUnlockActiveChanged_Params params {};
		params.numberOfRewardUnlockActive = numberOfRewardUnlockActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_OnLockPanelUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               lockPanel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::BP_OnLockPanelUnlocked(class URBInteractiblePanelComponent* lockPanel, class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_OnLockPanelUnlocked");
		
		ARBDoor_BP_OnLockPanelUnlocked_Params params {};
		params.lockPanel = lockPanel;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_OnLockPanelsReplicated
	 * 		Flags  -> ()
	 */
	void ARBDoor::BP_OnLockPanelsReplicated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_OnLockPanelsReplicated");
		
		ARBDoor_BP_OnLockPanelsReplicated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_OnDoorUnhingeEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::BP_OnDoorUnhingeEvent(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_OnDoorUnhingeEvent");
		
		ARBDoor_BP_OnDoorUnhingeEvent_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_OnDoorTrappedStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bTrapped                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromFront                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::BP_OnDoorTrappedStateChanged(bool bTrapped, bool bFromFront)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_OnDoorTrappedStateChanged");
		
		ARBDoor_BP_OnDoorTrappedStateChanged_Params params {};
		params.bTrapped = bTrapped;
		params.bFromFront = bFromFront;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_OnDoorTrapDisarmed
	 * 		Flags  -> ()
	 */
	void ARBDoor::BP_OnDoorTrapDisarmed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_OnDoorTrapDisarmed");
		
		ARBDoor_BP_OnDoorTrapDisarmed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_OnDoorTrapActivated
	 * 		Flags  -> ()
	 */
	void ARBDoor::BP_OnDoorTrapActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_OnDoorTrapActivated");
		
		ARBDoor_BP_OnDoorTrapActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_OnDoorInteract
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::BP_OnDoorInteract(class ARBPawn* interactor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_OnDoorInteract");
		
		ARBDoor_BP_OnDoorInteract_Params params {};
		params.interactor = interactor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_OnDoorBashEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplyVisualDoorDamage                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBashDoorType                                      bashType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::BP_OnDoorBashEvent(class ARBPawn* Pawn, bool bSuccess, bool bApplyVisualDoorDamage, EBashDoorType bashType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_OnDoorBashEvent");
		
		ARBDoor_BP_OnDoorBashEvent_Params params {};
		params.Pawn = Pawn;
		params.bSuccess = bSuccess;
		params.bApplyVisualDoorDamage = bApplyVisualDoorDamage;
		params.bashType = bashType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_OnDoorBarsLockingEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bLocking                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::BP_OnDoorBarsLockingEvent(bool bLocking)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_OnDoorBarsLockingEvent");
		
		ARBDoor_BP_OnDoorBarsLockingEvent_Params params {};
		params.bLocking = bLocking;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_OnActorAttachedToDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDoor::BP_OnActorAttachedToDoor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_OnActorAttachedToDoor");
		
		ARBDoor_BP_OnActorAttachedToDoor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_IsOpening
	 * 		Flags  -> ()
	 */
	bool ARBDoor::BP_IsOpening()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_IsOpening");
		
		ARBDoor_BP_IsOpening_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_IsOpen
	 * 		Flags  -> ()
	 */
	bool ARBDoor::BP_IsOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_IsOpen");
		
		ARBDoor_BP_IsOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_IsMoving
	 * 		Flags  -> ()
	 */
	bool ARBDoor::BP_IsMoving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_IsMoving");
		
		ARBDoor_BP_IsMoving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_IsLinkedTrapTriggered
	 * 		Flags  -> ()
	 */
	bool ARBDoor::BP_IsLinkedTrapTriggered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_IsLinkedTrapTriggered");
		
		ARBDoor_BP_IsLinkedTrapTriggered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_IsLinkedTrapArmed
	 * 		Flags  -> ()
	 */
	bool ARBDoor::BP_IsLinkedTrapArmed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_IsLinkedTrapArmed");
		
		ARBDoor_BP_IsLinkedTrapArmed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_IsIdle
	 * 		Flags  -> ()
	 */
	bool ARBDoor::BP_IsIdle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_IsIdle");
		
		ARBDoor_BP_IsIdle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_IsFullyOpenInFront
	 * 		Flags  -> ()
	 */
	bool ARBDoor::BP_IsFullyOpenInFront()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_IsFullyOpenInFront");
		
		ARBDoor_BP_IsFullyOpenInFront_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_IsFullyOpenInBack
	 * 		Flags  -> ()
	 */
	bool ARBDoor::BP_IsFullyOpenInBack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_IsFullyOpenInBack");
		
		ARBDoor_BP_IsFullyOpenInBack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_IsFullyOpen
	 * 		Flags  -> ()
	 */
	bool ARBDoor::BP_IsFullyOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_IsFullyOpen");
		
		ARBDoor_BP_IsFullyOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_IsClosing
	 * 		Flags  -> ()
	 */
	bool ARBDoor::BP_IsClosing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_IsClosing");
		
		ARBDoor_BP_IsClosing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_IsClosed
	 * 		Flags  -> ()
	 */
	bool ARBDoor::BP_IsClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_IsClosed");
		
		ARBDoor_BP_IsClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_IsBlockedOnAnySide
	 * 		Flags  -> ()
	 */
	bool ARBDoor::BP_IsBlockedOnAnySide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_IsBlockedOnAnySide");
		
		ARBDoor_BP_IsBlockedOnAnySide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_IsActorInFront
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBDoor::BP_IsActorInFront(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_IsActorInFront");
		
		ARBDoor_BP_IsActorInFront_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_DeactivateBars
	 * 		Flags  -> ()
	 */
	void ARBDoor::BP_DeactivateBars()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_DeactivateBars");
		
		ARBDoor_BP_DeactivateBars_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_Close
	 * 		Flags  -> ()
	 */
	void ARBDoor::BP_Close()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_Close");
		
		ARBDoor_BP_Close_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_ActivateSlowOpenTutorial
	 * 		Flags  -> ()
	 */
	void ARBDoor::BP_ActivateSlowOpenTutorial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_ActivateSlowOpenTutorial");
		
		ARBDoor_BP_ActivateSlowOpenTutorial_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.BP_ActivateBars
	 * 		Flags  -> ()
	 */
	void ARBDoor::BP_ActivateBars()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.BP_ActivateBars");
		
		ARBDoor_BP_ActivateBars_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoor.ApplyDoorframeOffsetToTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                                  Transform                                                  (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               isAddonInFront                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     offsetDirection                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplySideOffset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform ARBDoor::ApplyDoorframeOffsetToTransform(struct FTransform* Transform, bool isAddonInFront, const struct FVector& offsetDirection, bool bApplySideOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoor.ApplyDoorframeOffsetToTransform");
		
		ARBDoor_ApplyDoorframeOffsetToTransform_Params params {};
		params.isAddonInFront = isAddonInFront;
		params.offsetDirection = offsetDirection;
		params.bApplySideOffset = bApplySideOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Transform != nullptr)
			*Transform = params.Transform;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutomaticDoor.FrontEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBAutomaticDoor::FrontEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutomaticDoor.FrontEndOverlap");
		
		ARBAutomaticDoor_FrontEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutomaticDoor.FrontBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBAutomaticDoor::FrontBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutomaticDoor.FrontBeginOverlap");
		
		ARBAutomaticDoor_FrontBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutomaticDoor.BackEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBAutomaticDoor::BackEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutomaticDoor.BackEndOverlap");
		
		ARBAutomaticDoor_BackEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutomaticDoor.BackBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBAutomaticDoor::BackBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutomaticDoor.BackBeginOverlap");
		
		ARBAutomaticDoor_BackBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBAutomaticDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBAutomaticDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAutomaticDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.OnSpawnedItemInfosChanged
	 * 		Flags  -> ()
	 */
	void ARBContainer::OnSpawnedItemInfosChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.OnSpawnedItemInfosChanged");
		
		ARBContainer_OnSpawnedItemInfosChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.OnRep_SpawnedItemInfos
	 * 		Flags  -> ()
	 */
	void ARBContainer::OnRep_SpawnedItemInfos()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.OnRep_SpawnedItemInfos");
		
		ARBContainer_OnRep_SpawnedItemInfos_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.OnRep_PopulatedState
	 * 		Flags  -> ()
	 */
	void ARBContainer::OnRep_PopulatedState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.OnRep_PopulatedState");
		
		ARBContainer_OnRep_PopulatedState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.Multicast_ItemPickedUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPickup*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBContainer::Multicast_ItemPickedUp(class ARBPawn* Pawn, class ARBPickup* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.Multicast_ItemPickedUp");
		
		ARBContainer_Multicast_ItemPickedUp_Params params {};
		params.Pawn = Pawn;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.IsOpen
	 * 		Flags  -> ()
	 */
	bool ARBContainer::IsOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.IsOpen");
		
		ARBContainer_IsOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.IsLocked
	 * 		Flags  -> ()
	 */
	bool ARBContainer::IsLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.IsLocked");
		
		ARBContainer_IsLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.IsContainerEmpty
	 * 		Flags  -> ()
	 */
	bool ARBContainer::IsContainerEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.IsContainerEmpty");
		
		ARBContainer_IsContainerEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.IsClosableContainer
	 * 		Flags  -> ()
	 */
	bool ARBContainer::IsClosableContainer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.IsClosableContainer");
		
		ARBContainer_IsClosableContainer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.InsideItemPickedUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPickup*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBContainer::InsideItemPickedUp(class ARBPawn* Pawn, class ARBPickup* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.InsideItemPickedUp");
		
		ARBContainer_InsideItemPickedUp_Params params {};
		params.Pawn = Pawn;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.GetPopulatedState
	 * 		Flags  -> ()
	 */
	EContainerPopulatedState ARBContainer::GetPopulatedState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.GetPopulatedState");
		
		ARBContainer_GetPopulatedState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.GetPickupInteractionLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBContainerSpawnLocationComponent*          spawnComponent                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     out_location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     out_direction                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBContainer::GetPickupInteractionLocation(class ARBPawn* Pawn, class URBContainerSpawnLocationComponent* spawnComponent, struct FVector* out_location, struct FVector* out_direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.GetPickupInteractionLocation");
		
		ARBContainer_GetPickupInteractionLocation_Params params {};
		params.Pawn = Pawn;
		params.spawnComponent = spawnComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (out_location != nullptr)
			*out_location = params.out_location;
		if (out_direction != nullptr)
			*out_direction = params.out_direction;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.GetNumberOfSpawnedItems
	 * 		Flags  -> ()
	 */
	int32_t ARBContainer::GetNumberOfSpawnedItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.GetNumberOfSpawnedItems");
		
		ARBContainer_GetNumberOfSpawnedItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.GetItemSpawnLocationComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   itemInContainer                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBContainerSpawnLocationComponent* ARBContainer::GetItemSpawnLocationComponent(class ARBPickup* itemInContainer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.GetItemSpawnLocationComponent");
		
		ARBContainer_GetItemSpawnLocationComponent_Params params {};
		params.itemInContainer = itemInContainer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.GetItemFromSpawnLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBContainerSpawnLocationComponent*          spawnLocationComponent                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBPickup* ARBContainer::GetItemFromSpawnLocation(class URBContainerSpawnLocationComponent* spawnLocationComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.GetItemFromSpawnLocation");
		
		ARBContainer_GetItemFromSpawnLocation_Params params {};
		params.spawnLocationComponent = spawnLocationComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.Event_SnapToState
	 * 		Flags  -> ()
	 */
	void ARBContainer::Event_SnapToState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.Event_SnapToState");
		
		ARBContainer_Event_SnapToState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.Event_PostWorldPopulated_Server
	 * 		Flags  -> ()
	 */
	void ARBContainer::Event_PostWorldPopulated_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.Event_PostWorldPopulated_Server");
		
		ARBContainer_Event_PostWorldPopulated_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.Event_ItemRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBContainerSpawnLocationComponent*          Location                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBContainer::Event_ItemRemoved(class ARBPickup* Item, int32_t Index, class URBContainerSpawnLocationComponent* Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.Event_ItemRemoved");
		
		ARBContainer_Event_ItemRemoved_Params params {};
		params.Item = Item;
		params.Index = Index;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.Event_ItemPickedUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPickup*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBContainer::Event_ItemPickedUp(class ARBPawn* Pawn, class ARBPickup* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.Event_ItemPickedUp");
		
		ARBContainer_Event_ItemPickedUp_Params params {};
		params.Pawn = Pawn;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.Event_ItemAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBContainerSpawnLocationComponent*          Location                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBContainer::Event_ItemAdded(class ARBPickup* Item, int32_t Index, class URBContainerSpawnLocationComponent* Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.Event_ItemAdded");
		
		ARBContainer_Event_ItemAdded_Params params {};
		params.Item = Item;
		params.Index = Index;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.Editor_CreateAllItemDisplayMeshes
	 * 		Flags  -> ()
	 */
	void ARBContainer::Editor_CreateAllItemDisplayMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.Editor_CreateAllItemDisplayMeshes");
		
		ARBContainer_Editor_CreateAllItemDisplayMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.Editor_ClearForcedItems
	 * 		Flags  -> ()
	 */
	void ARBContainer::Editor_ClearForcedItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.Editor_ClearForcedItems");
		
		ARBContainer_Editor_ClearForcedItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.Editor_AddValidForcedItems
	 * 		Flags  -> ()
	 */
	void ARBContainer::Editor_AddValidForcedItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.Editor_AddValidForcedItems");
		
		ARBContainer_Editor_AddValidForcedItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.Editor_AddEditorForcedItems
	 * 		Flags  -> ()
	 */
	void ARBContainer::Editor_AddEditorForcedItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.Editor_AddEditorForcedItems");
		
		ARBContainer_Editor_AddEditorForcedItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.BP_ForceSpawnForcedContent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBContainer::BP_ForceSpawnForcedContent(int32_t RandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.BP_ForceSpawnForcedContent");
		
		ARBContainer_BP_ForceSpawnForcedContent_Params params {};
		params.RandomSeed = RandomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.BP_ForceReset
	 * 		Flags  -> ()
	 */
	void ARBContainer::BP_ForceReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.BP_ForceReset");
		
		ARBContainer_BP_ForceReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainer.BP_DestroyItemsInside
	 * 		Flags  -> ()
	 */
	void ARBContainer::BP_DestroyItemsInside()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainer.BP_DestroyItemsInside");
		
		ARBContainer_BP_DestroyItemsInside_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutoRespawnContainer.OnRep_SpawnsInBatchRemaining
	 * 		Flags  -> ()
	 */
	void ARBAutoRespawnContainer::OnRep_SpawnsInBatchRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutoRespawnContainer.OnRep_SpawnsInBatchRemaining");
		
		ARBAutoRespawnContainer_OnRep_SpawnsInBatchRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutoRespawnContainer.OnRep_AutoRespawnForcedItemsEnabled
	 * 		Flags  -> ()
	 */
	void ARBAutoRespawnContainer::OnRep_AutoRespawnForcedItemsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutoRespawnContainer.OnRep_AutoRespawnForcedItemsEnabled");
		
		ARBAutoRespawnContainer_OnRep_AutoRespawnForcedItemsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutoRespawnContainer.Event_OnSpawnsInBatchRemainingChanged
	 * 		Flags  -> ()
	 */
	void ARBAutoRespawnContainer::Event_OnSpawnsInBatchRemainingChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutoRespawnContainer.Event_OnSpawnsInBatchRemainingChanged");
		
		ARBAutoRespawnContainer_Event_OnSpawnsInBatchRemainingChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutoRespawnContainer.Event_OnAutoRespawnItemsEnabledChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBAutoRespawnContainer::Event_OnAutoRespawnItemsEnabledChanged(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutoRespawnContainer.Event_OnAutoRespawnItemsEnabledChanged");
		
		ARBAutoRespawnContainer_Event_OnAutoRespawnItemsEnabledChanged_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAutoRespawnContainer.BP_SetAutoRespawnForcedItemsEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSpawnRightNow                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBAutoRespawnContainer::BP_SetAutoRespawnForcedItemsEnabled(bool bEnabled, bool bSpawnRightNow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAutoRespawnContainer.BP_SetAutoRespawnForcedItemsEnabled");
		
		ARBAutoRespawnContainer_BP_SetAutoRespawnForcedItemsEnabled_Params params {};
		params.bEnabled = bEnabled;
		params.bSpawnRightNow = bSpawnRightNow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBAutoRespawnContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBAutoRespawnContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAutoRespawnContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAvailableTaskListWidget.SetMetaNpcType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMetaNPCType                                       metaNPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBAvailableTaskListWidget::SetMetaNpcType(EMetaNPCType metaNPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAvailableTaskListWidget.SetMetaNpcType");
		
		URBAvailableTaskListWidget_SetMetaNpcType_Params params {};
		params.metaNPCType = metaNPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBAvailableTaskListWidget.GetAvailableTasks
	 * 		Flags  -> ()
	 */
	TArray<struct FUINPCTask> URBAvailableTaskListWidget::GetAvailableTasks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBAvailableTaskListWidget.GetAvailableTasks");
		
		URBAvailableTaskListWidget_GetAvailableTasks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAvailableTaskListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAvailableTaskListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAvailableTaskListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBackgroundCharacter.SnapToStartPosition
	 * 		Flags  -> ()
	 */
	void ARBBackgroundCharacter::SnapToStartPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBackgroundCharacter.SnapToStartPosition");
		
		ARBBackgroundCharacter_SnapToStartPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBBackgroundCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBBackgroundCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBackgroundCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBBackgroundCharacterStation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBBackgroundCharacterStation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBackgroundCharacterStation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBackgroundDoor.Event_OpenDoor
	 * 		Flags  -> ()
	 */
	void ARBBackgroundDoor::Event_OpenDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBackgroundDoor.Event_OpenDoor");
		
		ARBBackgroundDoor_Event_OpenDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBackgroundDoor.Event_CloseDoor
	 * 		Flags  -> ()
	 */
	void ARBBackgroundDoor::Event_CloseDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBackgroundDoor.Event_CloseDoor");
		
		ARBBackgroundDoor_Event_CloseDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBBackgroundDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBBackgroundDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBackgroundDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBackToLobbyMenu.LeavingWillLeaveParty
	 * 		Flags  -> ()
	 */
	bool URBBackToLobbyMenu::LeavingWillLeaveParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBackToLobbyMenu.LeavingWillLeaveParty");
		
		URBBackToLobbyMenu_LeavingWillLeaveParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBackToLobbyMenu.IsOperationPending
	 * 		Flags  -> ()
	 */
	bool URBBackToLobbyMenu::IsOperationPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBackToLobbyMenu.IsOperationPending");
		
		URBBackToLobbyMenu_IsOperationPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBackToLobbyMenu.IsLeaving
	 * 		Flags  -> ()
	 */
	bool URBBackToLobbyMenu::IsLeaving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBackToLobbyMenu.IsLeaving");
		
		URBBackToLobbyMenu_IsLeaving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBackToLobbyMenu.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBBackToLobbyMenu::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBackToLobbyMenu.Event_Refresh");
		
		URBBackToLobbyMenu_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBackToLobbyMenu.CanReturnWithParty
	 * 		Flags  -> ()
	 */
	bool URBBackToLobbyMenu::CanReturnWithParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBackToLobbyMenu.CanReturnWithParty");
		
		URBBackToLobbyMenu_CanReturnWithParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBackToLobbyMenu.BackToLobby
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bWithParty                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBackToLobbyMenu::BackToLobby(bool bWithParty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBackToLobbyMenu.BackToLobby");
		
		URBBackToLobbyMenu_BackToLobby_Params params {};
		params.bWithParty = bWithParty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBBackToLobbyMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBBackToLobbyMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBackToLobbyMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabWidget.RequestNavigationBack
	 * 		Flags  -> ()
	 */
	void URBMenuTabWidget::RequestNavigationBack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabWidget.RequestNavigationBack");
		
		URBMenuTabWidget_RequestNavigationBack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabWidget.OnNavigationChanged
	 * 		Flags  -> ()
	 */
	void URBMenuTabWidget::OnNavigationChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabWidget.OnNavigationChanged");
		
		URBMenuTabWidget_OnNavigationChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabWidget.OnButtonReleased
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UUserWidget*                                 buttonClicked                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FKey                                        Key                                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuTabWidget::OnButtonReleased(class UUserWidget* buttonClicked, const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabWidget.OnButtonReleased");
		
		URBMenuTabWidget_OnButtonReleased_Params params {};
		params.buttonClicked = buttonClicked;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabWidget.OnButtonClicked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UUserWidget*                                 buttonClicked                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FKey                                        Key                                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuTabWidget::OnButtonClicked(class UUserWidget* buttonClicked, const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabWidget.OnButtonClicked");
		
		URBMenuTabWidget_OnButtonClicked_Params params {};
		params.buttonClicked = buttonClicked;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabWidget.OnBackRequested
	 * 		Flags  -> ()
	 */
	void URBMenuTabWidget::OnBackRequested()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabWidget.OnBackRequested");
		
		URBMenuTabWidget_OnBackRequested_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabWidget.IsReadyToClose
	 * 		Flags  -> ()
	 */
	bool URBMenuTabWidget::IsReadyToClose()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabWidget.IsReadyToClose");
		
		URBMenuTabWidget_IsReadyToClose_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabWidget.GetPageSpecificButtons
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UUserWidget*>                         outButtons                                                 (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBMenuTabWidget::GetPageSpecificButtons(TArray<class UUserWidget*>* outButtons)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabWidget.GetPageSpecificButtons");
		
		URBMenuTabWidget_GetPageSpecificButtons_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outButtons != nullptr)
			*outButtons = params.outButtons;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabWidget.GetMenuWithTabsParent
	 * 		Flags  -> ()
	 */
	class URBMenuWithTabsWidget* URBMenuTabWidget::GetMenuWithTabsParent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabWidget.GetMenuWithTabsParent");
		
		URBMenuTabWidget_GetMenuWithTabsParent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabWidget.Event_OnTabUnselected
	 * 		Flags  -> ()
	 */
	void URBMenuTabWidget::Event_OnTabUnselected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabWidget.Event_OnTabUnselected");
		
		URBMenuTabWidget_Event_OnTabUnselected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabWidget.Event_OnTabSelected
	 * 		Flags  -> ()
	 */
	void URBMenuTabWidget::Event_OnTabSelected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabWidget.Event_OnTabSelected");
		
		URBMenuTabWidget_Event_OnTabSelected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabWidget.Event_OnParentUnfocused
	 * 		Flags  -> ()
	 */
	void URBMenuTabWidget::Event_OnParentUnfocused()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabWidget.Event_OnParentUnfocused");
		
		URBMenuTabWidget_Event_OnParentUnfocused_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabWidget.Event_OnParentPopped
	 * 		Flags  -> ()
	 */
	void URBMenuTabWidget::Event_OnParentPopped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabWidget.Event_OnParentPopped");
		
		URBMenuTabWidget_Event_OnParentPopped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabWidget.Event_OnParentFocused
	 * 		Flags  -> ()
	 */
	void URBMenuTabWidget::Event_OnParentFocused()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabWidget.Event_OnParentFocused");
		
		URBMenuTabWidget_Event_OnParentFocused_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuTabWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuTabWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuTabWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterSheetMenuTabWidget.ShouldShowPageTitle
	 * 		Flags  -> ()
	 */
	bool URBCharacterSheetMenuTabWidget::ShouldShowPageTitle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterSheetMenuTabWidget.ShouldShowPageTitle");
		
		URBCharacterSheetMenuTabWidget_ShouldShowPageTitle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterSheetMenuTabWidget.ShouldShowNavigation
	 * 		Flags  -> ()
	 */
	bool URBCharacterSheetMenuTabWidget::ShouldShowNavigation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterSheetMenuTabWidget.ShouldShowNavigation");
		
		URBCharacterSheetMenuTabWidget_ShouldShowNavigation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterSheetMenuTabWidget.HandleMenuTabRight
	 * 		Flags  -> ()
	 */
	bool URBCharacterSheetMenuTabWidget::HandleMenuTabRight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterSheetMenuTabWidget.HandleMenuTabRight");
		
		URBCharacterSheetMenuTabWidget_HandleMenuTabRight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterSheetMenuTabWidget.HandleMenuTabLeft
	 * 		Flags  -> ()
	 */
	bool URBCharacterSheetMenuTabWidget::HandleMenuTabLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterSheetMenuTabWidget.HandleMenuTabLeft");
		
		URBCharacterSheetMenuTabWidget_HandleMenuTabLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterSheetMenuTabWidget.GetPageTitle
	 * 		Flags  -> ()
	 */
	class FText URBCharacterSheetMenuTabWidget::GetPageTitle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterSheetMenuTabWidget.GetPageTitle");
		
		URBCharacterSheetMenuTabWidget_GetPageTitle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterSheetMenuTabWidget.GetPageSubtitle
	 * 		Flags  -> ()
	 */
	class FText URBCharacterSheetMenuTabWidget::GetPageSubtitle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterSheetMenuTabWidget.GetPageSubtitle");
		
		URBCharacterSheetMenuTabWidget_GetPageSubtitle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCharacterSheetMenuTabWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCharacterSheetMenuTabWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCharacterSheetMenuTabWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBadgesTabWidget.OnPlayerStatsDataAvailable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRBStatContext>                      stats                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FRBUIReleasedCharacterDetails>       releasedCharacterDetailsList                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBBadgesTabWidget::OnPlayerStatsDataAvailable(TArray<struct FRBStatContext> stats, TArray<struct FRBUIReleasedCharacterDetails> releasedCharacterDetailsList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBadgesTabWidget.OnPlayerStatsDataAvailable");
		
		URBBadgesTabWidget_OnPlayerStatsDataAvailable_Params params {};
		params.stats = stats;
		params.releasedCharacterDetailsList = releasedCharacterDetailsList;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBadgesTabWidget.IsDataPending
	 * 		Flags  -> ()
	 */
	bool URBBadgesTabWidget::IsDataPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBadgesTabWidget.IsDataPending");
		
		URBBadgesTabWidget_IsDataPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBadgesTabWidget.HasClaimableBadgeReward
	 * 		Flags  -> ()
	 */
	bool URBBadgesTabWidget::HasClaimableBadgeReward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBadgesTabWidget.HasClaimableBadgeReward");
		
		URBBadgesTabWidget_HasClaimableBadgeReward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBadgesTabWidget.GetBadgeUnlockCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        BadgeId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBBadgesTabWidget::GetBadgeUnlockCount(const class FName& BadgeId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBadgesTabWidget.GetBadgeUnlockCount");
		
		URBBadgesTabWidget_GetBadgeUnlockCount_Params params {};
		params.BadgeId = BadgeId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBadgesTabWidget.GetBadgeProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        BadgeId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBBadgesTabWidget::GetBadgeProgress(const class FName& BadgeId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBadgesTabWidget.GetBadgeProgress");
		
		URBBadgesTabWidget_GetBadgeProgress_Params params {};
		params.BadgeId = BadgeId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBadgesTabWidget.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBBadgesTabWidget::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBadgesTabWidget.Event_Refresh");
		
		URBBadgesTabWidget_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBadgesTabWidget.ClaimBadgeReward
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        BadgeId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBadgesTabWidget::ClaimBadgeReward(const class FName& BadgeId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBadgesTabWidget.ClaimBadgeReward");
		
		URBBadgesTabWidget_ClaimBadgeReward_Params params {};
		params.BadgeId = BadgeId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBadgesTabWidget.CanClaimBadgeReward
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        BadgeId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBadgesTabWidget::CanClaimBadgeReward(const class FName& BadgeId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBadgesTabWidget.CanClaimBadgeReward");
		
		URBBadgesTabWidget_CanClaimBadgeReward_Params params {};
		params.BadgeId = BadgeId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBBadgesTabWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBBadgesTabWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBadgesTabWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBareBonesInteractionComponent.OnRep_PawnInteracting
	 * 		Flags  -> ()
	 */
	void URBBareBonesInteractionComponent::OnRep_PawnInteracting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBareBonesInteractionComponent.OnRep_PawnInteracting");
		
		URBBareBonesInteractionComponent_OnRep_PawnInteracting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBBareBonesInteractionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBBareBonesInteractionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBareBonesInteractionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.StopCoordinator
	 * 		Flags  -> ()
	 */
	void ARBBaseObjectiveCoordinator::StopCoordinator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.StopCoordinator");
		
		ARBBaseObjectiveCoordinator_StopCoordinator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.StartCoordinator
	 * 		Flags  -> ()
	 */
	void ARBBaseObjectiveCoordinator::StartCoordinator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.StartCoordinator");
		
		ARBBaseObjectiveCoordinator_StartCoordinator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBaseObjectiveCoordinator::SetEnabled(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.SetEnabled");
		
		ARBBaseObjectiveCoordinator_SetEnabled_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.OnStageReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBBaseObjectiveCoordinator::OnStageReady(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.OnStageReady");
		
		ARBBaseObjectiveCoordinator_OnStageReady_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.OnRep_StartedTime
	 * 		Flags  -> ()
	 */
	void ARBBaseObjectiveCoordinator::OnRep_StartedTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.OnRep_StartedTime");
		
		ARBBaseObjectiveCoordinator_OnRep_StartedTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.OnRep_RemainingObjectives
	 * 		Flags  -> ()
	 */
	void ARBBaseObjectiveCoordinator::OnRep_RemainingObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.OnRep_RemainingObjectives");
		
		ARBBaseObjectiveCoordinator_OnRep_RemainingObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.OnRep_ObjectiveMaxCount
	 * 		Flags  -> ()
	 */
	void ARBBaseObjectiveCoordinator::OnRep_ObjectiveMaxCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.OnRep_ObjectiveMaxCount");
		
		ARBBaseObjectiveCoordinator_OnRep_ObjectiveMaxCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.OnRep_CurrentObjectiveCount
	 * 		Flags  -> ()
	 */
	void ARBBaseObjectiveCoordinator::OnRep_CurrentObjectiveCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.OnRep_CurrentObjectiveCount");
		
		ARBBaseObjectiveCoordinator_OnRep_CurrentObjectiveCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.OnRep_CoordinatorState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EObjectiveCoordinatorState                         oldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBaseObjectiveCoordinator::OnRep_CoordinatorState(EObjectiveCoordinatorState oldState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.OnRep_CoordinatorState");
		
		ARBBaseObjectiveCoordinator_OnRep_CoordinatorState_Params params {};
		params.oldState = oldState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.OnFailConditionTimerElapsed
	 * 		Flags  -> ()
	 */
	void ARBBaseObjectiveCoordinator::OnFailConditionTimerElapsed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.OnFailConditionTimerElapsed");
		
		ARBBaseObjectiveCoordinator_OnFailConditionTimerElapsed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.OnEndOfStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               isRestart                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBaseObjectiveCoordinator::OnEndOfStage(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, bool isRestart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.OnEndOfStage");
		
		ARBBaseObjectiveCoordinator_OnEndOfStage_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		params.isRestart = isRestart;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.Multicast_OnSingleObjectiveCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      objectiveActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsFinalObjective                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRemoveFromRemainingList                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBaseObjectiveCoordinator::Multicast_OnSingleObjectiveCompleted(class AActor* Player, class AActor* objectiveActor, bool IsFinalObjective, bool bRemoveFromRemainingList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.Multicast_OnSingleObjectiveCompleted");
		
		ARBBaseObjectiveCoordinator_Multicast_OnSingleObjectiveCompleted_Params params {};
		params.Player = Player;
		params.objectiveActor = objectiveActor;
		params.IsFinalObjective = IsFinalObjective;
		params.bRemoveFromRemainingList = bRemoveFromRemainingList;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.Multicast_OnSingleCompletedObjectiveReverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      objectiveActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReaddToRemainingList                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBaseObjectiveCoordinator::Multicast_OnSingleCompletedObjectiveReverted(class AActor* objectiveActor, bool bReaddToRemainingList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.Multicast_OnSingleCompletedObjectiveReverted");
		
		ARBBaseObjectiveCoordinator_Multicast_OnSingleCompletedObjectiveReverted_Params params {};
		params.objectiveActor = objectiveActor;
		params.bReaddToRemainingList = bReaddToRemainingList;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.IsUserFacing
	 * 		Flags  -> ()
	 */
	bool ARBBaseObjectiveCoordinator::IsUserFacing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.IsUserFacing");
		
		ARBBaseObjectiveCoordinator_IsUserFacing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.IsStarted
	 * 		Flags  -> ()
	 */
	bool ARBBaseObjectiveCoordinator::IsStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.IsStarted");
		
		ARBBaseObjectiveCoordinator_IsStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.IsFinalObjective
	 * 		Flags  -> ()
	 */
	bool ARBBaseObjectiveCoordinator::IsFinalObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.IsFinalObjective");
		
		ARBBaseObjectiveCoordinator_IsFinalObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.IsCompleted
	 * 		Flags  -> ()
	 */
	bool ARBBaseObjectiveCoordinator::IsCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.IsCompleted");
		
		ARBBaseObjectiveCoordinator_IsCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.HasIntermediateObjectiveText
	 * 		Flags  -> ()
	 */
	bool ARBBaseObjectiveCoordinator::HasIntermediateObjectiveText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.HasIntermediateObjectiveText");
		
		ARBBaseObjectiveCoordinator_HasIntermediateObjectiveText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.GetMaxCount
	 * 		Flags  -> ()
	 */
	int32_t ARBBaseObjectiveCoordinator::GetMaxCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.GetMaxCount");
		
		ARBBaseObjectiveCoordinator_GetMaxCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.GetMainObjectiveType
	 * 		Flags  -> ()
	 */
	EMainObjectiveType ARBBaseObjectiveCoordinator::GetMainObjectiveType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.GetMainObjectiveType");
		
		ARBBaseObjectiveCoordinator_GetMainObjectiveType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.GetIntermediateObjectivesData
	 * 		Flags  -> ()
	 */
	TArray<struct FIntermediateObjectiveData> ARBBaseObjectiveCoordinator::GetIntermediateObjectivesData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.GetIntermediateObjectivesData");
		
		ARBBaseObjectiveCoordinator_GetIntermediateObjectivesData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.GetGameObjectiveType
	 * 		Flags  -> ()
	 */
	EGameObjectiveType ARBBaseObjectiveCoordinator::GetGameObjectiveType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.GetGameObjectiveType");
		
		ARBBaseObjectiveCoordinator_GetGameObjectiveType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.GetCurrentCompletedCount
	 * 		Flags  -> ()
	 */
	int32_t ARBBaseObjectiveCoordinator::GetCurrentCompletedCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.GetCurrentCompletedCount");
		
		ARBBaseObjectiveCoordinator_GetCurrentCompletedCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.GetCoordinatorName
	 * 		Flags  -> ()
	 */
	class FString ARBBaseObjectiveCoordinator::GetCoordinatorName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.GetCoordinatorName");
		
		ARBBaseObjectiveCoordinator_GetCoordinatorName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.ForceRefreshObjectiveText
	 * 		Flags  -> ()
	 */
	void ARBBaseObjectiveCoordinator::ForceRefreshObjectiveText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.ForceRefreshObjectiveText");
		
		ARBBaseObjectiveCoordinator_ForceRefreshObjectiveText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.FailCoordinator
	 * 		Flags  -> ()
	 */
	void ARBBaseObjectiveCoordinator::FailCoordinator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.FailCoordinator");
		
		ARBBaseObjectiveCoordinator_FailCoordinator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.Event_OnSetupSingleObjectiveActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      objectiveActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBaseObjectiveCoordinator::Event_OnSetupSingleObjectiveActor(class AActor* objectiveActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.Event_OnSetupSingleObjectiveActor");
		
		ARBBaseObjectiveCoordinator_Event_OnSetupSingleObjectiveActor_Params params {};
		params.objectiveActor = objectiveActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.Event_OnCoordinatorStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EObjectiveCoordinatorState                         oldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EObjectiveCoordinatorState                         newState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBaseObjectiveCoordinator::Event_OnCoordinatorStateChanged(EObjectiveCoordinatorState oldState, EObjectiveCoordinatorState newState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.Event_OnCoordinatorStateChanged");
		
		ARBBaseObjectiveCoordinator_Event_OnCoordinatorStateChanged_Params params {};
		params.oldState = oldState;
		params.newState = newState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.Event_OnCleanSingleObjectiveActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      objectiveActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBaseObjectiveCoordinator::Event_OnCleanSingleObjectiveActor(class AActor* objectiveActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.Event_OnCleanSingleObjectiveActor");
		
		ARBBaseObjectiveCoordinator_Event_OnCleanSingleObjectiveActor_Params params {};
		params.objectiveActor = objectiveActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.Editor_RebuildMissionObjectiveIndexes
	 * 		Flags  -> ()
	 */
	void ARBBaseObjectiveCoordinator::Editor_RebuildMissionObjectiveIndexes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.Editor_RebuildMissionObjectiveIndexes");
		
		ARBBaseObjectiveCoordinator_Editor_RebuildMissionObjectiveIndexes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.CompleteCoordinator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               forceCompletion                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBaseObjectiveCoordinator::CompleteCoordinator(bool forceCompletion)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.CompleteCoordinator");
		
		ARBBaseObjectiveCoordinator_CompleteCoordinator_Params params {};
		params.forceCompletion = forceCompletion;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.BP_ShouldShowObjectiveInHUD
	 * 		Flags  -> ()
	 */
	bool ARBBaseObjectiveCoordinator::BP_ShouldShowObjectiveInHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.BP_ShouldShowObjectiveInHUD");
		
		ARBBaseObjectiveCoordinator_BP_ShouldShowObjectiveInHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.BP_ShouldShowContinuousProgress
	 * 		Flags  -> ()
	 */
	bool ARBBaseObjectiveCoordinator::BP_ShouldShowContinuousProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.BP_ShouldShowContinuousProgress");
		
		ARBBaseObjectiveCoordinator_BP_ShouldShowContinuousProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.BP_HasContinuousProgress
	 * 		Flags  -> ()
	 */
	bool ARBBaseObjectiveCoordinator::BP_HasContinuousProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.BP_HasContinuousProgress");
		
		ARBBaseObjectiveCoordinator_BP_HasContinuousProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.BP_GetRemainingObjectiveCount
	 * 		Flags  -> ()
	 */
	int32_t ARBBaseObjectiveCoordinator::BP_GetRemainingObjectiveCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.BP_GetRemainingObjectiveCount");
		
		ARBBaseObjectiveCoordinator_BP_GetRemainingObjectiveCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.BP_GetRemainingObjectiveActors
	 * 		Flags  -> ()
	 */
	TArray<class AActor*> ARBBaseObjectiveCoordinator::BP_GetRemainingObjectiveActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.BP_GetRemainingObjectiveActors");
		
		ARBBaseObjectiveCoordinator_BP_GetRemainingObjectiveActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.BP_GetObjectiveMaxCount
	 * 		Flags  -> ()
	 */
	int32_t ARBBaseObjectiveCoordinator::BP_GetObjectiveMaxCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.BP_GetObjectiveMaxCount");
		
		ARBBaseObjectiveCoordinator_BP_GetObjectiveMaxCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.BP_GetObjectiveLevelText
	 * 		Flags  -> ()
	 */
	class FText ARBBaseObjectiveCoordinator::BP_GetObjectiveLevelText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.BP_GetObjectiveLevelText");
		
		ARBBaseObjectiveCoordinator_BP_GetObjectiveLevelText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.BP_GetFailedSound
	 * 		Flags  -> ()
	 */
	class UAkAudioEvent* ARBBaseObjectiveCoordinator::BP_GetFailedSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.BP_GetFailedSound");
		
		ARBBaseObjectiveCoordinator_BP_GetFailedSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.BP_GetAllValidPrimaryObjectiveActors
	 * 		Flags  -> ()
	 */
	TArray<class AActor*> ARBBaseObjectiveCoordinator::BP_GetAllValidPrimaryObjectiveActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.BP_GetAllValidPrimaryObjectiveActors");
		
		ARBBaseObjectiveCoordinator_BP_GetAllValidPrimaryObjectiveActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBaseObjectiveCoordinator.BP_CompleteSingleObjective
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      objectiveActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBaseObjectiveCoordinator::BP_CompleteSingleObjective(class ARBPawn* Player, class AActor* objectiveActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBaseObjectiveCoordinator.BP_CompleteSingleObjective");
		
		ARBBaseObjectiveCoordinator_BP_CompleteSingleObjective_Params params {};
		params.Player = Player;
		params.objectiveActor = objectiveActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBBaseObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBBaseObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBaseObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.Tick_Pushable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBasePushable::Tick_Pushable(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.Tick_Pushable");
		
		ARBBasePushable_Tick_Pushable_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.Tick_NonPushable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBasePushable::Tick_NonPushable(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.Tick_NonPushable");
		
		ARBBasePushable_Tick_NonPushable_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.SetIsHardToPush
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHardToPushValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBasePushable::SetIsHardToPush(bool bHardToPushValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.SetIsHardToPush");
		
		ARBBasePushable_SetIsHardToPush_Params params {};
		params.bHardToPushValue = bHardToPushValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.SetInteractionsEnabled_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBasePushable::SetInteractionsEnabled_Server(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.SetInteractionsEnabled_Server");
		
		ARBBasePushable_SetInteractionsEnabled_Server_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.OnRep_PushableInitialReplication
	 * 		Flags  -> ()
	 */
	void ARBBasePushable::OnRep_PushableInitialReplication()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.OnRep_PushableInitialReplication");
		
		ARBBasePushable_OnRep_PushableInitialReplication_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.OnRep_KeepTickingWithNoPushingPawns
	 * 		Flags  -> ()
	 */
	void ARBBasePushable::OnRep_KeepTickingWithNoPushingPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.OnRep_KeepTickingWithNoPushingPawns");
		
		ARBBasePushable_OnRep_KeepTickingWithNoPushingPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.OnRep_CanBePushed
	 * 		Flags  -> ()
	 */
	void ARBBasePushable::OnRep_CanBePushed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.OnRep_CanBePushed");
		
		ARBBasePushable_OnRep_CanBePushed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.Multicast_ShakePushable
	 * 		Flags  -> ()
	 */
	void ARBBasePushable::Multicast_ShakePushable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.Multicast_ShakePushable");
		
		ARBBasePushable_Multicast_ShakePushable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.Multicast_PushableStuck
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFromCollision                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBasePushable::Multicast_PushableStuck(bool bFromCollision)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.Multicast_PushableStuck");
		
		ARBBasePushable_Multicast_PushableStuck_Params params {};
		params.bFromCollision = bFromCollision;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.IsMoving
	 * 		Flags  -> ()
	 */
	bool ARBBasePushable::IsMoving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.IsMoving");
		
		ARBBasePushable_IsMoving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.IsConsideredMoving
	 * 		Flags  -> ()
	 */
	bool ARBBasePushable::IsConsideredMoving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.IsConsideredMoving");
		
		ARBBasePushable_IsConsideredMoving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.GetLedgeMarkerClosestTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBLedgeMarker* ARBBasePushable::GetLedgeMarkerClosestTo(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.GetLedgeMarkerClosestTo");
		
		ARBBasePushable_GetLedgeMarkerClosestTo_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.Event_ShakePushable
	 * 		Flags  -> ()
	 */
	void ARBBasePushable::Event_ShakePushable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.Event_ShakePushable");
		
		ARBBasePushable_Event_ShakePushable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.Event_OnPawnPushingChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPushableComponent*                        pushableComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBasePushable::Event_OnPawnPushingChanged(class URBPushableComponent* pushableComponent, class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.Event_OnPawnPushingChanged");
		
		ARBBasePushable_Event_OnPawnPushingChanged_Params params {};
		params.pushableComponent = pushableComponent;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.Event_OnCanBePushedChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               canBePushed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBasePushable::Event_OnCanBePushedChanged(bool canBePushed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.Event_OnCanBePushedChanged");
		
		ARBBasePushable_Event_OnCanBePushedChanged_Params params {};
		params.canBePushed = canBePushed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.BP_SetKeepTickingWithNoPushingPawns
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bKeepTicking                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBasePushable::BP_SetKeepTickingWithNoPushingPawns(bool bKeepTicking)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.BP_SetKeepTickingWithNoPushingPawns");
		
		ARBBasePushable_BP_SetKeepTickingWithNoPushingPawns_Params params {};
		params.bKeepTicking = bKeepTicking;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.BP_SetCustomUninteractableText_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Text                                                       (Parm, NativeAccessSpecifierPublic)
	 */
	void ARBBasePushable::BP_SetCustomUninteractableText_Server(const class FText& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.BP_SetCustomUninteractableText_Server");
		
		ARBBasePushable_BP_SetCustomUninteractableText_Server_Params params {};
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.BP_SetCustomPushSpeed_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              walkSpeed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              runSpeed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBasePushable::BP_SetCustomPushSpeed_Server(float walkSpeed, float runSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.BP_SetCustomPushSpeed_Server");
		
		ARBBasePushable_BP_SetCustomPushSpeed_Server_Params params {};
		params.walkSpeed = walkSpeed;
		params.runSpeed = runSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.BP_SetCanBePushed_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBasePushable::BP_SetCanBePushed_Server(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.BP_SetCanBePushed_Server");
		
		ARBBasePushable_BP_SetCanBePushed_Server_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.BP_PostMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     DeltaLocation                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBasePushable::BP_PostMove(const struct FVector& DeltaLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.BP_PostMove");
		
		ARBBasePushable_BP_PostMove_Params params {};
		params.DeltaLocation = DeltaLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.BP_GetPawnsPushing
	 * 		Flags  -> ()
	 */
	TArray<class ARBPawn*> ARBBasePushable::BP_GetPawnsPushing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.BP_GetPawnsPushing");
		
		ARBBasePushable_BP_GetPawnsPushing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.BP_ClearCustomUninteractableText_Server
	 * 		Flags  -> ()
	 */
	void ARBBasePushable::BP_ClearCustomUninteractableText_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.BP_ClearCustomUninteractableText_Server");
		
		ARBBasePushable_BP_ClearCustomUninteractableText_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBasePushable.BP_ClearCustomPush_Server
	 * 		Flags  -> ()
	 */
	void ARBBasePushable::BP_ClearCustomPush_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBasePushable.BP_ClearCustomPush_Server");
		
		ARBBasePushable_BP_ClearCustomPush_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBBasePushable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBBasePushable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBasePushable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractibleContainer.SnapToState_Implementation
	 * 		Flags  -> ()
	 */
	void ARBInteractibleContainer::SnapToState_Implementation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractibleContainer.SnapToState_Implementation");
		
		ARBInteractibleContainer_SnapToState_Implementation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractibleContainer.OpenContainer
	 * 		Flags  -> ()
	 */
	void ARBInteractibleContainer::OpenContainer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractibleContainer.OpenContainer");
		
		ARBInteractibleContainer_OpenContainer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractibleContainer.OnRep_PawnInteracting
	 * 		Flags  -> ()
	 */
	void ARBInteractibleContainer::OnRep_PawnInteracting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractibleContainer.OnRep_PawnInteracting");
		
		ARBInteractibleContainer_OnRep_PawnInteracting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractibleContainer.OnRep_LinkedLockingPanel
	 * 		Flags  -> ()
	 */
	void ARBInteractibleContainer::OnRep_LinkedLockingPanel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractibleContainer.OnRep_LinkedLockingPanel");
		
		ARBInteractibleContainer_OnRep_LinkedLockingPanel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractibleContainer.OnRep_IsOpened
	 * 		Flags  -> ()
	 */
	void ARBInteractibleContainer::OnRep_IsOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractibleContainer.OnRep_IsOpened");
		
		ARBInteractibleContainer_OnRep_IsOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractibleContainer.OnPawnInteractingChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractibleContainer::OnPawnInteractingChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractibleContainer.OnPawnInteractingChangedCallback");
		
		ARBInteractibleContainer_OnPawnInteractingChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractibleContainer.OnPanelUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     pawnInteracting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractibleContainer::OnPanelUnlocked(class URBInteractiblePanelComponent* panel, class ARBPawn* pawnInteracting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractibleContainer.OnPanelUnlocked");
		
		ARBInteractibleContainer_OnPanelUnlocked_Params params {};
		params.panel = panel;
		params.pawnInteracting = pawnInteracting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractibleContainer.OnNumberOfProjectileHitsChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBDamageableComponent*                      damageable                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractibleContainer::OnNumberOfProjectileHitsChanged(class URBDamageableComponent* damageable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractibleContainer.OnNumberOfProjectileHitsChanged");
		
		ARBInteractibleContainer_OnNumberOfProjectileHitsChanged_Params params {};
		params.damageable = damageable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractibleContainer.IsOpenedChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractibleContainer::IsOpenedChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractibleContainer.IsOpenedChangedCallback");
		
		ARBInteractibleContainer_IsOpenedChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractibleContainer.GivesFocusTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactorPawn                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBInteractionZoneComponent* ARBInteractibleContainer::GivesFocusTo(class ARBPawn* interactorPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractibleContainer.GivesFocusTo");
		
		ARBInteractibleContainer_GivesFocusTo_Params params {};
		params.interactorPawn = interactorPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractibleContainer.Event_SpawnLock
	 * 		Flags  -> ()
	 */
	void ARBInteractibleContainer::Event_SpawnLock()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractibleContainer.Event_SpawnLock");
		
		ARBInteractibleContainer_Event_SpawnLock_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractibleContainer.Event_OnPanelUnlocked
	 * 		Flags  -> ()
	 */
	void ARBInteractibleContainer::Event_OnPanelUnlocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractibleContainer.Event_OnPanelUnlocked");
		
		ARBInteractibleContainer_Event_OnPanelUnlocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractibleContainer.Event_OnIsOpenedChanged
	 * 		Flags  -> ()
	 */
	void ARBInteractibleContainer::Event_OnIsOpenedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractibleContainer.Event_OnIsOpenedChanged");
		
		ARBInteractibleContainer_Event_OnIsOpenedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBInteractibleContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBInteractibleContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInteractibleContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBBaseQuestItemContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBBaseQuestItemContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBaseQuestItemContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHidespotComponent.OnRep_PouncerEntered
	 * 		Flags  -> ()
	 */
	void URBHidespotComponent::OnRep_PouncerEntered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHidespotComponent.OnRep_PouncerEntered");
		
		URBHidespotComponent_OnRep_PouncerEntered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHidespotComponent.OnRep_PawnInteracting
	 * 		Flags  -> ()
	 */
	void URBHidespotComponent::OnRep_PawnInteracting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHidespotComponent.OnRep_PawnInteracting");
		
		URBHidespotComponent_OnRep_PawnInteracting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHidespotComponent.OnRep_PawnHiddenInside
	 * 		Flags  -> ()
	 */
	void URBHidespotComponent::OnRep_PawnHiddenInside()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHidespotComponent.OnRep_PawnHiddenInside");
		
		URBHidespotComponent_OnRep_PawnHiddenInside_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHidespotComponent.OnRep_Disabled
	 * 		Flags  -> ()
	 */
	void URBHidespotComponent::OnRep_Disabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHidespotComponent.OnRep_Disabled");
		
		URBHidespotComponent_OnRep_Disabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHidespotComponent.OnPawnInteractingChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHidespotComponent::OnPawnInteractingChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHidespotComponent.OnPawnInteractingChangedCallback");
		
		URBHidespotComponent_OnPawnInteractingChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHidespotComponent.OnPawnHiddenInsideChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHidespotComponent::OnPawnHiddenInsideChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHidespotComponent.OnPawnHiddenInsideChangedCallback");
		
		URBHidespotComponent_OnPawnHiddenInsideChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHidespotComponent.IsHidespotEnabled
	 * 		Flags  -> ()
	 */
	bool URBHidespotComponent::IsHidespotEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHidespotComponent.IsHidespotEnabled");
		
		URBHidespotComponent_IsHidespotEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHidespotComponent.InitializeClearanceBoxes
	 * 		Flags  -> ()
	 */
	void URBHidespotComponent::InitializeClearanceBoxes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHidespotComponent.InitializeClearanceBoxes");
		
		URBHidespotComponent_InitializeClearanceBoxes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHidespotComponent.FixUpPouncer
	 * 		Flags  -> ()
	 */
	void URBHidespotComponent::FixUpPouncer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHidespotComponent.FixUpPouncer");
		
		URBHidespotComponent_FixUpPouncer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHidespotComponent.BP_DisableHidespot
	 * 		Flags  -> ()
	 */
	void URBHidespotComponent::BP_DisableHidespot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHidespotComponent.BP_DisableHidespot");
		
		URBHidespotComponent_BP_DisableHidespot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHidespotComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHidespotComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHidespotComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBBedHidespotComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBBedHidespotComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBedHidespotComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.SnapToState
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::SnapToState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.SnapToState");
		
		ARBTriggerable_SnapToState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.ShouldBPTick
	 * 		Flags  -> ()
	 */
	bool ARBTriggerable::ShouldBPTick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.ShouldBPTick");
		
		ARBTriggerable_ShouldBPTick_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.RebuildGroupedOperatable
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::RebuildGroupedOperatable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.RebuildGroupedOperatable");
		
		ARBTriggerable_RebuildGroupedOperatable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.OnRep_TriggeredCallback
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::OnRep_TriggeredCallback()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.OnRep_TriggeredCallback");
		
		ARBTriggerable_OnRep_TriggeredCallback_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.OnRep_Triggered
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::OnRep_Triggered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.OnRep_Triggered");
		
		ARBTriggerable_OnRep_Triggered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.Multicast_StartUntriggerSequence
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::Multicast_StartUntriggerSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.Multicast_StartUntriggerSequence");
		
		ARBTriggerable_Multicast_StartUntriggerSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.Multicast_StartTriggerSequence
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::Multicast_StartTriggerSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.Multicast_StartTriggerSequence");
		
		ARBTriggerable_Multicast_StartTriggerSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.Event_SnapToState
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::Event_SnapToState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.Event_SnapToState");
		
		ARBTriggerable_Event_SnapToState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.Event_OnUntriggerSequenceStarted
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::Event_OnUntriggerSequenceStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.Event_OnUntriggerSequenceStarted");
		
		ARBTriggerable_Event_OnUntriggerSequenceStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.Event_OnUntriggered
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::Event_OnUntriggered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.Event_OnUntriggered");
		
		ARBTriggerable_Event_OnUntriggered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.Event_OnTriggerSequenceStarted
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::Event_OnTriggerSequenceStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.Event_OnTriggerSequenceStarted");
		
		ARBTriggerable_Event_OnTriggerSequenceStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.Event_OnTriggered
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::Event_OnTriggered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.Event_OnTriggered");
		
		ARBTriggerable_Event_OnTriggered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.Event_OnOperatableUncompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     operatable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerable::Event_OnOperatableUncompleted(class UObject* operatable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.Event_OnOperatableUncompleted");
		
		ARBTriggerable_Event_OnOperatableUncompleted_Params params {};
		params.operatable = operatable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.Event_OnOperatableProgressChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     operatable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              oldProgress                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              currentProgress                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSnap                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerable::Event_OnOperatableProgressChanged(class UObject* operatable, float oldProgress, float currentProgress, bool bSnap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.Event_OnOperatableProgressChanged");
		
		ARBTriggerable_Event_OnOperatableProgressChanged_Params params {};
		params.operatable = operatable;
		params.oldProgress = oldProgress;
		params.currentProgress = currentProgress;
		params.bSnap = bSnap;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.Event_OnOperatableCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     operatable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerable::Event_OnOperatableCompleted(class UObject* operatable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.Event_OnOperatableCompleted");
		
		ARBTriggerable_Event_OnOperatableCompleted_Params params {};
		params.operatable = operatable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.BP_SnapToTriggeredState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               triggered                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerable::BP_SnapToTriggeredState(bool triggered)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.BP_SnapToTriggeredState");
		
		ARBTriggerable_BP_SnapToTriggeredState_Params params {};
		params.triggered = triggered;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.BP_SetStartsTriggered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bTriggered                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerable::BP_SetStartsTriggered(bool bTriggered)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.BP_SetStartsTriggered");
		
		ARBTriggerable_BP_SetStartsTriggered_Params params {};
		params.bTriggered = bTriggered;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.BP_SetShowInDebug
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowInDebugValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerable::BP_SetShowInDebug(bool bShowInDebugValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.BP_SetShowInDebug");
		
		ARBTriggerable_BP_SetShowInDebug_Params params {};
		params.bShowInDebugValue = bShowInDebugValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.BP_SetOverrideOperatable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBOperatable*                               operatable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerable::BP_SetOverrideOperatable(class ARBOperatable* operatable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.BP_SetOverrideOperatable");
		
		ARBTriggerable_BP_SetOverrideOperatable_Params params {};
		params.operatable = operatable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.BP_RemoveOperatableToComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     operatable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerable::BP_RemoveOperatableToComplete(class UObject* operatable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.BP_RemoveOperatableToComplete");
		
		ARBTriggerable_BP_RemoveOperatableToComplete_Params params {};
		params.operatable = operatable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.BP_RefreshLinkedLedges
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::BP_RefreshLinkedLedges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.BP_RefreshLinkedLedges");
		
		ARBTriggerable_BP_RefreshLinkedLedges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.BP_OnUntriggerSequenceCompleted
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::BP_OnUntriggerSequenceCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.BP_OnUntriggerSequenceCompleted");
		
		ARBTriggerable_BP_OnUntriggerSequenceCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.BP_OnTriggerSequenceCompleted
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::BP_OnTriggerSequenceCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.BP_OnTriggerSequenceCompleted");
		
		ARBTriggerable_BP_OnTriggerSequenceCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.BP_ForceUntrigger
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::BP_ForceUntrigger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.BP_ForceUntrigger");
		
		ARBTriggerable_BP_ForceUntrigger_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.BP_ForceTrigger
	 * 		Flags  -> ()
	 */
	void ARBTriggerable::BP_ForceTrigger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.BP_ForceTrigger");
		
		ARBTriggerable_BP_ForceTrigger_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.BP_ForceState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bTrigger                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerable::BP_ForceState(bool bTrigger)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.BP_ForceState");
		
		ARBTriggerable_BP_ForceState_Params params {};
		params.bTrigger = bTrigger;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.BP_AreAllOperatablesCompleted
	 * 		Flags  -> ()
	 */
	bool ARBTriggerable::BP_AreAllOperatablesCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.BP_AreAllOperatablesCompleted");
		
		ARBTriggerable_BP_AreAllOperatablesCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerable.BP_AddOperatableToComplete
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTriggerableSetting                         triggerSetting                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerable::BP_AddOperatableToComplete(const struct FTriggerableSetting& triggerSetting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerable.BP_AddOperatableToComplete");
		
		ARBTriggerable_BP_AddOperatableToComplete_Params params {};
		params.triggerSetting = triggerSetting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTriggerable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTriggerable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTriggerable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlacklight.Event_SetupPPVolume
	 * 		Flags  -> ()
	 */
	void ARBBlacklight::Event_SetupPPVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlacklight.Event_SetupPPVolume");
		
		ARBBlacklight_Event_SetupPPVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBBlacklight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBBlacklight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBlacklight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlockable.GetBlockableState
	 * 		Flags  -> ()
	 */
	EBlockableState URBBlockable::GetBlockableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlockable.GetBlockableState");
		
		URBBlockable_GetBlockableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBBlockable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBBlockable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBlockable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlockingVolume.SetBlockingState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewBlockNPCs                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNewBlockPlayers                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBlockingVolume::SetBlockingState(bool bNewBlockNPCs, bool bNewBlockPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlockingVolume.SetBlockingState");
		
		ARBBlockingVolume_SetBlockingState_Params params {};
		params.bNewBlockNPCs = bNewBlockNPCs;
		params.bNewBlockPlayers = bNewBlockPlayers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlockingVolume.OnRep_PropertyChanged
	 * 		Flags  -> ()
	 */
	void ARBBlockingVolume::OnRep_PropertyChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlockingVolume.OnRep_PropertyChanged");
		
		ARBBlockingVolume_OnRep_PropertyChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlockingVolume.GetEnabled
	 * 		Flags  -> ()
	 */
	bool ARBBlockingVolume::GetEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlockingVolume.GetEnabled");
		
		ARBBlockingVolume_GetEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlockingVolume.GetBlockVisibility
	 * 		Flags  -> ()
	 */
	bool ARBBlockingVolume::GetBlockVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlockingVolume.GetBlockVisibility");
		
		ARBBlockingVolume_GetBlockVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlockingVolume.GetBlockPlayers
	 * 		Flags  -> ()
	 */
	bool ARBBlockingVolume::GetBlockPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlockingVolume.GetBlockPlayers");
		
		ARBBlockingVolume_GetBlockPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlockingVolume.GetBlockNPCs
	 * 		Flags  -> ()
	 */
	bool ARBBlockingVolume::GetBlockNPCs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlockingVolume.GetBlockNPCs");
		
		ARBBlockingVolume_GetBlockNPCs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlockingVolume.GetBlockInteractions
	 * 		Flags  -> ()
	 */
	bool ARBBlockingVolume::GetBlockInteractions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlockingVolume.GetBlockInteractions");
		
		ARBBlockingVolume_GetBlockInteractions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlockingVolume.EnableBlockingVolume
	 * 		Flags  -> ()
	 */
	void ARBBlockingVolume::EnableBlockingVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlockingVolume.EnableBlockingVolume");
		
		ARBBlockingVolume_EnableBlockingVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlockingVolume.DisableBlockingVolume
	 * 		Flags  -> ()
	 */
	void ARBBlockingVolume::DisableBlockingVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlockingVolume.DisableBlockingVolume");
		
		ARBBlockingVolume_DisableBlockingVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBBlockingVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBBlockingVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBlockingVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Warning
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      warningText                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Warning(const class FString& warningText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Warning");
		
		URBBlueprintLibrary_Warning_Params params {};
		params.warningText = warningText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.WaitForPlayerConditions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRBPlayerConditionSet                       conditionSet                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::WaitForPlayerConditions(class ARBPlayer* Player, const struct FLatentActionInfo& LatentInfo, const struct FRBPlayerConditionSet& conditionSet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.WaitForPlayerConditions");
		
		URBBlueprintLibrary_WaitForPlayerConditions_Params params {};
		params.Player = Player;
		params.LatentInfo = LatentInfo;
		params.conditionSet = conditionSet;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.UnblockPlayerRespawnInStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     blockOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::UnblockPlayerRespawnInStage(class UObject* blockOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.UnblockPlayerRespawnInStage");
		
		URBBlueprintLibrary_UnblockPlayerRespawnInStage_Params params {};
		params.blockOwner = blockOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ToString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUniqueNetIdRepl                            UniqueId                                                   (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBBlueprintLibrary::ToString(const struct FUniqueNetIdRepl& UniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ToString");
		
		URBBlueprintLibrary_ToString_Params params {};
		params.UniqueId = UniqueId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ToggleLedgeMarkerOnActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::ToggleLedgeMarkerOnActor(class AActor* Actor, bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ToggleLedgeMarkerOnActor");
		
		URBBlueprintLibrary_ToggleLedgeMarkerOnActor_Params params {};
		params.Actor = Actor;
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ToggleDebugMenu
	 * 		Flags  -> ()
	 */
	UFunction* fnToggleDebugMenu = nullptr;
	UClass* ToggleDebugMenuClass = nullptr;
	void URBBlueprintLibrary::ToggleDebugMenu()
	{
		if (!fnToggleDebugMenu)
			fnToggleDebugMenu = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ToggleDebugMenu");
		
		URBBlueprintLibrary_ToggleDebugMenu_Params params {};
		
		if(ToggleDebugMenuClass == nullptr)
			ToggleDebugMenuClass = UObject::FindClass("Class OPP.RBBlueprintLibrary");

		ToggleDebugMenuClass->ProcessEvent(fnToggleDebugMenu, &params);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ToggleActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::ToggleActor(class AActor* Actor, bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ToggleActor");
		
		URBBlueprintLibrary_ToggleActor_Params params {};
		params.Actor = Actor;
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.TestPlayerConditions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBoolCommandResult                                 operationResult                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBPlayerConditionSet                       conditionSet                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::TestPlayerConditions(class ARBPlayer* Player, EBoolCommandResult* operationResult, const struct FRBPlayerConditionSet& conditionSet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.TestPlayerConditions");
		
		URBBlueprintLibrary_TestPlayerConditions_Params params {};
		params.Player = Player;
		params.conditionSet = conditionSet;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (operationResult != nullptr)
			*operationResult = params.operationResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.TeleportRelative
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      sourceReference                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetReference                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseTransitionFX                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::TeleportRelative(class ARBPlayer* Player, class AActor* sourceReference, class AActor* TargetReference, bool bUseTransitionFX)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.TeleportRelative");
		
		URBBlueprintLibrary_TeleportRelative_Params params {};
		params.Player = Player;
		params.sourceReference = sourceReference;
		params.TargetReference = TargetReference;
		params.bUseTransitionFX = bUseTransitionFX;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.TeleportPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      targetLocation                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseTransitionFX                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseTargetForRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterruptAction                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::TeleportPlayer(class ARBPlayer* Player, class AActor* targetLocation, bool bUseTransitionFX, bool bUseTargetForRotation, bool bInterruptAction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.TeleportPlayer");
		
		URBBlueprintLibrary_TeleportPlayer_Params params {};
		params.Player = Player;
		params.targetLocation = targetLocation;
		params.bUseTransitionFX = bUseTransitionFX;
		params.bUseTargetForRotation = bUseTargetForRotation;
		params.bInterruptAction = bInterruptAction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SwitchLevelRandomN
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomizerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxOptions                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERandomSwitch10                                    randomSwitch                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SwitchLevelRandomN(int32_t RandomizerId, int32_t maxOptions, ERandomSwitch10* randomSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SwitchLevelRandomN");
		
		URBBlueprintLibrary_SwitchLevelRandomN_Params params {};
		params.RandomizerId = RandomizerId;
		params.maxOptions = maxOptions;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (randomSwitch != nullptr)
			*randomSwitch = params.randomSwitch;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SwitchLevelRandom5
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomizerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERandomSwitch5                                     randomSwitch                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SwitchLevelRandom5(int32_t RandomizerId, ERandomSwitch5* randomSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SwitchLevelRandom5");
		
		URBBlueprintLibrary_SwitchLevelRandom5_Params params {};
		params.RandomizerId = RandomizerId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (randomSwitch != nullptr)
			*randomSwitch = params.randomSwitch;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SwitchLevelRandom4
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomizerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERandomSwitch4                                     randomSwitch                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SwitchLevelRandom4(int32_t RandomizerId, ERandomSwitch4* randomSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SwitchLevelRandom4");
		
		URBBlueprintLibrary_SwitchLevelRandom4_Params params {};
		params.RandomizerId = RandomizerId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (randomSwitch != nullptr)
			*randomSwitch = params.randomSwitch;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SwitchLevelRandom3
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomizerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERandomSwitch3                                     randomSwitch                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SwitchLevelRandom3(int32_t RandomizerId, ERandomSwitch3* randomSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SwitchLevelRandom3");
		
		URBBlueprintLibrary_SwitchLevelRandom3_Params params {};
		params.RandomizerId = RandomizerId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (randomSwitch != nullptr)
			*randomSwitch = params.randomSwitch;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SwitchLevelRandom2
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomizerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERandomSwitch2                                     randomSwitch                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SwitchLevelRandom2(int32_t RandomizerId, ERandomSwitch2* randomSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SwitchLevelRandom2");
		
		URBBlueprintLibrary_SwitchLevelRandom2_Params params {};
		params.RandomizerId = RandomizerId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (randomSwitch != nullptr)
			*randomSwitch = params.randomSwitch;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.StopPsychosisOnAllPlayers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFadeOut                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::StopPsychosisOnAllPlayers(bool bFadeOut)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.StopPsychosisOnAllPlayers");
		
		URBBlueprintLibrary_StopPsychosisOnAllPlayers_Params params {};
		params.bFadeOut = bFadeOut;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.StopMusicTrack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               StartEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               StopEvent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bResumeLevelMusic                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::StopMusicTrack(class UAkAudioEvent* StartEvent, class UAkAudioEvent* StopEvent, bool bResumeLevelMusic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.StopMusicTrack");
		
		URBBlueprintLibrary_StopMusicTrack_Params params {};
		params.StartEvent = StartEvent;
		params.StopEvent = StopEvent;
		params.bResumeLevelMusic = bResumeLevelMusic;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.StopLoopingSoundOnActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               StartAkEvent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               StopAkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::StopLoopingSoundOnActor(class UAkAudioEvent* StartAkEvent, class UAkAudioEvent* StopAkEvent, class UObject* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.StopLoopingSoundOnActor");
		
		URBBlueprintLibrary_StopLoopingSoundOnActor_Params params {};
		params.StartAkEvent = StartAkEvent;
		params.StopAkEvent = StopAkEvent;
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.StopAllTimersOnObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     timerOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::StopAllTimersOnObject(class UObject* timerOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.StopAllTimersOnObject");
		
		URBBlueprintLibrary_StopAllTimersOnObject_Params params {};
		params.timerOwner = timerOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.StopAllMusic
	 * 		Flags  -> ()
	 */
	void URBBlueprintLibrary::StopAllMusic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.StopAllMusic");
		
		URBBlueprintLibrary_StopAllMusic_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.StartPsychosisOnAllPlayers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBHalluCfg_Psychosis*                       psychosisConfig                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Force                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::StartPsychosisOnAllPlayers(class URBHalluCfg_Psychosis* psychosisConfig, bool Force)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.StartPsychosisOnAllPlayers");
		
		URBBlueprintLibrary_StartPsychosisOnAllPlayers_Params params {};
		params.psychosisConfig = psychosisConfig;
		params.Force = Force;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SortCompareString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      stringA                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      stringB                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::SortCompareString(const class FString& stringA, const class FString& stringB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SortCompareString");
		
		URBBlueprintLibrary_SortCompareString_Params params {};
		params.stringA = stringA;
		params.stringB = stringB;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SortCompareActorsByName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      actorA                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      actorB                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::SortCompareActorsByName(class AActor* actorA, class AActor* actorB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SortCompareActorsByName");
		
		URBBlueprintLibrary_SortCompareActorsByName_Params params {};
		params.actorA = actorA;
		params.actorB = actorB;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SortByName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UObject*>                             inObjects                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	TArray<class UObject*> URBBlueprintLibrary::SortByName(TArray<class UObject*> inObjects)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SortByName");
		
		URBBlueprintLibrary_SortByName_Params params {};
		params.inObjects = inObjects;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ShowObjectiveMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               playSounds                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::ShowObjectiveMessage(class UObject* WorldContextObject, const class FText& Message, float duration, bool playSounds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ShowObjectiveMessage");
		
		URBBlueprintLibrary_ShowObjectiveMessage_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Message = Message;
		params.duration = duration;
		params.playSounds = playSounds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ShowInteractionMessageToAllPlayers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EMessagePriority                                   Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::ShowInteractionMessageToAllPlayers(const class FText& Message, EMessagePriority Priority, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ShowInteractionMessageToAllPlayers");
		
		URBBlueprintLibrary_ShowInteractionMessageToAllPlayers_Params params {};
		params.Message = Message;
		params.Priority = Priority;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ShowInteractionMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EMessagePriority                                   Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::ShowInteractionMessage(class ARBPlayer* Player, const class FText& Message, EMessagePriority Priority, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ShowInteractionMessage");
		
		URBBlueprintLibrary_ShowInteractionMessage_Params params {};
		params.Player = Player;
		params.Message = Message;
		params.Priority = Priority;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetupMasterPose
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      MasterPoseComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SetupMasterPose(class USkeletalMeshComponent* MasterPoseComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetupMasterPose");
		
		URBBlueprintLibrary_SetupMasterPose_Params params {};
		params.MasterPoseComponent = MasterPoseComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetupDisabledHidespotMeshesCollision
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             disabledRoot                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SetupDisabledHidespotMeshesCollision(class USceneComponent* disabledRoot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetupDisabledHidespotMeshesCollision");
		
		URBBlueprintLibrary_SetupDisabledHidespotMeshesCollision_Params params {};
		params.disabledRoot = disabledRoot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetupDisabledHidespotMeshCollision
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         disableMeshComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SetupDisabledHidespotMeshCollision(class UPrimitiveComponent* disableMeshComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetupDisabledHidespotMeshCollision");
		
		URBBlueprintLibrary_SetupDisabledHidespotMeshCollision_Params params {};
		params.disableMeshComponent = disableMeshComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetNVBattery
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	UFunction* fnSetNVBattery = nullptr;
	UClass* fnSetNVBatteryClass = nullptr;
	void URBBlueprintLibrary::SetNVBattery(class ARBPlayer* Player, float Value)
	{
		if (!fnSetNVBattery)
			fnSetNVBattery = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetNVBattery");
		
		URBBlueprintLibrary_SetNVBattery_Params params {};
		params.Player = Player;
		params.Value = Value;
		
		if (fnSetNVBatteryClass == nullptr)
			fnSetNVBatteryClass = UObject::FindObject<UClass>("Class OPP.RBBlueprintLibrary");
		
		fnSetNVBatteryClass->ProcessEvent(fnSetNVBattery, &params);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetNetworkSyncState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bChain                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SetNetworkSyncState(class AActor* Actor, bool bActive, bool bChain)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetNetworkSyncState");
		
		URBBlueprintLibrary_SetNetworkSyncState_Params params {};
		params.Actor = Actor;
		params.bActive = bActive;
		params.bChain = bChain;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetNarrativeMusicServer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNarrativeSoundEventsInfo                   NarrativeSoundEventsInfo                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bPauseLevelMusic                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SetNarrativeMusicServer(const struct FNarrativeSoundEventsInfo& NarrativeSoundEventsInfo, bool bPauseLevelMusic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetNarrativeMusicServer");
		
		URBBlueprintLibrary_SetNarrativeMusicServer_Params params {};
		params.NarrativeSoundEventsInfo = NarrativeSoundEventsInfo;
		params.bPauseLevelMusic = bPauseLevelMusic;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetNarrativeMusicClient
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNarrativeSoundEventsInfo                   NarrativeSoundEventsInfo                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SetNarrativeMusicClient(const struct FNarrativeSoundEventsInfo& NarrativeSoundEventsInfo, class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetNarrativeMusicClient");
		
		URBBlueprintLibrary_SetNarrativeMusicClient_Params params {};
		params.NarrativeSoundEventsInfo = NarrativeSoundEventsInfo;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetListenAtPlayerLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     requestOwner                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bListenAtPlayerLocation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SetListenAtPlayerLocation(class UObject* requestOwner, bool bListenAtPlayerLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetListenAtPlayerLocation");
		
		URBBlueprintLibrary_SetListenAtPlayerLocation_Params params {};
		params.requestOwner = requestOwner;
		params.bListenAtPlayerLocation = bListenAtPlayerLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetLevelMusic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UAkAudioEvent*>                       StartEvents                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class UAkAudioEvent*>                       StopEvents                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SetLevelMusic(TArray<class UAkAudioEvent*> StartEvents, TArray<class UAkAudioEvent*> StopEvents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetLevelMusic");
		
		URBBlueprintLibrary_SetLevelMusic_Params params {};
		params.StartEvents = StartEvents;
		params.StopEvents = StopEvents;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetHasPlayedTutorialMap
	 * 		Flags  -> ()
	 */
	void URBBlueprintLibrary::SetHasPlayedTutorialMap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetHasPlayedTutorialMap");
		
		URBBlueprintLibrary_SetHasPlayedTutorialMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetHasCompletedReleaseTrial
	 * 		Flags  -> ()
	 */
	void URBBlueprintLibrary::SetHasCompletedReleaseTrial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetHasCompletedReleaseTrial");
		
		URBBlueprintLibrary_SetHasCompletedReleaseTrial_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetForceNoVolumetricLightmapsOnHierarchy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             SceneComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceNoVolumetricLightMap                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SetForceNoVolumetricLightmapsOnHierarchy(class USceneComponent* SceneComponent, bool bForceNoVolumetricLightMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetForceNoVolumetricLightmapsOnHierarchy");
		
		URBBlueprintLibrary_SetForceNoVolumetricLightmapsOnHierarchy_Params params {};
		params.SceneComponent = SceneComponent;
		params.bForceNoVolumetricLightMap = bForceNoVolumetricLightMap;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetCollisionEnabledOnHierarchy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             SceneComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECollisionEnabled                                  NewType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SetCollisionEnabledOnHierarchy(class USceneComponent* SceneComponent, ECollisionEnabled NewType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetCollisionEnabledOnHierarchy");
		
		URBBlueprintLibrary_SetCollisionEnabledOnHierarchy_Params params {};
		params.SceneComponent = SceneComponent;
		params.NewType = NewType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetCanStepUpon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             SceneComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECanBeCharacterBase                                canStepUponValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPropagateToChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SetCanStepUpon(class USceneComponent* SceneComponent, ECanBeCharacterBase canStepUponValue, bool bPropagateToChildren)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetCanStepUpon");
		
		URBBlueprintLibrary_SetCanStepUpon_Params params {};
		params.SceneComponent = SceneComponent;
		params.canStepUponValue = canStepUponValue;
		params.bPropagateToChildren = bPropagateToChildren;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SetActorTemporarilyHiddenInEditor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsHidden                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SetActorTemporarilyHiddenInEditor(class AActor* TargetActor, bool bIsHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SetActorTemporarilyHiddenInEditor");
		
		URBBlueprintLibrary_SetActorTemporarilyHiddenInEditor_Params params {};
		params.TargetActor = TargetActor;
		params.bIsHidden = bIsHidden;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Set3DWidgetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWidgetEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Set3DWidgetEnabled(class AActor* Actor, const class FName& PropertyName, bool bWidgetEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Set3DWidgetEnabled");
		
		URBBlueprintLibrary_Set3DWidgetEnabled_Params params {};
		params.Actor = Actor;
		params.PropertyName = PropertyName;
		params.bWidgetEnabled = bWidgetEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SelectInEditor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SelectInEditor(class AActor* TargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SelectInEditor");
		
		URBBlueprintLibrary_SelectInEditor_Params params {};
		params.TargetActor = TargetActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SelectComponentsInEditor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UActorComponent*>                     Components                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bClearSelection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SelectComponentsInEditor(TArray<class UActorComponent*> Components, bool bClearSelection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SelectComponentsInEditor");
		
		URBBlueprintLibrary_SelectComponentsInEditor_Params params {};
		params.Components = Components;
		params.bClearSelection = bClearSelection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SelectActorsInEditor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              Actors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bClearSelection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SelectActorsInEditor(TArray<class AActor*> Actors, bool bClearSelection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SelectActorsInEditor");
		
		URBBlueprintLibrary_SelectActorsInEditor_Params params {};
		params.Actors = Actors;
		params.bClearSelection = bClearSelection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Select3DWidget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      PropertyName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PropertyIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsPropertyTransform                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Select3DWidget(const class FString& PropertyName, int32_t PropertyIndex, bool bIsPropertyTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Select3DWidget");
		
		URBBlueprintLibrary_Select3DWidget_Params params {};
		params.PropertyName = PropertyName;
		params.PropertyIndex = PropertyIndex;
		params.bIsPropertyTransform = bIsPropertyTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SeekOnEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      in_EventName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkComponent*                                in_pComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              in_fPercent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               in_bSeekToNearestMarker                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::SeekOnEvent(const class FString& in_EventName, class UAkComponent* in_pComponent, float in_fPercent, bool in_bSeekToNearestMarker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SeekOnEvent");
		
		URBBlueprintLibrary_SeekOnEvent_Params params {};
		params.in_EventName = in_EventName;
		params.in_pComponent = in_pComponent;
		params.in_fPercent = in_fPercent;
		params.in_bSeekToNearestMarker = in_bSeekToNearestMarker;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.SaveProfile
	 * 		Flags  -> ()
	 */
	void URBBlueprintLibrary::SaveProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.SaveProfile");
		
		URBBlueprintLibrary_SaveProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.RunConstructionScript
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::RunConstructionScript(class AActor* TargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.RunConstructionScript");
		
		URBBlueprintLibrary_RunConstructionScript_Params params {};
		params.TargetActor = TargetActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.RemovePing
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      pingedActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::RemovePing(class AActor* pingedActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.RemovePing");
		
		URBBlueprintLibrary_RemovePing_Params params {};
		params.pingedActor = pingedActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.RemoveObjectiveIconForSpecificPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      inActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::RemoveObjectiveIconForSpecificPlayer(class ARBPlayer* Player, class AActor* inActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.RemoveObjectiveIconForSpecificPlayer");
		
		URBBlueprintLibrary_RemoveObjectiveIconForSpecificPlayer_Params params {};
		params.Player = Player;
		params.inActor = inActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.RemoveObjectiveIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      inActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::RemoveObjectiveIcon(class AActor* inActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.RemoveObjectiveIcon");
		
		URBBlueprintLibrary_RemoveObjectiveIcon_Params params {};
		params.inActor = inActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.RandomizeActorArray
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomizerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              inActors                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<class AActor*> URBBlueprintLibrary::RandomizeActorArray(int32_t RandomizerId, TArray<class AActor*> inActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.RandomizeActorArray");
		
		URBBlueprintLibrary_RandomizeActorArray_Params params {};
		params.RandomizerId = RandomizerId;
		params.inActors = inActors;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.PrintScreenMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::PrintScreenMessage(const class FString& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.PrintScreenMessage");
		
		URBBlueprintLibrary_PrintScreenMessage_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.PostAudioEventOnGroup_Client
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        GroupName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::PostAudioEventOnGroup_Client(class UAkAudioEvent* akEvent, const class FName& GroupName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.PostAudioEventOnGroup_Client");
		
		URBBlueprintLibrary_PostAudioEventOnGroup_Client_Params params {};
		params.akEvent = akEvent;
		params.GroupName = GroupName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.PlaySingleShotMusicTrack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               musicTrack                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPauseLevelMusic                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::PlaySingleShotMusicTrack(class UAkAudioEvent* musicTrack, bool bPauseLevelMusic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.PlaySingleShotMusicTrack");
		
		URBBlueprintLibrary_PlaySingleShotMusicTrack_Params params {};
		params.musicTrack = musicTrack;
		params.bPauseLevelMusic = bPauseLevelMusic;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.PlayScareStinger
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      scareActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               StingerEvent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::PlayScareStinger(class AActor* scareActor, class UAkAudioEvent* StingerEvent, const struct FVector& Location, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.PlayScareStinger");
		
		URBBlueprintLibrary_PlayScareStinger_Params params {};
		params.scareActor = scareActor;
		params.StingerEvent = StingerEvent;
		params.Location = Location;
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.PlayObjectiveNarrativeScreenAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNarrativeScreenAnimationData               animData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayerDefaultIntro                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::PlayObjectiveNarrativeScreenAnimation(const struct FNarrativeScreenAnimationData& animData, bool bPlayerDefaultIntro)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.PlayObjectiveNarrativeScreenAnimation");
		
		URBBlueprintLibrary_PlayObjectiveNarrativeScreenAnimation_Params params {};
		params.animData = animData;
		params.bPlayerDefaultIntro = bPlayerDefaultIntro;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.PlayMurkoffAnnouncement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBMurkoffAnnouncentData                    announcementData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               StopEvent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              stopDelay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::PlayMurkoffAnnouncement(const struct FRBMurkoffAnnouncentData& announcementData, class UAkAudioEvent* StopEvent, float stopDelay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.PlayMurkoffAnnouncement");
		
		URBBlueprintLibrary_PlayMurkoffAnnouncement_Params params {};
		params.announcementData = announcementData;
		params.StopEvent = StopEvent;
		params.stopDelay = stopDelay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.PlayLoopingSoundOnActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               StartAkEvent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               StopAkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBBlueprintLibrary::PlayLoopingSoundOnActor(class UAkAudioEvent* StartAkEvent, class UAkAudioEvent* StopAkEvent, class UObject* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.PlayLoopingSoundOnActor");
		
		URBBlueprintLibrary_PlayLoopingSoundOnActor_Params params {};
		params.StartAkEvent = StartAkEvent;
		params.StopAkEvent = StopAkEvent;
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.PlayLoopingMusicTrack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               StartEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               StopEvent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bStopLevelMusic                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::PlayLoopingMusicTrack(class UAkAudioEvent* StartEvent, class UAkAudioEvent* StopEvent, bool bStopLevelMusic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.PlayLoopingMusicTrack");
		
		URBBlueprintLibrary_PlayLoopingMusicTrack_Params params {};
		params.StartEvent = StartEvent;
		params.StopEvent = StopEvent;
		params.bStopLevelMusic = bStopLevelMusic;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.PlayLobbyMurkoffAnnouncement
	 * 		Flags  -> ()
	 */
	void URBBlueprintLibrary::PlayLobbyMurkoffAnnouncement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.PlayLobbyMurkoffAnnouncement");
		
		URBBlueprintLibrary_PlayLobbyMurkoffAnnouncement_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.PlayAnnouncerLine_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVOBehavior                                        voBehavior                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              prePlayQueueDelay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::PlayAnnouncerLine_Server(class UAkAudioEvent* akEvent, EVOBehavior voBehavior, float prePlayQueueDelay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.PlayAnnouncerLine_Server");
		
		URBBlueprintLibrary_PlayAnnouncerLine_Server_Params params {};
		params.akEvent = akEvent;
		params.voBehavior = voBehavior;
		params.prePlayQueueDelay = prePlayQueueDelay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.NormalizeRotationAngle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Current                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::NormalizeRotationAngle(float Current)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.NormalizeRotationAngle");
		
		URBBlueprintLibrary_NormalizeRotationAngle_Params params {};
		params.Current = Current;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.MarkRenderStateDirty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         PrimitiveComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::MarkRenderStateDirty(class UPrimitiveComponent* PrimitiveComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.MarkRenderStateDirty");
		
		URBBlueprintLibrary_MarkRenderStateDirty_Params params {};
		params.PrimitiveComponent = PrimitiveComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.LogMovement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      string                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::LogMovement(class ARBPawn* Pawn, const class FString& string)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.LogMovement");
		
		URBBlueprintLibrary_LogMovement_Params params {};
		params.Pawn = Pawn;
		params.string = string;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.LevelRandomIntRange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomizerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MinValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBBlueprintLibrary::LevelRandomIntRange(int32_t RandomizerId, int32_t MinValue, int32_t MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.LevelRandomIntRange");
		
		URBBlueprintLibrary_LevelRandomIntRange_Params params {};
		params.RandomizerId = RandomizerId;
		params.MinValue = MinValue;
		params.MaxValue = MaxValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.LevelRandomInt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomizerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBBlueprintLibrary::LevelRandomInt(int32_t RandomizerId, int32_t MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.LevelRandomInt");
		
		URBBlueprintLibrary_LevelRandomInt_Params params {};
		params.RandomizerId = RandomizerId;
		params.MaxValue = MaxValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.LevelRandomFloatRange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomizerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::LevelRandomFloatRange(int32_t RandomizerId, float MinValue, float MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.LevelRandomFloatRange");
		
		URBBlueprintLibrary_LevelRandomFloatRange_Params params {};
		params.RandomizerId = RandomizerId;
		params.MinValue = MinValue;
		params.MaxValue = MaxValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.LevelRandomFloat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomizerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::LevelRandomFloat(int32_t RandomizerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.LevelRandomFloat");
		
		URBBlueprintLibrary_LevelRandomFloat_Params params {};
		params.RandomizerId = RandomizerId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.LevelRandomBool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomizerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::LevelRandomBool(int32_t RandomizerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.LevelRandomBool");
		
		URBBlueprintLibrary_LevelRandomBool_Params params {};
		params.RandomizerId = RandomizerId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.LerpAngle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              angleA                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              angleB                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::LerpAngle(float angleA, float angleB, float Alpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.LerpAngle");
		
		URBBlueprintLibrary_LerpAngle_Params params {};
		params.angleA = angleA;
		params.angleB = angleB;
		params.Alpha = Alpha;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsWorldPopulated
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::IsWorldPopulated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsWorldPopulated");
		
		URBBlueprintLibrary_IsWorldPopulated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsWaitingToStart
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::IsWaitingToStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsWaitingToStart");
		
		URBBlueprintLibrary_IsWaitingToStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsValidNPCForAuraVariator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      RBNPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsValidNPCForAuraVariator(class ARBNPC* RBNPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsValidNPCForAuraVariator");
		
		URBBlueprintLibrary_IsValidNPCForAuraVariator_Params params {};
		params.RBNPC = RBNPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsValid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUniqueNetIdRepl                            UniqueId                                                   (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsValid(const struct FUniqueNetIdRepl& UniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsValid");
		
		URBBlueprintLibrary_IsValid_Params params {};
		params.UniqueId = UniqueId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsUniqueVariatorTypeActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EUniqueVariatorType                                Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsUniqueVariatorTypeActive(EUniqueVariatorType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsUniqueVariatorTypeActive");
		
		URBBlueprintLibrary_IsUniqueVariatorTypeActive_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsTransient
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsTransient(class AActor* TargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsTransient");
		
		URBBlueprintLibrary_IsTransient_Params params {};
		params.TargetActor = TargetActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsTransactional
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsTransactional(class AActor* TargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsTransactional");
		
		URBBlueprintLibrary_IsTransactional_Params params {};
		params.TargetActor = TargetActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsStageStarted
	 * 		Flags  -> ()
	 */
	UFunction* fnIsStageStarted = nullptr;
	UClass* fnIsStageStartedClass = nullptr;
	bool URBBlueprintLibrary::IsStageStarted()
	{
		if (!fnIsStageStarted)
			fnIsStageStarted = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsStageStarted");
		
		URBBlueprintLibrary_IsStageStarted_Params params {};
		
		if (fnIsStageStartedClass == nullptr) {
			fnIsStageStartedClass = UObject::FindObject<UClass>("Class OPP.RBBlueprintLibrary");
		}

		fnIsStageStartedClass->ProcessEvent(fnIsStageStarted, &params);

		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsStageReady
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::IsStageReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsStageReady");
		
		URBBlueprintLibrary_IsStageReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsStagePrepared
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::IsStagePrepared()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsStagePrepared");
		
		URBBlueprintLibrary_IsStagePrepared_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsStageIDValid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsStageIDValid(const struct FRBStageID& StageID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsStageIDValid");
		
		URBBlueprintLibrary_IsStageIDValid_Params params {};
		params.StageID = StageID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsStageIDEqual
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  stageID1                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBStageID                                  stageID2                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsStageIDEqual(const struct FRBStageID& stageID1, const struct FRBStageID& stageID2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsStageIDEqual");
		
		URBBlueprintLibrary_IsStageIDEqual_Params params {};
		params.stageID1 = stageID1;
		params.stageID2 = stageID2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsSonyConsole
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::IsSonyConsole()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsSonyConsole");
		
		URBBlueprintLibrary_IsSonyConsole_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsSoloMode
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::IsSoloMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsSoloMode");
		
		URBBlueprintLibrary_IsSoloMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsRunningFunctionalTests
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::IsRunningFunctionalTests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsRunningFunctionalTests");
		
		URBBlueprintLibrary_IsRunningFunctionalTests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsRecentServerEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              maxDelay                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsRecentServerEvent(float Time, float maxDelay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsRecentServerEvent");
		
		URBBlueprintLibrary_IsRecentServerEvent_Params params {};
		params.Time = Time;
		params.maxDelay = maxDelay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsRecentEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              maxDelay                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsRecentEvent(float Time, float maxDelay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsRecentEvent");
		
		URBBlueprintLibrary_IsRecentEvent_Params params {};
		params.Time = Time;
		params.maxDelay = maxDelay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsPropertyWidgetSelected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      inActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InWidgetName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            outWidgetIndex                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsPropertyWidgetSelected(class AActor* inActor, const class FString& InWidgetName, int32_t* outWidgetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsPropertyWidgetSelected");
		
		URBBlueprintLibrary_IsPropertyWidgetSelected_Params params {};
		params.inActor = inActor;
		params.InWidgetName = InWidgetName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outWidgetIndex != nullptr)
			*outWidgetIndex = params.outWidgetIndex;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsPlayInEditor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsPlayInEditor(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsPlayInEditor");
		
		URBBlueprintLibrary_IsPlayInEditor_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsMissionIDValid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsMissionIDValid(const struct FRBMissionID& MissionID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsMissionIDValid");
		
		URBBlueprintLibrary_IsMissionIDValid_Params params {};
		params.MissionID = MissionID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsMissionIDEqual
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBMissionID                                missionID1                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                missionID2                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsMissionIDEqual(const struct FRBMissionID& missionID1, const struct FRBMissionID& missionID2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsMissionIDEqual");
		
		URBBlueprintLibrary_IsMissionIDEqual_Params params {};
		params.missionID1 = missionID1;
		params.missionID2 = missionID2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsInTutorialStage
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::IsInTutorialStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsInTutorialStage");
		
		URBBlueprintLibrary_IsInTutorialStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsInReagentReleaseTrial
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::IsInReagentReleaseTrial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsInReagentReleaseTrial");
		
		URBBlueprintLibrary_IsInReagentReleaseTrial_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsInPIE
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsInPIE(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsInPIE");
		
		URBBlueprintLibrary_IsInPIE_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsInEditorOrCommandlet
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsInEditorOrCommandlet(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsInEditorOrCommandlet");
		
		URBBlueprintLibrary_IsInEditorOrCommandlet_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsInEditor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsInEditor(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsInEditor");
		
		URBBlueprintLibrary_IsInEditor_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsInBlueprintEditor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsInBlueprintEditor(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsInBlueprintEditor");
		
		URBBlueprintLibrary_IsInBlueprintEditor_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsHiddenInEditor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      inActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsHiddenInEditor(class AActor* inActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsHiddenInEditor");
		
		URBBlueprintLibrary_IsHiddenInEditor_Params params {};
		params.inActor = inActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsExperimentStarted
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::IsExperimentStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsExperimentStarted");
		
		URBBlueprintLibrary_IsExperimentStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsEqual
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUniqueNetIdRepl                            uniqueID1                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FUniqueNetIdRepl                            uniqueID2                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsEqual(const struct FUniqueNetIdRepl& uniqueID1, const struct FUniqueNetIdRepl& uniqueID2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsEqual");
		
		URBBlueprintLibrary_IsEqual_Params params {};
		params.uniqueID1 = uniqueID1;
		params.uniqueID2 = uniqueID2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsDifficultyLessThan
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGameDifficulty                                    Difficulty                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsDifficultyLessThan(EGameDifficulty Difficulty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsDifficultyLessThan");
		
		URBBlueprintLibrary_IsDifficultyLessThan_Params params {};
		params.Difficulty = Difficulty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsDifficultyGreaterThan
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGameDifficulty                                    Difficulty                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsDifficultyGreaterThan(EGameDifficulty Difficulty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsDifficultyGreaterThan");
		
		URBBlueprintLibrary_IsDifficultyGreaterThan_Params params {};
		params.Difficulty = Difficulty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsDifficultyEqualTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGameDifficulty                                    Difficulty                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsDifficultyEqualTo(EGameDifficulty Difficulty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsDifficultyEqualTo");
		
		URBBlueprintLibrary_IsDifficultyEqualTo_Params params {};
		params.Difficulty = Difficulty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsDifficultyEqualOrLessThan
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGameDifficulty                                    Difficulty                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsDifficultyEqualOrLessThan(EGameDifficulty Difficulty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsDifficultyEqualOrLessThan");
		
		URBBlueprintLibrary_IsDifficultyEqualOrLessThan_Params params {};
		params.Difficulty = Difficulty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsDifficultyEqualOrGreaterThan
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGameDifficulty                                    Difficulty                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsDifficultyEqualOrGreaterThan(EGameDifficulty Difficulty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsDifficultyEqualOrGreaterThan");
		
		URBBlueprintLibrary_IsDifficultyEqualOrGreaterThan_Params params {};
		params.Difficulty = Difficulty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsConsole
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::IsConsole()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsConsole");
		
		URBBlueprintLibrary_IsConsole_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsConsideredSoloGame
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::IsConsideredSoloGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsConsideredSoloGame");
		
		URBBlueprintLibrary_IsConsideredSoloGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsClient
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::IsClient()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsClient");
		
		URBBlueprintLibrary_IsClient_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsAxisMappingValid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputAxisKeyMapping                        keyMapping                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsAxisMappingValid(const struct FInputAxisKeyMapping& keyMapping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsAxisMappingValid");
		
		URBBlueprintLibrary_IsAxisMappingValid_Params params {};
		params.keyMapping = keyMapping;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.IsActionMappingValid
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FInputActionKeyMapping                      keyMapping                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::IsActionMappingValid(const struct FInputActionKeyMapping& keyMapping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.IsActionMappingValid");
		
		URBBlueprintLibrary_IsActionMappingValid_Params params {};
		params.keyMapping = keyMapping;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.HideInteractionMessageForAllPlayers
	 * 		Flags  -> ()
	 */
	void URBBlueprintLibrary::HideInteractionMessageForAllPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.HideInteractionMessageForAllPlayers");
		
		URBBlueprintLibrary_HideInteractionMessageForAllPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.HideInteractionMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::HideInteractionMessage(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.HideInteractionMessage");
		
		URBBlueprintLibrary_HideInteractionMessage_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.HasPlayerUpgradeEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        upgradeID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::HasPlayerUpgradeEffect(class ARBPlayer* Player, const class FName& upgradeID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.HasPlayerUpgradeEffect");
		
		URBBlueprintLibrary_HasPlayerUpgradeEffect_Params params {};
		params.Player = Player;
		params.upgradeID = upgradeID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.HasPlayedTutorialMap
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::HasPlayedTutorialMap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.HasPlayedTutorialMap");
		
		URBBlueprintLibrary_HasPlayedTutorialMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.HashString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      string                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBBlueprintLibrary::HashString(const class FString& string)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.HashString");
		
		URBBlueprintLibrary_HashString_Params params {};
		params.string = string;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.HasActorNotBegunPlay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::HasActorNotBegunPlay(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.HasActorNotBegunPlay");
		
		URBBlueprintLibrary_HasActorNotBegunPlay_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.HasActorBegunPlay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::HasActorBegunPlay(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.HasActorBegunPlay");
		
		URBBlueprintLibrary_HasActorBegunPlay_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixFromGhostAnimationAnchorByTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ghostAnimClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  inTransformReference                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  OutTransform                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::GetWorldTransformMatrixFromGhostAnimationAnchorByTransform(class UClass* ghostAnimClass, const struct FTransform& inTransformReference, struct FTransform* OutTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixFromGhostAnimationAnchorByTransform");
		
		URBBlueprintLibrary_GetWorldTransformMatrixFromGhostAnimationAnchorByTransform_Params params {};
		params.ghostAnimClass = ghostAnimClass;
		params.inTransformReference = inTransformReference;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTransform != nullptr)
			*OutTransform = params.OutTransform;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixFromAnimationAnchorByTransformInMeshSpace
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               Sequence                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  inTransformReference                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bSnapToGround                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  OutTransform                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     snapToGroundRequester                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::GetWorldTransformMatrixFromAnimationAnchorByTransformInMeshSpace(class ARBPawn* Pawn, class UAnimSequence* Sequence, const struct FTransform& inTransformReference, bool bSnapToGround, struct FTransform* OutTransform, class UObject* snapToGroundRequester)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixFromAnimationAnchorByTransformInMeshSpace");
		
		URBBlueprintLibrary_GetWorldTransformMatrixFromAnimationAnchorByTransformInMeshSpace_Params params {};
		params.Pawn = Pawn;
		params.Sequence = Sequence;
		params.inTransformReference = inTransformReference;
		params.bSnapToGround = bSnapToGround;
		params.snapToGroundRequester = snapToGroundRequester;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTransform != nullptr)
			*OutTransform = params.OutTransform;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixFromAnimationAnchorByTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               Sequence                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  inTransformReference                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bSnapToGround                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  OutTransform                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     snapToGroundRequester                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::GetWorldTransformMatrixFromAnimationAnchorByTransform(class ARBPawn* Pawn, class UAnimSequence* Sequence, const struct FTransform& inTransformReference, bool bSnapToGround, struct FTransform* OutTransform, class UObject* snapToGroundRequester)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixFromAnimationAnchorByTransform");
		
		URBBlueprintLibrary_GetWorldTransformMatrixFromAnimationAnchorByTransform_Params params {};
		params.Pawn = Pawn;
		params.Sequence = Sequence;
		params.inTransformReference = inTransformReference;
		params.bSnapToGround = bSnapToGround;
		params.snapToGroundRequester = snapToGroundRequester;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTransform != nullptr)
			*OutTransform = params.OutTransform;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixForBoneAtTimeRelativeToTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequence*                               Sequence                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              evalTime                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  inTransformReference                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  OutTransform                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::GetWorldTransformMatrixForBoneAtTimeRelativeToTransform(class UAnimSequence* Sequence, const class FName& BoneName, float evalTime, const struct FTransform& inTransformReference, struct FTransform* OutTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixForBoneAtTimeRelativeToTransform");
		
		URBBlueprintLibrary_GetWorldTransformMatrixForBoneAtTimeRelativeToTransform_Params params {};
		params.Sequence = Sequence;
		params.BoneName = BoneName;
		params.evalTime = evalTime;
		params.inTransformReference = inTransformReference;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTransform != nullptr)
			*OutTransform = params.OutTransform;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixForBoneAtTheEndOfTheSequenceRelativeToTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequence*                               Sequence                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  inTransformReference                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  OutTransform                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::GetWorldTransformMatrixForBoneAtTheEndOfTheSequenceRelativeToTransform(class UAnimSequence* Sequence, const class FName& BoneName, const struct FTransform& inTransformReference, struct FTransform* OutTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetWorldTransformMatrixForBoneAtTheEndOfTheSequenceRelativeToTransform");
		
		URBBlueprintLibrary_GetWorldTransformMatrixForBoneAtTheEndOfTheSequenceRelativeToTransform_Params params {};
		params.Sequence = Sequence;
		params.BoneName = BoneName;
		params.inTransformReference = inTransformReference;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTransform != nullptr)
			*OutTransform = params.OutTransform;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetWorldTransformFromGhostAnimationAnchorByTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ghostAnimClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  inTransformReference                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     outDirection                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::GetWorldTransformFromGhostAnimationAnchorByTransform(class UClass* ghostAnimClass, const struct FTransform& inTransformReference, struct FVector* OutLocation, struct FVector* outDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetWorldTransformFromGhostAnimationAnchorByTransform");
		
		URBBlueprintLibrary_GetWorldTransformFromGhostAnimationAnchorByTransform_Params params {};
		params.ghostAnimClass = ghostAnimClass;
		params.inTransformReference = inTransformReference;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		if (outDirection != nullptr)
			*outDirection = params.outDirection;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetWorldTransformFromAnimationAnchorByTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               Sequence                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  inTransformReference                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bSnapToGround                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     outDirection                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     snapToGroundRequester                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::GetWorldTransformFromAnimationAnchorByTransform(class ARBPawn* Pawn, class UAnimSequence* Sequence, const struct FTransform& inTransformReference, bool bSnapToGround, struct FVector* OutLocation, struct FVector* outDirection, class UObject* snapToGroundRequester)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetWorldTransformFromAnimationAnchorByTransform");
		
		URBBlueprintLibrary_GetWorldTransformFromAnimationAnchorByTransform_Params params {};
		params.Pawn = Pawn;
		params.Sequence = Sequence;
		params.inTransformReference = inTransformReference;
		params.bSnapToGround = bSnapToGround;
		params.snapToGroundRequester = snapToGroundRequester;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		if (outDirection != nullptr)
			*outDirection = params.outDirection;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetWorldTransformFromAnimationAnchor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               Sequence                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             inSceneComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSnapToGround                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     outDirection                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     snapToGroundRequester                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::GetWorldTransformFromAnimationAnchor(class ARBPawn* Pawn, class UAnimSequence* Sequence, class USceneComponent* inSceneComponent, bool bSnapToGround, struct FVector* OutLocation, struct FVector* outDirection, class UObject* snapToGroundRequester)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetWorldTransformFromAnimationAnchor");
		
		URBBlueprintLibrary_GetWorldTransformFromAnimationAnchor_Params params {};
		params.Pawn = Pawn;
		params.Sequence = Sequence;
		params.inSceneComponent = inSceneComponent;
		params.bSnapToGround = bSnapToGround;
		params.snapToGroundRequester = snapToGroundRequester;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		if (outDirection != nullptr)
			*outDirection = params.outDirection;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetWorldSettings
	 * 		Flags  -> ()
	 */
	class ARBWorldSettings* URBBlueprintLibrary::GetWorldSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetWorldSettings");
		
		URBBlueprintLibrary_GetWorldSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetWorldAnchorTransformForGhostAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ghostAnimClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             inSceneComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform URBBlueprintLibrary::GetWorldAnchorTransformForGhostAnimation(class UClass* ghostAnimClass, class USceneComponent* inSceneComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetWorldAnchorTransformForGhostAnimation");
		
		URBBlueprintLibrary_GetWorldAnchorTransformForGhostAnimation_Params params {};
		params.ghostAnimClass = ghostAnimClass;
		params.inSceneComponent = inSceneComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetViewRotation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRotator URBBlueprintLibrary::GetViewRotation(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetViewRotation");
		
		URBBlueprintLibrary_GetViewRotation_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetViewPoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ViewLocation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    ViewRotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::GetViewPoint(class UObject* WorldContextObject, struct FVector* ViewLocation, struct FRotator* ViewRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetViewPoint");
		
		URBBlueprintLibrary_GetViewPoint_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ViewLocation != nullptr)
			*ViewLocation = params.ViewLocation;
		if (ViewRotation != nullptr)
			*ViewRotation = params.ViewRotation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetViewLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector URBBlueprintLibrary::GetViewLocation(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetViewLocation");
		
		URBBlueprintLibrary_GetViewLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetViewForward
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector URBBlueprintLibrary::GetViewForward(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetViewForward");
		
		URBBlueprintLibrary_GetViewForward_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetVariatorManager
	 * 		Flags  -> ()
	 */
	class ARBVariatorManager* URBBlueprintLibrary::GetVariatorManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetVariatorManager");
		
		URBBlueprintLibrary_GetVariatorManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetValidCustomizationOption
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUICustomizationItem                        Item                                                       (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class URBCustomizationOption* URBBlueprintLibrary::GetValidCustomizationOption(struct FUICustomizationItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetValidCustomizationOption");
		
		URBBlueprintLibrary_GetValidCustomizationOption_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Item != nullptr)
			*Item = params.Item;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetUniqueVariatorTypeValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EUniqueVariatorType                                Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Name                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::GetUniqueVariatorTypeValue(EUniqueVariatorType Type, const class FName& Name, float* OutValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetUniqueVariatorTypeValue");
		
		URBBlueprintLibrary_GetUniqueVariatorTypeValue_Params params {};
		params.Type = Type;
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutValue != nullptr)
			*OutValue = params.OutValue;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetTexturesFromMaterial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UTexture*> URBBlueprintLibrary::GetTexturesFromMaterial(class UMaterialInterface* Material)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetTexturesFromMaterial");
		
		URBBlueprintLibrary_GetTexturesFromMaterial_Params params {};
		params.Material = Material;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetTasksConfig
	 * 		Flags  -> ()
	 */
	class URBTasksConfig* URBBlueprintLibrary::GetTasksConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetTasksConfig");
		
		URBBlueprintLibrary_GetTasksConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetStaticMeshLODGenerateLightmapUVs
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 StaticMesh                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            LODIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::GetStaticMeshLODGenerateLightmapUVs(class UStaticMesh* StaticMesh, int32_t LODIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetStaticMeshLODGenerateLightmapUVs");
		
		URBBlueprintLibrary_GetStaticMeshLODGenerateLightmapUVs_Params params {};
		params.StaticMesh = StaticMesh;
		params.LODIndex = LODIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetStaticMeshImportSettingsGenerateLightmapUVs
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMesh*                                 StaticMesh                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            LODIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::GetStaticMeshImportSettingsGenerateLightmapUVs(class UStaticMesh* StaticMesh, int32_t LODIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetStaticMeshImportSettingsGenerateLightmapUVs");
		
		URBBlueprintLibrary_GetStaticMeshImportSettingsGenerateLightmapUVs_Params params {};
		params.StaticMesh = StaticMesh;
		params.LODIndex = LODIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetStageTime
	 * 		Flags  -> ()
	 */
	float URBBlueprintLibrary::GetStageTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetStageTime");
		
		URBBlueprintLibrary_GetStageTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetStageResetCount
	 * 		Flags  -> ()
	 */
	int32_t URBBlueprintLibrary::GetStageResetCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetStageResetCount");
		
		URBBlueprintLibrary_GetStageResetCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetStageInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class URBStageInfo* URBBlueprintLibrary::GetStageInfo(const struct FRBStageID& StageID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetStageInfo");
		
		URBBlueprintLibrary_GetStageInfo_Params params {};
		params.StageID = StageID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetSpectatorPawn
	 * 		Flags  -> ()
	 */
	class ARBSpectatorPawn* URBBlueprintLibrary::GetSpectatorPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetSpectatorPawn");
		
		URBBlueprintLibrary_GetSpectatorPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetSpectatedPlayer
	 * 		Flags  -> ()
	 */
	class ARBPlayer* URBBlueprintLibrary::GetSpectatedPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetSpectatedPlayer");
		
		URBBlueprintLibrary_GetSpectatedPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetSoftObjectPathFromSoftObjectReference
	 * 		Flags  -> ()
	 */
	struct FSoftObjectPath URBBlueprintLibrary::GetSoftObjectPathFromSoftObjectReference()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetSoftObjectPathFromSoftObjectReference");
		
		URBBlueprintLibrary_GetSoftObjectPathFromSoftObjectReference_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetServerTime
	 * 		Flags  -> ()
	 */
	float URBBlueprintLibrary::GetServerTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetServerTime");
		
		URBBlueprintLibrary_GetServerTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetServerAddressUrl
	 * 		Flags  -> ()
	 */
	class FString URBBlueprintLibrary::GetServerAddressUrl()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetServerAddressUrl");
		
		URBBlueprintLibrary_GetServerAddressUrl_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetScoringConfig
	 * 		Flags  -> ()
	 */
	class URBScoringConfig* URBBlueprintLibrary::GetScoringConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetScoringConfig");
		
		URBBlueprintLibrary_GetScoringConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRoomPathedDistance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      SourceActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DestActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               out_ValidPath                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxDistance                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               allowCoopRooms                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::GetRoomPathedDistance(class AActor* SourceActor, class AActor* DestActor, bool* out_ValidPath, float MaxDistance, bool allowCoopRooms)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRoomPathedDistance");
		
		URBBlueprintLibrary_GetRoomPathedDistance_Params params {};
		params.SourceActor = SourceActor;
		params.DestActor = DestActor;
		params.MaxDistance = MaxDistance;
		params.allowCoopRooms = allowCoopRooms;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (out_ValidPath != nullptr)
			*out_ValidPath = params.out_ValidPath;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRoomForActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBRoom* URBBlueprintLibrary::GetRoomForActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRoomForActor");
		
		URBBlueprintLibrary_GetRoomForActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRefPoseBoneComponentSpace
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      SkelMesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform URBBlueprintLibrary::GetRefPoseBoneComponentSpace(class USkeletalMeshComponent* SkelMesh, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRefPoseBoneComponentSpace");
		
		URBBlueprintLibrary_GetRefPoseBoneComponentSpace_Params params {};
		params.SkelMesh = SkelMesh;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBWorld
	 * 		Flags  -> ()
	 */
	class URBWorld* URBBlueprintLibrary::GetRBWorld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBWorld");
		
		URBBlueprintLibrary_GetRBWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBTaskManager
	 * 		Flags  -> ()
	 */
	class ARBTaskManager* URBBlueprintLibrary::GetRBTaskManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBTaskManager");
		
		URBBlueprintLibrary_GetRBTaskManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBStreaming
	 * 		Flags  -> ()
	 */
	class ARBStreaming* URBBlueprintLibrary::GetRBStreaming()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBStreaming");
		
		URBBlueprintLibrary_GetRBStreaming_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBSettings_Gameplay
	 * 		Flags  -> ()
	 */
	class URBSettings_Gameplay* URBBlueprintLibrary::GetRBSettings_Gameplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBSettings_Gameplay");
		
		URBBlueprintLibrary_GetRBSettings_Gameplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBSettings_Anim
	 * 		Flags  -> ()
	 */
	class URBSettings_Anim* URBBlueprintLibrary::GetRBSettings_Anim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBSettings_Anim");
		
		URBBlueprintLibrary_GetRBSettings_Anim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBPlayerLoadoutManager
	 * 		Flags  -> ()
	 */
	class ARBPlayerLoadoutManager* URBBlueprintLibrary::GetRBPlayerLoadoutManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBPlayerLoadoutManager");
		
		URBBlueprintLibrary_GetRBPlayerLoadoutManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBObjectiveManager
	 * 		Flags  -> ()
	 */
	class URBObjectiveManager* URBBlueprintLibrary::GetRBObjectiveManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBObjectiveManager");
		
		URBBlueprintLibrary_GetRBObjectiveManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBGameUserSettings
	 * 		Flags  -> ()
	 */
	class URBGameUserSettings* URBBlueprintLibrary::GetRBGameUserSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBGameUserSettings");
		
		URBBlueprintLibrary_GetRBGameUserSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBGameUserPreferences
	 * 		Flags  -> ()
	 */
	class URBGameUserPreferences* URBBlueprintLibrary::GetRBGameUserPreferences()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBGameUserPreferences");
		
		URBBlueprintLibrary_GetRBGameUserPreferences_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBGameStateLobby
	 * 		Flags  -> ()
	 */
	class ARBGameStateLobby* URBBlueprintLibrary::GetRBGameStateLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBGameStateLobby");
		
		URBBlueprintLibrary_GetRBGameStateLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBGameStateBase
	 * 		Flags  -> ()
	 */
	class ARBGameStateBase* URBBlueprintLibrary::GetRBGameStateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBGameStateBase");
		
		URBBlueprintLibrary_GetRBGameStateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBGameState
	 * 		Flags  -> ()
	 */
	class ARBGameState* URBBlueprintLibrary::GetRBGameState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBGameState");
		
		URBBlueprintLibrary_GetRBGameState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBGameModeMainMenu
	 * 		Flags  -> ()
	 */
	class ARBGameModeMainMenu* URBBlueprintLibrary::GetRBGameModeMainMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBGameModeMainMenu");
		
		URBBlueprintLibrary_GetRBGameModeMainMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBGameModeLobby
	 * 		Flags  -> ()
	 */
	class ARBGameModeLobby* URBBlueprintLibrary::GetRBGameModeLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBGameModeLobby");
		
		URBBlueprintLibrary_GetRBGameModeLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBGameModeBase
	 * 		Flags  -> ()
	 */
	class ARBGameModeBase* URBBlueprintLibrary::GetRBGameModeBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBGameModeBase");
		
		URBBlueprintLibrary_GetRBGameModeBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBGameMode
	 * 		Flags  -> ()
	 */
	class ARBGameMode* URBBlueprintLibrary::GetRBGameMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBGameMode");
		
		URBBlueprintLibrary_GetRBGameMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRBGameInstance
	 * 		Flags  -> ()
	 */
	class URBGameInstance* URBBlueprintLibrary::GetRBGameInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRBGameInstance");
		
		URBBlueprintLibrary_GetRBGameInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetRandomIndexForNPCCustomizationSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGruntCustomizationMeshesConfig             customizationMeshesConfig                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bFemale                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ENPCCustomizationSlot                              Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ENPCFlavor                                         Flavor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBBlueprintLibrary::GetRandomIndexForNPCCustomizationSlot(const struct FGruntCustomizationMeshesConfig& customizationMeshesConfig, bool bFemale, ENPCCustomizationSlot Slot, ENPCFlavor Flavor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetRandomIndexForNPCCustomizationSlot");
		
		URBBlueprintLibrary_GetRandomIndexForNPCCustomizationSlot_Params params {};
		params.customizationMeshesConfig = customizationMeshesConfig;
		params.bFemale = bFemale;
		params.Slot = Slot;
		params.Flavor = Flavor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetProfile
	 * 		Flags  -> ()
	 */
	class URBLocalProfile* URBBlueprintLibrary::GetProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetProfile");
		
		URBBlueprintLibrary_GetProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPostProcessUpdateManager
	 * 		Flags  -> ()
	 */
	class ARBPostProcessUpdateManager* URBBlueprintLibrary::GetPostProcessUpdateManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPostProcessUpdateManager");
		
		URBBlueprintLibrary_GetPostProcessUpdateManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerStatsConfig
	 * 		Flags  -> ()
	 */
	class URBPlayerStatsConfig* URBBlueprintLibrary::GetPlayerStatsConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerStatsConfig");
		
		URBBlueprintLibrary_GetPlayerStatsConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerStateByUniqueId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUniqueNetIdRepl                            UniqueId                                                   (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBPlayerState* URBBlueprintLibrary::GetPlayerStateByUniqueId(const struct FUniqueNetIdRepl& UniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerStateByUniqueId");
		
		URBBlueprintLibrary_GetPlayerStateByUniqueId_Params params {};
		params.UniqueId = UniqueId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerStateByPlayerId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBPlayerId                                 PlayerId                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class ARBPlayerState* URBBlueprintLibrary::GetPlayerStateByPlayerId(const struct FRBPlayerId& PlayerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerStateByPlayerId");
		
		URBBlueprintLibrary_GetPlayerStateByPlayerId_Params params {};
		params.PlayerId = PlayerId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerStateByPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBPlayerState* URBBlueprintLibrary::GetPlayerStateByPlayer(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerStateByPlayer");
		
		URBBlueprintLibrary_GetPlayerStateByPlayer_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerProgressionManager
	 * 		Flags  -> ()
	 */
	class ARBPlayerProgressionManager* URBBlueprintLibrary::GetPlayerProgressionManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerProgressionManager");
		
		URBBlueprintLibrary_GetPlayerProgressionManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerProgressionData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBPlayerProgressionData* URBBlueprintLibrary::GetPlayerProgressionData(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerProgressionData");
		
		URBBlueprintLibrary_GetPlayerProgressionData_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerPingDataFromId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        dataId                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FPlayerPingData URBBlueprintLibrary::GetPlayerPingDataFromId(const class FName& dataId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerPingDataFromId");
		
		URBBlueprintLibrary_GetPlayerPingDataFromId_Params params {};
		params.dataId = dataId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerLoadoutConfig
	 * 		Flags  -> ()
	 */
	class URBPlayerLoadoutConfig* URBBlueprintLibrary::GetPlayerLoadoutConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerLoadoutConfig");
		
		URBBlueprintLibrary_GetPlayerLoadoutConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerGameSessionManager
	 * 		Flags  -> ()
	 */
	class URBPlayerGameSessionManager* URBBlueprintLibrary::GetPlayerGameSessionManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerGameSessionManager");
		
		URBBlueprintLibrary_GetPlayerGameSessionManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerCustomizationOptionForSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      customizationOwner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayerCustomizationSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBPlayerCustomizationOption* URBBlueprintLibrary::GetPlayerCustomizationOptionForSlot(class AActor* customizationOwner, EPlayerCustomizationSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerCustomizationOptionForSlot");
		
		URBBlueprintLibrary_GetPlayerCustomizationOptionForSlot_Params params {};
		params.customizationOwner = customizationOwner;
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerCustomizationConfig
	 * 		Flags  -> ()
	 */
	class URBPlayerCustomizationConfig* URBBlueprintLibrary::GetPlayerCustomizationConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerCustomizationConfig");
		
		URBBlueprintLibrary_GetPlayerCustomizationConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerCellCustomizationConfig
	 * 		Flags  -> ()
	 */
	class URBPlayerCellCustomizationConfig* URBBlueprintLibrary::GetPlayerCellCustomizationConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerCellCustomizationConfig");
		
		URBBlueprintLibrary_GetPlayerCellCustomizationConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerByUniqueId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUniqueNetIdRepl                            UniqueId                                                   (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBPlayer* URBBlueprintLibrary::GetPlayerByUniqueId(const struct FUniqueNetIdRepl& UniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerByUniqueId");
		
		URBBlueprintLibrary_GetPlayerByUniqueId_Params params {};
		params.UniqueId = UniqueId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPlayerByPlayerId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBPlayerId                                 PlayerId                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class ARBPlayer* URBBlueprintLibrary::GetPlayerByPlayerId(const struct FRBPlayerId& PlayerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPlayerByPlayerId");
		
		URBBlueprintLibrary_GetPlayerByPlayerId_Params params {};
		params.PlayerId = PlayerId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetPawnCustomizationManager
	 * 		Flags  -> ()
	 */
	class URBPawnCustomizationManager* URBBlueprintLibrary::GetPawnCustomizationManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetPawnCustomizationManager");
		
		URBBlueprintLibrary_GetPawnCustomizationManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetNumberOfPlayer
	 * 		Flags  -> ()
	 */
	int32_t URBBlueprintLibrary::GetNumberOfPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetNumberOfPlayer");
		
		URBBlueprintLibrary_GetNumberOfPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetNumberOfAlivePlayer
	 * 		Flags  -> ()
	 */
	int32_t URBBlueprintLibrary::GetNumberOfAlivePlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetNumberOfAlivePlayer");
		
		URBBlueprintLibrary_GetNumberOfAlivePlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetNewRandomActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              actorList                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      currentActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AActor* URBBlueprintLibrary::GetNewRandomActor(TArray<class AActor*> actorList, class AActor* currentActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetNewRandomActor");
		
		URBBlueprintLibrary_GetNewRandomActor_Params params {};
		params.actorList = actorList;
		params.currentActor = currentActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetNearbyPlayers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCheckClearance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class ARBPlayer*> URBBlueprintLibrary::GetNearbyPlayers(class AActor* Source, float Radius, bool bCheckClearance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetNearbyPlayers");
		
		URBBlueprintLibrary_GetNearbyPlayers_Params params {};
		params.Source = Source;
		params.Radius = Radius;
		params.bCheckClearance = bCheckClearance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetNearbyBots
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCheckClearance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class ARBBot*> URBBlueprintLibrary::GetNearbyBots(class AActor* Source, float Radius, bool bCheckClearance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetNearbyBots");
		
		URBBlueprintLibrary_GetNearbyBots_Params params {};
		params.Source = Source;
		params.Radius = Radius;
		params.bCheckClearance = bCheckClearance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetNarrator_ClientOnly
	 * 		Flags  -> ()
	 */
	class AActor* URBBlueprintLibrary::GetNarrator_ClientOnly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetNarrator_ClientOnly");
		
		URBBlueprintLibrary_GetNarrator_ClientOnly_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetMissionInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class URBMissionInfo* URBBlueprintLibrary::GetMissionInfo(const struct FRBMissionID& MissionID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetMissionInfo");
		
		URBBlueprintLibrary_GetMissionInfo_Params params {};
		params.MissionID = MissionID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetMenuManager
	 * 		Flags  -> ()
	 */
	UFunction* fnGetMenuManager = nullptr;
	UClass* classGetMenuManager = nullptr;
	class URBMenuManager* URBBlueprintLibrary::GetMenuManager()
	{
		if (!fnGetMenuManager)
			fnGetMenuManager = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetMenuManager");
		
		URBBlueprintLibrary_GetMenuManager_Params params {};
		

		if (!classGetMenuManager)
			classGetMenuManager = UObject::FindClass("Class OPP.RBBlueprintLibrary");

		classGetMenuManager->ProcessEvent(fnGetMenuManager, &params);

		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetLocalPlayerState
	 * 		Flags  -> ()
	 */
	class ARBPlayerState* URBBlueprintLibrary::GetLocalPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetLocalPlayerState");
		
		URBBlueprintLibrary_GetLocalPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetLocalPlayerProgressionData
	 * 		Flags  -> ()
	 */
	class URBPlayerProgressionData* URBBlueprintLibrary::GetLocalPlayerProgressionData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetLocalPlayerProgressionData");
		
		URBBlueprintLibrary_GetLocalPlayerProgressionData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetLocalPlayerController
	 * 		Flags  -> ()
	 */
	class ARBController* URBBlueprintLibrary::GetLocalPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetLocalPlayerController");
		
		URBBlueprintLibrary_GetLocalPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetLocalPawn
	 * 		Flags  -> ()
	 */
	class ARBPlayer* URBBlueprintLibrary::GetLocalPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetLocalPawn");
		
		URBBlueprintLibrary_GetLocalPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetLocalMenuController
	 * 		Flags  -> ()
	 */
	class ARBMenuPlayerController* URBBlueprintLibrary::GetLocalMenuController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetLocalMenuController");
		
		URBBlueprintLibrary_GetLocalMenuController_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetLocalMainMenuPlayerController
	 * 		Flags  -> ()
	 */
	class ARBMainMenuPlayerController* URBBlueprintLibrary::GetLocalMainMenuPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetLocalMainMenuPlayerController");
		
		URBBlueprintLibrary_GetLocalMainMenuPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetLocalLobbyPlayerController
	 * 		Flags  -> ()
	 */
	class ARBLobbyPlayerController* URBBlueprintLibrary::GetLocalLobbyPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetLocalLobbyPlayerController");
		
		URBBlueprintLibrary_GetLocalLobbyPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetLoadedOnServerComponents
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UActorComponent*> URBBlueprintLibrary::GetLoadedOnServerComponents(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetLoadedOnServerComponents");
		
		URBBlueprintLibrary_GetLoadedOnServerComponents_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetKeyFName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FName URBBlueprintLibrary::GetKeyFName(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetKeyFName");
		
		URBBlueprintLibrary_GetKeyFName_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetIntValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FConfigurableInt                            ConfigurableInt                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBBlueprintLibrary::GetIntValue(const struct FConfigurableInt& ConfigurableInt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetIntValue");
		
		URBBlueprintLibrary_GetIntValue_Params params {};
		params.ConfigurableInt = ConfigurableInt;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetInputBinding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ActionName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceGamepad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceKBM                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FInputActionKeyMapping URBBlueprintLibrary::GetInputBinding(const class FName& ActionName, int32_t Value, bool bForceGamepad, bool bForceKBM)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetInputBinding");
		
		URBBlueprintLibrary_GetInputBinding_Params params {};
		params.ActionName = ActionName;
		params.Value = Value;
		params.bForceGamepad = bForceGamepad;
		params.bForceKBM = bForceKBM;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetHUDWidget
	 * 		Flags  -> ()
	 */
	class URBHUDWidget* URBBlueprintLibrary::GetHUDWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetHUDWidget");
		
		URBBlueprintLibrary_GetHUDWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetHUD
	 * 		Flags  -> ()
	 */
	class ARBHUD* URBBlueprintLibrary::GetHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetHUD");
		
		URBBlueprintLibrary_GetHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetHallucinationManager
	 * 		Flags  -> ()
	 */
	class ARBHallucinationManager* URBBlueprintLibrary::GetHallucinationManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetHallucinationManager");
		
		URBBlueprintLibrary_GetHallucinationManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetGlobalUIConfig
	 * 		Flags  -> ()
	 */
	class URBGlobalUIConfig* URBBlueprintLibrary::GetGlobalUIConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetGlobalUIConfig");
		
		URBBlueprintLibrary_GetGlobalUIConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetGlobalAudioConfig
	 * 		Flags  -> ()
	 */
	class URBGlobalAudioConfig* URBBlueprintLibrary::GetGlobalAudioConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetGlobalAudioConfig");
		
		URBBlueprintLibrary_GetGlobalAudioConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetGameVersionString
	 * 		Flags  -> ()
	 */
	class FString URBBlueprintLibrary::GetGameVersionString()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetGameVersionString");
		
		URBBlueprintLibrary_GetGameVersionString_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetGameTime
	 * 		Flags  -> ()
	 */
	float URBBlueprintLibrary::GetGameTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetGameTime");
		
		URBBlueprintLibrary_GetGameTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetGameStructureConfig
	 * 		Flags  -> ()
	 */
	class URBGameStructureConfig* URBBlueprintLibrary::GetGameStructureConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetGameStructureConfig");
		
		URBBlueprintLibrary_GetGameStructureConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetGameStageInfo
	 * 		Flags  -> ()
	 */
	struct FRBGameStageInfo URBBlueprintLibrary::GetGameStageInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetGameStageInfo");
		
		URBBlueprintLibrary_GetGameStageInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetGameDifficulty
	 * 		Flags  -> ()
	 */
	EGameDifficulty URBBlueprintLibrary::GetGameDifficulty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetGameDifficulty");
		
		URBBlueprintLibrary_GetGameDifficulty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetFXManager
	 * 		Flags  -> ()
	 */
	class URBFXManager* URBBlueprintLibrary::GetFXManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetFXManager");
		
		URBBlueprintLibrary_GetFXManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetFoleySwitchOverrideFromGruntCustomization
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSelectedGruntCustomizationMeshesInfo       selectedMeshInfo                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FGruntCustomizationMeshesConfig             meshesConfig                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class FName URBBlueprintLibrary::GetFoleySwitchOverrideFromGruntCustomization(const struct FSelectedGruntCustomizationMeshesInfo& selectedMeshInfo, const struct FGruntCustomizationMeshesConfig& meshesConfig)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetFoleySwitchOverrideFromGruntCustomization");
		
		URBBlueprintLibrary_GetFoleySwitchOverrideFromGruntCustomization_Params params {};
		params.selectedMeshInfo = selectedMeshInfo;
		params.meshesConfig = meshesConfig;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetFloatValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FConfigurableFloat                          ConfigurableFloat                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::GetFloatValue(const struct FConfigurableFloat& ConfigurableFloat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetFloatValue");
		
		URBBlueprintLibrary_GetFloatValue_Params params {};
		params.ConfigurableFloat = ConfigurableFloat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetFirstPushableCart
	 * 		Flags  -> ()
	 */
	class ARBBasePushable* URBBlueprintLibrary::GetFirstPushableCart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetFirstPushableCart");
		
		URBBlueprintLibrary_GetFirstPushableCart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetElapsedTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::GetElapsedTime(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetElapsedTime");
		
		URBBlueprintLibrary_GetElapsedTime_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetElapsedServerTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::GetElapsedServerTime(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetElapsedServerTime");
		
		URBBlueprintLibrary_GetElapsedServerTime_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetElapsedPawnTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::GetElapsedPawnTime(class ARBPawn* Pawn, float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetElapsedPawnTime");
		
		URBBlueprintLibrary_GetElapsedPawnTime_Params params {};
		params.Pawn = Pawn;
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetEffectiveSASVariatorType
	 * 		Flags  -> ()
	 */
	ESASVariatorType URBBlueprintLibrary::GetEffectiveSASVariatorType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetEffectiveSASVariatorType");
		
		URBBlueprintLibrary_GetEffectiveSASVariatorType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetEffectivePlayerCountForConfiguration
	 * 		Flags  -> ()
	 */
	int32_t URBBlueprintLibrary::GetEffectivePlayerCountForConfiguration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetEffectivePlayerCountForConfiguration");
		
		URBBlueprintLibrary_GetEffectivePlayerCountForConfiguration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetEditorWorldSettings
	 * 		Flags  -> ()
	 */
	class ARBWorldSettings* URBBlueprintLibrary::GetEditorWorldSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetEditorWorldSettings");
		
		URBBlueprintLibrary_GetEditorWorldSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetDefaultObjectFromAssetData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAssetData                                  Asset                                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UObject* URBBlueprintLibrary::GetDefaultObjectFromAssetData(const struct FAssetData& Asset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetDefaultObjectFromAssetData");
		
		URBBlueprintLibrary_GetDefaultObjectFromAssetData_Params params {};
		params.Asset = Asset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetDefaultObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UObject* URBBlueprintLibrary::GetDefaultObject(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetDefaultObject");
		
		URBBlueprintLibrary_GetDefaultObject_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetCustomizationMeshForGrunt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGruntCustomizationMeshesConfig             customizationMeshesConfig                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FSelectedGruntCustomizationMeshesInfo       customizationMeshesInfo                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		ENPCCustomizationSlot                              Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FNPCCustomizationMesh URBBlueprintLibrary::GetCustomizationMeshForGrunt(const struct FGruntCustomizationMeshesConfig& customizationMeshesConfig, const struct FSelectedGruntCustomizationMeshesInfo& customizationMeshesInfo, ENPCCustomizationSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetCustomizationMeshForGrunt");
		
		URBBlueprintLibrary_GetCustomizationMeshForGrunt_Params params {};
		params.customizationMeshesConfig = customizationMeshesConfig;
		params.customizationMeshesInfo = customizationMeshesInfo;
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetCurveValueFromAnimInstance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimInstance*                               AnimInstance                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        CurveName                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              out_value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::GetCurveValueFromAnimInstance(class UAnimInstance* AnimInstance, const class FName& CurveName, float* out_value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetCurveValueFromAnimInstance");
		
		URBBlueprintLibrary_GetCurveValueFromAnimInstance_Params params {};
		params.AnimInstance = AnimInstance;
		params.CurveName = CurveName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (out_value != nullptr)
			*out_value = params.out_value;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetCurveValueForAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequence*                               Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        CurveName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              evalTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::GetCurveValueForAnimation(class UAnimSequence* Sequence, const class FName& CurveName, float evalTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetCurveValueForAnimation");
		
		URBBlueprintLibrary_GetCurveValueForAnimation_Params params {};
		params.Sequence = Sequence;
		params.CurveName = CurveName;
		params.evalTime = evalTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetCurrentSAS
	 * 		Flags  -> ()
	 */
	class ARBSAS* URBBlueprintLibrary::GetCurrentSAS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetCurrentSAS");
		
		URBBlueprintLibrary_GetCurrentSAS_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetCurrentMissionID
	 * 		Flags  -> ()
	 */
	struct FRBMissionID URBBlueprintLibrary::GetCurrentMissionID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetCurrentMissionID");
		
		URBBlueprintLibrary_GetCurrentMissionID_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetCurrentEditorNormal
	 * 		Flags  -> ()
	 */
	struct FVector URBBlueprintLibrary::GetCurrentEditorNormal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetCurrentEditorNormal");
		
		URBBlueprintLibrary_GetCurrentEditorNormal_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetControlledPlayer
	 * 		Flags  -> ()
	 */
	class ARBPlayer* URBBlueprintLibrary::GetControlledPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetControlledPlayer");
		
		URBBlueprintLibrary_GetControlledPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetControlledPawn
	 * 		Flags  -> ()
	 */
	class APawn* URBBlueprintLibrary::GetControlledPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetControlledPawn");
		
		URBBlueprintLibrary_GetControlledPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetComponentFromSelector
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBComponentSelector                        componentSelector                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UActorComponent* URBBlueprintLibrary::GetComponentFromSelector(struct FRBComponentSelector* componentSelector, class AActor* Owner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetComponentFromSelector");
		
		URBBlueprintLibrary_GetComponentFromSelector_Params params {};
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (componentSelector != nullptr)
			*componentSelector = params.componentSelector;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetComponentByClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      classOf                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UActorComponent*>                     OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::GetComponentByClass(class AActor* Actor, class UClass* classOf, TArray<class UActorComponent*>* OutComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetComponentByClass");
		
		URBBlueprintLibrary_GetComponentByClass_Params params {};
		params.Actor = Actor;
		params.classOf = classOf;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetCollectibleDocumentsConfig
	 * 		Flags  -> ()
	 */
	class URBCollectibleDocumentsConfig* URBBlueprintLibrary::GetCollectibleDocumentsConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetCollectibleDocumentsConfig");
		
		URBBlueprintLibrary_GetCollectibleDocumentsConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetClosestPushCartGoalManager
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBPushCartGoalManager* URBBlueprintLibrary::GetClosestPushCartGoalManager(const struct FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetClosestPushCartGoalManager");
		
		URBBlueprintLibrary_GetClosestPushCartGoalManager_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetChunkInstallManager
	 * 		Flags  -> ()
	 */
	class URBChunkInstallManager* URBBlueprintLibrary::GetChunkInstallManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetChunkInstallManager");
		
		URBBlueprintLibrary_GetChunkInstallManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetChildComponentsByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ComponentTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class USceneComponent*>                     OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::GetChildComponentsByTag(class USceneComponent* Component, const class FName& ComponentTag, TArray<class USceneComponent*>* OutComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetChildComponentsByTag");
		
		URBBlueprintLibrary_GetChildComponentsByTag_Params params {};
		params.Component = Component;
		params.ComponentTag = ComponentTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetChildComponentsByClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      classOf                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class USceneComponent*>                     OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::GetChildComponentsByClass(class USceneComponent* Component, class UClass* classOf, TArray<class USceneComponent*>* OutComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetChildComponentsByClass");
		
		URBBlueprintLibrary_GetChildComponentsByClass_Params params {};
		params.Component = Component;
		params.classOf = classOf;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetChildComponentByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ComponentTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             outComponent                                               (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::GetChildComponentByTag(class USceneComponent* Component, const class FName& ComponentTag, class USceneComponent** outComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetChildComponentByTag");
		
		URBBlueprintLibrary_GetChildComponentByTag_Params params {};
		params.Component = Component;
		params.ComponentTag = ComponentTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outComponent != nullptr)
			*outComponent = params.outComponent;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetChildComponentByClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      classOf                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USceneComponent* URBBlueprintLibrary::GetChildComponentByClass(class USceneComponent* Component, class UClass* classOf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetChildComponentByClass");
		
		URBBlueprintLibrary_GetChildComponentByClass_Params params {};
		params.Component = Component;
		params.classOf = classOf;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetBoolValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FConfigurableBool                           ConfigurableBool                                           (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::GetBoolValue(const struct FConfigurableBool& ConfigurableBool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetBoolValue");
		
		URBBlueprintLibrary_GetBoolValue_Params params {};
		params.ConfigurableBool = ConfigurableBool;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetBoneTransformForAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequence*                               Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              evalTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform URBBlueprintLibrary::GetBoneTransformForAnimation(class UAnimSequence* Sequence, const class FName& BoneName, float evalTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetBoneTransformForAnimation");
		
		URBBlueprintLibrary_GetBoneTransformForAnimation_Params params {};
		params.Sequence = Sequence;
		params.BoneName = BoneName;
		params.evalTime = evalTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetBinariesVersion
	 * 		Flags  -> ()
	 */
	int32_t URBBlueprintLibrary::GetBinariesVersion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetBinariesVersion");
		
		URBBlueprintLibrary_GetBinariesVersion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetAnyPlayer
	 * 		Flags  -> ()
	 */
	class ARBPlayer* URBBlueprintLibrary::GetAnyPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetAnyPlayer");
		
		URBBlueprintLibrary_GetAnyPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetAnyAlivePlayer
	 * 		Flags  -> ()
	 */
	class ARBPlayer* URBBlueprintLibrary::GetAnyAlivePlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetAnyAlivePlayer");
		
		URBBlueprintLibrary_GetAnyAlivePlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetAnimPlayLength
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequence*                               animSeqence                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::GetAnimPlayLength(class UAnimSequence* animSeqence)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetAnimPlayLength");
		
		URBBlueprintLibrary_GetAnimPlayLength_Params params {};
		params.animSeqence = animSeqence;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetAnimBoneTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      SkeletalMesh                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               AnimAsset                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform URBBlueprintLibrary::GetAnimBoneTransform(class USkeletalMeshComponent* SkeletalMesh, class UAnimSequence* AnimAsset, const class FName& BoneName, float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetAnimBoneTransform");
		
		URBBlueprintLibrary_GetAnimBoneTransform_Params params {};
		params.SkeletalMesh = SkeletalMesh;
		params.AnimAsset = AnimAsset;
		params.BoneName = BoneName;
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetAnchorTransformForInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequence*                               Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             inSceneComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform URBBlueprintLibrary::GetAnchorTransformForInteraction(class UAnimSequence* Sequence, class USceneComponent* inSceneComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetAnchorTransformForInteraction");
		
		URBBlueprintLibrary_GetAnchorTransformForInteraction_Params params {};
		params.Sequence = Sequence;
		params.inSceneComponent = inSceneComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetAnchorOffsetTransformFromGhostAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ghostAnimClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform URBBlueprintLibrary::GetAnchorOffsetTransformFromGhostAnimation(class UClass* ghostAnimClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetAnchorOffsetTransformFromGhostAnimation");
		
		URBBlueprintLibrary_GetAnchorOffsetTransformFromGhostAnimation_Params params {};
		params.ghostAnimClass = ghostAnimClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetAnchorOffsetTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequence*                               Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform URBBlueprintLibrary::GetAnchorOffsetTransform(class UAnimSequence* Sequence)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetAnchorOffsetTransform");
		
		URBBlueprintLibrary_GetAnchorOffsetTransform_Params params {};
		params.Sequence = Sequence;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetAllPushableCarts
	 * 		Flags  -> ()
	 */
	TArray<class ARBBasePushable*> URBBlueprintLibrary::GetAllPushableCarts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetAllPushableCarts");
		
		URBBlueprintLibrary_GetAllPushableCarts_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetAllPlayerStates
	 * 		Flags  -> ()
	 */
	TArray<class ARBPlayerState*> URBBlueprintLibrary::GetAllPlayerStates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetAllPlayerStates");
		
		URBBlueprintLibrary_GetAllPlayerStates_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetActorSelectedInEditor
	 * 		Flags  -> ()
	 */
	TArray<class AActor*> URBBlueprintLibrary::GetActorSelectedInEditor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetActorSelectedInEditor");
		
		URBBlueprintLibrary_GetActorSelectedInEditor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetActiveSkillCommonParamsById
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FActiveSkillCommonParams URBBlueprintLibrary::GetActiveSkillCommonParamsById(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetActiveSkillCommonParamsById");
		
		URBBlueprintLibrary_GetActiveSkillCommonParamsById_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetActiveSkillCommonParams
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActiveSkillType                                   Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FActiveSkillCommonParams URBBlueprintLibrary::GetActiveSkillCommonParams(EActiveSkillType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetActiveSkillCommonParams");
		
		URBBlueprintLibrary_GetActiveSkillCommonParams_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GetActiveSkillClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActiveSkillType                                   Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* URBBlueprintLibrary::GetActiveSkillClass(EActiveSkillType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GetActiveSkillClass");
		
		URBBlueprintLibrary_GetActiveSkillClass_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GenerateRandomString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            nbOfCharactersNeeded                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBBlueprintLibrary::GenerateRandomString(int32_t nbOfCharactersNeeded)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GenerateRandomString");
		
		URBBlueprintLibrary_GenerateRandomString_Params params {};
		params.nbOfCharactersNeeded = nbOfCharactersNeeded;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GenerateRandomSeedNonDeterministic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     randomSeedObject                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBBlueprintLibrary::GenerateRandomSeedNonDeterministic(class UObject* randomSeedObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GenerateRandomSeedNonDeterministic");
		
		URBBlueprintLibrary_GenerateRandomSeedNonDeterministic_Params params {};
		params.randomSeedObject = randomSeedObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.GenerateRandomSeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     randomSeedObject                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBBlueprintLibrary::GenerateRandomSeed(class UObject* randomSeedObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.GenerateRandomSeed");
		
		URBBlueprintLibrary_GenerateRandomSeed_Params params {};
		params.randomSeedObject = randomSeedObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.FromUnixTimestamp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int64_t                                            Timestamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDateTime URBBlueprintLibrary::FromUnixTimestamp(int64_t Timestamp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.FromUnixTimestamp");
		
		URBBlueprintLibrary_FromUnixTimestamp_Params params {};
		params.Timestamp = Timestamp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.FormatTimeFromInt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBBlueprintLibrary::FormatTimeFromInt(int32_t Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.FormatTimeFromInt");
		
		URBBlueprintLibrary_FormatTimeFromInt_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.FormatTimeFromFloat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBBlueprintLibrary::FormatTimeFromFloat(float Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.FormatTimeFromFloat");
		
		URBBlueprintLibrary_FormatTimeFromFloat_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ForceSpecificClosetPlayerRespawnPoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBMonsterCloset*                            Closet                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::ForceSpecificClosetPlayerRespawnPoint(class ARBMonsterCloset* Closet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ForceSpecificClosetPlayerRespawnPoint");
		
		URBBlueprintLibrary_ForceSpecificClosetPlayerRespawnPoint_Params params {};
		params.Closet = Closet;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.FlipRelativeLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFlipX                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFlipY                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFlipZ                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::FlipRelativeLocation(class USceneComponent* Component, bool bFlipX, bool bFlipY, bool bFlipZ)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.FlipRelativeLocation");
		
		URBBlueprintLibrary_FlipRelativeLocation_Params params {};
		params.Component = Component;
		params.bFlipX = bFlipX;
		params.bFlipY = bFlipY;
		params.bFlipZ = bFlipZ;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.FindQuatBetweenVectors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     vec1                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     vec2                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FQuat URBBlueprintLibrary::FindQuatBetweenVectors(const struct FVector& vec1, const struct FVector& vec2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.FindQuatBetweenVectors");
		
		URBBlueprintLibrary_FindQuatBetweenVectors_Params params {};
		params.vec1 = vec1;
		params.vec2 = vec2;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.FindCollisionUVFromHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   UV                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::FindCollisionUVFromHit(const struct FHitResult& Hit, struct FVector2D* UV)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.FindCollisionUVFromHit");
		
		URBBlueprintLibrary_FindCollisionUVFromHit_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (UV != nullptr)
			*UV = params.UV;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.FindChildComponentByTag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class USceneComponent*> URBBlueprintLibrary::FindChildComponentByTag(class USceneComponent* Component, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.FindChildComponentByTag");
		
		URBBlueprintLibrary_FindChildComponentByTag_Params params {};
		params.Component = Component;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.FindAssociatedComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ComponentClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UActorComponent* URBBlueprintLibrary::FindAssociatedComponent(class USceneComponent* Component, class UClass* ComponentClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.FindAssociatedComponent");
		
		URBBlueprintLibrary_FindAssociatedComponent_Params params {};
		params.Component = Component;
		params.ComponentClass = ComponentClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.FilterByRandomState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              inActors                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsStateA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class AActor*> URBBlueprintLibrary::FilterByRandomState(TArray<class AActor*> inActors, bool bIsStateA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.FilterByRandomState");
		
		URBBlueprintLibrary_FilterByRandomState_Params params {};
		params.inActors = inActors;
		params.bIsStateA = bIsStateA;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.EvalRuntimeFloatCurve
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRuntimeFloatCurve                          Curve                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DefaultValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::EvalRuntimeFloatCurve(const struct FRuntimeFloatCurve& Curve, float Time, float DefaultValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.EvalRuntimeFloatCurve");
		
		URBBlueprintLibrary_EvalRuntimeFloatCurve_Params params {};
		params.Curve = Curve;
		params.Time = Time;
		params.DefaultValue = DefaultValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Error
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ErrorText                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Error(const class FString& ErrorText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Error");
		
		URBBlueprintLibrary_Error_Params params {};
		params.ErrorText = ErrorText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.EndCurrentStage
	 * 		Flags  -> ()
	 */
	void URBBlueprintLibrary::EndCurrentStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.EndCurrentStage");
		
		URBBlueprintLibrary_EndCurrentStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Editor_SelectActors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              Actors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Editor_SelectActors(TArray<class AActor*> Actors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Editor_SelectActors");
		
		URBBlueprintLibrary_Editor_SelectActors_Params params {};
		params.Actors = Actors;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Dispatch_StopCameraShake
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInstantly                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     shakeOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreOwnerCondition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Dispatch_StopCameraShake(bool bInstantly, class UObject* shakeOwner, bool bIgnoreOwnerCondition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Dispatch_StopCameraShake");
		
		URBBlueprintLibrary_Dispatch_StopCameraShake_Params params {};
		params.bInstantly = bInstantly;
		params.shakeOwner = shakeOwner;
		params.bIgnoreOwnerCondition = bIgnoreOwnerCondition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Dispatch_PostAudioEventOnIntercom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Dispatch_PostAudioEventOnIntercom(class UAkAudioEvent* akEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Dispatch_PostAudioEventOnIntercom");
		
		URBBlueprintLibrary_Dispatch_PostAudioEventOnIntercom_Params params {};
		params.akEvent = akEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Dispatch_PostAudioEventOnGroup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        GroupName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Dispatch_PostAudioEventOnGroup(class UAkAudioEvent* akEvent, const class FName& GroupName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Dispatch_PostAudioEventOnGroup");
		
		URBBlueprintLibrary_Dispatch_PostAudioEventOnGroup_Params params {};
		params.akEvent = akEvent;
		params.GroupName = GroupName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Dispatch_PostAssociatedAKEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkComponent*                                AkComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Dispatch_PostAssociatedAKEvent(class UAkComponent* AkComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Dispatch_PostAssociatedAKEvent");
		
		URBBlueprintLibrary_Dispatch_PostAssociatedAKEvent_Params params {};
		params.AkComponent = AkComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Dispatch_PostAkEventOnActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Dispatch_PostAkEventOnActor(class AActor* Actor, class UAkAudioEvent* akEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Dispatch_PostAkEventOnActor");
		
		URBBlueprintLibrary_Dispatch_PostAkEventOnActor_Params params {};
		params.Actor = Actor;
		params.akEvent = akEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Dispatch_PostAkEventGlobal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Dispatch_PostAkEventGlobal(class UAkAudioEvent* akEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Dispatch_PostAkEventGlobal");
		
		URBBlueprintLibrary_Dispatch_PostAkEventGlobal_Params params {};
		params.akEvent = akEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Dispatch_PostAkEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkComponent*                                AkComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Dispatch_PostAkEvent(class UAkComponent* AkComponent, class UAkAudioEvent* akEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Dispatch_PostAkEvent");
		
		URBBlueprintLibrary_Dispatch_PostAkEvent_Params params {};
		params.AkComponent = AkComponent;
		params.akEvent = akEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Dispatch_PlayVOOnWatch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Dispatch_PlayVOOnWatch(class UAkAudioEvent* akEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Dispatch_PlayVOOnWatch");
		
		URBBlueprintLibrary_Dispatch_PlayVOOnWatch_Params params {};
		params.akEvent = akEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Dispatch_PlayVOOnNarrator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVOPriority                                        VOPriority                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Dispatch_PlayVOOnNarrator(class UAkAudioEvent* akEvent, EVOPriority VOPriority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Dispatch_PlayVOOnNarrator");
		
		URBBlueprintLibrary_Dispatch_PlayVOOnNarrator_Params params {};
		params.akEvent = akEvent;
		params.VOPriority = VOPriority;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Dispatch_PlayVOOnActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVOPriority                                        VOPriority                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayOnPlayersWatch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Dispatch_PlayVOOnActor(class UAkAudioEvent* akEvent, class AActor* Owner, EVOPriority VOPriority, bool bPlayOnPlayersWatch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Dispatch_PlayVOOnActor");
		
		URBBlueprintLibrary_Dispatch_PlayVOOnActor_Params params {};
		params.akEvent = akEvent;
		params.Owner = Owner;
		params.VOPriority = VOPriority;
		params.bPlayOnPlayersWatch = bPlayOnPlayersWatch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Dispatch_PlaySingleShotMusicTrack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               musicTrack                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPauseLevelMusic                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Dispatch_PlaySingleShotMusicTrack(class UAkAudioEvent* musicTrack, class ARBPlayer* Player, bool bPauseLevelMusic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Dispatch_PlaySingleShotMusicTrack");
		
		URBBlueprintLibrary_Dispatch_PlaySingleShotMusicTrack_Params params {};
		params.musicTrack = musicTrack;
		params.Player = Player;
		params.bPauseLevelMusic = bPauseLevelMusic;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Dispatch_ActivateVFX
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Dispatch_ActivateVFX(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Dispatch_ActivateVFX");
		
		URBBlueprintLibrary_Dispatch_ActivateVFX_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Dispatch_ActivateCameraShake
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCameraShakeData                            shakeData                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     sourceLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     shakeOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::Dispatch_ActivateCameraShake(const struct FCameraShakeData& shakeData, const struct FVector& sourceLocation, class UObject* shakeOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Dispatch_ActivateCameraShake");
		
		URBBlueprintLibrary_Dispatch_ActivateCameraShake_Params params {};
		params.shakeData = shakeData;
		params.sourceLocation = sourceLocation;
		params.shakeOwner = shakeOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.DisablePawnAnimOptims
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     RBPawn                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisableOptims                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::DisablePawnAnimOptims(class ARBPawn* RBPawn, bool bDisableOptims)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.DisablePawnAnimOptims");
		
		URBBlueprintLibrary_DisablePawnAnimOptims_Params params {};
		params.RBPawn = RBPawn;
		params.bDisableOptims = bDisableOptims;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.DestroyComponentHierarchy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::DestroyComponentHierarchy(class USceneComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.DestroyComponentHierarchy");
		
		URBBlueprintLibrary_DestroyComponentHierarchy_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ConfigurableIntToString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FConfigurableInt                            ConfigurableInt                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBBlueprintLibrary::ConfigurableIntToString(const struct FConfigurableInt& ConfigurableInt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ConfigurableIntToString");
		
		URBBlueprintLibrary_ConfigurableIntToString_Params params {};
		params.ConfigurableInt = ConfigurableInt;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ConfigurableFloatToString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FConfigurableFloat                          ConfigurableFloat                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBBlueprintLibrary::ConfigurableFloatToString(const struct FConfigurableFloat& ConfigurableFloat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ConfigurableFloatToString");
		
		URBBlueprintLibrary_ConfigurableFloatToString_Params params {};
		params.ConfigurableFloat = ConfigurableFloat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ConfigurableBoolToString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FConfigurableBool                           ConfigurableBool                                           (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBBlueprintLibrary::ConfigurableBoolToString(const struct FConfigurableBool& ConfigurableBool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ConfigurableBoolToString");
		
		URBBlueprintLibrary_ConfigurableBoolToString_Params params {};
		params.ConfigurableBool = ConfigurableBool;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.CompleteSingleObjective
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     playerCompleting                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      objectiveActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::CompleteSingleObjective(class ARBPawn* playerCompleting, class AActor* objectiveActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.CompleteSingleObjective");
		
		URBBlueprintLibrary_CompleteSingleObjective_Params params {};
		params.playerCompleting = playerCompleting;
		params.objectiveActor = objectiveActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ClientOnly_QueueVOOnActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVOPriority                                        VOPriority                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              prePlayDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            forcedRandomSeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::ClientOnly_QueueVOOnActor(class UAkAudioEvent* akEvent, class AActor* Owner, EVOPriority VOPriority, float prePlayDelay, int32_t forcedRandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ClientOnly_QueueVOOnActor");
		
		URBBlueprintLibrary_ClientOnly_QueueVOOnActor_Params params {};
		params.akEvent = akEvent;
		params.Owner = Owner;
		params.VOPriority = VOPriority;
		params.prePlayDelay = prePlayDelay;
		params.forcedRandomSeed = forcedRandomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ClientOnly_PlayVOOnActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVOPriority                                        VOPriority                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            forcedRandomSeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::ClientOnly_PlayVOOnActor(class UAkAudioEvent* akEvent, class AActor* Owner, EVOPriority VOPriority, int32_t forcedRandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ClientOnly_PlayVOOnActor");
		
		URBBlueprintLibrary_ClientOnly_PlayVOOnActor_Params params {};
		params.akEvent = akEvent;
		params.Owner = Owner;
		params.VOPriority = VOPriority;
		params.forcedRandomSeed = forcedRandomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ClearVariatorGlobalSwitchesChanged
	 * 		Flags  -> ()
	 */
	void URBBlueprintLibrary::ClearVariatorGlobalSwitchesChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ClearVariatorGlobalSwitchesChanged");
		
		URBBlueprintLibrary_ClearVariatorGlobalSwitchesChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.CheckFeatureSwitch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::CheckFeatureSwitch(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.CheckFeatureSwitch");
		
		URBBlueprintLibrary_CheckFeatureSwitch_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.CanNPCBeFemale
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGruntCustomizationMeshesConfig             customizationMeshesConfig                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		ENPCFlavor                                         Flavor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::CanNPCBeFemale(const struct FGruntCustomizationMeshesConfig& customizationMeshesConfig, ENPCFlavor Flavor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.CanNPCBeFemale");
		
		URBBlueprintLibrary_CanNPCBeFemale_Params params {};
		params.customizationMeshesConfig = customizationMeshesConfig;
		params.Flavor = Flavor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.CanEditLoadouts
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::CanEditLoadouts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.CanEditLoadouts");
		
		URBBlueprintLibrary_CanEditLoadouts_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.CanActorCollisionOverlapInEditor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      baseActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      actorToCheck                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::CanActorCollisionOverlapInEditor(class AActor* baseActor, class AActor* actorToCheck)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.CanActorCollisionOverlapInEditor");
		
		URBBlueprintLibrary_CanActorCollisionOverlapInEditor_Params params {};
		params.baseActor = baseActor;
		params.actorToCheck = actorToCheck;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.BP_IsRayTracingEnabled
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::BP_IsRayTracingEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.BP_IsRayTracingEnabled");
		
		URBBlueprintLibrary_BP_IsRayTracingEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.BP_IsIndicatorOfObjectiveType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerIndicatorType                               indicatorType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::BP_IsIndicatorOfObjectiveType(EPlayerIndicatorType indicatorType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.BP_IsIndicatorOfObjectiveType");
		
		URBBlueprintLibrary_BP_IsIndicatorOfObjectiveType_Params params {};
		params.indicatorType = indicatorType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.BP_IsIndicatorOfIncapacitatedType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerIndicatorType                               indicatorType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::BP_IsIndicatorOfIncapacitatedType(EPlayerIndicatorType indicatorType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.BP_IsIndicatorOfIncapacitatedType");
		
		URBBlueprintLibrary_BP_IsIndicatorOfIncapacitatedType_Params params {};
		params.indicatorType = indicatorType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.BlockPlayerRespawnInStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     blockOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::BlockPlayerRespawnInStage(class UObject* blockOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.BlockPlayerRespawnInStage");
		
		URBBlueprintLibrary_BlockPlayerRespawnInStage_Params params {};
		params.blockOwner = blockOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.AreSameProfileIds
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProfileId                                  firstProfileId                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FProfileId                                  secondProfileId                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBBlueprintLibrary::AreSameProfileIds(const struct FProfileId& firstProfileId, const struct FProfileId& secondProfileId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.AreSameProfileIds");
		
		URBBlueprintLibrary_AreSameProfileIds_Params params {};
		params.firstProfileId = firstProfileId;
		params.secondProfileId = secondProfileId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.AreCheatsEnabled
	 * 		Flags  -> ()
	 */
	bool URBBlueprintLibrary::AreCheatsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.AreCheatsEnabled");
		
		URBBlueprintLibrary_AreCheatsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.Approach
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Current                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Target                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              coeff                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::Approach(float Current, float Target, float coeff, float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.Approach");
		
		URBBlueprintLibrary_Approach_Params params {};
		params.Current = Current;
		params.Target = Target;
		params.coeff = coeff;
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.AInterpTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBBlueprintLibrary::AInterpTo(float Current, float Target, float DeltaTime, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.AInterpTo");
		
		URBBlueprintLibrary_AInterpTo_Params params {};
		params.Current = Current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.AddVariatorGlobalSwitch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        SwitchGroup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SwitchName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::AddVariatorGlobalSwitch(const class FName& SwitchGroup, const class FName& SwitchName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.AddVariatorGlobalSwitch");
		
		URBBlueprintLibrary_AddVariatorGlobalSwitch_Params params {};
		params.SwitchGroup = SwitchGroup;
		params.SwitchName = SwitchName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.AddRandomizeRelativeLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              rangeXMin                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              rangeXMax                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              rangeYMin                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              rangeYMax                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              rangeZMin                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              rangeZMax                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBlueprintLibrary::AddRandomizeRelativeLocation(class USceneComponent* Component, int32_t RandomSeed, float rangeXMin, float rangeXMax, float rangeYMin, float rangeYMax, float rangeZMin, float rangeZMax)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.AddRandomizeRelativeLocation");
		
		URBBlueprintLibrary_AddRandomizeRelativeLocation_Params params {};
		params.Component = Component;
		params.RandomSeed = RandomSeed;
		params.rangeXMin = rangeXMin;
		params.rangeXMax = rangeXMax;
		params.rangeYMin = rangeYMin;
		params.rangeYMax = rangeYMax;
		params.rangeZMin = rangeZMin;
		params.rangeZMax = rangeZMax;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBlueprintLibrary.ActivateStageExitSAS
	 * 		Flags  -> ()
	 */
	void URBBlueprintLibrary::ActivateStageExitSAS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBlueprintLibrary.ActivateStageExitSAS");
		
		URBBlueprintLibrary_ActivateStageExitSAS_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBot.BP_GetDebugPawnName
	 * 		Flags  -> ()
	 */
	class FString ARBBot::BP_GetDebugPawnName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBot.BP_GetDebugPawnName");
		
		ARBBot_BP_GetDebugPawnName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBBot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBBot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBBotVision.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBBotVision::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBotVision");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBoxNavMeshBlockingComponent.SetBlocking
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bBlockingValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBoxNavMeshBlockingComponent::SetBlocking(bool bBlockingValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBoxNavMeshBlockingComponent.SetBlocking");
		
		URBBoxNavMeshBlockingComponent_SetBlocking_Params params {};
		params.bBlockingValue = bBlockingValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBoxNavMeshBlockingComponent.RecomputeTransform
	 * 		Flags  -> ()
	 */
	void URBBoxNavMeshBlockingComponent::RecomputeTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBoxNavMeshBlockingComponent.RecomputeTransform");
		
		URBBoxNavMeshBlockingComponent_RecomputeTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBoxNavMeshBlockingComponent.OnRep_CurrentlyBlocking
	 * 		Flags  -> ()
	 */
	void URBBoxNavMeshBlockingComponent::OnRep_CurrentlyBlocking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBoxNavMeshBlockingComponent.OnRep_CurrentlyBlocking");
		
		URBBoxNavMeshBlockingComponent_OnRep_CurrentlyBlocking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBBoxNavMeshBlockingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBBoxNavMeshBlockingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBoxNavMeshBlockingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableObstacle.OnRep_CurrentlyEnabled
	 * 		Flags  -> ()
	 */
	void ARBBreakableObstacle::OnRep_CurrentlyEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableObstacle.OnRep_CurrentlyEnabled");
		
		ARBBreakableObstacle_OnRep_CurrentlyEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableObstacle.OnRep_Broken
	 * 		Flags  -> ()
	 */
	void ARBBreakableObstacle::OnRep_Broken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableObstacle.OnRep_Broken");
		
		ARBBreakableObstacle_OnRep_Broken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableObstacle.OnBreak
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBDamageableComponent*                      damageComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBreakableObstacle::OnBreak(class URBDamageableComponent* damageComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableObstacle.OnBreak");
		
		ARBBreakableObstacle_OnBreak_Params params {};
		params.damageComponent = damageComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableObstacle.IsBlocked
	 * 		Flags  -> ()
	 */
	bool ARBBreakableObstacle::IsBlocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableObstacle.IsBlocked");
		
		ARBBreakableObstacle_IsBlocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableObstacle.Event_OnStateChanged
	 * 		Flags  -> ()
	 */
	void ARBBreakableObstacle::Event_OnStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableObstacle.Event_OnStateChanged");
		
		ARBBreakableObstacle_Event_OnStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableObstacle.Event_OnBreakObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      SourceActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBreakableObstacle::Event_OnBreakObject(class AActor* SourceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableObstacle.Event_OnBreakObject");
		
		ARBBreakableObstacle_Event_OnBreakObject_Params params {};
		params.SourceActor = SourceActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableObstacle.BrokenChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBreakableObstacle::BrokenChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableObstacle.BrokenChangedCallback");
		
		ARBBreakableObstacle_BrokenChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableObstacle.BP_IsBroken
	 * 		Flags  -> ()
	 */
	bool ARBBreakableObstacle::BP_IsBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableObstacle.BP_IsBroken");
		
		ARBBreakableObstacle_BP_IsBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableObstacle.BP_IsActive
	 * 		Flags  -> ()
	 */
	bool ARBBreakableObstacle::BP_IsActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableObstacle.BP_IsActive");
		
		ARBBreakableObstacle_BP_IsActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBBreakableObstacle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBBreakableObstacle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBreakableObstacle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableWindowReplaceableClass.OnReplacedWindow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBreakableWindow*                          Window                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBBreakableWindowReplaceableClass::OnReplacedWindow(class ARBBreakableWindow* Window)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableWindowReplaceableClass.OnReplacedWindow");
		
		URBBreakableWindowReplaceableClass_OnReplacedWindow_Params params {};
		params.Window = Window;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBBreakableWindowReplaceableClass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBBreakableWindowReplaceableClass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBreakableWindowReplaceableClass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableWindow.OnRep_ShutterClosed
	 * 		Flags  -> ()
	 */
	void ARBBreakableWindow::OnRep_ShutterClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableWindow.OnRep_ShutterClosed");
		
		ARBBreakableWindow_OnRep_ShutterClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableWindow.OnRep_DynamicallyReplaced
	 * 		Flags  -> ()
	 */
	void ARBBreakableWindow::OnRep_DynamicallyReplaced()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableWindow.OnRep_DynamicallyReplaced");
		
		ARBBreakableWindow_OnRep_DynamicallyReplaced_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableWindow.OnRep_BlockableState
	 * 		Flags  -> ()
	 */
	void ARBBreakableWindow::OnRep_BlockableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableWindow.OnRep_BlockableState");
		
		ARBBreakableWindow_OnRep_BlockableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableWindow.OnLinkedShutterStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsOn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBTriggerable*                              triggerable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBreakableWindow::OnLinkedShutterStateChanged(bool IsOn, class ARBTriggerable* triggerable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableWindow.OnLinkedShutterStateChanged");
		
		ARBBreakableWindow_OnLinkedShutterStateChanged_Params params {};
		params.IsOn = IsOn;
		params.triggerable = triggerable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableWindow.GetBlockableState
	 * 		Flags  -> ()
	 */
	EBlockableState ARBBreakableWindow::GetBlockableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableWindow.GetBlockableState");
		
		ARBBreakableWindow_GetBlockableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableWindow.Event_OnShutterStateChanged
	 * 		Flags  -> ()
	 */
	void ARBBreakableWindow::Event_OnShutterStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableWindow.Event_OnShutterStateChanged");
		
		ARBBreakableWindow_Event_OnShutterStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableWindow.Event_OnBlockableStateChanged
	 * 		Flags  -> ()
	 */
	void ARBBreakableWindow::Event_OnBlockableStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableWindow.Event_OnBlockableStateChanged");
		
		ARBBreakableWindow_Event_OnBlockableStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableWindow.Editor_RefreshGroundDetection
	 * 		Flags  -> ()
	 */
	void ARBBreakableWindow::Editor_RefreshGroundDetection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableWindow.Editor_RefreshGroundDetection");
		
		ARBBreakableWindow_Editor_RefreshGroundDetection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBBreakableWindow.BP_ForceBlockableState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EBlockableState                                    inBlockableState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBBreakableWindow::BP_ForceBlockableState(EBlockableState inBlockableState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBBreakableWindow.BP_ForceBlockableState");
		
		ARBBreakableWindow_BP_ForceBlockableState_Params params {};
		params.inBlockableState = inBlockableState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBBreakableWindow.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBBreakableWindow::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBreakableWindow");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBCameraManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBCameraManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCameraManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanel.RefreshLightStatus
	 * 		Flags  -> ()
	 */
	void ARBSwitchPanel::RefreshLightStatus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanel.RefreshLightStatus");
		
		ARBSwitchPanel_RefreshLightStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanel.OnRep_StatusValue
	 * 		Flags  -> ()
	 */
	void ARBSwitchPanel::OnRep_StatusValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanel.OnRep_StatusValue");
		
		ARBSwitchPanel_OnRep_StatusValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanel.OnRep_PanelParts
	 * 		Flags  -> ()
	 */
	void ARBSwitchPanel::OnRep_PanelParts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanel.OnRep_PanelParts");
		
		ARBSwitchPanel_OnRep_PanelParts_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanel.OnRep_PanelEnabled
	 * 		Flags  -> ()
	 */
	void ARBSwitchPanel::OnRep_PanelEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanel.OnRep_PanelEnabled");
		
		ARBSwitchPanel_OnRep_PanelEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanel.GivesFocusTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactorPawn                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBInteractionZoneComponent* ARBSwitchPanel::GivesFocusTo(class ARBPawn* interactorPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanel.GivesFocusTo");
		
		ARBSwitchPanel_GivesFocusTo_Params params {};
		params.interactorPawn = interactorPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanel.Event_PanelEnabledChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabledValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSwitchPanel::Event_PanelEnabledChanged(bool bEnabledValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanel.Event_PanelEnabledChanged");
		
		ARBSwitchPanel_Event_PanelEnabledChanged_Params params {};
		params.bEnabledValue = bEnabledValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanel.BP_StopShake
	 * 		Flags  -> ()
	 */
	void ARBSwitchPanel::BP_StopShake()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanel.BP_StopShake");
		
		ARBSwitchPanel_BP_StopShake_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanel.BP_StartShake
	 * 		Flags  -> ()
	 */
	void ARBSwitchPanel::BP_StartShake()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanel.BP_StartShake");
		
		ARBSwitchPanel_BP_StartShake_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanel.BP_SetPanelEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabledValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSwitchPanel::BP_SetPanelEnabled(bool bEnabledValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanel.BP_SetPanelEnabled");
		
		ARBSwitchPanel_BP_SetPanelEnabled_Params params {};
		params.bEnabledValue = bEnabledValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanel.BP_ResetAllPartsValues
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bKeepCurrentValues                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSwitchPanel::BP_ResetAllPartsValues(bool bKeepCurrentValues)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanel.BP_ResetAllPartsValues");
		
		ARBSwitchPanel_BP_ResetAllPartsValues_Params params {};
		params.bKeepCurrentValues = bKeepCurrentValues;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanel.BP_OnStoppedInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBSwitchPanelPart*                          panelPart                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSwitchPanel::BP_OnStoppedInteraction(class ARBPawn* Pawn, class ARBSwitchPanelPart* panelPart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanel.BP_OnStoppedInteraction");
		
		ARBSwitchPanel_BP_OnStoppedInteraction_Params params {};
		params.Pawn = Pawn;
		params.panelPart = panelPart;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanel.BP_OnStatusUpdated
	 * 		Flags  -> ()
	 */
	void ARBSwitchPanel::BP_OnStatusUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanel.BP_OnStatusUpdated");
		
		ARBSwitchPanel_BP_OnStatusUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanel.BP_OnStartedInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBSwitchPanelPart*                          panelPart                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSwitchPanel::BP_OnStartedInteraction(class ARBPawn* Pawn, class ARBSwitchPanelPart* panelPart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanel.BP_OnStartedInteraction");
		
		ARBSwitchPanel_BP_OnStartedInteraction_Params params {};
		params.Pawn = Pawn;
		params.panelPart = panelPart;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSwitchPanel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSwitchPanel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSwitchPanel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCameraPanel.OnRep_PowerButtonActivated
	 * 		Flags  -> ()
	 */
	void ARBCameraPanel::OnRep_PowerButtonActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCameraPanel.OnRep_PowerButtonActivated");
		
		ARBCameraPanel_OnRep_PowerButtonActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCameraPanel.OnRep_DestructionStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            oldDestructionStage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCameraPanel::OnRep_DestructionStage(int32_t oldDestructionStage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCameraPanel.OnRep_DestructionStage");
		
		ARBCameraPanel_OnRep_DestructionStage_Params params {};
		params.oldDestructionStage = oldDestructionStage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCameraPanel.Event_PowerButtonActivatedChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabledValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCameraPanel::Event_PowerButtonActivatedChanged(bool bEnabledValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCameraPanel.Event_PowerButtonActivatedChanged");
		
		ARBCameraPanel_Event_PowerButtonActivatedChanged_Params params {};
		params.bEnabledValue = bEnabledValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCameraPanel.BP_SetCameraPowerButton
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBSwitchPanelPart*                          part                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCameraPanel::BP_SetCameraPowerButton(class ARBSwitchPanelPart* part)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCameraPanel.BP_SetCameraPowerButton");
		
		ARBCameraPanel_BP_SetCameraPowerButton_Params params {};
		params.part = part;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBCameraPanel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBCameraPanel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCameraPanel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.OnPlayerCustomizationUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBPlayerCustomizationInfo                  customizationInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::OnPlayerCustomizationUpdated(const struct FRBPlayerCustomizationInfo& customizationInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.OnPlayerCustomizationUpdated");
		
		URBCharacterCustomizationContent_OnPlayerCustomizationUpdated_Params params {};
		params.customizationInfo = customizationInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.OnItemMouseUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUICustomizationItem                        Item                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::OnItemMouseUp(const struct FUICustomizationItem& Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.OnItemMouseUp");
		
		URBCharacterCustomizationContent_OnItemMouseUp_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.OnItemMouseDown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUICustomizationItem                        Item                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::OnItemMouseDown(const struct FUICustomizationItem& Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.OnItemMouseDown");
		
		URBCharacterCustomizationContent_OnItemMouseDown_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.OnItemClicked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUICustomizationItem                        Item                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		ECustomizationMenuCategory                         Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::OnItemClicked(const struct FUICustomizationItem& Item, ECustomizationMenuCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.OnItemClicked");
		
		URBCharacterCustomizationContent_OnItemClicked_Params params {};
		params.Item = Item;
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.OnHairColorClicked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        newHairColorId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::OnHairColorClicked(const class FName& newHairColorId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.OnHairColorClicked");
		
		URBCharacterCustomizationContent_OnHairColorClicked_Params params {};
		params.newHairColorId = newHairColorId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.OnAcquiredItemsChanged
	 * 		Flags  -> ()
	 */
	void URBCharacterCustomizationContent::OnAcquiredItemsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.OnAcquiredItemsChanged");
		
		URBCharacterCustomizationContent_OnAcquiredItemsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.GetItemCountForCategory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECustomizationMenuCategory                         Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isCustomizingFemale                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBCharacterCustomizationContent::GetItemCountForCategory(ECustomizationMenuCategory Category, bool isCustomizingFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.GetItemCountForCategory");
		
		URBCharacterCustomizationContent_GetItemCountForCategory_Params params {};
		params.Category = Category;
		params.isCustomizingFemale = isCustomizingFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.GetIsCustomizingFemale
	 * 		Flags  -> ()
	 */
	bool URBCharacterCustomizationContent::GetIsCustomizingFemale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.GetIsCustomizingFemale");
		
		URBCharacterCustomizationContent_GetIsCustomizingFemale_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.GetEquippedHairColor
	 * 		Flags  -> ()
	 */
	class FName URBCharacterCustomizationContent::GetEquippedHairColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.GetEquippedHairColor");
		
		URBCharacterCustomizationContent_GetEquippedHairColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.Event_RefreshItemInfos
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FUICustomizationItem>                Items                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::Event_RefreshItemInfos(TArray<struct FUICustomizationItem> Items)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.Event_RefreshItemInfos");
		
		URBCharacterCustomizationContent_Event_RefreshItemInfos_Params params {};
		params.Items = Items;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.Event_PlayerCustomizationUpdated
	 * 		Flags  -> ()
	 */
	void URBCharacterCustomizationContent::Event_PlayerCustomizationUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.Event_PlayerCustomizationUpdated");
		
		URBCharacterCustomizationContent_Event_PlayerCustomizationUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.Event_LoadingStarted
	 * 		Flags  -> ()
	 */
	void URBCharacterCustomizationContent::Event_LoadingStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.Event_LoadingStarted");
		
		URBCharacterCustomizationContent_Event_LoadingStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.Event_ItemEquipped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUICustomizationItem                        Item                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::Event_ItemEquipped(const struct FUICustomizationItem& Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.Event_ItemEquipped");
		
		URBCharacterCustomizationContent_Event_ItemEquipped_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.Event_ItemBought
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUICustomizationItem                        Item                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::Event_ItemBought(const struct FUICustomizationItem& Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.Event_ItemBought");
		
		URBCharacterCustomizationContent_Event_ItemBought_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.Event_AddVoiceOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class URBVoiceCustomizationOption*>         voiceOptions                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::Event_AddVoiceOptions(TArray<class URBVoiceCustomizationOption*> voiceOptions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.Event_AddVoiceOptions");
		
		URBCharacterCustomizationContent_Event_AddVoiceOptions_Params params {};
		params.voiceOptions = voiceOptions;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.Event_AddPlayerIconOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class URBPlayerIconCustomizationOption*>    playerIconOptions                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::Event_AddPlayerIconOptions(TArray<class URBPlayerIconCustomizationOption*> playerIconOptions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.Event_AddPlayerIconOptions");
		
		URBCharacterCustomizationContent_Event_AddPlayerIconOptions_Params params {};
		params.playerIconOptions = playerIconOptions;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.Event_AddCustomizationSlotOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class URBPlayerCustomizationOption*>        Options                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               selectSpecificIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            selectedIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::Event_AddCustomizationSlotOptions(TArray<class URBPlayerCustomizationOption*> Options, bool selectSpecificIndex, int32_t selectedIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.Event_AddCustomizationSlotOptions");
		
		URBCharacterCustomizationContent_Event_AddCustomizationSlotOptions_Params params {};
		params.Options = Options;
		params.selectSpecificIndex = selectSpecificIndex;
		params.selectedIndex = selectedIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.Event_AddCustomizationItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FUICustomizationItem>                Items                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::Event_AddCustomizationItems(TArray<struct FUICustomizationItem> Items)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.Event_AddCustomizationItems");
		
		URBCharacterCustomizationContent_Event_AddCustomizationItems_Params params {};
		params.Items = Items;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.EquipVoice
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBVoiceCustomizationOption*                 clickedVoice                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::EquipVoice(class URBVoiceCustomizationOption* clickedVoice)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.EquipVoice");
		
		URBCharacterCustomizationContent_EquipVoice_Params params {};
		params.clickedVoice = clickedVoice;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.EquipPlayerIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPlayerIconCustomizationOption*            clickedPlayerIcon                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::EquipPlayerIcon(class URBPlayerIconCustomizationOption* clickedPlayerIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.EquipPlayerIcon");
		
		URBCharacterCustomizationContent_EquipPlayerIcon_Params params {};
		params.clickedPlayerIcon = clickedPlayerIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.EquipOutfit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBCustomizationOutfit*                      clickedOutfit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::EquipOutfit(class URBCustomizationOutfit* clickedOutfit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.EquipOutfit");
		
		URBCharacterCustomizationContent_EquipOutfit_Params params {};
		params.clickedOutfit = clickedOutfit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.EquipItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPlayerCustomizationOption*                clickedOption                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::EquipItem(class URBPlayerCustomizationOption* clickedOption)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.EquipItem");
		
		URBCharacterCustomizationContent_EquipItem_Params params {};
		params.clickedOption = clickedOption;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.CategoryClicked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECustomizationMenuCategory                         Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCharacterCustomizationContent::CategoryClicked(ECustomizationMenuCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.CategoryClicked");
		
		URBCharacterCustomizationContent_CategoryClicked_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.BP_GetOptionsForPreview
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPlayerCustomizationOption*                optionToPreview                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBCustomizationOutfit*                      outfitToPreview                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBPlayerCustomizationInfo URBCharacterCustomizationContent::BP_GetOptionsForPreview(class URBPlayerCustomizationOption* optionToPreview, class URBCustomizationOutfit* outfitToPreview)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.BP_GetOptionsForPreview");
		
		URBCharacterCustomizationContent_BP_GetOptionsForPreview_Params params {};
		params.optionToPreview = optionToPreview;
		params.outfitToPreview = outfitToPreview;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationContent.BP_GetCurrentPreviewOptions
	 * 		Flags  -> ()
	 */
	struct FRBPlayerCustomizationInfo URBCharacterCustomizationContent::BP_GetCurrentPreviewOptions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationContent.BP_GetCurrentPreviewOptions");
		
		URBCharacterCustomizationContent_BP_GetCurrentPreviewOptions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCharacterCustomizationContent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCharacterCustomizationContent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCharacterCustomizationContent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationMenu.SaveCustomization
	 * 		Flags  -> ()
	 */
	void URBCharacterCustomizationMenu::SaveCustomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationMenu.SaveCustomization");
		
		URBCharacterCustomizationMenu_SaveCustomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCharacterCustomizationMenu.Event_SetupPostRelease
	 * 		Flags  -> ()
	 */
	void URBCharacterCustomizationMenu::Event_SetupPostRelease()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCharacterCustomizationMenu.Event_SetupPostRelease");
		
		URBCharacterCustomizationMenu_Event_SetupPostRelease_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCharacterCustomizationMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCharacterCustomizationMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCharacterCustomizationMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.TryChangeTab
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuWithTabsWidget::TryChangeTab(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.TryChangeTab");
		
		URBMenuWithTabsWidget_TryChangeTab_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.TransitionDone
	 * 		Flags  -> ()
	 */
	void URBMenuWithTabsWidget::TransitionDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.TransitionDone");
		
		URBMenuWithTabsWidget_TransitionDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.RequestNavigationBack
	 * 		Flags  -> ()
	 */
	void URBMenuWithTabsWidget::RequestNavigationBack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.RequestNavigationBack");
		
		URBMenuWithTabsWidget_RequestNavigationBack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.PreviousTab
	 * 		Flags  -> ()
	 */
	void URBMenuWithTabsWidget::PreviousTab()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.PreviousTab");
		
		URBMenuWithTabsWidget_PreviousTab_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.PreNavigationChangeAction
	 * 		Flags  -> ()
	 */
	bool URBMenuWithTabsWidget::PreNavigationChangeAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.PreNavigationChangeAction");
		
		URBMenuWithTabsWidget_PreNavigationChangeAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.OnTabNavigationChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               CanExitMenu                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuWithTabsWidget::OnTabNavigationChanged(bool CanExitMenu)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.OnTabNavigationChanged");
		
		URBMenuWithTabsWidget_OnTabNavigationChanged_Params params {};
		params.CanExitMenu = CanExitMenu;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.OnTabButtonClicked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMenuTabButton*                            Button                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuWithTabsWidget::OnTabButtonClicked(class URBMenuTabButton* Button)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.OnTabButtonClicked");
		
		URBMenuWithTabsWidget_OnTabButtonClicked_Params params {};
		params.Button = Button;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.OnMenuCancelPressed
	 * 		Flags  -> ()
	 */
	void URBMenuWithTabsWidget::OnMenuCancelPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.OnMenuCancelPressed");
		
		URBMenuWithTabsWidget_OnMenuCancelPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.NextTab
	 * 		Flags  -> ()
	 */
	void URBMenuWithTabsWidget::NextTab()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.NextTab");
		
		URBMenuWithTabsWidget_NextTab_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.GetSelectedTabButton
	 * 		Flags  -> ()
	 */
	class URBMenuTabButton* URBMenuWithTabsWidget::GetSelectedTabButton()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.GetSelectedTabButton");
		
		URBMenuWithTabsWidget_GetSelectedTabButton_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.Event_UpdateNavigation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               CanExitMenu                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuWithTabsWidget::Event_UpdateNavigation(bool CanExitMenu)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.Event_UpdateNavigation");
		
		URBMenuWithTabsWidget_Event_UpdateNavigation_Params params {};
		params.CanExitMenu = CanExitMenu;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.Event_StartTransitionOut
	 * 		Flags  -> ()
	 */
	void URBMenuWithTabsWidget::Event_StartTransitionOut()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.Event_StartTransitionOut");
		
		URBMenuWithTabsWidget_Event_StartTransitionOut_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.Event_StartTransitionIn
	 * 		Flags  -> ()
	 */
	void URBMenuWithTabsWidget::Event_StartTransitionIn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.Event_StartTransitionIn");
		
		URBMenuWithTabsWidget_Event_StartTransitionIn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.Event_OnMenuTabSwitched
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            previousIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuWithTabsWidget::Event_OnMenuTabSwitched(int32_t previousIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.Event_OnMenuTabSwitched");
		
		URBMenuWithTabsWidget_Event_OnMenuTabSwitched_Params params {};
		params.previousIndex = previousIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.CanExitMenu
	 * 		Flags  -> ()
	 */
	bool URBMenuWithTabsWidget::CanExitMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.CanExitMenu");
		
		URBMenuWithTabsWidget_CanExitMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.BP_SetSelectedTabFromButton
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMenuTabButton*                            Button                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuWithTabsWidget::BP_SetSelectedTabFromButton(class URBMenuTabButton* Button)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.BP_SetSelectedTabFromButton");
		
		URBMenuWithTabsWidget_BP_SetSelectedTabFromButton_Params params {};
		params.Button = Button;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.BP_SetSelectedTab
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuWithTabsWidget::BP_SetSelectedTab(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.BP_SetSelectedTab");
		
		URBMenuWithTabsWidget_BP_SetSelectedTab_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuWithTabsWidget.BP_Initialize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class URBMenuTabButton*>                    inTabButtons                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UWidgetSwitcher*                             inTabSwitcher                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuWithTabsWidget::BP_Initialize(TArray<class URBMenuTabButton*> inTabButtons, class UWidgetSwitcher* inTabSwitcher)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuWithTabsWidget.BP_Initialize");
		
		URBMenuWithTabsWidget_BP_Initialize_Params params {};
		params.inTabButtons = inTabButtons;
		params.inTabSwitcher = inTabSwitcher;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuWithTabsWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuWithTabsWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuWithTabsWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCharacterSheetMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCharacterSheetMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCharacterSheetMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ViewMode_Wireframe
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ViewMode_Wireframe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ViewMode_Wireframe");
		
		URBCheatManager_ViewMode_Wireframe_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ViewMode_Lit_DetailLighting
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ViewMode_Lit_DetailLighting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ViewMode_Lit_DetailLighting");
		
		URBCheatManager_ViewMode_Lit_DetailLighting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ViewMode_Lit
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ViewMode_Lit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ViewMode_Lit");
		
		URBCheatManager_ViewMode_Lit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ViewMode_Design
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ViewMode_Design()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ViewMode_Design");
		
		URBCheatManager_ViewMode_Design_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.UpdateStatistic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerStat                                        PlayerStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::UpdateStatistic(EPlayerStat PlayerStat, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.UpdateStatistic");
		
		URBCheatManager_UpdateStatistic_Params params {};
		params.PlayerStat = PlayerStat;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.UntriggerAll
	 * 		Flags  -> ()
	 */
	void URBCheatManager::UntriggerAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.UntriggerAll");
		
		URBCheatManager_UntriggerAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.UnlockAllTrials
	 * 		Flags  -> ()
	 */
	void URBCheatManager::UnlockAllTrials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.UnlockAllTrials");
		
		URBCheatManager_UnlockAllTrials_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.TurnInTasks
	 * 		Flags  -> ()
	 */
	void URBCheatManager::TurnInTasks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.TurnInTasks");
		
		URBCheatManager_TurnInTasks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.TriggerAll
	 * 		Flags  -> ()
	 */
	void URBCheatManager::TriggerAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.TriggerAll");
		
		URBCheatManager_TriggerAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.TriggerAIEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EAIEvent                                           AIEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::TriggerAIEvent(EAIEvent AIEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.TriggerAIEvent");
		
		URBCheatManager_TriggerAIEvent_Params params {};
		params.AIEvent = AIEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleWWWMode
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleWWWMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleWWWMode");
		
		URBCheatManager_ToggleWWWMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleVOs
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleVOs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleVOs");
		
		URBCheatManager_ToggleVOs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleStatUnit
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleStatUnit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleStatUnit");
		
		URBCheatManager_ToggleStatUnit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleSpectator
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleSpectator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleSpectator");
		
		URBCheatManager_ToggleSpectator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleSilentForBots
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleSilentForBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleSilentForBots");
		
		URBCheatManager_ToggleSilentForBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleRespawnDeadPlayerInStage
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleRespawnDeadPlayerInStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleRespawnDeadPlayerInStage");
		
		URBCheatManager_ToggleRespawnDeadPlayerInStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleResetStageWhenAllPlayersDead
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleResetStageWhenAllPlayersDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleResetStageWhenAllPlayersDead");
		
		URBCheatManager_ToggleResetStageWhenAllPlayersDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleReplacementSound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      soundEventName                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ToggleReplacementSound(class FString* soundEventName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleReplacementSound");
		
		URBCheatManager_ToggleReplacementSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (soundEventName != nullptr)
			*soundEventName = params.soundEventName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.TogglePsychosisDebugHud
	 * 		Flags  -> ()
	 */
	void URBCheatManager::TogglePsychosisDebugHud()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.TogglePsychosisDebugHud");
		
		URBCheatManager_TogglePsychosisDebugHud_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.TogglePlayerDetectionComponentsDebug
	 * 		Flags  -> ()
	 */
	void URBCheatManager::TogglePlayerDetectionComponentsDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.TogglePlayerDetectionComponentsDebug");
		
		URBCheatManager_TogglePlayerDetectionComponentsDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.TogglePause
	 * 		Flags  -> ()
	 */
	void URBCheatManager::TogglePause()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.TogglePause");
		
		URBCheatManager_TogglePause_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleOverseerMode
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleOverseerMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleOverseerMode");
		
		URBCheatManager_ToggleOverseerMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleOverseerInfo
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleOverseerInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleOverseerInfo");
		
		URBCheatManager_ToggleOverseerInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleOnlineDebug
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleOnlineDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleOnlineDebug");
		
		URBCheatManager_ToggleOnlineDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleNPCDebugIcons
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleNPCDebugIcons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleNPCDebugIcons");
		
		URBCheatManager_ToggleNPCDebugIcons_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleNetMoveCorrection
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleNetMoveCorrection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleNetMoveCorrection");
		
		URBCheatManager_ToggleNetMoveCorrection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleNavmesh
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleNavmesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleNavmesh");
		
		URBCheatManager_ToggleNavmesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleMute
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleMute()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleMute");
		
		URBCheatManager_ToggleMute_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleMusic
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleMusic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleMusic");
		
		URBCheatManager_ToggleMusic_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleMapWarnings
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleMapWarnings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleMapWarnings");
		
		URBCheatManager_ToggleMapWarnings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleInvisibleToBots
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleInvisibleToBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleInvisibleToBots");
		
		URBCheatManager_ToggleInvisibleToBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleInfiniteLives
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleInfiniteLives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleInfiniteLives");
		
		URBCheatManager_ToggleInfiniteLives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleInfiniteActiveSkills
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleInfiniteActiveSkills()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleInfiniteActiveSkills");
		
		URBCheatManager_ToggleInfiniteActiveSkills_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleGameplayPPS
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleGameplayPPS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleGameplayPPS");
		
		URBCheatManager_ToggleGameplayPPS_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleFoleys
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleFoleys()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleFoleys");
		
		URBCheatManager_ToggleFoleys_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleDumpWidgetHierarchyOnClick
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleDumpWidgetHierarchyOnClick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleDumpWidgetHierarchyOnClick");
		
		URBCheatManager_ToggleDumpWidgetHierarchyOnClick_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleDebugStreaming
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleDebugStreaming()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleDebugStreaming");
		
		URBCheatManager_ToggleDebugStreaming_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleDebugSelectedActor
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleDebugSelectedActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleDebugSelectedActor");
		
		URBCheatManager_ToggleDebugSelectedActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleDebugMenu
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleDebugMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleDebugMenu");
		
		URBCheatManager_ToggleDebugMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleDebugDarknessUpdate
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleDebugDarknessUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleDebugDarknessUpdate");
		
		URBCheatManager_ToggleDebugDarknessUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleDarknessEffect
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleDarknessEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleDarknessEffect");
		
		URBCheatManager_ToggleDarknessEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleConditionalDebugActorInViewServer
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleConditionalDebugActorInViewServer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleConditionalDebugActorInViewServer");
		
		URBCheatManager_ToggleConditionalDebugActorInViewServer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleCheats
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleCheats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleCheats");
		
		URBCheatManager_ToggleCheats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleCameraShake
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleCameraShake()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleCameraShake");
		
		URBCheatManager_ToggleCameraShake_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleAlwaysKeepConsumables
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ToggleAlwaysKeepConsumables()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleAlwaysKeepConsumables");
		
		URBCheatManager_ToggleAlwaysKeepConsumables_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ToggleAll
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      searchQuery                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bStateA                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ToggleAll(const class FString& searchQuery, bool bStateA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ToggleAll");
		
		URBCheatManager_ToggleAll_Params params {};
		params.searchQuery = searchQuery;
		params.bStateA = bStateA;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.TestRandomness
	 * 		Flags  -> ()
	 */
	void URBCheatManager::TestRandomness()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.TestRandomness");
		
		URBCheatManager_TestRandomness_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.TestIntercom
	 * 		Flags  -> ()
	 */
	void URBCheatManager::TestIntercom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.TestIntercom");
		
		URBCheatManager_TestIntercom_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.TeleportAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Z                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Pitch                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Yaw                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Roll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::TeleportAtLocation(float X, float Y, float Z, float Pitch, float Yaw, float Roll)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.TeleportAtLocation");
		
		URBCheatManager_TeleportAtLocation_Params params {};
		params.X = X;
		params.Y = Y;
		params.Z = Z;
		params.Pitch = Pitch;
		params.Yaw = Yaw;
		params.Roll = Roll;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.StunSelf
	 * 		Flags  -> ()
	 */
	void URBCheatManager::StunSelf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.StunSelf");
		
		URBCheatManager_StunSelf_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.StopPsychosis
	 * 		Flags  -> ()
	 */
	void URBCheatManager::StopPsychosis()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.StopPsychosis");
		
		URBCheatManager_StopPsychosis_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.StatHLODMem
	 * 		Flags  -> ()
	 */
	void URBCheatManager::StatHLODMem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.StatHLODMem");
		
		URBCheatManager_StatHLODMem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.StartStageEnding
	 * 		Flags  -> ()
	 */
	void URBCheatManager::StartStageEnding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.StartStageEnding");
		
		URBCheatManager_StartStageEnding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.StartRelease
	 * 		Flags  -> ()
	 */
	void URBCheatManager::StartRelease()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.StartRelease");
		
		URBCheatManager_StartRelease_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.StartPsychosisSpook
	 * 		Flags  -> ()
	 */
	void URBCheatManager::StartPsychosisSpook()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.StartPsychosisSpook");
		
		URBCheatManager_StartPsychosisSpook_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.StartPsychosis
	 * 		Flags  -> ()
	 */
	void URBCheatManager::StartPsychosis()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.StartPsychosis");
		
		URBCheatManager_StartPsychosis_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.StartObjectiveCoordinator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::StartObjectiveCoordinator(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.StartObjectiveCoordinator");
		
		URBCheatManager_StartObjectiveCoordinator_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.StartExperiment
	 * 		Flags  -> ()
	 */
	void URBCheatManager::StartExperiment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.StartExperiment");
		
		URBCheatManager_StartExperiment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.StartEndOfStageDamage
	 * 		Flags  -> ()
	 */
	void URBCheatManager::StartEndOfStageDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.StartEndOfStageDamage");
		
		URBCheatManager_StartEndOfStageDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SpawnScientist
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Options                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SpawnScientist(const class FString& Options)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SpawnScientist");
		
		URBCheatManager_SpawnScientist_Params params {};
		params.Options = Options;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SpawnRandomPouncers
	 * 		Flags  -> ()
	 */
	void URBCheatManager::SpawnRandomPouncers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SpawnRandomPouncers");
		
		URBCheatManager_SpawnRandomPouncers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SpawnPouncersInHidingSpot
	 * 		Flags  -> ()
	 */
	void URBCheatManager::SpawnPouncersInHidingSpot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SpawnPouncersInHidingSpot");
		
		URBCheatManager_SpawnPouncersInHidingSpot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SpawnMultipleLargePickups
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ItemName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            numberOfCopy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SpawnMultipleLargePickups(const class FString& ItemName, int32_t numberOfCopy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SpawnMultipleLargePickups");
		
		URBCheatManager_SpawnMultipleLargePickups_Params params {};
		params.ItemName = ItemName;
		params.numberOfCopy = numberOfCopy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SpawnLargePickup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ItemName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SpawnLargePickup(const class FString& ItemName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SpawnLargePickup");
		
		URBCheatManager_SpawnLargePickup_Params params {};
		params.ItemName = ItemName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SpawnInteractingPlayer
	 * 		Flags  -> ()
	 */
	void URBCheatManager::SpawnInteractingPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SpawnInteractingPlayer");
		
		URBCheatManager_SpawnInteractingPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SpawnGuard
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Options                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SpawnGuard(const class FString& Options)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SpawnGuard");
		
		URBCheatManager_SpawnGuard_Params params {};
		params.Options = Options;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SpawnFollowAI
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      cheatName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SpawnFollowAI(const class FString& cheatName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SpawnFollowAI");
		
		URBCheatManager_SpawnFollowAI_Params params {};
		params.cheatName = cheatName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SpawnDownedPlayer
	 * 		Flags  -> ()
	 */
	void URBCheatManager::SpawnDownedPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SpawnDownedPlayer");
		
		URBCheatManager_SpawnDownedPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SpawnDeadPlayer
	 * 		Flags  -> ()
	 */
	void URBCheatManager::SpawnDeadPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SpawnDeadPlayer");
		
		URBCheatManager_SpawnDeadPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SpawnAI
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      cheatName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SpawnAI(const class FString& cheatName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SpawnAI");
		
		URBCheatManager_SpawnAI_Params params {};
		params.cheatName = cheatName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SingleFrame
	 * 		Flags  -> ()
	 */
	void URBCheatManager::SingleFrame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SingleFrame");
		
		URBCheatManager_SingleFrame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SimulateRTADisconnection
	 * 		Flags  -> ()
	 */
	void URBCheatManager::SimulateRTADisconnection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SimulateRTADisconnection");
		
		URBCheatManager_SimulateRTADisconnection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ShowWorldOctreeObjects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDebugWorldOctreeObjectType                        ObjectType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ShowWorldOctreeObjects(EDebugWorldOctreeObjectType ObjectType, float Range)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ShowWorldOctreeObjects");
		
		URBCheatManager_ShowWorldOctreeObjects_Params params {};
		params.ObjectType = ObjectType;
		params.Range = Range;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ShowStageIntro
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ShowStageIntro()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ShowStageIntro");
		
		URBCheatManager_ShowStageIntro_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ShowQuickGraph
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filter                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ShowQuickGraph(const class FString& Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ShowQuickGraph");
		
		URBCheatManager_ShowQuickGraph_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ShowPartyInviteNotification
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ShowPartyInviteNotification()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ShowPartyInviteNotification");
		
		URBCheatManager_ShowPartyInviteNotification_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ShowMatchAcceptanceNotification
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ShowMatchAcceptanceNotification()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ShowMatchAcceptanceNotification");
		
		URBCheatManager_ShowMatchAcceptanceNotification_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ShowFriendInviteNotification
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ShowFriendInviteNotification()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ShowFriendInviteNotification");
		
		URBCheatManager_ShowFriendInviteNotification_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ShowError
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            facility                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            code                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ShowError(const class FString& Message, int32_t facility, int32_t code)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ShowError");
		
		URBCheatManager_ShowError_Params params {};
		params.Message = Message;
		params.facility = facility;
		params.code = code;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ShowEndOfStageScreen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ShowEndOfStageScreen(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ShowEndOfStageScreen");
		
		URBCheatManager_ShowEndOfStageScreen_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ShowBadgeNotification
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      BadgeId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ShowBadgeNotification(const class FString& BadgeId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ShowBadgeNotification");
		
		URBCheatManager_ShowBadgeNotification_Params params {};
		params.BadgeId = BadgeId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ShowAllItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemType                                          ItemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ShowAllItems(EItemType ItemType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ShowAllItems");
		
		URBCheatManager_ShowAllItems_Params params {};
		params.ItemType = ItemType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ShowAll
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      searchQuery                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ShowAll(const class FString& searchQuery)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ShowAll");
		
		URBCheatManager_ShowAll_Params params {};
		params.searchQuery = searchQuery;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetVOSwitch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SwitchGroup                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      SwitchState                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetVOSwitch(const class FString& SwitchGroup, const class FString& SwitchState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetVOSwitch");
		
		URBCheatManager_SetVOSwitch_Params params {};
		params.SwitchGroup = SwitchGroup;
		params.SwitchState = SwitchState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetTutorialSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EUIFontSize                                        Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetTutorialSize(EUIFontSize Size)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetTutorialSize");
		
		URBCheatManager_SetTutorialSize_Params params {};
		params.Size = Size;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetTriggerableNetCullDistanceSquared
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NetCullDistanceSquared                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetTriggerableNetCullDistanceSquared(float NetCullDistanceSquared)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetTriggerableNetCullDistanceSquared");
		
		URBCheatManager_SetTriggerableNetCullDistanceSquared_Params params {};
		params.NetCullDistanceSquared = NetCullDistanceSquared;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetTrialCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetTrialCompleted(const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetTrialCompleted");
		
		URBCheatManager_SetTrialCompleted_Params params {};
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetSubtitleSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EUIFontSize                                        Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetSubtitleSize(EUIFontSize Size)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetSubtitleSize");
		
		URBCheatManager_SetSubtitleSize_Params params {};
		params.Size = Size;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetSoloMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSoloMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetSoloMode(bool bSoloMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetSoloMode");
		
		URBCheatManager_SetSoloMode_Params params {};
		params.bSoloMode = bSoloMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetServerAnimTickOptimsEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetServerAnimTickOptimsEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetServerAnimTickOptimsEnabled");
		
		URBCheatManager_SetServerAnimTickOptimsEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetPressureAccumulator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PressureAccumulator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetPressureAccumulator(int32_t PressureAccumulator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetPressureAccumulator");
		
		URBCheatManager_SetPressureAccumulator_Params params {};
		params.PressureAccumulator = PressureAccumulator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetPlayerLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      loadoutCode                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetPlayerLoadout(const class FString& loadoutCode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetPlayerLoadout");
		
		URBCheatManager_SetPlayerLoadout_Params params {};
		params.loadoutCode = loadoutCode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetPlatformPartition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Partition                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetPlatformPartition(const class FString& Partition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetPlatformPartition");
		
		URBCheatManager_SetPlatformPartition_Params params {};
		params.Partition = Partition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetNVBattery
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetNVBattery(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetNVBattery");
		
		URBCheatManager_SetNVBattery_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetNoConnectionTimeout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               noTimeout                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetNoConnectionTimeout(bool noTimeout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetNoConnectionTimeout");
		
		URBCheatManager_SetNoConnectionTimeout_Params params {};
		params.noTimeout = noTimeout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetMaxReservedPlayerSlotsOverride
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            maxReservedPlayerSlotsOverride                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetMaxReservedPlayerSlotsOverride(int32_t maxReservedPlayerSlotsOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetMaxReservedPlayerSlotsOverride");
		
		URBCheatManager_SetMaxReservedPlayerSlotsOverride_Params params {};
		params.maxReservedPlayerSlotsOverride = maxReservedPlayerSlotsOverride;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetMaxNumberOfPlayers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            maxNumberOfPlayers                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetMaxNumberOfPlayers(int32_t maxNumberOfPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetMaxNumberOfPlayers");
		
		URBCheatManager_SetMaxNumberOfPlayers_Params params {};
		params.maxNumberOfPlayers = maxNumberOfPlayers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetMarketingMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetMarketingMode(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetMarketingMode");
		
		URBCheatManager_SetMarketingMode_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetLevelSeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		uint32_t                                           initSeed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetLevelSeed(uint32_t initSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetLevelSeed");
		
		URBCheatManager_SetLevelSeed_Params params {};
		params.initSeed = initSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetInteractibleNetCullDistanceSquared
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NetCullDistanceSquared                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetInteractibleNetCullDistanceSquared(float NetCullDistanceSquared)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetInteractibleNetCullDistanceSquared");
		
		URBCheatManager_SetInteractibleNetCullDistanceSquared_Params params {};
		params.NetCullDistanceSquared = NetCullDistanceSquared;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetGameDifficulty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      difficultyStr                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetGameDifficulty(const class FString& difficultyStr)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetGameDifficulty");
		
		URBCheatManager_SetGameDifficulty_Params params {};
		params.difficultyStr = difficultyStr;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetFreeCamPos
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Z                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Roll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Pitch                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Yaw                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetFreeCamPos(float X, float Y, float Z, float Roll, float Pitch, float Yaw)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetFreeCamPos");
		
		URBCheatManager_SetFreeCamPos_Params params {};
		params.X = X;
		params.Y = Y;
		params.Z = Z;
		params.Roll = Roll;
		params.Pitch = Pitch;
		params.Yaw = Yaw;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetFreeCamMoveSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              MovementSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetFreeCamMoveSpeed(float MovementSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetFreeCamMoveSpeed");
		
		URBCheatManager_SetFreeCamMoveSpeed_Params params {};
		params.MovementSpeed = MovementSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetFreeCamMouseSensitivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Sensitivity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetFreeCamMouseSensitivity(float Sensitivity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetFreeCamMouseSensitivity");
		
		URBCheatManager_SetFreeCamMouseSensitivity_Params params {};
		params.Sensitivity = Sensitivity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetFreeCamGamepadLookSensitivity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Sensitivity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetFreeCamGamepadLookSensitivity(float Sensitivity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetFreeCamGamepadLookSensitivity");
		
		URBCheatManager_SetFreeCamGamepadLookSensitivity_Params params {};
		params.Sensitivity = Sensitivity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetDebugCameraRotationRatio
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ratio                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetDebugCameraRotationRatio(float ratio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetDebugCameraRotationRatio");
		
		URBCheatManager_SetDebugCameraRotationRatio_Params params {};
		params.ratio = ratio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetCpulimit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Limit                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetCpulimit(int32_t Limit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetCpulimit");
		
		URBCheatManager_SetCpulimit_Params params {};
		params.Limit = Limit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetCharacterLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Level                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetCharacterLevel(int32_t Level)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetCharacterLevel");
		
		URBCheatManager_SetCharacterLevel_Params params {};
		params.Level = Level;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetCharacterIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        iconId                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetCharacterIcon(const class FName& iconId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetCharacterIcon");
		
		URBCheatManager_SetCharacterIcon_Params params {};
		params.iconId = iconId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetBreadcrumbsLogsEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetBreadcrumbsLogsEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetBreadcrumbsLogsEnabled");
		
		URBCheatManager_SetBreadcrumbsLogsEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SetActiveSkill
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      skillDisplayName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SetActiveSkill(const class FString& skillDisplayName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SetActiveSkill");
		
		URBCheatManager_SetActiveSkill_Params params {};
		params.skillDisplayName = skillDisplayName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ServerComponentsReport
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ServerComponentsReport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ServerComponentsReport");
		
		URBCheatManager_ServerComponentsReport_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ServerCmd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ServerCmd                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ServerCmd(const class FString& ServerCmd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ServerCmd");
		
		URBCheatManager_ServerCmd_Params params {};
		params.ServerCmd = ServerCmd;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SendXPEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerEvent                                       EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SendXPEvent(EPlayerEvent EventType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SendXPEvent");
		
		URBCheatManager_SendXPEvent_Params params {};
		params.EventType = EventType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SCE
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      serverConsoleEvent                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SCE(const class FString& serverConsoleEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SCE");
		
		URBCheatManager_SCE_Params params {};
		params.serverConsoleEvent = serverConsoleEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SaveWWW
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filename                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::SaveWWW(const class FString& Filename)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SaveWWW");
		
		URBCheatManager_SaveWWW_Params params {};
		params.Filename = Filename;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.SaveProfile
	 * 		Flags  -> ()
	 */
	void URBCheatManager::SaveProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.SaveProfile");
		
		URBCheatManager_SaveProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.RevalidateLedgeMarkers
	 * 		Flags  -> ()
	 */
	void URBCheatManager::RevalidateLedgeMarkers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.RevalidateLedgeMarkers");
		
		URBCheatManager_RevalidateLedgeMarkers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.RestartExperiment
	 * 		Flags  -> ()
	 */
	void URBCheatManager::RestartExperiment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.RestartExperiment");
		
		URBCheatManager_RestartExperiment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.RespawnDeadPlayers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Force                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::RespawnDeadPlayers(bool Force)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.RespawnDeadPlayers");
		
		URBCheatManager_RespawnDeadPlayers_Params params {};
		params.Force = Force;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.RespawnAllPlayers
	 * 		Flags  -> ()
	 */
	void URBCheatManager::RespawnAllPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.RespawnAllPlayers");
		
		URBCheatManager_RespawnAllPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ReshuffleNPCs
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ReshuffleNPCs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ReshuffleNPCs");
		
		URBCheatManager_ReshuffleNPCs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ResetWorldStateWithSeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ResetWorldStateWithSeed(int32_t RandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ResetWorldStateWithSeed");
		
		URBCheatManager_ResetWorldStateWithSeed_Params params {};
		params.RandomSeed = RandomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ResetWorldState_Input
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ResetWorldState_Input()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ResetWorldState_Input");
		
		URBCheatManager_ResetWorldState_Input_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ResetWorldState
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ResetWorldState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ResetWorldState");
		
		URBCheatManager_ResetWorldState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ResetStageWithSeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ResetStageWithSeed(int32_t RandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ResetStageWithSeed");
		
		URBCheatManager_ResetStageWithSeed_Params params {};
		params.RandomSeed = RandomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ResetStage
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ResetStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ResetStage");
		
		URBCheatManager_ResetStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ResetPlayer
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ResetPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ResetPlayer");
		
		URBCheatManager_ResetPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ResetLoadouts
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ResetLoadouts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ResetLoadouts");
		
		URBCheatManager_ResetLoadouts_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ResetDoors
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ResetDoors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ResetDoors");
		
		URBCheatManager_ResetDoors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ResetCustomization
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ResetCustomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ResetCustomization");
		
		URBCheatManager_ResetCustomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ResetCharacterProgression
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ResetCharacterProgression()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ResetCharacterProgression");
		
		URBCheatManager_ResetCharacterProgression_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ResetAccountProgression
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ResetAccountProgression()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ResetAccountProgression");
		
		URBCheatManager_ResetAccountProgression_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ResetAccount
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ResetAccount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ResetAccount");
		
		URBCheatManager_ResetAccount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ReregisterInteractionZonesWithRBWorld
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ReregisterInteractionZonesWithRBWorld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ReregisterInteractionZonesWithRBWorld");
		
		URBCheatManager_ReregisterInteractionZonesWithRBWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.RequestReleaseCurrentCharacter
	 * 		Flags  -> ()
	 */
	void URBCheatManager::RequestReleaseCurrentCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.RequestReleaseCurrentCharacter");
		
		URBCheatManager_RequestReleaseCurrentCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.RemoveVariator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::RemoveVariator(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.RemoveVariator");
		
		URBCheatManager_RemoveVariator_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.RemoveDebugActorInViewFilter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filter                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::RemoveDebugActorInViewFilter(const class FString& Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.RemoveDebugActorInViewFilter");
		
		URBCheatManager_RemoveDebugActorInViewFilter_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.RefreshPathfindingCosts
	 * 		Flags  -> ()
	 */
	void URBCheatManager::RefreshPathfindingCosts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.RefreshPathfindingCosts");
		
		URBCheatManager_RefreshPathfindingCosts_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ReactivateBenchmarkOnNextBoot
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ReactivateBenchmarkOnNextBoot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ReactivateBenchmarkOnNextBoot");
		
		URBCheatManager_ReactivateBenchmarkOnNextBoot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.RBSlomoSlower
	 * 		Flags  -> ()
	 */
	void URBCheatManager::RBSlomoSlower()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.RBSlomoSlower");
		
		URBCheatManager_RBSlomoSlower_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.RBSlomoFaster
	 * 		Flags  -> ()
	 */
	void URBCheatManager::RBSlomoFaster()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.RBSlomoFaster");
		
		URBCheatManager_RBSlomoFaster_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.RandomizeCustomization
	 * 		Flags  -> ()
	 */
	void URBCheatManager::RandomizeCustomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.RandomizeCustomization");
		
		URBCheatManager_RandomizeCustomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.QuickTestServer
	 * 		Flags  -> ()
	 */
	void URBCheatManager::QuickTestServer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.QuickTestServer");
		
		URBCheatManager_QuickTestServer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.QuickTest
	 * 		Flags  -> ()
	 */
	void URBCheatManager::QuickTest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.QuickTest");
		
		URBCheatManager_QuickTest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.Profiling_NextCamera
	 * 		Flags  -> ()
	 */
	void URBCheatManager::Profiling_NextCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.Profiling_NextCamera");
		
		URBCheatManager_Profiling_NextCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.PreviousDebugActorInView
	 * 		Flags  -> ()
	 */
	void URBCheatManager::PreviousDebugActorInView()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.PreviousDebugActorInView");
		
		URBCheatManager_PreviousDebugActorInView_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.PlayVO
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      soundEventName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      SwitchGroup                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      SwitchState                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            forcedRandomSeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::PlayVO(const class FString& soundEventName, const class FString& SwitchGroup, const class FString& SwitchState, int32_t forcedRandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.PlayVO");
		
		URBCheatManager_PlayVO_Params params {};
		params.soundEventName = soundEventName;
		params.SwitchGroup = SwitchGroup;
		params.SwitchState = SwitchState;
		params.forcedRandomSeed = forcedRandomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.PlaytestMode
	 * 		Flags  -> ()
	 */
	void URBCheatManager::PlaytestMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.PlaytestMode");
		
		URBCheatManager_PlaytestMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.PersistPlayerProgression
	 * 		Flags  -> ()
	 */
	void URBCheatManager::PersistPlayerProgression()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.PersistPlayerProgression");
		
		URBCheatManager_PersistPlayerProgression_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.PasteCameraLocation
	 * 		Flags  -> ()
	 */
	void URBCheatManager::PasteCameraLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.PasteCameraLocation");
		
		URBCheatManager_PasteCameraLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.NextDebugActorInView
	 * 		Flags  -> ()
	 */
	void URBCheatManager::NextDebugActorInView()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.NextDebugActorInView");
		
		URBCheatManager_NextDebugActorInView_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.MulticastCommand
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      InMulticastCommand                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::MulticastCommand(const class FString& InMulticastCommand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.MulticastCommand");
		
		URBCheatManager_MulticastCommand_Params params {};
		params.InMulticastCommand = InMulticastCommand;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.MarketingMode
	 * 		Flags  -> ()
	 */
	void URBCheatManager::MarketingMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.MarketingMode");
		
		URBCheatManager_MarketingMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.MakeNoise
	 * 		Flags  -> ()
	 */
	void URBCheatManager::MakeNoise()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.MakeNoise");
		
		URBCheatManager_MakeNoise_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.LogStreamingDebug
	 * 		Flags  -> ()
	 */
	void URBCheatManager::LogStreamingDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.LogStreamingDebug");
		
		URBCheatManager_LogStreamingDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.Local_SetTriggerableNetCullDistanceSquared
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NetCullDistanceSquared                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::Local_SetTriggerableNetCullDistanceSquared(float NetCullDistanceSquared)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.Local_SetTriggerableNetCullDistanceSquared");
		
		URBCheatManager_Local_SetTriggerableNetCullDistanceSquared_Params params {};
		params.NetCullDistanceSquared = NetCullDistanceSquared;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.Local_SetInteractibleNetCullDistanceSquared
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              NetCullDistanceSquared                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::Local_SetInteractibleNetCullDistanceSquared(float NetCullDistanceSquared)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.Local_SetInteractibleNetCullDistanceSquared");
		
		URBCheatManager_Local_SetInteractibleNetCullDistanceSquared_Params params {};
		params.NetCullDistanceSquared = NetCullDistanceSquared;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.LoadWWW
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filename                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::LoadWWW(const class FString& Filename)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.LoadWWW");
		
		URBCheatManager_LoadWWW_Params params {};
		params.Filename = Filename;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.LoadProfile
	 * 		Flags  -> ()
	 */
	void URBCheatManager::LoadProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.LoadProfile");
		
		URBCheatManager_LoadProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.LoadHeatmap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      FilePath                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::LoadHeatmap(const class FString& FilePath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.LoadHeatmap");
		
		URBCheatManager_LoadHeatmap_Params params {};
		params.FilePath = FilePath;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.LoadAllVOSwitchGroups
	 * 		Flags  -> ()
	 */
	void URBCheatManager::LoadAllVOSwitchGroups()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.LoadAllVOSwitchGroups");
		
		URBCheatManager_LoadAllVOSwitchGroups_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ListTickingSkelComp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filter                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ListTickingSkelComp(const class FString& Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ListTickingSkelComp");
		
		URBCheatManager_ListTickingSkelComp_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ListStaticMeshNoCollision
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ListStaticMeshNoCollision()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ListStaticMeshNoCollision");
		
		URBCheatManager_ListStaticMeshNoCollision_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ListNews
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ListNews()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ListNews");
		
		URBCheatManager_ListNews_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ListLoadedAnimationSequences
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ListLoadedAnimationSequences()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ListLoadedAnimationSequences");
		
		URBCheatManager_ListLoadedAnimationSequences_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ListItems
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ListItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ListItems");
		
		URBCheatManager_ListItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ListContainers
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ListContainers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ListContainers");
		
		URBCheatManager_ListContainers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ListAllTickingActors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filter                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ListAllTickingActors(const class FString& Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ListAllTickingActors");
		
		URBCheatManager_ListAllTickingActors_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ListAllActiveSoundsInGroup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        GroupName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ListAllActiveSoundsInGroup(const class FName& GroupName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ListAllActiveSoundsInGroup");
		
		URBCheatManager_ListAllActiveSoundsInGroup_Params params {};
		params.GroupName = GroupName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ListAllActiveSounds
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ListAllActiveSounds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ListAllActiveSounds");
		
		URBCheatManager_ListAllActiveSounds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.KillSelfInstant
	 * 		Flags  -> ()
	 */
	void URBCheatManager::KillSelfInstant()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.KillSelfInstant");
		
		URBCheatManager_KillSelfInstant_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.KillSelf
	 * 		Flags  -> ()
	 */
	void URBCheatManager::KillSelf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.KillSelf");
		
		URBCheatManager_KillSelf_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.KillSelectedBot
	 * 		Flags  -> ()
	 */
	void URBCheatManager::KillSelectedBot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.KillSelectedBot");
		
		URBCheatManager_KillSelectedBot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.KillOtherBots
	 * 		Flags  -> ()
	 */
	void URBCheatManager::KillOtherBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.KillOtherBots");
		
		URBCheatManager_KillOtherBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.KillFakePlayers
	 * 		Flags  -> ()
	 */
	void URBCheatManager::KillFakePlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.KillFakePlayers");
		
		URBCheatManager_KillFakePlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.KillBots
	 * 		Flags  -> ()
	 */
	void URBCheatManager::KillBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.KillBots");
		
		URBCheatManager_KillBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.Kick
	 * 		Flags  -> ()
	 */
	void URBCheatManager::Kick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.Kick");
		
		URBCheatManager_Kick_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.keOnDebugActorInViewOnServer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::keOnDebugActorInViewOnServer(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.keOnDebugActorInViewOnServer");
		
		URBCheatManager_keOnDebugActorInViewOnServer_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.keOnDebugActorInView
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::keOnDebugActorInView(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.keOnDebugActorInView");
		
		URBCheatManager_keOnDebugActorInView_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.JoinParty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ProfileId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::JoinParty(const class FString& ProfileId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.JoinParty");
		
		URBCheatManager_JoinParty_Params params {};
		params.ProfileId = ProfileId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.InfiniteThrowables
	 * 		Flags  -> ()
	 */
	void URBCheatManager::InfiniteThrowables()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.InfiniteThrowables");
		
		URBCheatManager_InfiniteThrowables_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.InfiniteMasterKey
	 * 		Flags  -> ()
	 */
	void URBCheatManager::InfiniteMasterKey()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.InfiniteMasterKey");
		
		URBCheatManager_InfiniteMasterKey_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.InfiniteLockpick
	 * 		Flags  -> ()
	 */
	void URBCheatManager::InfiniteLockpick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.InfiniteLockpick");
		
		URBCheatManager_InfiniteLockpick_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.InfiniteGibs
	 * 		Flags  -> ()
	 */
	void URBCheatManager::InfiniteGibs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.InfiniteGibs");
		
		URBCheatManager_InfiniteGibs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.InfiniteBricks
	 * 		Flags  -> ()
	 */
	void URBCheatManager::InfiniteBricks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.InfiniteBricks");
		
		URBCheatManager_InfiniteBricks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.InfiniteBottles
	 * 		Flags  -> ()
	 */
	void URBCheatManager::InfiniteBottles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.InfiniteBottles");
		
		URBCheatManager_InfiniteBottles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.InfiniteBleedOut
	 * 		Flags  -> ()
	 */
	void URBCheatManager::InfiniteBleedOut()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.InfiniteBleedOut");
		
		URBCheatManager_InfiniteBleedOut_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.IncapacitateSelf
	 * 		Flags  -> ()
	 */
	void URBCheatManager::IncapacitateSelf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.IncapacitateSelf");
		
		URBCheatManager_IncapacitateSelf_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.HurtSelf
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHitReaction                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            hurtType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::HurtSelf(float amount, bool bHitReaction, int32_t hurtType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.HurtSelf");
		
		URBCheatManager_HurtSelf_Params params {};
		params.amount = amount;
		params.bHitReaction = bHitReaction;
		params.hurtType = hurtType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.HitReaction_Medium
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              relativeAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::HitReaction_Medium(float relativeAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.HitReaction_Medium");
		
		URBCheatManager_HitReaction_Medium_Params params {};
		params.relativeAngle = relativeAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.HitReaction_Light
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              relativeAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::HitReaction_Light(float relativeAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.HitReaction_Light");
		
		URBCheatManager_HitReaction_Light_Params params {};
		params.relativeAngle = relativeAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.HitReaction_Knockdown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              relativeAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::HitReaction_Knockdown(float relativeAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.HitReaction_Knockdown");
		
		URBCheatManager_HitReaction_Knockdown_Params params {};
		params.relativeAngle = relativeAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.HitReaction_Heavy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              relativeAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::HitReaction_Heavy(float relativeAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.HitReaction_Heavy");
		
		URBCheatManager_HitReaction_Heavy_Params params {};
		params.relativeAngle = relativeAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.HitReaction_Flinch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              relativeAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::HitReaction_Flinch(float relativeAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.HitReaction_Flinch");
		
		URBCheatManager_HitReaction_Flinch_Params params {};
		params.relativeAngle = relativeAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.HitReaction_Dead
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              relativeAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::HitReaction_Dead(float relativeAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.HitReaction_Dead");
		
		URBCheatManager_HitReaction_Dead_Params params {};
		params.relativeAngle = relativeAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.HeatmapLowpass
	 * 		Flags  -> ()
	 */
	void URBCheatManager::HeatmapLowpass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.HeatmapLowpass");
		
		URBCheatManager_HeatmapLowpass_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.HeatmapClampMin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::HeatmapClampMin(float Min)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.HeatmapClampMin");
		
		URBCheatManager_HeatmapClampMin_Params params {};
		params.Min = Min;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.HeatmapClampMax
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::HeatmapClampMax(float Max)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.HeatmapClampMax");
		
		URBCheatManager_HeatmapClampMax_Params params {};
		params.Max = Max;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.GotoTargetAI
	 * 		Flags  -> ()
	 */
	void URBCheatManager::GotoTargetAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.GotoTargetAI");
		
		URBCheatManager_GotoTargetAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.GetRich
	 * 		Flags  -> ()
	 */
	void URBCheatManager::GetRich()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.GetRich");
		
		URBCheatManager_GetRich_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.GetLevelSeed
	 * 		Flags  -> ()
	 */
	void URBCheatManager::GetLevelSeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.GetLevelSeed");
		
		URBCheatManager_GetLevelSeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.GetGoodCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Level                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::GetGoodCharacter(int32_t Level)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.GetGoodCharacter");
		
		URBCheatManager_GetGoodCharacter_Params params {};
		params.Level = Level;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.FreeCamClean
	 * 		Flags  -> ()
	 */
	void URBCheatManager::FreeCamClean()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.FreeCamClean");
		
		URBCheatManager_FreeCamClean_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.FreeCam
	 * 		Flags  -> ()
	 */
	void URBCheatManager::FreeCam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.FreeCam");
		
		URBCheatManager_FreeCam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceUseClientOnlyLevels
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ForceUseClientOnlyLevels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceUseClientOnlyLevels");
		
		URBCheatManager_ForceUseClientOnlyLevels_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceUseAllTraps
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ForceUseAllTraps()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceUseAllTraps");
		
		URBCheatManager_ForceUseAllTraps_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceUseAllRewardRooms
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ForceUseAllRewardRooms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceUseAllRewardRooms");
		
		URBCheatManager_ForceUseAllRewardRooms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceUseAllPuzzleRooms
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ForceUseAllPuzzleRooms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceUseAllPuzzleRooms");
		
		URBCheatManager_ForceUseAllPuzzleRooms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceUseAllObjectiveActors
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ForceUseAllObjectiveActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceUseAllObjectiveActors");
		
		URBCheatManager_ForceUseAllObjectiveActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceSnapToStateForAllActors
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ForceSnapToStateForAllActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceSnapToStateForAllActors");
		
		URBCheatManager_ForceSnapToStateForAllActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceShowLoadingScreen
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ForceShowLoadingScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceShowLoadingScreen");
		
		URBCheatManager_ForceShowLoadingScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceRandomState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      searchQuery                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bStateA                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ForceRandomState(const class FString& searchQuery, bool bStateA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceRandomState");
		
		URBCheatManager_ForceRandomState_Params params {};
		params.searchQuery = searchQuery;
		params.bStateA = bStateA;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceRandomSoundsCycle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filter                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ForceRandomSoundsCycle(const class FString& Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceRandomSoundsCycle");
		
		URBCheatManager_ForceRandomSoundsCycle_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForcePreLoginError
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Error                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ForcePreLoginError(const class FString& Error, int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForcePreLoginError");
		
		URBCheatManager_ForcePreLoginError_Params params {};
		params.Error = Error;
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForcePawnAnimOptimLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            forcedLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ForcePawnAnimOptimLevel(int32_t forcedLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForcePawnAnimOptimLevel");
		
		URBCheatManager_ForcePawnAnimOptimLevel_Params params {};
		params.forcedLevel = forcedLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceMovementDesynch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              desyncSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ForceMovementDesynch(float desyncSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceMovementDesynch");
		
		URBCheatManager_ForceMovementDesynch_Params params {};
		params.desyncSize = desyncSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceJumpOverOnFakePlayer
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ForceJumpOverOnFakePlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceJumpOverOnFakePlayer");
		
		URBCheatManager_ForceJumpOverOnFakePlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceJoinPlayerSessionErrors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ForceJoinPlayerSessionErrors(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceJoinPlayerSessionErrors");
		
		URBCheatManager_ForceJoinPlayerSessionErrors_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceHudMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHudMode                                           hudMode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ForceHudMode(EHudMode hudMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceHudMode");
		
		URBCheatManager_ForceHudMode_Params params {};
		params.hudMode = hudMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceHideLoadingScreen
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ForceHideLoadingScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceHideLoadingScreen");
		
		URBCheatManager_ForceHideLoadingScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceGrabsInDirection
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Direction                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ForceGrabsInDirection(const class FString& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceGrabsInDirection");
		
		URBCheatManager_ForceGrabsInDirection_Params params {};
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceGrabs
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ForceGrabs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceGrabs");
		
		URBCheatManager_ForceGrabs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceAssignPlayerCell
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ForceAssignPlayerCell()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceAssignPlayerCell");
		
		URBCheatManager_ForceAssignPlayerCell_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ForceAdversityMeter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newAdversity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ForceAdversityMeter(float newAdversity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ForceAdversityMeter");
		
		URBCheatManager_ForceAdversityMeter_Params params {};
		params.newAdversity = newAdversity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.FlushNetDormancyActorInView
	 * 		Flags  -> ()
	 */
	void URBCheatManager::FlushNetDormancyActorInView()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.FlushNetDormancyActorInView");
		
		URBCheatManager_FlushNetDormancyActorInView_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.FixedCam
	 * 		Flags  -> ()
	 */
	void URBCheatManager::FixedCam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.FixedCam");
		
		URBCheatManager_FixedCam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.FeatureSwitchToggle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      FeatureSwitch                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::FeatureSwitchToggle(const class FString& FeatureSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.FeatureSwitchToggle");
		
		URBCheatManager_FeatureSwitchToggle_Params params {};
		params.FeatureSwitch = FeatureSwitch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.FeatureSwitchOn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      FeatureSwitch                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::FeatureSwitchOn(const class FString& FeatureSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.FeatureSwitchOn");
		
		URBCheatManager_FeatureSwitchOn_Params params {};
		params.FeatureSwitch = FeatureSwitch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.FeatureSwitchOff
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      FeatureSwitch                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::FeatureSwitchOff(const class FString& FeatureSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.FeatureSwitchOff");
		
		URBCheatManager_FeatureSwitchOff_Params params {};
		params.FeatureSwitch = FeatureSwitch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.FailStage
	 * 		Flags  -> ()
	 */
	void URBCheatManager::FailStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.FailStage");
		
		URBCheatManager_FailStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.EquipOutfit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      outfitId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::EquipOutfit(const class FString& outfitId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.EquipOutfit");
		
		URBCheatManager_EquipOutfit_Params params {};
		params.outfitId = outfitId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.EndExperiment
	 * 		Flags  -> ()
	 */
	void URBCheatManager::EndExperiment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.EndExperiment");
		
		URBCheatManager_EndExperiment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.EnableAutoBackfill
	 * 		Flags  -> ()
	 */
	void URBCheatManager::EnableAutoBackfill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.EnableAutoBackfill");
		
		URBCheatManager_EnableAutoBackfill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DumpWWWStats
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filename                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DumpWWWStats(const class FString& Filename)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DumpWWWStats");
		
		URBCheatManager_DumpWWWStats_Params params {};
		params.Filename = Filename;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DumpSoundVolumes
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DumpSoundVolumes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DumpSoundVolumes");
		
		URBCheatManager_DumpSoundVolumes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DumpServerLog
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DumpServerLog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DumpServerLog");
		
		URBCheatManager_DumpServerLog_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DumpReplicatedLevelActors
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DumpReplicatedLevelActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DumpReplicatedLevelActors");
		
		URBCheatManager_DumpReplicatedLevelActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DumpPlayerMeshesDebugInfo
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DumpPlayerMeshesDebugInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DumpPlayerMeshesDebugInfo");
		
		URBCheatManager_DumpPlayerMeshesDebugInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DumpPersistentLevelActors
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DumpPersistentLevelActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DumpPersistentLevelActors");
		
		URBCheatManager_DumpPersistentLevelActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DumpNavMeshContinuousRequests
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DumpNavMeshContinuousRequests()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DumpNavMeshContinuousRequests");
		
		URBCheatManager_DumpNavMeshContinuousRequests_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DumpGameEventLog
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DumpGameEventLog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DumpGameEventLog");
		
		URBCheatManager_DumpGameEventLog_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DumpDebugInfoInViewOnServer
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DumpDebugInfoInViewOnServer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DumpDebugInfoInViewOnServer");
		
		URBCheatManager_DumpDebugInfoInViewOnServer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DumpDebugInfoInViewOnClient
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DumpDebugInfoInViewOnClient()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DumpDebugInfoInViewOnClient");
		
		URBCheatManager_DumpDebugInfoInViewOnClient_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DrawLocXYZ
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Z                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DrawLocXYZ(float X, float Y, float Z)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DrawLocXYZ");
		
		URBCheatManager_DrawLocXYZ_Params params {};
		params.X = X;
		params.Y = Y;
		params.Z = Z;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DownSelf
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DownSelf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DownSelf");
		
		URBCheatManager_DownSelf_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DisplayMenuManagerDebugInfo
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DisplayMenuManagerDebugInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DisplayMenuManagerDebugInfo");
		
		URBCheatManager_DisplayMenuManagerDebugInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DisconnectOnlineModule
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DisconnectOnlineModule(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DisconnectOnlineModule");
		
		URBCheatManager_DisconnectOnlineModule_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DisableStageEnding
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DisableStageEnding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DisableStageEnding");
		
		URBCheatManager_DisableStageEnding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DisableSkelCompTick
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filter                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DisableSkelCompTick(const class FString& Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DisableSkelCompTick");
		
		URBCheatManager_DisableSkelCompTick_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DisableAutoBackfill
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DisableAutoBackfill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DisableAutoBackfill");
		
		URBCheatManager_DisableAutoBackfill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DeleteProfile
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DeleteProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DeleteProfile");
		
		URBCheatManager_DeleteProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DelayedBugIt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              delayInSeconds                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Description                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DelayedBugIt(float delayInSeconds, const class FString& Description)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DelayedBugIt");
		
		URBCheatManager_DelayedBugIt_Params params {};
		params.delayInSeconds = delayInSeconds;
		params.Description = Description;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugVoiceChat
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugVoiceChat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugVoiceChat");
		
		URBCheatManager_DebugVoiceChat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugVO
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugVO()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugVO");
		
		URBCheatManager_DebugVO_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugVariators
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugVariators()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugVariators");
		
		URBCheatManager_DebugVariators_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugUINoise
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugUINoise()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugUINoise");
		
		URBCheatManager_DebugUINoise_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugUI
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugUI");
		
		URBCheatManager_DebugUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugTraps
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowDisabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugTraps(bool bShowDisabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugTraps");
		
		URBCheatManager_DebugTraps_Params params {};
		params.bShowDisabled = bShowDisabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugTq
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugTq()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugTq");
		
		URBCheatManager_DebugTq_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugThrow
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugThrow");
		
		URBCheatManager_DebugThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugTargetAI
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugTargetAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugTargetAI");
		
		URBCheatManager_DebugTargetAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugTalkWheel
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugTalkWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugTalkWheel");
		
		URBCheatManager_DebugTalkWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugSwitchMatch
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugSwitchMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugSwitchMatch");
		
		URBCheatManager_DebugSwitchMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugSubtitles
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugSubtitles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugSubtitles");
		
		URBCheatManager_DebugSubtitles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugSpecialRooms
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugSpecialRooms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugSpecialRooms");
		
		URBCheatManager_DebugSpecialRooms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugSpatialReasoning
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugSpatialReasoning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugSpatialReasoning");
		
		URBCheatManager_DebugSpatialReasoning_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugSoundEnvironmentOnPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filter                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugSoundEnvironmentOnPlayer(const class FString& Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugSoundEnvironmentOnPlayer");
		
		URBCheatManager_DebugSoundEnvironmentOnPlayer_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugSoundEnvironmentForCloneGroups
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filter                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugSoundEnvironmentForCloneGroups(const class FString& Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugSoundEnvironmentForCloneGroups");
		
		URBCheatManager_DebugSoundEnvironmentForCloneGroups_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugSoundEnvironment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filter                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugSoundEnvironment(const class FString& Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugSoundEnvironment");
		
		URBCheatManager_DebugSoundEnvironment_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugSimultaneousJumpForward
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugSimultaneousJumpForward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugSimultaneousJumpForward");
		
		URBCheatManager_DebugSimultaneousJumpForward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugSimultaneousInteraction
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugSimultaneousInteraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugSimultaneousInteraction");
		
		URBCheatManager_DebugSimultaneousInteraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugScheduledSpecialMoveLate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugScheduledSpecialMoveLate(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugScheduledSpecialMoveLate");
		
		URBCheatManager_DebugScheduledSpecialMoveLate_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugScheduledProperties
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugScheduledProperties()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugScheduledProperties");
		
		URBCheatManager_DebugScheduledProperties_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugSafeZone
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugSafeZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugSafeZone");
		
		URBCheatManager_DebugSafeZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugRTPC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filter                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugRTPC(const class FString& Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugRTPC");
		
		URBCheatManager_DebugRTPC_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugRooms
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugRooms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugRooms");
		
		URBCheatManager_DebugRooms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugRoomPathing
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugRoomPathing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugRoomPathing");
		
		URBCheatManager_DebugRoomPathing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugRepulsion
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugRepulsion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugRepulsion");
		
		URBCheatManager_DebugRepulsion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugRB
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugRB()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugRB");
		
		URBCheatManager_DebugRB_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugRandomSounds
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugRandomSounds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugRandomSounds");
		
		URBCheatManager_DebugRandomSounds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugProximityDetectables
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugProximityDetectables()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugProximityDetectables");
		
		URBCheatManager_DebugProximityDetectables_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugProximity
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugProximity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugProximity");
		
		URBCheatManager_DebugProximity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugPrevPage
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugPrevPage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugPrevPage");
		
		URBCheatManager_DebugPrevPage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugPlayerStats
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugPlayerStats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugPlayerStats");
		
		URBCheatManager_DebugPlayerStats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugPlayerCustomization
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugPlayerCustomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugPlayerCustomization");
		
		URBCheatManager_DebugPlayerCustomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugPhysics
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugPhysics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugPhysics");
		
		URBCheatManager_DebugPhysics_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugPerception
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugPerception()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugPerception");
		
		URBCheatManager_DebugPerception_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugPasscodeDecals
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugPasscodeDecals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugPasscodeDecals");
		
		URBCheatManager_DebugPasscodeDecals_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugObjectives
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugObjectives");
		
		URBCheatManager_DebugObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugNPCRandomization
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugNPCRandomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugNPCRandomization");
		
		URBCheatManager_DebugNPCRandomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugNPCLocomotion
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugNPCLocomotion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugNPCLocomotion");
		
		URBCheatManager_DebugNPCLocomotion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugNPCAttacks
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugNPCAttacks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugNPCAttacks");
		
		URBCheatManager_DebugNPCAttacks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugNextPage
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugNextPage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugNextPage");
		
		URBCheatManager_DebugNextPage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugMusic
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugMusic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugMusic");
		
		URBCheatManager_DebugMusic_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugMovementNetwork
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugMovementNetwork()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugMovementNetwork");
		
		URBCheatManager_DebugMovementNetwork_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugMovementDesync
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugMovementDesync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugMovementDesync");
		
		URBCheatManager_DebugMovementDesync_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugMovementAlwaysDesync_Server
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugMovementAlwaysDesync_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugMovementAlwaysDesync_Server");
		
		URBCheatManager_DebugMovementAlwaysDesync_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugLowPawnAnimOptimLevel
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugLowPawnAnimOptimLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugLowPawnAnimOptimLevel");
		
		URBCheatManager_DebugLowPawnAnimOptimLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugLobbyGameChess
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugLobbyGameChess()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugLobbyGameChess");
		
		URBCheatManager_DebugLobbyGameChess_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugJumpScare
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugJumpScare()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugJumpScare");
		
		URBCheatManager_DebugJumpScare_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugItemSpawning
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugItemSpawning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugItemSpawning");
		
		URBCheatManager_DebugItemSpawning_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugInvestigateInteraction
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugInvestigateInteraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugInvestigateInteraction");
		
		URBCheatManager_DebugInvestigateInteraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugInventory
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugInventory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugInventory");
		
		URBCheatManager_DebugInventory_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugInteractionResync_Local
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugInteractionResync_Local()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugInteractionResync_Local");
		
		URBCheatManager_DebugInteractionResync_Local_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugInteractionDesync_Server
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugInteractionDesync_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugInteractionDesync_Server");
		
		URBCheatManager_DebugInteractionDesync_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugInteractionDesync_Local
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugInteractionDesync_Local()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugInteractionDesync_Local");
		
		URBCheatManager_DebugInteractionDesync_Local_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugInteraction
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugInteraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugInteraction");
		
		URBCheatManager_DebugInteraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugIgnoreSpecialMoveDesync_Local
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugIgnoreSpecialMoveDesync_Local()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugIgnoreSpecialMoveDesync_Local");
		
		URBCheatManager_DebugIgnoreSpecialMoveDesync_Local_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugHidingSpots
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugHidingSpots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugHidingSpots");
		
		URBCheatManager_DebugHidingSpots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugHidespots
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugHidespots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugHidespots");
		
		URBCheatManager_DebugHidespots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugHidespotPeek
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugHidespotPeek()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugHidespotPeek");
		
		URBCheatManager_DebugHidespotPeek_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugGameplayRandom
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugGameplayRandom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugGameplayRandom");
		
		URBCheatManager_DebugGameplayRandom_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugGameplayAttributes
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugGameplayAttributes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugGameplayAttributes");
		
		URBCheatManager_DebugGameplayAttributes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugGameplay
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugGameplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugGameplay");
		
		URBCheatManager_DebugGameplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugGameMode
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugGameMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugGameMode");
		
		URBCheatManager_DebugGameMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugForceListenerOnPlayer
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugForceListenerOnPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugForceListenerOnPlayer");
		
		URBCheatManager_DebugForceListenerOnPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugFootsteps
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShowGrid                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugFootsteps(bool bShowGrid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugFootsteps");
		
		URBCheatManager_DebugFootsteps_Params params {};
		params.bShowGrid = bShowGrid;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugFirstPerson
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugFirstPerson()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugFirstPerson");
		
		URBCheatManager_DebugFirstPerson_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugFatalitiesForceIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugFatalitiesForceIndex(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugFatalitiesForceIndex");
		
		URBCheatManager_DebugFatalitiesForceIndex_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugFatalities
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Option                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugFatalities(int32_t Option)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugFatalities");
		
		URBCheatManager_DebugFatalities_Params params {};
		params.Option = Option;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugFailedAdjustment
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugFailedAdjustment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugFailedAdjustment");
		
		URBCheatManager_DebugFailedAdjustment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugEyesClosed
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugEyesClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugEyesClosed");
		
		URBCheatManager_DebugEyesClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugEvalCorridor
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugEvalCorridor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugEvalCorridor");
		
		URBCheatManager_DebugEvalCorridor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugEncroachment
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugEncroachment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugEncroachment");
		
		URBCheatManager_DebugEncroachment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugDrawInteractionBox
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bServer                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugDrawInteractionBox(bool bServer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugDrawInteractionBox");
		
		URBCheatManager_DebugDrawInteractionBox_Params params {};
		params.bServer = bServer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugDoors
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugDoors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugDoors");
		
		URBCheatManager_DebugDoors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugDoorRepulsion
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSlam                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugDoorRepulsion(bool bSlam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugDoorRepulsion");
		
		URBCheatManager_DebugDoorRepulsion_Params params {};
		params.bSlam = bSlam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugDisplayMessages
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugDisplayMessages()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugDisplayMessages");
		
		URBCheatManager_DebugDisplayMessages_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugDeadRepulsion
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugDeadRepulsion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugDeadRepulsion");
		
		URBCheatManager_DebugDeadRepulsion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugDarkness
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugDarkness()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugDarkness");
		
		URBCheatManager_DebugDarkness_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugCoopMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bExceptLocal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugCoopMove(bool bExceptLocal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugCoopMove");
		
		URBCheatManager_DebugCoopMove_Params params {};
		params.bExceptLocal = bExceptLocal;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugClearance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bForceShowValid                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugClearance(bool bForceShowValid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugClearance");
		
		URBCheatManager_DebugClearance_Params params {};
		params.bForceShowValid = bForceShowValid;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugChunkInstall
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugChunkInstall()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugChunkInstall");
		
		URBCheatManager_DebugChunkInstall_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugChase
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugChase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugChase");
		
		URBCheatManager_DebugChase_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugBlockables
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugBlockables()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugBlockables");
		
		URBCheatManager_DebugBlockables_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugBleedOut
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugBleedOut()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugBleedOut");
		
		URBCheatManager_DebugBleedOut_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugBackgroundCharacters
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugBackgroundCharacters()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugBackgroundCharacters");
		
		URBCheatManager_DebugBackgroundCharacters_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugAudioEvents
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            playingIDFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugAudioEvents(int32_t playingIDFilter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugAudioEvents");
		
		URBCheatManager_DebugAudioEvents_Params params {};
		params.playingIDFilter = playingIDFilter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugAnimUsage
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugAnimUsage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugAnimUsage");
		
		URBCheatManager_DebugAnimUsage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugAlertedStance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Option                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::DebugAlertedStance(int32_t Option)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugAlertedStance");
		
		URBCheatManager_DebugAlertedStance_Params params {};
		params.Option = Option;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugAIPointSelection
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugAIPointSelection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugAIPointSelection");
		
		URBCheatManager_DebugAIPointSelection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugAI
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugAI");
		
		URBCheatManager_DebugAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugActorInView
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugActorInView()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugActorInView");
		
		URBCheatManager_DebugActorInView_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.DebugActiveSkills
	 * 		Flags  -> ()
	 */
	void URBCheatManager::DebugActiveSkills()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.DebugActiveSkills");
		
		URBCheatManager_DebugActiveSkills_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.CyclePlayerDebug
	 * 		Flags  -> ()
	 */
	void URBCheatManager::CyclePlayerDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.CyclePlayerDebug");
		
		URBCheatManager_CyclePlayerDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.CycleDebugPerceptionDarkness
	 * 		Flags  -> ()
	 */
	void URBCheatManager::CycleDebugPerceptionDarkness()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.CycleDebugPerceptionDarkness");
		
		URBCheatManager_CycleDebugPerceptionDarkness_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.CycleCollisionDebug
	 * 		Flags  -> ()
	 */
	void URBCheatManager::CycleCollisionDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.CycleCollisionDebug");
		
		URBCheatManager_CycleCollisionDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.CycleAIDebug
	 * 		Flags  -> ()
	 */
	void URBCheatManager::CycleAIDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.CycleAIDebug");
		
		URBCheatManager_CycleAIDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.Crash
	 * 		Flags  -> ()
	 */
	void URBCheatManager::Crash()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.Crash");
		
		URBCheatManager_Crash_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.CopyCameraLocation
	 * 		Flags  -> ()
	 */
	void URBCheatManager::CopyCameraLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.CopyCameraLocation");
		
		URBCheatManager_CopyCameraLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.CompleteTasks
	 * 		Flags  -> ()
	 */
	void URBCheatManager::CompleteTasks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.CompleteTasks");
		
		URBCheatManager_CompleteTasks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.CompleteObjectiveCoordinator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::CompleteObjectiveCoordinator(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.CompleteObjectiveCoordinator");
		
		URBCheatManager_CompleteObjectiveCoordinator_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.CompleteMainObjectivesToIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::CompleteMainObjectivesToIndex(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.CompleteMainObjectivesToIndex");
		
		URBCheatManager_CompleteMainObjectivesToIndex_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.CompleteMainObjectivesTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::CompleteMainObjectivesTo(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.CompleteMainObjectivesTo");
		
		URBCheatManager_CompleteMainObjectivesTo_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.CompleteMainObjective
	 * 		Flags  -> ()
	 */
	void URBCheatManager::CompleteMainObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.CompleteMainObjective");
		
		URBCheatManager_CompleteMainObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.CompleteCurrentStage
	 * 		Flags  -> ()
	 */
	void URBCheatManager::CompleteCurrentStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.CompleteCurrentStage");
		
		URBCheatManager_CompleteCurrentStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.CollisionReport
	 * 		Flags  -> ()
	 */
	void URBCheatManager::CollisionReport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.CollisionReport");
		
		URBCheatManager_CollisionReport_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ClearVisitedNPCs
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ClearVisitedNPCs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ClearVisitedNPCs");
		
		URBCheatManager_ClearVisitedNPCs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ClearTasks
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ClearTasks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ClearTasks");
		
		URBCheatManager_ClearTasks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ClearShowAll
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ClearShowAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ClearShowAll");
		
		URBCheatManager_ClearShowAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ClearRandomState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      searchQuery                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::ClearRandomState(const class FString& searchQuery)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ClearRandomState");
		
		URBCheatManager_ClearRandomState_Params params {};
		params.searchQuery = searchQuery;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ClearPsychosis
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ClearPsychosis()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ClearPsychosis");
		
		URBCheatManager_ClearPsychosis_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ClearMenuTutorials
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ClearMenuTutorials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ClearMenuTutorials");
		
		URBCheatManager_ClearMenuTutorials_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ClearLastPartyFindProfileIds
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ClearLastPartyFindProfileIds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ClearLastPartyFindProfileIds");
		
		URBCheatManager_ClearLastPartyFindProfileIds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ClearItemsDisplayedInMenu
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ClearItemsDisplayedInMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ClearItemsDisplayedInMenu");
		
		URBCheatManager_ClearItemsDisplayedInMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ClearHeatmap
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ClearHeatmap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ClearHeatmap");
		
		URBCheatManager_ClearHeatmap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ClearForcedLevelSeed
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ClearForcedLevelSeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ClearForcedLevelSeed");
		
		URBCheatManager_ClearForcedLevelSeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ClearDebugActorInViewFilters
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ClearDebugActorInViewFilters()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ClearDebugActorInViewFilters");
		
		URBCheatManager_ClearDebugActorInViewFilters_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.CheatCameraLocation
	 * 		Flags  -> ()
	 */
	void URBCheatManager::CheatCameraLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.CheatCameraLocation");
		
		URBCheatManager_CheatCameraLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.BugIt_TextEnteredCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::BugIt_TextEnteredCallback(const class FString& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.BugIt_TextEnteredCallback");
		
		URBCheatManager_BugIt_TextEnteredCallback_Params params {};
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.BugIt_Input
	 * 		Flags  -> ()
	 */
	void URBCheatManager::BugIt_Input()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.BugIt_Input");
		
		URBCheatManager_BugIt_Input_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.BigLag
	 * 		Flags  -> ()
	 */
	void URBCheatManager::BigLag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.BigLag");
		
		URBCheatManager_BigLag_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.BadFPS
	 * 		Flags  -> ()
	 */
	void URBCheatManager::BadFPS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.BadFPS");
		
		URBCheatManager_BadFPS_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.Assert
	 * 		Flags  -> ()
	 */
	void URBCheatManager::Assert()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.Assert");
		
		URBCheatManager_Assert_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AILog
	 * 		Flags  -> ()
	 */
	void URBCheatManager::AILog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AILog");
		
		URBCheatManager_AILog_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddXp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddXp(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddXp");
		
		URBCheatManager_AddXp_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddVariator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddVariator(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddVariator");
		
		URBCheatManager_AddVariator_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddTQ
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddTQ(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddTQ");
		
		URBCheatManager_AddTQ_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddTaskByID
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        taskId                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddTaskByID(const class FName& taskId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddTaskByID");
		
		URBCheatManager_AddTaskByID_Params params {};
		params.taskId = taskId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddTask
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      taskTitle                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddTask(const class FString& taskTitle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddTask");
		
		URBCheatManager_AddTask_Params params {};
		params.taskTitle = taskTitle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddStageXp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddStageXp(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddStageXp");
		
		URBCheatManager_AddStageXp_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddSelfRevive
	 * 		Flags  -> ()
	 */
	void URBCheatManager::AddSelfRevive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddSelfRevive");
		
		URBCheatManager_AddSelfRevive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddPsychosis
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGas                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddPsychosis(int32_t amount, bool bGas)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddPsychosis");
		
		URBCheatManager_AddPsychosis_Params params {};
		params.amount = amount;
		params.bGas = bGas;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddOnlineItemWithID
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        upgradeOnlineItemId                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsPersistentItem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddOnlineItemWithID(const class FName& upgradeOnlineItemId, bool bIsPersistentItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddOnlineItemWithID");
		
		URBCheatManager_AddOnlineItemWithID_Params params {};
		params.upgradeOnlineItemId = upgradeOnlineItemId;
		params.bIsPersistentItem = bIsPersistentItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddMurkoffPoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddMurkoffPoints(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddMurkoffPoints");
		
		URBCheatManager_AddMurkoffPoints_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddMurkoffDollars
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddMurkoffDollars(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddMurkoffDollars");
		
		URBCheatManager_AddMurkoffDollars_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddMultipleItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ItemName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            numberOfCopy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddMultipleItems(const class FString& ItemName, int32_t numberOfCopy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddMultipleItems");
		
		URBCheatManager_AddMultipleItems_Params params {};
		params.ItemName = ItemName;
		params.numberOfCopy = numberOfCopy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ItemName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddItem(const class FString& ItemName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddItem");
		
		URBCheatManager_AddItem_Params params {};
		params.ItemName = ItemName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddDebugActorInViewFilter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Filter                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddDebugActorInViewFilter(const class FString& Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddDebugActorInViewFilter");
		
		URBCheatManager_AddDebugActorInViewFilter_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AddCurrency
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECurrencyType                                      currencyType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AddCurrency(ECurrencyType currencyType, int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AddCurrency");
		
		URBCheatManager_AddCurrency_Params params {};
		params.currencyType = currencyType;
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.ActivateAllMines
	 * 		Flags  -> ()
	 */
	void URBCheatManager::ActivateAllMines()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.ActivateAllMines");
		
		URBCheatManager_ActivateAllMines_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AcquireRewardPoolItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        RewardPoolId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AcquireRewardPoolItem(const class FName& RewardPoolId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AcquireRewardPoolItem");
		
		URBCheatManager_AcquireRewardPoolItem_Params params {};
		params.RewardPoolId = RewardPoolId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AcquireFullRewardPool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        RewardPoolId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AcquireFullRewardPool(const class FName& RewardPoolId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AcquireFullRewardPool");
		
		URBCheatManager_AcquireFullRewardPool_Params params {};
		params.RewardPoolId = RewardPoolId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AcquireBadge
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      BadgeId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCheatManager::AcquireBadge(const class FString& BadgeId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AcquireBadge");
		
		URBCheatManager_AcquireBadge_Params params {};
		params.BadgeId = BadgeId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AcquireAllDocuments
	 * 		Flags  -> ()
	 */
	void URBCheatManager::AcquireAllDocuments()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AcquireAllDocuments");
		
		URBCheatManager_AcquireAllDocuments_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AcquireAllCustomization
	 * 		Flags  -> ()
	 */
	void URBCheatManager::AcquireAllCustomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AcquireAllCustomization");
		
		URBCheatManager_AcquireAllCustomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCheatManager.AcquireAllCellCustomization
	 * 		Flags  -> ()
	 */
	void URBCheatManager::AcquireAllCellCustomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCheatManager.AcquireAllCellCustomization");
		
		URBCheatManager_AcquireAllCellCustomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCheatManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCheatManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCheatManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.RegisterDebugPiecesData
	 * 		Flags  -> ()
	 */
	void ARBChessBoard::RegisterDebugPiecesData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.RegisterDebugPiecesData");
		
		ARBChessBoard_RegisterDebugPiecesData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.OnRep_TeamTurn
	 * 		Flags  -> ()
	 */
	void ARBChessBoard::OnRep_TeamTurn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.OnRep_TeamTurn");
		
		ARBChessBoard_OnRep_TeamTurn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.OnRep_Team
	 * 		Flags  -> ()
	 */
	void ARBChessBoard::OnRep_Team()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.OnRep_Team");
		
		ARBChessBoard_OnRep_Team_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.OnRep_Stats
	 * 		Flags  -> ()
	 */
	void ARBChessBoard::OnRep_Stats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.OnRep_Stats");
		
		ARBChessBoard_OnRep_Stats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.OnRep_LastMoveCoords
	 * 		Flags  -> ()
	 */
	void ARBChessBoard::OnRep_LastMoveCoords()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.OnRep_LastMoveCoords");
		
		ARBChessBoard_OnRep_LastMoveCoords_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.OnRep_ChessGameTurnType
	 * 		Flags  -> ()
	 */
	void ARBChessBoard::OnRep_ChessGameTurnType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.OnRep_ChessGameTurnType");
		
		ARBChessBoard_OnRep_ChessGameTurnType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.OnRep_ChessGameState
	 * 		Flags  -> ()
	 */
	void ARBChessBoard::OnRep_ChessGameState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.OnRep_ChessGameState");
		
		ARBChessBoard_OnRep_ChessGameState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.OnRep_ChessGameEndReason
	 * 		Flags  -> ()
	 */
	void ARBChessBoard::OnRep_ChessGameEndReason()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.OnRep_ChessGameEndReason");
		
		ARBChessBoard_OnRep_ChessGameEndReason_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.OnRep_ChessClockData
	 * 		Flags  -> ()
	 */
	void ARBChessBoard::OnRep_ChessClockData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.OnRep_ChessClockData");
		
		ARBChessBoard_OnRep_ChessClockData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.OnRep_ChessBoardSideA
	 * 		Flags  -> ()
	 */
	void ARBChessBoard::OnRep_ChessBoardSideA()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.OnRep_ChessBoardSideA");
		
		ARBChessBoard_OnRep_ChessBoardSideA_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.Multicast_PlayerDropPieceAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EChessTeam                                         Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FIntPoint                                   targetLocation                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBChessBoard::Multicast_PlayerDropPieceAt(EChessTeam Team, const struct FIntPoint& targetLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.Multicast_PlayerDropPieceAt");
		
		ARBChessBoard_Multicast_PlayerDropPieceAt_Params params {};
		params.Team = Team;
		params.targetLocation = targetLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.Multicast_BroadcastMatchStartMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   player1Ptr                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   player2Ptr                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBChessBoard::Multicast_BroadcastMatchStartMessage(class ARBPlayer* player1Ptr, class ARBPlayer* player2Ptr)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.Multicast_BroadcastMatchStartMessage");
		
		ARBChessBoard_Multicast_BroadcastMatchStartMessage_Params params {};
		params.player1Ptr = player1Ptr;
		params.player2Ptr = player2Ptr;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.Multicast_BroadcastMatchEndMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   winnerPtr                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   loserPtr                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsDraw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBChessBoard::Multicast_BroadcastMatchEndMessage(class ARBPlayer* winnerPtr, class ARBPlayer* loserPtr, bool bIsDraw)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.Multicast_BroadcastMatchEndMessage");
		
		ARBChessBoard_Multicast_BroadcastMatchEndMessage_Params params {};
		params.winnerPtr = winnerPtr;
		params.loserPtr = loserPtr;
		params.bIsDraw = bIsDraw;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.IsGameInProgress
	 * 		Flags  -> ()
	 */
	bool ARBChessBoard::IsGameInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.IsGameInProgress");
		
		ARBChessBoard_IsGameInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.IsEndReasonDrawType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EChessGameEndReason                                endReason                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBChessBoard::IsEndReasonDrawType(EChessGameEndReason endReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.IsEndReasonDrawType");
		
		ARBChessBoard_IsEndReasonDrawType_Params params {};
		params.endReason = endReason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetTeamRemainingTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EChessTeam                                         Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ARBChessBoard::GetTeamRemainingTime(EChessTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetTeamRemainingTime");
		
		ARBChessBoard_GetTeamRemainingTime_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetTeamChessPanelComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EChessTeam                                         Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBChessBoardPanelComponent* ARBChessBoard::GetTeamChessPanelComponent(EChessTeam Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetTeamChessPanelComponent");
		
		ARBChessBoard_GetTeamChessPanelComponent_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetRating
	 * 		Flags  -> ()
	 */
	int32_t ARBChessBoard::GetRating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetRating");
		
		ARBChessBoard_GetRating_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetPromotingCoords
	 * 		Flags  -> ()
	 */
	TArray<struct FIntPoint> ARBChessBoard::GetPromotingCoords()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetPromotingCoords");
		
		ARBChessBoard_GetPromotingCoords_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetPossibleCoordsForPiece
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBChessPieceComponent*                      chessPiece                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FIntPoint> ARBChessBoard::GetPossibleCoordsForPiece(class URBChessPieceComponent* chessPiece)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetPossibleCoordsForPiece");
		
		ARBChessBoard_GetPossibleCoordsForPiece_Params params {};
		params.chessPiece = chessPiece;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetOpponentRating
	 * 		Flags  -> ()
	 */
	int32_t ARBChessBoard::GetOpponentRating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetOpponentRating");
		
		ARBChessBoard_GetOpponentRating_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetOpponentPlayer
	 * 		Flags  -> ()
	 */
	class ARBPlayer* ARBChessBoard::GetOpponentPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetOpponentPlayer");
		
		ARBChessBoard_GetOpponentPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetOpponentPanel
	 * 		Flags  -> ()
	 */
	class URBChessBoardPanelComponent* ARBChessBoard::GetOpponentPanel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetOpponentPanel");
		
		ARBChessBoard_GetOpponentPanel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetOpponentMatchesWon
	 * 		Flags  -> ()
	 */
	int32_t ARBChessBoard::GetOpponentMatchesWon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetOpponentMatchesWon");
		
		ARBChessBoard_GetOpponentMatchesWon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetOpponentMatchesLost
	 * 		Flags  -> ()
	 */
	int32_t ARBChessBoard::GetOpponentMatchesLost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetOpponentMatchesLost");
		
		ARBChessBoard_GetOpponentMatchesLost_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetMatchesWon
	 * 		Flags  -> ()
	 */
	int32_t ARBChessBoard::GetMatchesWon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetMatchesWon");
		
		ARBChessBoard_GetMatchesWon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetMatchesLost
	 * 		Flags  -> ()
	 */
	int32_t ARBChessBoard::GetMatchesLost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetMatchesLost");
		
		ARBChessBoard_GetMatchesLost_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetLocalPositionForCoord
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FIntPoint                                   coord                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector ARBChessBoard::GetLocalPositionForCoord(const struct FIntPoint& coord)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetLocalPositionForCoord");
		
		ARBChessBoard_GetLocalPositionForCoord_Params params {};
		params.coord = coord;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoard.GetLocalPanel
	 * 		Flags  -> ()
	 */
	class URBChessBoardPanelComponent* ARBChessBoard::GetLocalPanel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoard.GetLocalPanel");
		
		ARBChessBoard_GetLocalPanel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBChessBoard.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBChessBoard::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBChessBoard");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.SetChessGamePlayerAnimState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EChessGamePlayerAnimState                          newState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBChessBoardPanelComponent::SetChessGamePlayerAnimState(EChessGamePlayerAnimState newState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.SetChessGamePlayerAnimState");
		
		URBChessBoardPanelComponent_SetChessGamePlayerAnimState_Params params {};
		params.newState = newState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.OnTurnChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBChessBoardPanelComponent::OnTurnChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.OnTurnChangedCallback");
		
		URBChessBoardPanelComponent_OnTurnChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.OnRep_Turn
	 * 		Flags  -> ()
	 */
	void URBChessBoardPanelComponent::OnRep_Turn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.OnRep_Turn");
		
		URBChessBoardPanelComponent_OnRep_Turn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.OnRep_HoldingPiece
	 * 		Flags  -> ()
	 */
	void URBChessBoardPanelComponent::OnRep_HoldingPiece()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.OnRep_HoldingPiece");
		
		URBChessBoardPanelComponent_OnRep_HoldingPiece_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.OnRep_ChessGamePlayerAnimState
	 * 		Flags  -> ()
	 */
	void URBChessBoardPanelComponent::OnRep_ChessGamePlayerAnimState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.OnRep_ChessGamePlayerAnimState");
		
		URBChessBoardPanelComponent_OnRep_ChessGamePlayerAnimState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.OnHoldingPieceChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBChessBoardPanelComponent::OnHoldingPieceChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.OnHoldingPieceChangedCallback");
		
		URBChessBoardPanelComponent_OnHoldingPieceChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.OnChessGameStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EChessGameState                                    newGameState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBChessBoardPanelComponent::OnChessGameStateChanged(EChessGameState newGameState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.OnChessGameStateChanged");
		
		URBChessBoardPanelComponent_OnChessGameStateChanged_Params params {};
		params.newGameState = newGameState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.IsPlayer1
	 * 		Flags  -> ()
	 */
	bool URBChessBoardPanelComponent::IsPlayer1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.IsPlayer1");
		
		URBChessBoardPanelComponent_IsPlayer1_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.GetWSFocusedLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bUseReplicatedValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector URBChessBoardPanelComponent::GetWSFocusedLocation(bool bUseReplicatedValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.GetWSFocusedLocation");
		
		URBChessBoardPanelComponent_GetWSFocusedLocation_Params params {};
		params.bUseReplicatedValue = bUseReplicatedValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.GetWorldPosFromCoord
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FIntPoint                                   coords                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector URBChessBoardPanelComponent::GetWorldPosFromCoord(const struct FIntPoint& coords)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.GetWorldPosFromCoord");
		
		URBChessBoardPanelComponent_GetWorldPosFromCoord_Params params {};
		params.coords = coords;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.GetLocalPosFromProjPos
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     projWorldPos                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector2D URBChessBoardPanelComponent::GetLocalPosFromProjPos(const struct FVector& projWorldPos)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.GetLocalPosFromProjPos");
		
		URBChessBoardPanelComponent_GetLocalPosFromProjPos_Params params {};
		params.projWorldPos = projWorldPos;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.GetLocalPosFromCoord
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FIntPoint                                   coords                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector2D URBChessBoardPanelComponent::GetLocalPosFromCoord(const struct FIntPoint& coords)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.GetLocalPosFromCoord");
		
		URBChessBoardPanelComponent_GetLocalPosFromCoord_Params params {};
		params.coords = coords;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.GetHoldingPiece
	 * 		Flags  -> ()
	 */
	class URBChessPieceComponent* URBChessBoardPanelComponent::GetHoldingPiece()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.GetHoldingPiece");
		
		URBChessBoardPanelComponent_GetHoldingPiece_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.Event_ShowMoveLeavesOwnKingChecked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBChessPieceComponent*                      kingPiece                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBChessBoardPanelComponent::Event_ShowMoveLeavesOwnKingChecked(class URBChessPieceComponent* kingPiece)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.Event_ShowMoveLeavesOwnKingChecked");
		
		URBChessBoardPanelComponent_Event_ShowMoveLeavesOwnKingChecked_Params params {};
		params.kingPiece = kingPiece;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.Event_PlayerLeftGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBChessBoardPanelComponent::Event_PlayerLeftGame(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.Event_PlayerLeftGame");
		
		URBChessBoardPanelComponent_Event_PlayerLeftGame_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.Event_PlayerEnteredGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBChessBoardPanelComponent::Event_PlayerEnteredGame(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.Event_PlayerEnteredGame");
		
		URBChessBoardPanelComponent_Event_PlayerEnteredGame_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.Event_PlayerDropPieceAt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector2D                                   coords                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBChessBoardPanelComponent::Event_PlayerDropPieceAt(const struct FVector2D& coords)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.Event_PlayerDropPieceAt");
		
		URBChessBoardPanelComponent_Event_PlayerDropPieceAt_Params params {};
		params.coords = coords;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessBoardPanelComponent.BP_ChessGamePlayerAnimStateChanged
	 * 		Flags  -> ()
	 */
	void URBChessBoardPanelComponent::BP_ChessGamePlayerAnimStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessBoardPanelComponent.BP_ChessGamePlayerAnimStateChanged");
		
		URBChessBoardPanelComponent_BP_ChessGamePlayerAnimStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBChessBoardPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBChessBoardPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBChessBoardPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessPieceComponent.UpdatePosition
	 * 		Flags  -> ()
	 */
	void URBChessPieceComponent::UpdatePosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessPieceComponent.UpdatePosition");
		
		URBChessPieceComponent_UpdatePosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessPieceComponent.OnRep_PieceData
	 * 		Flags  -> ()
	 */
	void URBChessPieceComponent::OnRep_PieceData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessPieceComponent.OnRep_PieceData");
		
		URBChessPieceComponent_OnRep_PieceData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessPieceComponent.GetCoordinates
	 * 		Flags  -> ()
	 */
	struct FIntPoint URBChessPieceComponent::GetCoordinates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessPieceComponent.GetCoordinates");
		
		URBChessPieceComponent_GetCoordinates_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBChessPieceComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBChessPieceComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBChessPieceComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChessSpectatorPanelComponent.Multicast_PlayerTaunt
	 * 		Flags  -> ()
	 */
	void URBChessSpectatorPanelComponent::Multicast_PlayerTaunt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChessSpectatorPanelComponent.Multicast_PlayerTaunt");
		
		URBChessSpectatorPanelComponent_Multicast_PlayerTaunt_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBChessSpectatorPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBChessSpectatorPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBChessSpectatorPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChunkInstallManager.IsChunkInstallationCompleted
	 * 		Flags  -> ()
	 */
	bool URBChunkInstallManager::IsChunkInstallationCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChunkInstallManager.IsChunkInstallationCompleted");
		
		URBChunkInstallManager_IsChunkInstallationCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBChunkInstallManager.GetChunkInstallationStatus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Percent                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBChunkInstallManager::GetChunkInstallationStatus(float* Percent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBChunkInstallManager.GetChunkInstallationStatus");
		
		URBChunkInstallManager_GetChunkInstallationStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Percent != nullptr)
			*Percent = params.Percent;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBChunkInstallManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBChunkInstallManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBChunkInstallManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCinematicZoneComponent.SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCinematicZoneComponent::SetEnabled(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCinematicZoneComponent.SetEnabled");
		
		URBCinematicZoneComponent_SetEnabled_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCinematicZoneComponent.OnPlayerCustomizationChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   RBPlayer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCinematicZoneComponent::OnPlayerCustomizationChanged(class ARBPlayer* RBPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCinematicZoneComponent.OnPlayerCustomizationChanged");
		
		URBCinematicZoneComponent_OnPlayerCustomizationChanged_Params params {};
		params.RBPlayer = RBPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCinematicZoneComponent.OnActiveSkillActorChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBActiveSkill*                              activeSkillActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCinematicZoneComponent::OnActiveSkillActorChanged(class ARBActiveSkill* activeSkillActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCinematicZoneComponent.OnActiveSkillActorChanged");
		
		URBCinematicZoneComponent_OnActiveSkillActorChanged_Params params {};
		params.activeSkillActor = activeSkillActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCinematicZoneComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCinematicZoneComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCinematicZoneComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBClientOnlyActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBClientOnlyActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBClientOnlyActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBClueable.SetClue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FClueData                                   ClueData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBClueable::SetClue(const struct FClueData& ClueData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBClueable.SetClue");
		
		URBClueable_SetClue_Params params {};
		params.ClueData = ClueData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBClueable.GetClue
	 * 		Flags  -> ()
	 */
	struct FClueData URBClueable::GetClue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBClueable.GetClue");
		
		URBClueable_GetClue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBClueable.GetAssociatedInvestigationComponent
	 * 		Flags  -> ()
	 */
	class URBPlayerInvestigationZoneComponent* URBClueable::GetAssociatedInvestigationComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBClueable.GetAssociatedInvestigationComponent");
		
		URBClueable_GetAssociatedInvestigationComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBClueable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBClueable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBClueable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBCollectibleDisplay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBCollectibleDisplay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCollectibleDisplay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCollectibleDocumentsConfig.GetDocumentGroups
	 * 		Flags  -> ()
	 */
	TArray<struct FRBCollectibleDocumentGroupRow> URBCollectibleDocumentsConfig::GetDocumentGroups()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCollectibleDocumentsConfig.GetDocumentGroups");
		
		URBCollectibleDocumentsConfig_GetDocumentGroups_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCollectibleDocumentsConfig.GetDocumentGroupDocuments
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FRBCollectibleDocumentDefinitionRow> URBCollectibleDocumentsConfig::GetDocumentGroupDocuments(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCollectibleDocumentsConfig.GetDocumentGroupDocuments");
		
		URBCollectibleDocumentsConfig_GetDocumentGroupDocuments_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCollectibleDocumentsConfig.GetDocumentGroup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBCollectibleDocumentGroupRow URBCollectibleDocumentsConfig::GetDocumentGroup(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCollectibleDocumentsConfig.GetDocumentGroup");
		
		URBCollectibleDocumentsConfig_GetDocumentGroup_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCollectibleDocumentsConfig.GetCollectibleDocumentDefinition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBCollectibleDocumentDefinitionRow URBCollectibleDocumentsConfig::GetCollectibleDocumentDefinition(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCollectibleDocumentsConfig.GetCollectibleDocumentDefinition");
		
		URBCollectibleDocumentsConfig_GetCollectibleDocumentDefinition_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCollectibleDocumentsConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCollectibleDocumentsConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCollectibleDocumentsConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCollectibleDocumentPickup.OnRep_ProfileIdsInteracted
	 * 		Flags  -> ()
	 */
	void ARBCollectibleDocumentPickup::OnRep_ProfileIdsInteracted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCollectibleDocumentPickup.OnRep_ProfileIdsInteracted");
		
		ARBCollectibleDocumentPickup_OnRep_ProfileIdsInteracted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCollectibleDocumentPickup.Multicast_OnDocumentPickedUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   RBPlayer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstInteraction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWasAcquired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCollectibleDocumentPickup::Multicast_OnDocumentPickedUp(class ARBPlayer* RBPlayer, bool bFirstInteraction, bool bWasAcquired)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCollectibleDocumentPickup.Multicast_OnDocumentPickedUp");
		
		ARBCollectibleDocumentPickup_Multicast_OnDocumentPickedUp_Params params {};
		params.RBPlayer = RBPlayer;
		params.bFirstInteraction = bFirstInteraction;
		params.bWasAcquired = bWasAcquired;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCollectibleDocumentPickup.GetDocumentId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FName ARBCollectibleDocumentPickup::GetDocumentId(class ARBPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCollectibleDocumentPickup.GetDocumentId");
		
		ARBCollectibleDocumentPickup_GetDocumentId_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCollectibleDocumentPickup.Event_OnWorldPopulateFinished
	 * 		Flags  -> ()
	 */
	void ARBCollectibleDocumentPickup::Event_OnWorldPopulateFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCollectibleDocumentPickup.Event_OnWorldPopulateFinished");
		
		ARBCollectibleDocumentPickup_Event_OnWorldPopulateFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBCollectibleDocumentPickup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBCollectibleDocumentPickup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCollectibleDocumentPickup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomManager.BP_Randomize
	 * 		Flags  -> ()
	 */
	void ARBRandomManager::BP_Randomize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomManager.BP_Randomize");
		
		ARBRandomManager_BP_Randomize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomManager.BP_ForceRandomization
	 * 		Flags  -> ()
	 */
	void ARBRandomManager::BP_ForceRandomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomManager.BP_ForceRandomization");
		
		ARBRandomManager_BP_ForceRandomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRandomManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRandomManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRandomManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBConditionalRandomManager.OnRandomManagerRandomizationDone
	 * 		Flags  -> ()
	 */
	void ARBConditionalRandomManager::OnRandomManagerRandomizationDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBConditionalRandomManager.OnRandomManagerRandomizationDone");
		
		ARBConditionalRandomManager_OnRandomManagerRandomizationDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBConditionalRandomManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBConditionalRandomManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBConditionalRandomManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPickupVisualizerHelper.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPickupVisualizerHelper::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPickupVisualizerHelper");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContainerSpawnLocationComponent.Editor_CreateAllItemDisplayMeshes
	 * 		Flags  -> ()
	 */
	void URBContainerSpawnLocationComponent::Editor_CreateAllItemDisplayMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContainerSpawnLocationComponent.Editor_CreateAllItemDisplayMeshes");
		
		URBContainerSpawnLocationComponent_Editor_CreateAllItemDisplayMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBContainerSpawnLocationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBContainerSpawnLocationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBContainerSpawnLocationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBContainerInteractibleZoneComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBContainerInteractibleZoneComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBContainerInteractibleZoneComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBContainerTrapTriggerable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBContainerTrapTriggerable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBContainerTrapTriggerable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundComponent.StopLoopingSoundFromID
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            LoopingSoundID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSoundComponent::StopLoopingSoundFromID(int32_t LoopingSoundID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundComponent.StopLoopingSoundFromID");
		
		URBSoundComponent_StopLoopingSoundFromID_Params params {};
		params.LoopingSoundID = LoopingSoundID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundComponent.StopLoopingSound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               LoopStartEvent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               LoopStopEvent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBSoundComponent::StopLoopingSound(class UAkAudioEvent* LoopStartEvent, class UAkAudioEvent* LoopStopEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundComponent.StopLoopingSound");
		
		URBSoundComponent_StopLoopingSound_Params params {};
		params.LoopStartEvent = LoopStartEvent;
		params.LoopStopEvent = LoopStopEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundComponent.StopAssociatedAkEvent
	 * 		Flags  -> ()
	 */
	int32_t URBSoundComponent::StopAssociatedAkEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundComponent.StopAssociatedAkEvent");
		
		URBSoundComponent_StopAssociatedAkEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundComponent.StopAllLoopingSounds
	 * 		Flags  -> ()
	 */
	void URBSoundComponent::StopAllLoopingSounds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundComponent.StopAllLoopingSounds");
		
		URBSoundComponent_StopAllLoopingSounds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundComponent.SetBillboardVisibility
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bBillboardVisibleValue                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSoundComponent::SetBillboardVisibility(bool bBillboardVisibleValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundComponent.SetBillboardVisibility");
		
		URBSoundComponent_SetBillboardVisibility_Params params {};
		params.bBillboardVisibleValue = bBillboardVisibleValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundComponent.PlayVOLoopingSound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               LoopStartEvent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               LoopStopEvent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBSoundComponent::PlayVOLoopingSound(class UAkAudioEvent* LoopStartEvent, class UAkAudioEvent* LoopStopEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundComponent.PlayVOLoopingSound");
		
		URBSoundComponent_PlayVOLoopingSound_Params params {};
		params.LoopStartEvent = LoopStartEvent;
		params.LoopStopEvent = LoopStopEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundComponent.PlayLoopingSound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               LoopStartEvent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               LoopStopEvent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAllowMultipleIdenticalLoops                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBSoundComponent::PlayLoopingSound(class UAkAudioEvent* LoopStartEvent, class UAkAudioEvent* LoopStopEvent, bool bAllowMultipleIdenticalLoops)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundComponent.PlayLoopingSound");
		
		URBSoundComponent_PlayLoopingSound_Params params {};
		params.LoopStartEvent = LoopStartEvent;
		params.LoopStopEvent = LoopStopEvent;
		params.bAllowMultipleIdenticalLoops = bAllowMultipleIdenticalLoops;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundComponent.IsPlayingLoopingSound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               LoopStartEvent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               LoopStopEvent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBSoundComponent::IsPlayingLoopingSound(class UAkAudioEvent* LoopStartEvent, class UAkAudioEvent* LoopStopEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundComponent.IsPlayingLoopingSound");
		
		URBSoundComponent_IsPlayingLoopingSound_Params params {};
		params.LoopStartEvent = LoopStartEvent;
		params.LoopStopEvent = LoopStopEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundComponent.BP_RegisterToAudioManager
	 * 		Flags  -> ()
	 */
	void URBSoundComponent::BP_RegisterToAudioManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundComponent.BP_RegisterToAudioManager");
		
		URBSoundComponent_BP_RegisterToAudioManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundComponent.BP_IsPlaying
	 * 		Flags  -> ()
	 */
	bool URBSoundComponent::BP_IsPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundComponent.BP_IsPlaying");
		
		URBSoundComponent_BP_IsPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSoundComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSoundComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSoundComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBContinuousMovementSoundComponent.ResetMovementDelta
	 * 		Flags  -> ()
	 */
	void URBContinuousMovementSoundComponent::ResetMovementDelta()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBContinuousMovementSoundComponent.ResetMovementDelta");
		
		URBContinuousMovementSoundComponent_ResetMovementDelta_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBContinuousMovementSoundComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBContinuousMovementSoundComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBContinuousMovementSoundComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.SetMenuViewTargetWithBlend
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      NewViewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              blendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EViewTargetBlendFunction                           BlendFunc                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLockOutgoing                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::SetMenuViewTargetWithBlend(class AActor* NewViewTarget, float blendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.SetMenuViewTargetWithBlend");
		
		ARBMenuPlayerController_SetMenuViewTargetWithBlend_Params params {};
		params.NewViewTarget = NewViewTarget;
		params.blendTime = blendTime;
		params.BlendFunc = BlendFunc;
		params.BlendExp = BlendExp;
		params.bLockOutgoing = bLockOutgoing;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.SetAllowLookInMenu
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::SetAllowLookInMenu(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.SetAllowLookInMenu");
		
		ARBMenuPlayerController_SetAllowLookInMenu_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.Server_SetVoiceChatState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::Server_SetVoiceChatState(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.Server_SetVoiceChatState");
		
		ARBMenuPlayerController_Server_SetVoiceChatState_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.Server_SetRegionLatency
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRegionLatency>                      RegionLatency                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::Server_SetRegionLatency(TArray<struct FRegionLatency> RegionLatency)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.Server_SetRegionLatency");
		
		ARBMenuPlayerController_Server_SetRegionLatency_Params params {};
		params.RegionLatency = RegionLatency;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.Server_SetPresenceInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      partyId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            playerCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bJoinable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFriendRequiresInvite                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPublicRequiresInvite                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::Server_SetPresenceInfo(const class FString& partyId, int32_t playerCount, bool bJoinable, bool bFriendRequiresInvite, bool bPublicRequiresInvite)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.Server_SetPresenceInfo");
		
		ARBMenuPlayerController_Server_SetPresenceInfo_Params params {};
		params.partyId = partyId;
		params.playerCount = playerCount;
		params.bJoinable = bJoinable;
		params.bFriendRequiresInvite = bFriendRequiresInvite;
		params.bPublicRequiresInvite = bPublicRequiresInvite;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.Server_SetIsLeaving
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerLeaveTarget                                 Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::Server_SetIsLeaving(EPlayerLeaveTarget Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.Server_SetIsLeaving");
		
		ARBMenuPlayerController_Server_SetIsLeaving_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.Server_SetIsInLoadingScreen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::Server_SetIsInLoadingScreen(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.Server_SetIsInLoadingScreen");
		
		ARBMenuPlayerController_Server_SetIsInLoadingScreen_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.Server_SetBlockedProfileIds
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FProfileId>                          profileIds                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::Server_SetBlockedProfileIds(TArray<struct FProfileId> profileIds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.Server_SetBlockedProfileIds");
		
		ARBMenuPlayerController_Server_SetBlockedProfileIds_Params params {};
		params.profileIds = profileIds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.Server_ReservePartyMemberPlayerSlots
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FProfileId>                          members                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::Server_ReservePartyMemberPlayerSlots(TArray<struct FProfileId> members)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.Server_ReservePartyMemberPlayerSlots");
		
		ARBMenuPlayerController_Server_ReservePartyMemberPlayerSlots_Params params {};
		params.members = members;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.Server_RequestPlayerStatsData
	 * 		Flags  -> ()
	 */
	void ARBMenuPlayerController::Server_RequestPlayerStatsData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.Server_RequestPlayerStatsData");
		
		ARBMenuPlayerController_Server_RequestPlayerStatsData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.Server_Report
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProfileId                                  targetProfileId                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayerReportReason                                Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      reasonText                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::Server_Report(const struct FProfileId& targetProfileId, EPlayerReportReason Reason, const class FString& reasonText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.Server_Report");
		
		ARBMenuPlayerController_Server_Report_Params params {};
		params.targetProfileId = targetProfileId;
		params.Reason = Reason;
		params.reasonText = reasonText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.Server_KeepAlive
	 * 		Flags  -> ()
	 */
	void ARBMenuPlayerController::Server_KeepAlive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.Server_KeepAlive");
		
		ARBMenuPlayerController_Server_KeepAlive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.RestorePlayerViewTarget
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      oldMenuViewTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              blendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EViewTargetBlendFunction                           BlendFunc                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLockOutgoing                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::RestorePlayerViewTarget(class AActor* oldMenuViewTarget, float blendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.RestorePlayerViewTarget");
		
		ARBMenuPlayerController_RestorePlayerViewTarget_Params params {};
		params.oldMenuViewTarget = oldMenuViewTarget;
		params.blendTime = blendTime;
		params.BlendFunc = BlendFunc;
		params.BlendExp = BlendExp;
		params.bLockOutgoing = bLockOutgoing;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.OnLocalProfileLoaded
	 * 		Flags  -> ()
	 */
	void ARBMenuPlayerController::OnLocalProfileLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.OnLocalProfileLoaded");
		
		ARBMenuPlayerController_OnLocalProfileLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.OnExpectedPlayerCountUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            expectedPlayerCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::OnExpectedPlayerCountUpdated(int32_t expectedPlayerCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.OnExpectedPlayerCountUpdated");
		
		ARBMenuPlayerController_OnExpectedPlayerCountUpdated_Params params {};
		params.expectedPlayerCount = expectedPlayerCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.IsUsingGamePad
	 * 		Flags  -> ()
	 */
	bool ARBMenuPlayerController::IsUsingGamePad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.IsUsingGamePad");
		
		ARBMenuPlayerController_IsUsingGamePad_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.IsLeaving
	 * 		Flags  -> ()
	 */
	bool ARBMenuPlayerController::IsLeaving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.IsLeaving");
		
		ARBMenuPlayerController_IsLeaving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.IsInMenu
	 * 		Flags  -> ()
	 */
	bool ARBMenuPlayerController::IsInMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.IsInMenu");
		
		ARBMenuPlayerController_IsInMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.IsInLoadingScreen
	 * 		Flags  -> ()
	 */
	bool ARBMenuPlayerController::IsInLoadingScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.IsInLoadingScreen");
		
		ARBMenuPlayerController_IsInLoadingScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.GetLeaveTarget
	 * 		Flags  -> ()
	 */
	EPlayerLeaveTarget ARBMenuPlayerController::GetLeaveTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.GetLeaveTarget");
		
		ARBMenuPlayerController_GetLeaveTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.GetCurrentGamepadType
	 * 		Flags  -> ()
	 */
	EGamepadType ARBMenuPlayerController::GetCurrentGamepadType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.GetCurrentGamepadType");
		
		ARBMenuPlayerController_GetCurrentGamepadType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.GetAllowLookInMenu
	 * 		Flags  -> ()
	 */
	bool ARBMenuPlayerController::GetAllowLookInMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.GetAllowLookInMenu");
		
		ARBMenuPlayerController_GetAllowLookInMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.ExitToMainMenu
	 * 		Flags  -> ()
	 */
	void ARBMenuPlayerController::ExitToMainMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.ExitToMainMenu");
		
		ARBMenuPlayerController_ExitToMainMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.ExitGame
	 * 		Flags  -> ()
	 */
	void ARBMenuPlayerController::ExitGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.ExitGame");
		
		ARBMenuPlayerController_ExitGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.Client_SetPlayerStatsData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRBStatContext>                      stats                                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FRBUIReleasedCharacterDetails>       releasedCharacterDetailsList                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::Client_SetPlayerStatsData(TArray<struct FRBStatContext> stats, TArray<struct FRBUIReleasedCharacterDetails> releasedCharacterDetailsList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.Client_SetPlayerStatsData");
		
		ARBMenuPlayerController_Client_SetPlayerStatsData_Params params {};
		params.stats = stats;
		params.releasedCharacterDetailsList = releasedCharacterDetailsList;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.Client_PartyMemberPlayerSlotsReservationProcessed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FProfileId>                          members                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bAccepted                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::Client_PartyMemberPlayerSlotsReservationProcessed(TArray<struct FProfileId> members, bool bAccepted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.Client_PartyMemberPlayerSlotsReservationProcessed");
		
		ARBMenuPlayerController_Client_PartyMemberPlayerSlotsReservationProcessed_Params params {};
		params.members = members;
		params.bAccepted = bAccepted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuPlayerController.Client_KickedFromServer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        errorCauseMessage                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            errorFacility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ErrorCode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMenuPlayerController::Client_KickedFromServer(const class FText& Message, const class FText& errorCauseMessage, int32_t errorFacility, int32_t ErrorCode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuPlayerController.Client_KickedFromServer");
		
		ARBMenuPlayerController_Client_KickedFromServer_Params params {};
		params.Message = Message;
		params.errorCauseMessage = errorCauseMessage;
		params.errorFacility = errorFacility;
		params.ErrorCode = ErrorCode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBMenuPlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBMenuPlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuPlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.ViewPrevPlayer
	 * 		Flags  -> ()
	 */
	void ARBController::ViewPrevPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.ViewPrevPlayer");
		
		ARBController_ViewPrevPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.ViewNextPlayer
	 * 		Flags  -> ()
	 */
	void ARBController::ViewNextPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.ViewNextPlayer");
		
		ARBController_ViewNextPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.TryShowCharacterSheet
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bAllowPlayerInteracting                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBController::TryShowCharacterSheet(bool bAllowPlayerInteracting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.TryShowCharacterSheet");
		
		ARBController_TryShowCharacterSheet_Params params {};
		params.bAllowPlayerInteracting = bAllowPlayerInteracting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.TravelToLobby
	 * 		Flags  -> ()
	 */
	void ARBController::TravelToLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.TravelToLobby");
		
		ARBController_TravelToLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.StartTransitionFeedback_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              TransitionDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::StartTransitionFeedback_Server(float TransitionDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.StartTransitionFeedback_Server");
		
		ARBController_StartTransitionFeedback_Server_Params params {};
		params.TransitionDuration = TransitionDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.SetForceHideObjectiveIcons
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::SetForceHideObjectiveIcons(bool InBool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.SetForceHideObjectiveIcons");
		
		ARBController_SetForceHideObjectiveIcons_Params params {};
		params.InBool = InBool;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_VoiceChat_VoiceChatActiveStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewVoiceChatActive                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_VoiceChat_VoiceChatActiveStateChanged(bool bNewVoiceChatActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_VoiceChat_VoiceChatActiveStateChanged");
		
		ARBController_Server_VoiceChat_VoiceChatActiveStateChanged_Params params {};
		params.bNewVoiceChatActive = bNewVoiceChatActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_VoiceChat_RequestLoginToken
	 * 		Flags  -> ()
	 */
	void ARBController::Server_VoiceChat_RequestLoginToken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_VoiceChat_RequestLoginToken");
		
		ARBController_Server_VoiceChat_RequestLoginToken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_VoiceChat_RequestEchoChannelToken
	 * 		Flags  -> ()
	 */
	void ARBController::Server_VoiceChat_RequestEchoChannelToken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_VoiceChat_RequestEchoChannelToken");
		
		ARBController_Server_VoiceChat_RequestEchoChannelToken_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_VoiceChat_RequestChannelToken
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProfileId                                  ProfileId                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_VoiceChat_RequestChannelToken(const struct FProfileId& ProfileId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_VoiceChat_RequestChannelToken");
		
		ARBController_Server_VoiceChat_RequestChannelToken_Params params {};
		params.ProfileId = ProfileId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_UpdatePlayerLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBPlayerLoadout                            loadout                                                    (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_UpdatePlayerLoadout(const struct FRBPlayerLoadout& loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_UpdatePlayerLoadout");
		
		ARBController_Server_UpdatePlayerLoadout_Params params {};
		params.loadout = loadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_SpectatorCyclePlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNext                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_SpectatorCyclePlayer(bool bNext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_SpectatorCyclePlayer");
		
		ARBController_Server_SpectatorCyclePlayer_Params params {};
		params.bNext = bNext;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_SetWorldPopulatingDone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bbWorldPopulatingDone                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_SetWorldPopulatingDone(bool bbWorldPopulatingDone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_SetWorldPopulatingDone");
		
		ARBController_Server_SetWorldPopulatingDone_Params params {};
		params.bbWorldPopulatingDone = bbWorldPopulatingDone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_SetTemporarySpectatorMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSpectate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_SetTemporarySpectatorMode(bool bSpectate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_SetTemporarySpectatorMode");
		
		ARBController_Server_SetTemporarySpectatorMode_Params params {};
		params.bSpectate = bSpectate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_SetStreamingTargetStateReached
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bStreamingTargetStateReached                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_SetStreamingTargetStateReached(bool bStreamingTargetStateReached)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_SetStreamingTargetStateReached");
		
		ARBController_Server_SetStreamingTargetStateReached_Params params {};
		params.bStreamingTargetStateReached = bStreamingTargetStateReached;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_SetStreamingStable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bStreamingStable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_SetStreamingStable(bool bStreamingStable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_SetStreamingStable");
		
		ARBController_Server_SetStreamingStable_Params params {};
		params.bStreamingStable = bStreamingStable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_SetStreamingReadyToCommit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bStreamingReadyToCommit                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_SetStreamingReadyToCommit(bool bStreamingReadyToCommit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_SetStreamingReadyToCommit");
		
		ARBController_Server_SetStreamingReadyToCommit_Params params {};
		params.bStreamingReadyToCommit = bStreamingReadyToCommit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_SetReadyForStageReset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bReadyForStageReset                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_SetReadyForStageReset(bool bReadyForStageReset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_SetReadyForStageReset");
		
		ARBController_Server_SetReadyForStageReset_Params params {};
		params.bReadyForStageReset = bReadyForStageReset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_SetProcessId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		uint32_t                                           ProcessId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_SetProcessId(uint32_t ProcessId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_SetProcessId");
		
		ARBController_Server_SetProcessId_Params params {};
		params.ProcessId = ProcessId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_SetNoConnectionTimeout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               noTimeout                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_SetNoConnectionTimeout(bool noTimeout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_SetNoConnectionTimeout");
		
		ARBController_Server_SetNoConnectionTimeout_Params params {};
		params.noTimeout = noTimeout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_SetNewPlayerCustomizationOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsFemale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class URBPlayerCustomizationOption*>        newCustomizationOptions                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        newHairColor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBCustomizationOutfit*                      LegendaryOutfit                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBVoiceCustomizationOption*                 VoiceOption                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBPlayerIconCustomizationOption*            PlayerIconOption                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_SetNewPlayerCustomizationOptions(bool bIsFemale, TArray<class URBPlayerCustomizationOption*> newCustomizationOptions, const class FName& newHairColor, class URBCustomizationOutfit* LegendaryOutfit, class URBVoiceCustomizationOption* VoiceOption, class URBPlayerIconCustomizationOption* PlayerIconOption)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_SetNewPlayerCustomizationOptions");
		
		ARBController_Server_SetNewPlayerCustomizationOptions_Params params {};
		params.bIsFemale = bIsFemale;
		params.newCustomizationOptions = newCustomizationOptions;
		params.newHairColor = newHairColor;
		params.LegendaryOutfit = LegendaryOutfit;
		params.VoiceOption = VoiceOption;
		params.PlayerIconOption = PlayerIconOption;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_SetIsRunningFunctionalTest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_SetIsRunningFunctionalTest(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_SetIsRunningFunctionalTest");
		
		ARBController_Server_SetIsRunningFunctionalTest_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_SetGameDownloadCompleted
	 * 		Flags  -> ()
	 */
	void ARBController::Server_SetGameDownloadCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_SetGameDownloadCompleted");
		
		ARBController_Server_SetGameDownloadCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_SetClientInitData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bVoiceChatEnabled                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FRegionLatency>                      RegionLatency                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_SetClientInitData(bool bVoiceChatEnabled, TArray<struct FRegionLatency> RegionLatency)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_SetClientInitData");
		
		ARBController_Server_SetClientInitData_Params params {};
		params.bVoiceChatEnabled = bVoiceChatEnabled;
		params.RegionLatency = RegionLatency;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_RequestBugItData
	 * 		Flags  -> ()
	 */
	void ARBController::Server_RequestBugItData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_RequestBugItData");
		
		ARBController_Server_RequestBugItData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_ReportLobbyFound
	 * 		Flags  -> ()
	 */
	void ARBController::Server_ReportLobbyFound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_ReportLobbyFound");
		
		ARBController_Server_ReportLobbyFound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_RandomizeCustomization
	 * 		Flags  -> ()
	 */
	void ARBController::Server_RandomizeCustomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_RandomizeCustomization");
		
		ARBController_Server_RandomizeCustomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_QuickTest
	 * 		Flags  -> ()
	 */
	void ARBController::Server_QuickTest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_QuickTest");
		
		ARBController_Server_QuickTest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_PurchaseOutfit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ItemId                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_PurchaseOutfit(const class FName& ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_PurchaseOutfit");
		
		ARBController_Server_PurchaseOutfit_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_PurchaseItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        itemOnlineUnlockId                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayerCustomizationRarity                         Rarity                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_PurchaseItem(const class FName& itemOnlineUnlockId, EPlayerCustomizationRarity Rarity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_PurchaseItem");
		
		ARBController_Server_PurchaseItem_Params params {};
		params.itemOnlineUnlockId = itemOnlineUnlockId;
		params.Rarity = Rarity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_PurchasedMurkoffPoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Quantity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_PurchasedMurkoffPoints(int32_t Quantity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_PurchasedMurkoffPoints");
		
		ARBController_Server_PurchasedMurkoffPoints_Params params {};
		params.Quantity = Quantity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_OnCreditsDone
	 * 		Flags  -> ()
	 */
	void ARBController::Server_OnCreditsDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_OnCreditsDone");
		
		ARBController_Server_OnCreditsDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Multicast_Command
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ServerMulticastCommand                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Multicast_Command(const class FString& ServerMulticastCommand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Multicast_Command");
		
		ARBController_Server_Multicast_Command_Params params {};
		params.ServerMulticastCommand = ServerMulticastCommand;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_LogStreamingDebug
	 * 		Flags  -> ()
	 */
	void ARBController::Server_LogStreamingDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_LogStreamingDebug");
		
		ARBController_Server_LogStreamingDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_KillFakePlayers
	 * 		Flags  -> ()
	 */
	void ARBController::Server_KillFakePlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_KillFakePlayers");
		
		ARBController_Server_KillFakePlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_GhostPawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bGhost                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     camLoc                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    camRot                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_GhostPawn(bool bGhost, const struct FVector& camLoc, const struct FRotator& camRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_GhostPawn");
		
		ARBController_Server_GhostPawn_Params params {};
		params.bGhost = bGhost;
		params.camLoc = camLoc;
		params.camRot = camRot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_EquipOutfit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBCustomizationOutfit*                      Outfit                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_EquipOutfit(class URBCustomizationOutfit* Outfit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_EquipOutfit");
		
		ARBController_Server_EquipOutfit_Params params {};
		params.Outfit = Outfit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_DumpRecentServerLog
	 * 		Flags  -> ()
	 */
	void ARBController::Server_DumpRecentServerLog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_DumpRecentServerLog");
		
		ARBController_Server_DumpRecentServerLog_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_DumpGameEventLog
	 * 		Flags  -> ()
	 */
	void ARBController::Server_DumpGameEventLog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_DumpGameEventLog");
		
		ARBController_Server_DumpGameEventLog_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_DumpAILog
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxEvents                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_DumpAILog(class ARBNPC* NPC, int32_t maxEvents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_DumpAILog");
		
		ARBController_Server_DumpAILog_Params params {};
		params.NPC = NPC;
		params.maxEvents = maxEvents;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cmd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      ServerCmd                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cmd(const class FString& ServerCmd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cmd");
		
		ARBController_Server_Cmd_Params params {};
		params.ServerCmd = ServerCmd;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_ClearGameEventLog
	 * 		Flags  -> ()
	 */
	void ARBController::Server_ClearGameEventLog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_ClearGameEventLog");
		
		ARBController_Server_ClearGameEventLog_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_ClaimBadgeReward
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        BadgeId                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_ClaimBadgeReward(const class FName& BadgeId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_ClaimBadgeReward");
		
		ARBController_Server_ClaimBadgeReward_Params params {};
		params.BadgeId = BadgeId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_CheatTeleportAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     targetLoc                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    targetRot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_CheatTeleportAtLocation(const struct FVector& targetLoc, const struct FRotator& targetRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_CheatTeleportAtLocation");
		
		ARBController_Server_CheatTeleportAtLocation_Params params {};
		params.targetLoc = targetLoc;
		params.targetRot = targetRot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_CheatSpawnRandomPouncers
	 * 		Flags  -> ()
	 */
	void ARBController::Server_CheatSpawnRandomPouncers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_CheatSpawnRandomPouncers");
		
		ARBController_Server_CheatSpawnRandomPouncers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_CheatSpawnPouncersInHidingSpot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBHidespotComponent*                        hidingSpot                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_CheatSpawnPouncersInHidingSpot(class URBHidespotComponent* hidingSpot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_CheatSpawnPouncersInHidingSpot");
		
		ARBController_Server_CheatSpawnPouncersInHidingSpot_Params params {};
		params.hidingSpot = hidingSpot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_CheatSpawnBot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     spawnLoc                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    spawnRot                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FString                                      cheatName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_CheatSpawnBot(const struct FVector& spawnLoc, const struct FRotator& spawnRot, const class FString& cheatName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_CheatSpawnBot");
		
		ARBController_Server_CheatSpawnBot_Params params {};
		params.spawnLoc = spawnLoc;
		params.spawnRot = spawnRot;
		params.cheatName = cheatName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_CheatSpawnAIFollow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     spawnLoc                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    spawnRot                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FString                                      cheatName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_CheatSpawnAIFollow(const struct FVector& spawnLoc, const struct FRotator& spawnRot, const class FString& cheatName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_CheatSpawnAIFollow");
		
		ARBController_Server_CheatSpawnAIFollow_Params params {};
		params.spawnLoc = spawnLoc;
		params.spawnRot = spawnRot;
		params.cheatName = cheatName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_CheatSendXPEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerEvent                                       EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_CheatSendXPEvent(EPlayerEvent EventType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_CheatSendXPEvent");
		
		ARBController_Server_CheatSendXPEvent_Params params {};
		params.EventType = EventType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_CheatRespawnDeadPlayers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Force                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_CheatRespawnDeadPlayers(bool Force)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_CheatRespawnDeadPlayers");
		
		ARBController_Server_CheatRespawnDeadPlayers_Params params {};
		params.Force = Force;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_CheatRespawnAllPlayers
	 * 		Flags  -> ()
	 */
	void ARBController::Server_CheatRespawnAllPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_CheatRespawnAllPlayers");
		
		ARBController_Server_CheatRespawnAllPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_CheatReshuffleNPCs
	 * 		Flags  -> ()
	 */
	void ARBController::Server_CheatReshuffleNPCs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_CheatReshuffleNPCs");
		
		ARBController_Server_CheatReshuffleNPCs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_CheatDestroyOtherNPC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_CheatDestroyOtherNPC(class ARBNPC* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_CheatDestroyOtherNPC");
		
		ARBController_Server_CheatDestroyOtherNPC_Params params {};
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_CheatDestroyNPC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_CheatDestroyNPC(class ARBNPC* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_CheatDestroyNPC");
		
		ARBController_Server_CheatDestroyNPC_Params params {};
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_CheatDestroyAllNPCs
	 * 		Flags  -> ()
	 */
	void ARBController::Server_CheatDestroyAllNPCs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_CheatDestroyAllNPCs");
		
		ARBController_Server_CheatDestroyAllNPCs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_UpdateStatistic
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerStat                                        PlayerStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_UpdateStatistic(EPlayerStat PlayerStat, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_UpdateStatistic");
		
		ARBController_Server_Cheat_UpdateStatistic_Params params {};
		params.PlayerStat = PlayerStat;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_UnlockAllTrials
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_UnlockAllTrials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_UnlockAllTrials");
		
		ARBController_Server_Cheat_UnlockAllTrials_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_TurnInTasks
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_TurnInTasks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_TurnInTasks");
		
		ARBController_Server_Cheat_TurnInTasks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ToggleVariator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_ToggleVariator(const class FName& ID, bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ToggleVariator");
		
		ARBController_Server_Cheat_ToggleVariator_Params params {};
		params.ID = ID;
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ToggleRespawnDeadPlayerInStage
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ToggleRespawnDeadPlayerInStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ToggleRespawnDeadPlayerInStage");
		
		ARBController_Server_Cheat_ToggleRespawnDeadPlayerInStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ToggleResetStageWhenAllPlayersDead
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ToggleResetStageWhenAllPlayersDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ToggleResetStageWhenAllPlayersDead");
		
		ARBController_Server_Cheat_ToggleResetStageWhenAllPlayersDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ToggleInfiniteLives
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ToggleInfiniteLives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ToggleInfiniteLives");
		
		ARBController_Server_Cheat_ToggleInfiniteLives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ToggleDeadRepsulsion
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ToggleDeadRepsulsion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ToggleDeadRepsulsion");
		
		ARBController_Server_Cheat_ToggleDeadRepsulsion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ToggleAll
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Query                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bStateA                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_ToggleAll(const class FString& Query, bool bStateA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ToggleAll");
		
		ARBController_Server_Cheat_ToggleAll_Params params {};
		params.Query = Query;
		params.bStateA = bStateA;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_TeleportToSASExit
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_TeleportToSASExit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_TeleportToSASExit");
		
		ARBController_Server_Cheat_TeleportToSASExit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_TeleportToEndOfStage
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_TeleportToEndOfStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_TeleportToEndOfStage");
		
		ARBController_Server_Cheat_TeleportToEndOfStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_StopPsychosis
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_StopPsychosis()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_StopPsychosis");
		
		ARBController_Server_Cheat_StopPsychosis_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_StartStageEnding
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_StartStageEnding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_StartStageEnding");
		
		ARBController_Server_Cheat_StartStageEnding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_StartPsychosisSpook
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_StartPsychosisSpook()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_StartPsychosisSpook");
		
		ARBController_Server_Cheat_StartPsychosisSpook_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_StartPsychosis
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_StartPsychosis()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_StartPsychosis");
		
		ARBController_Server_Cheat_StartPsychosis_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_StartObjectiveCoordinator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_StartObjectiveCoordinator(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_StartObjectiveCoordinator");
		
		ARBController_Server_Cheat_StartObjectiveCoordinator_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_StartExperiment
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_StartExperiment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_StartExperiment");
		
		ARBController_Server_Cheat_StartExperiment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_StartEndOfStageDamage
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_StartEndOfStageDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_StartEndOfStageDamage");
		
		ARBController_Server_Cheat_StartEndOfStageDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SpawnLargePickup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SpawnLargePickup(class UClass* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SpawnLargePickup");
		
		ARBController_Server_Cheat_SpawnLargePickup_Params params {};
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SpawnInteractingPlayer
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_SpawnInteractingPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SpawnInteractingPlayer");
		
		ARBController_Server_Cheat_SpawnInteractingPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SpawnDownedPlayer
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_SpawnDownedPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SpawnDownedPlayer");
		
		ARBController_Server_Cheat_SpawnDownedPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SpawnDeadPlayer
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_SpawnDeadPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SpawnDeadPlayer");
		
		ARBController_Server_Cheat_SpawnDeadPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ShowEndOfStageScreen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_ShowEndOfStageScreen(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ShowEndOfStageScreen");
		
		ARBController_Server_Cheat_ShowEndOfStageScreen_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetTrialCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetTrialCompleted(const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetTrialCompleted");
		
		ARBController_Server_Cheat_SetTrialCompleted_Params params {};
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetSoloMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSoloMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetSoloMode(bool bSoloMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetSoloMode");
		
		ARBController_Server_Cheat_SetSoloMode_Params params {};
		params.bSoloMode = bSoloMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetServerAnimTickOptimsEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetServerAnimTickOptimsEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetServerAnimTickOptimsEnabled");
		
		ARBController_Server_Cheat_SetServerAnimTickOptimsEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetPlayerLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBPlayerLoadout                            loadout                                                    (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetPlayerLoadout(const struct FRBPlayerLoadout& loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetPlayerLoadout");
		
		ARBController_Server_Cheat_SetPlayerLoadout_Params params {};
		params.loadout = loadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetNPCToDebug
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetNPCToDebug(class ARBPawn* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetNPCToDebug");
		
		ARBController_Server_Cheat_SetNPCToDebug_Params params {};
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetMaxReservedPlayerSlotsOverride
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            maxReservedPlayerSlotsOverride                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetMaxReservedPlayerSlotsOverride(int32_t maxReservedPlayerSlotsOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetMaxReservedPlayerSlotsOverride");
		
		ARBController_Server_Cheat_SetMaxReservedPlayerSlotsOverride_Params params {};
		params.maxReservedPlayerSlotsOverride = maxReservedPlayerSlotsOverride;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetLevelSeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		uint32_t                                           Seed                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetLevelSeed(uint32_t Seed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetLevelSeed");
		
		ARBController_Server_Cheat_SetLevelSeed_Params params {};
		params.Seed = Seed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetInfiniteThrowables
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInfinite                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetInfiniteThrowables(bool bInfinite)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetInfiniteThrowables");
		
		ARBController_Server_Cheat_SetInfiniteThrowables_Params params {};
		params.bInfinite = bInfinite;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetInfiniteActiveSkills
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInfinite                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetInfiniteActiveSkills(bool bInfinite)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetInfiniteActiveSkills");
		
		ARBController_Server_Cheat_SetInfiniteActiveSkills_Params params {};
		params.bInfinite = bInfinite;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetForcedSASVariatorIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetForcedSASVariatorIndex(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetForcedSASVariatorIndex");
		
		ARBController_Server_Cheat_SetForcedSASVariatorIndex_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetForcedRollingGateVariatorIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetForcedRollingGateVariatorIndex(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetForcedRollingGateVariatorIndex");
		
		ARBController_Server_Cheat_SetForcedRollingGateVariatorIndex_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetFeatureSwitchOverrides
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRBFeatureSwitchOverride>            FeatureSwitchOverrides                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetFeatureSwitchOverrides(TArray<struct FRBFeatureSwitchOverride> FeatureSwitchOverrides)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetFeatureSwitchOverrides");
		
		ARBController_Server_Cheat_SetFeatureSwitchOverrides_Params params {};
		params.FeatureSwitchOverrides = FeatureSwitchOverrides;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetDebugFailedAdjustment
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewDebugFailedAdjustment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetDebugFailedAdjustment(bool bNewDebugFailedAdjustment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetDebugFailedAdjustment");
		
		ARBController_Server_Cheat_SetDebugFailedAdjustment_Params params {};
		params.bNewDebugFailedAdjustment = bNewDebugFailedAdjustment;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetCharacterLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Level                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetCharacterLevel(int32_t Level)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetCharacterLevel");
		
		ARBController_Server_Cheat_SetCharacterLevel_Params params {};
		params.Level = Level;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetCharacterIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        iconId                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetCharacterIcon(const class FName& iconId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetCharacterIcon");
		
		ARBController_Server_Cheat_SetCharacterIcon_Params params {};
		params.iconId = iconId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetAlwaysKeepConsumables
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetAlwaysKeepConsumables(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetAlwaysKeepConsumables");
		
		ARBController_Server_Cheat_SetAlwaysKeepConsumables_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetActiveUpgrades
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FName>                                coreUpgrades                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EActiveSkillType                                   ActiveSkillType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                activeSkillUpgrades                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                Perks                                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetActiveUpgrades(TArray<class FName> coreUpgrades, EActiveSkillType ActiveSkillType, TArray<class FName> activeSkillUpgrades, TArray<class FName> Perks)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetActiveUpgrades");
		
		ARBController_Server_Cheat_SetActiveUpgrades_Params params {};
		params.coreUpgrades = coreUpgrades;
		params.ActiveSkillType = ActiveSkillType;
		params.activeSkillUpgrades = activeSkillUpgrades;
		params.Perks = Perks;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_SetActiveSkill
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActiveSkillType                                   skillType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_SetActiveSkill(EActiveSkillType skillType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_SetActiveSkill");
		
		ARBController_Server_Cheat_SetActiveSkill_Params params {};
		params.skillType = skillType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ReturnToLobby
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ReturnToLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ReturnToLobby");
		
		ARBController_Server_Cheat_ReturnToLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_RestartExperiment
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_RestartExperiment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_RestartExperiment");
		
		ARBController_Server_Cheat_RestartExperiment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ResetWorldState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		uint32_t                                           RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_ResetWorldState(uint32_t RandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ResetWorldState");
		
		ARBController_Server_Cheat_ResetWorldState_Params params {};
		params.RandomSeed = RandomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ResetStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		uint32_t                                           RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_ResetStage(uint32_t RandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ResetStage");
		
		ARBController_Server_Cheat_ResetStage_Params params {};
		params.RandomSeed = RandomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ResetLoadouts
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ResetLoadouts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ResetLoadouts");
		
		ARBController_Server_Cheat_ResetLoadouts_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ResetCharacterProgression
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ResetCharacterProgression()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ResetCharacterProgression");
		
		ARBController_Server_Cheat_ResetCharacterProgression_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ResetAccountProgression
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ResetAccountProgression()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ResetAccountProgression");
		
		ARBController_Server_Cheat_ResetAccountProgression_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_RequestEvalCorridorDebugInfo
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_RequestEvalCorridorDebugInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_RequestEvalCorridorDebugInfo");
		
		ARBController_Server_Cheat_RequestEvalCorridorDebugInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_MakeNoise
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_MakeNoise()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_MakeNoise");
		
		ARBController_Server_Cheat_MakeNoise_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_Kick
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_Kick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_Kick");
		
		ARBController_Server_Cheat_Kick_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_keOnActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_keOnActor(class AActor* Actor, const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_keOnActor");
		
		ARBController_Server_Cheat_keOnActor_Params params {};
		params.Actor = Actor;
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_GetRich
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_GetRich()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_GetRich");
		
		ARBController_Server_Cheat_GetRich_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_GetGoodCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Level                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_GetGoodCharacter(int32_t Level)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_GetGoodCharacter");
		
		ARBController_Server_Cheat_GetGoodCharacter_Params params {};
		params.Level = Level;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ForceUseClientOnlyLevels
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ForceUseClientOnlyLevels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ForceUseClientOnlyLevels");
		
		ARBController_Server_Cheat_ForceUseClientOnlyLevels_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ForceUseAllTraps
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ForceUseAllTraps()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ForceUseAllTraps");
		
		ARBController_Server_Cheat_ForceUseAllTraps_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ForceUseAllRewardRooms
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ForceUseAllRewardRooms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ForceUseAllRewardRooms");
		
		ARBController_Server_Cheat_ForceUseAllRewardRooms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ForceUseAllPuzzleRooms
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ForceUseAllPuzzleRooms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ForceUseAllPuzzleRooms");
		
		ARBController_Server_Cheat_ForceUseAllPuzzleRooms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ForceUseAllObjectiveActors
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ForceUseAllObjectiveActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ForceUseAllObjectiveActors");
		
		ARBController_Server_Cheat_ForceUseAllObjectiveActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ForceSnapToStateToAllActors
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ForceSnapToStateToAllActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ForceSnapToStateToAllActors");
		
		ARBController_Server_Cheat_ForceSnapToStateToAllActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ForceSitInSASChair
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ForceSitInSASChair()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ForceSitInSASChair");
		
		ARBController_Server_Cheat_ForceSitInSASChair_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ForceRandomState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Query                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bStateA                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_ForceRandomState(const class FString& Query, bool bStateA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ForceRandomState");
		
		ARBController_Server_Cheat_ForceRandomState_Params params {};
		params.Query = Query;
		params.bStateA = bStateA;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ForcePreLoginError
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Error                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_ForcePreLoginError(const class FString& Error, int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ForcePreLoginError");
		
		ARBController_Server_Cheat_ForcePreLoginError_Params params {};
		params.Error = Error;
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ForceMovementDesynch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              desyncSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_ForceMovementDesynch(float desyncSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ForceMovementDesynch");
		
		ARBController_Server_Cheat_ForceMovementDesynch_Params params {};
		params.desyncSize = desyncSize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ForceDeath
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ForceDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ForceDeath");
		
		ARBController_Server_Cheat_ForceDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_FailStage
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_FailStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_FailStage");
		
		ARBController_Server_Cheat_FailStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_EndExperiment
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_EndExperiment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_EndExperiment");
		
		ARBController_Server_Cheat_EndExperiment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_DisableStageEnding
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_DisableStageEnding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_DisableStageEnding");
		
		ARBController_Server_Cheat_DisableStageEnding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_DebugTalkWheel
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_DebugTalkWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_DebugTalkWheel");
		
		ARBController_Server_Cheat_DebugTalkWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_DebugJumpScare
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_DebugJumpScare()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_DebugJumpScare");
		
		ARBController_Server_Cheat_DebugJumpScare_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_DebugInventory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_DebugInventory(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_DebugInventory");
		
		ARBController_Server_Cheat_DebugInventory_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_DebugGameMode
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_DebugGameMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_DebugGameMode");
		
		ARBController_Server_Cheat_DebugGameMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_DebugDrawInteractionBox
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_DebugDrawInteractionBox()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_DebugDrawInteractionBox");
		
		ARBController_Server_Cheat_DebugDrawInteractionBox_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_DebugDoorRepulsion
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSlam                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_DebugDoorRepulsion(bool bSlam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_DebugDoorRepulsion");
		
		ARBController_Server_Cheat_DebugDoorRepulsion_Params params {};
		params.bSlam = bSlam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_DebugAlertedStance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            debugOption                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_DebugAlertedStance(int32_t debugOption)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_DebugAlertedStance");
		
		ARBController_Server_Cheat_DebugAlertedStance_Params params {};
		params.debugOption = debugOption;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_CompleteTasks
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_CompleteTasks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_CompleteTasks");
		
		ARBController_Server_Cheat_CompleteTasks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_CompleteStage
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_CompleteStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_CompleteStage");
		
		ARBController_Server_Cheat_CompleteStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_CompleteObjectiveCoordinator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_CompleteObjectiveCoordinator(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_CompleteObjectiveCoordinator");
		
		ARBController_Server_Cheat_CompleteObjectiveCoordinator_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_CompleteMainObjectivesTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_CompleteMainObjectivesTo(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_CompleteMainObjectivesTo");
		
		ARBController_Server_Cheat_CompleteMainObjectivesTo_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_CompleteMainObjectivesInStage
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_CompleteMainObjectivesInStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_CompleteMainObjectivesInStage");
		
		ARBController_Server_Cheat_CompleteMainObjectivesInStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_CompleteCurrentObjectiveCoordinators
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_CompleteCurrentObjectiveCoordinators()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_CompleteCurrentObjectiveCoordinators");
		
		ARBController_Server_Cheat_CompleteCurrentObjectiveCoordinators_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ClearTasks
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ClearTasks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ClearTasks");
		
		ARBController_Server_Cheat_ClearTasks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ClearRandomState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Query                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_ClearRandomState(const class FString& Query)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ClearRandomState");
		
		ARBController_Server_Cheat_ClearRandomState_Params params {};
		params.Query = Query;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ClearProgressivePsychosis
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ClearProgressivePsychosis()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ClearProgressivePsychosis");
		
		ARBController_Server_Cheat_ClearProgressivePsychosis_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AddXp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_AddXp(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AddXp");
		
		ARBController_Server_Cheat_AddXp_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AddTQ
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_AddTQ(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AddTQ");
		
		ARBController_Server_Cheat_AddTQ_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AddTask
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        taskId                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_AddTask(const class FName& taskId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AddTask");
		
		ARBController_Server_Cheat_AddTask_Params params {};
		params.taskId = taskId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AddStageXp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_AddStageXp(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AddStageXp");
		
		ARBController_Server_Cheat_AddStageXp_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AddSelfRevive
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_AddSelfRevive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AddSelfRevive");
		
		ARBController_Server_Cheat_AddSelfRevive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AddProgressivePsychosis
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGas                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_AddProgressivePsychosis(int32_t amount, bool bGas)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AddProgressivePsychosis");
		
		ARBController_Server_Cheat_AddProgressivePsychosis_Params params {};
		params.amount = amount;
		params.bGas = bGas;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AddOnlineItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        onlineItemId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsPersistentItem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_AddOnlineItem(const class FName& onlineItemId, bool bIsPersistentItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AddOnlineItem");
		
		ARBController_Server_Cheat_AddOnlineItem_Params params {};
		params.onlineItemId = onlineItemId;
		params.bIsPersistentItem = bIsPersistentItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AddMurkoffPoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_AddMurkoffPoints(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AddMurkoffPoints");
		
		ARBController_Server_Cheat_AddMurkoffPoints_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AddMurkoffDollars
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_AddMurkoffDollars(int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AddMurkoffDollars");
		
		ARBController_Server_Cheat_AddMurkoffDollars_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AddItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_AddItem(class UClass* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AddItem");
		
		ARBController_Server_Cheat_AddItem_Params params {};
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AddCurrency
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECurrencyType                                      currencyType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_AddCurrency(ECurrencyType currencyType, int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AddCurrency");
		
		ARBController_Server_Cheat_AddCurrency_Params params {};
		params.currencyType = currencyType;
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_ActivateAllMines
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_ActivateAllMines()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_ActivateAllMines");
		
		ARBController_Server_Cheat_ActivateAllMines_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AcquireRewardPoolItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        RewardPoolId                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_AcquireRewardPoolItem(const class FName& RewardPoolId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AcquireRewardPoolItem");
		
		ARBController_Server_Cheat_AcquireRewardPoolItem_Params params {};
		params.RewardPoolId = RewardPoolId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AcquireFullRewardPool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        RewardPoolId                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_AcquireFullRewardPool(const class FName& RewardPoolId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AcquireFullRewardPool");
		
		ARBController_Server_Cheat_AcquireFullRewardPool_Params params {};
		params.RewardPoolId = RewardPoolId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AcquireBadge
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        BadgeId                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Server_Cheat_AcquireBadge(const class FName& BadgeId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AcquireBadge");
		
		ARBController_Server_Cheat_AcquireBadge_Params params {};
		params.BadgeId = BadgeId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AcquireAllDocuments
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_AcquireAllDocuments()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AcquireAllDocuments");
		
		ARBController_Server_Cheat_AcquireAllDocuments_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AcquireAllCustomization
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_AcquireAllCustomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AcquireAllCustomization");
		
		ARBController_Server_Cheat_AcquireAllCustomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Server_Cheat_AcquireAllCellCustomization
	 * 		Flags  -> ()
	 */
	void ARBController::Server_Cheat_AcquireAllCellCustomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Server_Cheat_AcquireAllCellCustomization");
		
		ARBController_Server_Cheat_AcquireAllCellCustomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.OnRep_RBSpectatorPawn
	 * 		Flags  -> ()
	 */
	void ARBController::OnRep_RBSpectatorPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.OnRep_RBSpectatorPawn");
		
		ARBController_OnRep_RBSpectatorPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.OnRep_bSpectator
	 * 		Flags  -> ()
	 */
	void ARBController::OnRep_bSpectator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.OnRep_bSpectator");
		
		ARBController_OnRep_bSpectator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.OnPlayerLeftGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::OnPlayerLeftGame(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.OnPlayerLeftGame");
		
		ARBController_OnPlayerLeftGame_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.OnPlayerJoinedGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::OnPlayerJoinedGame(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.OnPlayerJoinedGame");
		
		ARBController_OnPlayerJoinedGame_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.OnPlayerInsideCameraCustomizationChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   RBPlayer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::OnPlayerInsideCameraCustomizationChanged(class ARBPlayer* RBPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.OnPlayerInsideCameraCustomizationChanged");
		
		ARBController_OnPlayerInsideCameraCustomizationChanged_Params params {};
		params.RBPlayer = RBPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.OnPlayerInsideActiveSkillChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBActiveSkill*                              activeSkillActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::OnPlayerInsideActiveSkillChanged(class ARBActiveSkill* activeSkillActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.OnPlayerInsideActiveSkillChanged");
		
		ARBController_OnPlayerInsideActiveSkillChanged_Params params {};
		params.activeSkillActor = activeSkillActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.OnGamePhaseUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGamePhase                                         gamePhase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::OnGamePhaseUpdated(EGamePhase gamePhase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.OnGamePhaseUpdated");
		
		ARBController_OnGamePhaseUpdated_Params params {};
		params.gamePhase = gamePhase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Multicast_StartTransitionFeedback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              TransitionDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Multicast_StartTransitionFeedback(float TransitionDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Multicast_StartTransitionFeedback");
		
		ARBController_Multicast_StartTransitionFeedback_Params params {};
		params.TransitionDuration = TransitionDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Multicast_SetNoConnectionTimeout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               noTimeout                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Multicast_SetNoConnectionTimeout(bool noTimeout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Multicast_SetNoConnectionTimeout");
		
		ARBController_Multicast_SetNoConnectionTimeout_Params params {};
		params.noTimeout = noTimeout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Multicast_NotifyEndOfStage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FEndStageInfo                               endOfStageInfo                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowEndOfMatchScreen                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Multicast_NotifyEndOfStage(const struct FEndStageInfo& endOfStageInfo, bool bShowEndOfMatchScreen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Multicast_NotifyEndOfStage");
		
		ARBController_Multicast_NotifyEndOfStage_Params params {};
		params.endOfStageInfo = endOfStageInfo;
		params.bShowEndOfMatchScreen = bShowEndOfMatchScreen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Multicast_LogStreamingDebug
	 * 		Flags  -> ()
	 */
	void ARBController::Multicast_LogStreamingDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Multicast_LogStreamingDebug");
		
		ARBController_Multicast_LogStreamingDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Multicast_Cheat_ForceSnapToStateToAllActors
	 * 		Flags  -> ()
	 */
	void ARBController::Multicast_Cheat_ForceSnapToStateToAllActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Multicast_Cheat_ForceSnapToStateToAllActors");
		
		ARBController_Multicast_Cheat_ForceSnapToStateToAllActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Multicast_Cheat_DebugTalkWheel
	 * 		Flags  -> ()
	 */
	void ARBController::Multicast_Cheat_DebugTalkWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Multicast_Cheat_DebugTalkWheel");
		
		ARBController_Multicast_Cheat_DebugTalkWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.IsPlaytestMode
	 * 		Flags  -> ()
	 */
	bool ARBController::IsPlaytestMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.IsPlaytestMode");
		
		ARBController_IsPlaytestMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_VoiceChat_SetLoginToken
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Token                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_VoiceChat_SetLoginToken(const class FString& Token)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_VoiceChat_SetLoginToken");
		
		ARBController_Client_VoiceChat_SetLoginToken_Params params {};
		params.Token = Token;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_VoiceChat_SetEchoChannelToken
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Token                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_VoiceChat_SetEchoChannelToken(const class FString& Token)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_VoiceChat_SetEchoChannelToken");
		
		ARBController_Client_VoiceChat_SetEchoChannelToken_Params params {};
		params.Token = Token;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_VoiceChat_SetChannelToken
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProfileId                                  ProfileId                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Token                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_VoiceChat_SetChannelToken(const struct FProfileId& ProfileId, const class FString& Token)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_VoiceChat_SetChannelToken");
		
		ARBController_Client_VoiceChat_SetChannelToken_Params params {};
		params.ProfileId = ProfileId;
		params.Token = Token;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_TryTravelToLobby
	 * 		Flags  -> ()
	 */
	void ARBController::Client_TryTravelToLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_TryTravelToLobby");
		
		ARBController_Client_TryTravelToLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_TriggerGlobalAudioAnnouncement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               announcementEvent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_TriggerGlobalAudioAnnouncement(class UAkAudioEvent* announcementEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_TriggerGlobalAudioAnnouncement");
		
		ARBController_Client_TriggerGlobalAudioAnnouncement_Params params {};
		params.announcementEvent = announcementEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_TravelToLobby
	 * 		Flags  -> ()
	 */
	void ARBController::Client_TravelToLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_TravelToLobby");
		
		ARBController_Client_TravelToLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_ShowGameMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        objectiveText                                              (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_ShowGameMessage(const class FText& objectiveText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_ShowGameMessage");
		
		ARBController_Client_ShowGameMessage_Params params {};
		params.objectiveText = objectiveText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_SetIgnoreMoveInput
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewMoveInput                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_SetIgnoreMoveInput(bool bNewMoveInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_SetIgnoreMoveInput");
		
		ARBController_Client_SetIgnoreMoveInput_Params params {};
		params.bNewMoveInput = bNewMoveInput;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_SetIgnoreLookInput
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewMoveInput                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_SetIgnoreLookInput(bool bNewMoveInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_SetIgnoreLookInput");
		
		ARBController_Client_SetIgnoreLookInput_Params params {};
		params.bNewMoveInput = bNewMoveInput;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_ServerMsg
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      serverMsg                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisplayOnScreen                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_ServerMsg(const class FString& serverMsg, bool bDisplayOnScreen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_ServerMsg");
		
		ARBController_Client_ServerMsg_Params params {};
		params.serverMsg = serverMsg;
		params.bDisplayOnScreen = bDisplayOnScreen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_ServerError
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      serverError                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisplayOnScreen                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_ServerError(const class FString& serverError, bool bDisplayOnScreen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_ServerError");
		
		ARBController_Client_ServerError_Params params {};
		params.serverError = serverError;
		params.bDisplayOnScreen = bDisplayOnScreen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_ReturningToLobby
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      TicketId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      MatchmakingConfigurationName                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FProfileId>                          groupMembers                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_ReturningToLobby(const class FString& TicketId, const class FString& MatchmakingConfigurationName, TArray<struct FProfileId> groupMembers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_ReturningToLobby");
		
		ARBController_Client_ReturningToLobby_Params params {};
		params.TicketId = TicketId;
		params.MatchmakingConfigurationName = MatchmakingConfigurationName;
		params.groupMembers = groupMembers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_ResolvePendingOrders
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<int64_t>                                    pendingOrderIds                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_ResolvePendingOrders(TArray<int64_t> pendingOrderIds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_ResolvePendingOrders");
		
		ARBController_Client_ResolvePendingOrders_Params params {};
		params.pendingOrderIds = pendingOrderIds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_PostAudioEventOnGroup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        GroupName                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_PostAudioEventOnGroup(class UAkAudioEvent* akEvent, const class FName& GroupName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_PostAudioEventOnGroup");
		
		ARBController_Client_PostAudioEventOnGroup_Params params {};
		params.akEvent = akEvent;
		params.GroupName = GroupName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_PostAssociatedAKEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkComponent*                                AkComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_PostAssociatedAKEvent(class UAkComponent* AkComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_PostAssociatedAKEvent");
		
		ARBController_Client_PostAssociatedAKEvent_Params params {};
		params.AkComponent = AkComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_PostAkEventOnActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_PostAkEventOnActor(class AActor* Actor, class UAkAudioEvent* akEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_PostAkEventOnActor");
		
		ARBController_Client_PostAkEventOnActor_Params params {};
		params.Actor = Actor;
		params.akEvent = akEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_PostAkEventGlobal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_PostAkEventGlobal(class UAkAudioEvent* akEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_PostAkEventGlobal");
		
		ARBController_Client_PostAkEventGlobal_Params params {};
		params.akEvent = akEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_PostAkEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkComponent*                                AkComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_PostAkEvent(class UAkComponent* AkComponent, class UAkAudioEvent* akEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_PostAkEvent");
		
		ARBController_Client_PostAkEvent_Params params {};
		params.AkComponent = AkComponent;
		params.akEvent = akEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_PlayVOOnWatch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_PlayVOOnWatch(class UAkAudioEvent* akEvent, uint32_t RandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_PlayVOOnWatch");
		
		ARBController_Client_PlayVOOnWatch_Params params {};
		params.akEvent = akEvent;
		params.RandomSeed = RandomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_PlayVOOnNarrator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVOPriority                                        VOPriority                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_PlayVOOnNarrator(class UAkAudioEvent* akEvent, EVOPriority VOPriority, uint32_t RandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_PlayVOOnNarrator");
		
		ARBController_Client_PlayVOOnNarrator_Params params {};
		params.akEvent = akEvent;
		params.VOPriority = VOPriority;
		params.RandomSeed = RandomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_PlayVOOnActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      voOwner                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVOPriority                                        VOPriority                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayOnPlayersWatch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_PlayVOOnActor(class UAkAudioEvent* akEvent, class AActor* voOwner, EVOPriority VOPriority, uint32_t RandomSeed, bool bPlayOnPlayersWatch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_PlayVOOnActor");
		
		ARBController_Client_PlayVOOnActor_Params params {};
		params.akEvent = akEvent;
		params.voOwner = voOwner;
		params.VOPriority = VOPriority;
		params.RandomSeed = RandomSeed;
		params.bPlayOnPlayersWatch = bPlayOnPlayersWatch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_PlaySingleShotMusicTrack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               musicTrack                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPauseLevelMusic                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_PlaySingleShotMusicTrack(class UAkAudioEvent* musicTrack, bool bPauseLevelMusic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_PlaySingleShotMusicTrack");
		
		ARBController_Client_PlaySingleShotMusicTrack_Params params {};
		params.musicTrack = musicTrack;
		params.bPauseLevelMusic = bPauseLevelMusic;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_OnPlayerScoringEventRecorded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerEvent                                       EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        RuleId                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            scoreValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            xpValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_OnPlayerScoringEventRecorded(EPlayerEvent EventType, const class FName& RuleId, int32_t scoreValue, int32_t xpValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_OnPlayerScoringEventRecorded");
		
		ARBController_Client_OnPlayerScoringEventRecorded_Params params {};
		params.EventType = EventType;
		params.RuleId = RuleId;
		params.scoreValue = scoreValue;
		params.xpValue = xpValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_LeaveSpectatorMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bRestartingPlayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_LeaveSpectatorMode(bool bRestartingPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_LeaveSpectatorMode");
		
		ARBController_Client_LeaveSpectatorMode_Params params {};
		params.bRestartingPlayer = bRestartingPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_KeepAlive
	 * 		Flags  -> ()
	 */
	void ARBController::Client_KeepAlive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_KeepAlive");
		
		ARBController_Client_KeepAlive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_HideTutorial
	 * 		Flags  -> ()
	 */
	void ARBController::Client_HideTutorial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_HideTutorial");
		
		ARBController_Client_HideTutorial_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_FinishBugItData
	 * 		Flags  -> ()
	 */
	void ARBController::Client_FinishBugItData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_FinishBugItData");
		
		ARBController_Client_FinishBugItData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_EnterSpectatorMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESpectatorMode                                     Mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_EnterSpectatorMode(ESpectatorMode Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_EnterSpectatorMode");
		
		ARBController_Client_EnterSpectatorMode_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_DumpRecentServerLog
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      serverLog                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_DumpRecentServerLog(const class FString& serverLog)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_DumpRecentServerLog");
		
		ARBController_Client_DumpRecentServerLog_Params params {};
		params.serverLog = serverLog;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_DumpGameEventLog
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FGameEvent>                          EventLog                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_DumpGameEventLog(TArray<struct FGameEvent> EventLog)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_DumpGameEventLog");
		
		ARBController_Client_DumpGameEventLog_Params params {};
		params.EventLog = EventLog;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_DumpAILog
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      BotName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FAIEventLogItem>                     EventLog                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_DumpAILog(const class FString& BotName, TArray<struct FAIEventLogItem> EventLog)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_DumpAILog");
		
		ARBController_Client_DumpAILog_Params params {};
		params.BotName = BotName;
		params.EventLog = EventLog;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_Cheat_DebugCorridorDebugInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBEvalCorridorDebugInfo                    serverDebugInfo                                            (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_Cheat_DebugCorridorDebugInfo(const struct FRBEvalCorridorDebugInfo& serverDebugInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_Cheat_DebugCorridorDebugInfo");
		
		ARBController_Client_Cheat_DebugCorridorDebugInfo_Params params {};
		params.serverDebugInfo = serverDebugInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_BadgeAcquired
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        BadgeId                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_BadgeAcquired(const class FName& BadgeId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_BadgeAcquired");
		
		ARBController_Client_BadgeAcquired_Params params {};
		params.BadgeId = BadgeId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_AddHudMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        MessageId                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        Text                                                       (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EMessagePriority                                   Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EGameMessageCategory                               GameMessageCategory                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_AddHudMessage(const class FName& MessageId, const class FText& Text, EMessagePriority Priority, float duration, EGameMessageCategory GameMessageCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_AddHudMessage");
		
		ARBController_Client_AddHudMessage_Params params {};
		params.MessageId = MessageId;
		params.Text = Text;
		params.Priority = Priority;
		params.duration = duration;
		params.GameMessageCategory = GameMessageCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.Client_ActivateVFX
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::Client_ActivateVFX(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.Client_ActivateVFX");
		
		ARBController_Client_ActivateVFX_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.CanTravelToLobby
	 * 		Flags  -> ()
	 */
	bool ARBController::CanTravelToLobby()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.CanTravelToLobby");
		
		ARBController_CanTravelToLobby_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.BP_GetRBSpectatedPawn
	 * 		Flags  -> ()
	 */
	class ARBPlayer* ARBController::BP_GetRBSpectatedPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.BP_GetRBSpectatedPawn");
		
		ARBController_BP_GetRBSpectatedPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.BP_GetPlayerViewPoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     out_location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    out_Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBController::BP_GetPlayerViewPoint(struct FVector* out_location, struct FRotator* out_Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.BP_GetPlayerViewPoint");
		
		ARBController_BP_GetPlayerViewPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (out_location != nullptr)
			*out_location = params.out_location;
		if (out_Rotation != nullptr)
			*out_Rotation = params.out_Rotation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.BP_Cheat_SetActiveSkill
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActiveSkillType                                   skillType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::BP_Cheat_SetActiveSkill(EActiveSkillType skillType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.BP_Cheat_SetActiveSkill");
		
		ARBController_BP_Cheat_SetActiveSkill_Params params {};
		params.skillType = skillType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.BP_Cheat_AddOnlineItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        onlineItemId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsPersistentItem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBController::BP_Cheat_AddOnlineItem(const class FName& onlineItemId, bool bIsPersistentItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.BP_Cheat_AddOnlineItem");
		
		ARBController_BP_Cheat_AddOnlineItem_Params params {};
		params.onlineItemId = onlineItemId;
		params.bIsPersistentItem = bIsPersistentItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBController.BP_CanSpectatorRespawn
	 * 		Flags  -> ()
	 */
	bool ARBController::BP_CanSpectatorRespawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBController.BP_CanSpectatorRespawn");
		
		ARBController_BP_CanSpectatorRespawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBConveyorBelt.StopFollowingActors_Server
	 * 		Flags  -> ()
	 */
	void ARBConveyorBelt::StopFollowingActors_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBConveyorBelt.StopFollowingActors_Server");
		
		ARBConveyorBelt_StopFollowingActors_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBConveyorBelt.StartFollowingActors_Server
	 * 		Flags  -> ()
	 */
	void ARBConveyorBelt::StartFollowingActors_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBConveyorBelt.StartFollowingActors_Server");
		
		ARBConveyorBelt_StartFollowingActors_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBConveyorBelt.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBConveyorBelt::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBConveyorBelt");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBConveyorDropZone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBConveyorDropZone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBConveyorDropZone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBConveyorDropZoneInteractionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBConveyorDropZoneInteractionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBConveyorDropZoneInteractionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingActor.OnRep_CurrentSplineComp
	 * 		Flags  -> ()
	 */
	void ARBSplineFollowingActor::OnRep_CurrentSplineComp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingActor.OnRep_CurrentSplineComp");
		
		ARBSplineFollowingActor_OnRep_CurrentSplineComp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingActor.OnNetworkSyncPlayStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBNetworkSyncComponent*                     networkSyncComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSplineFollowingActor::OnNetworkSyncPlayStateChanged(class URBNetworkSyncComponent* networkSyncComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingActor.OnNetworkSyncPlayStateChanged");
		
		ARBSplineFollowingActor_OnNetworkSyncPlayStateChanged_Params params {};
		params.networkSyncComponent = networkSyncComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingActor.FindDefaultSplineComponent
	 * 		Flags  -> ()
	 */
	class USplineComponent* ARBSplineFollowingActor::FindDefaultSplineComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingActor.FindDefaultSplineComponent");
		
		ARBSplineFollowingActor_FindDefaultSplineComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingActor.BP_SetCurrentSplineComp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USplineComponent*                            newSplineComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSplineFollowingActor::BP_SetCurrentSplineComp(class USplineComponent* newSplineComp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingActor.BP_SetCurrentSplineComp");
		
		ARBSplineFollowingActor_BP_SetCurrentSplineComp_Params params {};
		params.newSplineComp = newSplineComp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingActor.BP_OnStoppedMoving
	 * 		Flags  -> ()
	 */
	void ARBSplineFollowingActor::BP_OnStoppedMoving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingActor.BP_OnStoppedMoving");
		
		ARBSplineFollowingActor_BP_OnStoppedMoving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingActor.BP_OnStartedMoving
	 * 		Flags  -> ()
	 */
	void ARBSplineFollowingActor::BP_OnStartedMoving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingActor.BP_OnStartedMoving");
		
		ARBSplineFollowingActor_BP_OnStartedMoving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingActor.BP_OnPingPongExtremityEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              progress                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSplineFollowingActor::BP_OnPingPongExtremityEvent(float progress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingActor.BP_OnPingPongExtremityEvent");
		
		ARBSplineFollowingActor_BP_OnPingPongExtremityEvent_Params params {};
		params.progress = progress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingActor.BP_OnCurrentSplineCompChanged
	 * 		Flags  -> ()
	 */
	void ARBSplineFollowingActor::BP_OnCurrentSplineCompChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingActor.BP_OnCurrentSplineCompChanged");
		
		ARBSplineFollowingActor_BP_OnCurrentSplineCompChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingActor.BP_ForceRefreshTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bRefreshTickState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSplineFollowingActor::BP_ForceRefreshTransform(bool bRefreshTickState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingActor.BP_ForceRefreshTransform");
		
		ARBSplineFollowingActor_BP_ForceRefreshTransform_Params params {};
		params.bRefreshTickState = bRefreshTickState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSplineFollowingActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSplineFollowingActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSplineFollowingActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBConveyorFollowingActor.RefreshSplineData_Server
	 * 		Flags  -> ()
	 */
	void ARBConveyorFollowingActor::RefreshSplineData_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBConveyorFollowingActor.RefreshSplineData_Server");
		
		ARBConveyorFollowingActor_RefreshSplineData_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBConveyorFollowingActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBConveyorFollowingActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBConveyorFollowingActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.OnRep_UsedLargeObjectRefs
	 * 		Flags  -> ()
	 */
	void URBLargeObjectInteractionPanelComponent::OnRep_UsedLargeObjectRefs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.OnRep_UsedLargeObjectRefs");
		
		URBLargeObjectInteractionPanelComponent_OnRep_UsedLargeObjectRefs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.OnRep_NumberOfCompletedInteractions
	 * 		Flags  -> ()
	 */
	void URBLargeObjectInteractionPanelComponent::OnRep_NumberOfCompletedInteractions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.OnRep_NumberOfCompletedInteractions");
		
		URBLargeObjectInteractionPanelComponent_OnRep_NumberOfCompletedInteractions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.OnRep_InteractionTimeStartedPawnTimestamp
	 * 		Flags  -> ()
	 */
	void URBLargeObjectInteractionPanelComponent::OnRep_InteractionTimeStartedPawnTimestamp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.OnRep_InteractionTimeStartedPawnTimestamp");
		
		URBLargeObjectInteractionPanelComponent_OnRep_InteractionTimeStartedPawnTimestamp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.OnRep_AccumulatedInteractionTime
	 * 		Flags  -> ()
	 */
	void URBLargeObjectInteractionPanelComponent::OnRep_AccumulatedInteractionTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.OnRep_AccumulatedInteractionTime");
		
		URBLargeObjectInteractionPanelComponent_OnRep_AccumulatedInteractionTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.OnNumberOfCompletedInteractionsChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLargeObjectInteractionPanelComponent::OnNumberOfCompletedInteractionsChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.OnNumberOfCompletedInteractionsChangedCallback");
		
		URBLargeObjectInteractionPanelComponent_OnNumberOfCompletedInteractionsChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.OnInteractionTimeStartedPawnTimestampChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLargeObjectInteractionPanelComponent::OnInteractionTimeStartedPawnTimestampChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.OnInteractionTimeStartedPawnTimestampChangedCallback");
		
		URBLargeObjectInteractionPanelComponent_OnInteractionTimeStartedPawnTimestampChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.OnAccumulatedInteractionTimeChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLargeObjectInteractionPanelComponent::OnAccumulatedInteractionTimeChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.OnAccumulatedInteractionTimeChangedCallback");
		
		URBLargeObjectInteractionPanelComponent_OnAccumulatedInteractionTimeChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.IsCompleted
	 * 		Flags  -> ()
	 */
	bool URBLargeObjectInteractionPanelComponent::IsCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.IsCompleted");
		
		URBLargeObjectInteractionPanelComponent_IsCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.GetSpecialMoveAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsFirstPerson                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimSequence* URBLargeObjectInteractionPanelComponent::GetSpecialMoveAnimation(class ARBPawn* Pawn, bool bIsFirstPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.GetSpecialMoveAnimation");
		
		URBLargeObjectInteractionPanelComponent_GetSpecialMoveAnimation_Params params {};
		params.Pawn = Pawn;
		params.bIsFirstPerson = bIsFirstPerson;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.GetProgressRatio
	 * 		Flags  -> ()
	 */
	float URBLargeObjectInteractionPanelComponent::GetProgressRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.GetProgressRatio");
		
		URBLargeObjectInteractionPanelComponent_GetProgressRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.GetLargeObjectRef
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLargePickup*                              pickup                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USceneComponent* URBLargeObjectInteractionPanelComponent::GetLargeObjectRef(class ARBLargePickup* pickup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.GetLargeObjectRef");
		
		URBLargeObjectInteractionPanelComponent_GetLargeObjectRef_Params params {};
		params.pickup = pickup;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.GetInteractionDuration
	 * 		Flags  -> ()
	 */
	float URBLargeObjectInteractionPanelComponent::GetInteractionDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.GetInteractionDuration");
		
		URBLargeObjectInteractionPanelComponent_GetInteractionDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.Event_OnTossIntoFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLargePickup*                              largeObject                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLargeObjectInteractionPanelComponent::Event_OnTossIntoFinished(class ARBLargePickup* largeObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.Event_OnTossIntoFinished");
		
		URBLargeObjectInteractionPanelComponent_Event_OnTossIntoFinished_Params params {};
		params.largeObject = largeObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.Event_OnNumberOfCompletedInteractionsChanged
	 * 		Flags  -> ()
	 */
	void URBLargeObjectInteractionPanelComponent::Event_OnNumberOfCompletedInteractionsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.Event_OnNumberOfCompletedInteractionsChanged");
		
		URBLargeObjectInteractionPanelComponent_Event_OnNumberOfCompletedInteractionsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.Event_OnLargeObjectDoAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLargePickup*                              largeObject                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLargeObjectInteractionPanelComponent::Event_OnLargeObjectDoAction(class ARBLargePickup* largeObject, class ARBPawn* interactor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.Event_OnLargeObjectDoAction");
		
		URBLargeObjectInteractionPanelComponent_Event_OnLargeObjectDoAction_Params params {};
		params.largeObject = largeObject;
		params.interactor = interactor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeObjectInteractionPanelComponent.Event_OnAccumulatedInteractionTimeChanged
	 * 		Flags  -> ()
	 */
	void URBLargeObjectInteractionPanelComponent::Event_OnAccumulatedInteractionTimeChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeObjectInteractionPanelComponent.Event_OnAccumulatedInteractionTimeChanged");
		
		URBLargeObjectInteractionPanelComponent_Event_OnAccumulatedInteractionTimeChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLargeObjectInteractionPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLargeObjectInteractionPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLargeObjectInteractionPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBConveyorLargePanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBConveyorLargePanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBConveyorLargePanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableComponent.GetOperatorStopAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstPerson                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimSequence* URBOperatableComponent::GetOperatorStopAnimation(class ARBPawn* Pawn, bool bFirstPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableComponent.GetOperatorStopAnimation");
		
		URBOperatableComponent_GetOperatorStopAnimation_Params params {};
		params.Pawn = Pawn;
		params.bFirstPerson = bFirstPerson;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableComponent.GetOperatorStartAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstPerson                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimSequence* URBOperatableComponent::GetOperatorStartAnimation(class ARBPawn* Pawn, bool bFirstPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableComponent.GetOperatorStartAnimation");
		
		URBOperatableComponent_GetOperatorStartAnimation_Params params {};
		params.Pawn = Pawn;
		params.bFirstPerson = bFirstPerson;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableComponent.GetOperatorLoopAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstPerson                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimSequence* URBOperatableComponent::GetOperatorLoopAnimation(class ARBPawn* Pawn, bool bFirstPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableComponent.GetOperatorLoopAnimation");
		
		URBOperatableComponent_GetOperatorLoopAnimation_Params params {};
		params.Pawn = Pawn;
		params.bFirstPerson = bFirstPerson;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableComponent.GetOperateTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform URBOperatableComponent::GetOperateTransform(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableComponent.GetOperateTransform");
		
		URBOperatableComponent_GetOperateTransform_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableComponent.CanOperate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBOperatableComponent::CanOperate(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableComponent.CanOperate");
		
		URBOperatableComponent_CanOperate_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBOperatableComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBOperatableComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBOperatableComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCoopOperatableComponent.ShouldActivateDelayedRelease
	 * 		Flags  -> ()
	 */
	bool URBCoopOperatableComponent::ShouldActivateDelayedRelease()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCoopOperatableComponent.ShouldActivateDelayedRelease");
		
		URBCoopOperatableComponent_ShouldActivateDelayedRelease_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCoopOperatableComponent.SetLinkedCoopOperatableComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBCoopOperatableComponent*                  cmp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCoopOperatableComponent::SetLinkedCoopOperatableComponent(class URBCoopOperatableComponent* cmp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCoopOperatableComponent.SetLinkedCoopOperatableComponent");
		
		URBCoopOperatableComponent_SetLinkedCoopOperatableComponent_Params params {};
		params.cmp = cmp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCoopOperatableComponent.OnRep_DelayedReleaseButtonServerTimestamp
	 * 		Flags  -> ()
	 */
	void URBCoopOperatableComponent::OnRep_DelayedReleaseButtonServerTimestamp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCoopOperatableComponent.OnRep_DelayedReleaseButtonServerTimestamp");
		
		URBCoopOperatableComponent_OnRep_DelayedReleaseButtonServerTimestamp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCoopOperatableComponent.OnRep_CoopOperatableActive
	 * 		Flags  -> ()
	 */
	void URBCoopOperatableComponent::OnRep_CoopOperatableActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCoopOperatableComponent.OnRep_CoopOperatableActive");
		
		URBCoopOperatableComponent_OnRep_CoopOperatableActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCoopOperatableComponent.OnCoopOperatableActiveChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCoopOperatableComponent::OnCoopOperatableActiveChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCoopOperatableComponent.OnCoopOperatableActiveChangedCallback");
		
		URBCoopOperatableComponent_OnCoopOperatableActiveChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCoopOperatableComponent.GetLinkedCoopOperatableComponent
	 * 		Flags  -> ()
	 */
	class URBCoopOperatableComponent* URBCoopOperatableComponent::GetLinkedCoopOperatableComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCoopOperatableComponent.GetLinkedCoopOperatableComponent");
		
		URBCoopOperatableComponent_GetLinkedCoopOperatableComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCoopOperatableComponent.GetDelayedReleaseTimeLeftRatio
	 * 		Flags  -> ()
	 */
	float URBCoopOperatableComponent::GetDelayedReleaseTimeLeftRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCoopOperatableComponent.GetDelayedReleaseTimeLeftRatio");
		
		URBCoopOperatableComponent_GetDelayedReleaseTimeLeftRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCoopOperatableComponent.GetDelayedReleaseTimeLeft
	 * 		Flags  -> ()
	 */
	float URBCoopOperatableComponent::GetDelayedReleaseTimeLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCoopOperatableComponent.GetDelayedReleaseTimeLeft");
		
		URBCoopOperatableComponent_GetDelayedReleaseTimeLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCoopOperatableComponent.Event_OnCoopOperatableActiveStateChanged
	 * 		Flags  -> ()
	 */
	void URBCoopOperatableComponent::Event_OnCoopOperatableActiveStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCoopOperatableComponent.Event_OnCoopOperatableActiveStateChanged");
		
		URBCoopOperatableComponent_Event_OnCoopOperatableActiveStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCoopOperatableComponent.Event_DelayedReleaseButtonServerTimestampChanged
	 * 		Flags  -> ()
	 */
	void URBCoopOperatableComponent::Event_DelayedReleaseButtonServerTimestampChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCoopOperatableComponent.Event_DelayedReleaseButtonServerTimestampChanged");
		
		URBCoopOperatableComponent_Event_DelayedReleaseButtonServerTimestampChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCoopOperatableComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCoopOperatableComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCoopOperatableComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUseQuestItemsObjectiveCoordinator.OnRep_QuestItemRuntimeInfos
	 * 		Flags  -> ()
	 */
	void ARBUseQuestItemsObjectiveCoordinator::OnRep_QuestItemRuntimeInfos()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUseQuestItemsObjectiveCoordinator.OnRep_QuestItemRuntimeInfos");
		
		ARBUseQuestItemsObjectiveCoordinator_OnRep_QuestItemRuntimeInfos_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUseQuestItemsObjectiveCoordinator.OnQuestItemPickedUp_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPickup*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBUseQuestItemsObjectiveCoordinator::OnQuestItemPickedUp_Server(class ARBPawn* Pawn, class ARBPickup* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUseQuestItemsObjectiveCoordinator.OnQuestItemPickedUp_Server");
		
		ARBUseQuestItemsObjectiveCoordinator_OnQuestItemPickedUp_Server_Params params {};
		params.Pawn = Pawn;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUseQuestItemsObjectiveCoordinator.OnQuestItemDropped_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPickup*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBUseQuestItemsObjectiveCoordinator::OnQuestItemDropped_Server(class ARBPawn* Pawn, class ARBPickup* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUseQuestItemsObjectiveCoordinator.OnQuestItemDropped_Server");
		
		ARBUseQuestItemsObjectiveCoordinator_OnQuestItemDropped_Server_Params params {};
		params.Pawn = Pawn;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPlayerStoppedOperating
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBOperatable*                               operatable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBUseQuestItemsObjectiveCoordinator::OnPlayerStoppedOperating(class ARBPawn* Pawn, class ARBOperatable* operatable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPlayerStoppedOperating");
		
		ARBUseQuestItemsObjectiveCoordinator_OnPlayerStoppedOperating_Params params {};
		params.Pawn = Pawn;
		params.operatable = operatable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPlayerDoAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBInteractibleComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBUseQuestItemsObjectiveCoordinator::OnPlayerDoAction(class ARBPawn* Player, class URBInteractibleComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPlayerDoAction");
		
		ARBUseQuestItemsObjectiveCoordinator_OnPlayerDoAction_Params params {};
		params.Player = Player;
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPlayerDisconnect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBUseQuestItemsObjectiveCoordinator::OnPlayerDisconnect(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPlayerDisconnect");
		
		ARBUseQuestItemsObjectiveCoordinator_OnPlayerDisconnect_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPawnKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     instigatorActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Subject                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBUseQuestItemsObjectiveCoordinator::OnPawnKilled(class ARBPawn* instigatorActor, class ARBPawn* Subject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPawnKilled");
		
		ARBUseQuestItemsObjectiveCoordinator_OnPawnKilled_Params params {};
		params.instigatorActor = instigatorActor;
		params.Subject = Subject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPanelInteractionCompletedChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBUseQuestItemsObjectiveCoordinator::OnPanelInteractionCompletedChanged(class URBInteractiblePanelComponent* panel, class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUseQuestItemsObjectiveCoordinator.OnPanelInteractionCompletedChanged");
		
		ARBUseQuestItemsObjectiveCoordinator_OnPanelInteractionCompletedChanged_Params params {};
		params.panel = panel;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUseQuestItemsObjectiveCoordinator.Event_OnSpawnObjectiveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      spawner                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPickup*                                   newObjectiveItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBUseQuestItemsObjectiveCoordinator::Event_OnSpawnObjectiveItem(class AActor* spawner, class ARBPickup* newObjectiveItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUseQuestItemsObjectiveCoordinator.Event_OnSpawnObjectiveItem");
		
		ARBUseQuestItemsObjectiveCoordinator_Event_OnSpawnObjectiveItem_Params params {};
		params.spawner = spawner;
		params.newObjectiveItem = newObjectiveItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUseQuestItemsObjectiveCoordinator.Event_OnQuestItemRuntimeInfosChanged
	 * 		Flags  -> ()
	 */
	void ARBUseQuestItemsObjectiveCoordinator::Event_OnQuestItemRuntimeInfosChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUseQuestItemsObjectiveCoordinator.Event_OnQuestItemRuntimeInfosChanged");
		
		ARBUseQuestItemsObjectiveCoordinator_Event_OnQuestItemRuntimeInfosChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBUseQuestItemsObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBUseQuestItemsObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBUseQuestItemsObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCorpseSearchObjectiveCoordinator.OnEmptyCorpseInteractionDone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     pawnInteracting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCorpseSearchObjectiveCoordinator::OnEmptyCorpseInteractionDone(class URBInteractiblePanelComponent* panel, class ARBPawn* pawnInteracting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCorpseSearchObjectiveCoordinator.OnEmptyCorpseInteractionDone");
		
		ARBCorpseSearchObjectiveCoordinator_OnEmptyCorpseInteractionDone_Params params {};
		params.panel = panel;
		params.pawnInteracting = pawnInteracting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCorpseSearchObjectiveCoordinator.OnCorpseClueDiscovered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPlayerInvestigationZoneComponent*         InvestigationComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCorpseSearchObjectiveCoordinator::OnCorpseClueDiscovered(class URBPlayerInvestigationZoneComponent* InvestigationComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCorpseSearchObjectiveCoordinator.OnCorpseClueDiscovered");
		
		ARBCorpseSearchObjectiveCoordinator_OnCorpseClueDiscovered_Params params {};
		params.InvestigationComponent = InvestigationComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCorpseSearchObjectiveCoordinator.OnClueDiscovered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPlayerInvestigationZoneComponent*         InvestigationComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCorpseSearchObjectiveCoordinator::OnClueDiscovered(class URBPlayerInvestigationZoneComponent* InvestigationComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCorpseSearchObjectiveCoordinator.OnClueDiscovered");
		
		ARBCorpseSearchObjectiveCoordinator_OnClueDiscovered_Params params {};
		params.InvestigationComponent = InvestigationComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_OnEmptyCorpseInteractionDone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     RBPawn                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCorpseSearchObjectiveCoordinator::Multicast_OnEmptyCorpseInteractionDone(class ARBPawn* RBPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_OnEmptyCorpseInteractionDone");
		
		ARBCorpseSearchObjectiveCoordinator_Multicast_OnEmptyCorpseInteractionDone_Params params {};
		params.RBPawn = RBPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_KeyPickedUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FClueData                                   ClueData                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstTimePickedUp                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCorpseSearchObjectiveCoordinator::Multicast_KeyPickedUp(const struct FClueData& ClueData, bool bFirstTimePickedUp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_KeyPickedUp");
		
		ARBCorpseSearchObjectiveCoordinator_Multicast_KeyPickedUp_Params params {};
		params.ClueData = ClueData;
		params.bFirstTimePickedUp = bFirstTimePickedUp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_KeyDropped
	 * 		Flags  -> ()
	 */
	void ARBCorpseSearchObjectiveCoordinator::Multicast_KeyDropped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_KeyDropped");
		
		ARBCorpseSearchObjectiveCoordinator_Multicast_KeyDropped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_GateUnlocked
	 * 		Flags  -> ()
	 */
	void ARBCorpseSearchObjectiveCoordinator::Multicast_GateUnlocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_GateUnlocked");
		
		ARBCorpseSearchObjectiveCoordinator_Multicast_GateUnlocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_CorpseClueGathered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPlayerInvestigationZoneComponent*         InvestigationComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCorpseSearchObjectiveCoordinator::Multicast_CorpseClueGathered(class URBPlayerInvestigationZoneComponent* InvestigationComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_CorpseClueGathered");
		
		ARBCorpseSearchObjectiveCoordinator_Multicast_CorpseClueGathered_Params params {};
		params.InvestigationComponent = InvestigationComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_ClueGathered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FClueData                                   ClueData                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBCorpseSearchObjectiveCoordinator::Multicast_ClueGathered(const struct FClueData& ClueData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCorpseSearchObjectiveCoordinator.Multicast_ClueGathered");
		
		ARBCorpseSearchObjectiveCoordinator_Multicast_ClueGathered_Params params {};
		params.ClueData = ClueData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCorpseSearchObjectiveCoordinator.GetClueTextFromClueName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        clueName                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText ARBCorpseSearchObjectiveCoordinator::GetClueTextFromClueName(const class FName& clueName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCorpseSearchObjectiveCoordinator.GetClueTextFromClueName");
		
		ARBCorpseSearchObjectiveCoordinator_GetClueTextFromClueName_Params params {};
		params.clueName = clueName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCorpseSearchObjectiveCoordinator.GetClueObjectiveIconFromClueName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        clueName                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FSlateBrush ARBCorpseSearchObjectiveCoordinator::GetClueObjectiveIconFromClueName(const class FName& clueName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCorpseSearchObjectiveCoordinator.GetClueObjectiveIconFromClueName");
		
		ARBCorpseSearchObjectiveCoordinator_GetClueObjectiveIconFromClueName_Params params {};
		params.clueName = clueName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBCorpseSearchObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBCorpseSearchObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCorpseSearchObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCounterInterface.SetCounter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCounterInterface::SetCounter(int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCounterInterface.SetCounter");
		
		URBCounterInterface_SetCounter_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCounterInterface.GetCounter
	 * 		Flags  -> ()
	 */
	int32_t URBCounterInterface::GetCounter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCounterInterface.GetCounter");
		
		URBCounterInterface_GetCounter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCounterInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCounterInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCounterInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCreditsMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCreditsMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCreditsMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCrouchUnderMarker.SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabledValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCrouchUnderMarker::SetEnabled(bool bEnabledValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCrouchUnderMarker.SetEnabled");
		
		ARBCrouchUnderMarker_SetEnabled_Params params {};
		params.bEnabledValue = bEnabledValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCrouchUnderMarker.SetBlocksNavMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bBlocks                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCrouchUnderMarker::SetBlocksNavMesh(bool bBlocks)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCrouchUnderMarker.SetBlocksNavMesh");
		
		ARBCrouchUnderMarker_SetBlocksNavMesh_Params params {};
		params.bBlocks = bBlocks;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBCrouchUnderMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBCrouchUnderMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCrouchUnderMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCurrencyItem.OnSpectatingPlayerChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBCurrencyItem::OnSpectatingPlayerChanged(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCurrencyItem.OnSpectatingPlayerChanged");
		
		ARBCurrencyItem_OnSpectatingPlayerChanged_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCurrencyItem.OnRep_ProfileIdsInteracted
	 * 		Flags  -> ()
	 */
	void ARBCurrencyItem::OnRep_ProfileIdsInteracted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCurrencyItem.OnRep_ProfileIdsInteracted");
		
		ARBCurrencyItem_OnRep_ProfileIdsInteracted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCurrencyItem.OnClientInitReplicated
	 * 		Flags  -> ()
	 */
	void ARBCurrencyItem::OnClientInitReplicated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCurrencyItem.OnClientInitReplicated");
		
		ARBCurrencyItem_OnClientInitReplicated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBCurrencyItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBCurrencyItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCurrencyItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCurrencyPackMenu.Purchase
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCurrencyPackMenuItem                       Item                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBCurrencyPackMenu::Purchase(const struct FCurrencyPackMenuItem& Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCurrencyPackMenu.Purchase");
		
		URBCurrencyPackMenu_Purchase_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCurrencyPackMenu.IsOperationPending
	 * 		Flags  -> ()
	 */
	bool URBCurrencyPackMenu::IsOperationPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCurrencyPackMenu.IsOperationPending");
		
		URBCurrencyPackMenu_IsOperationPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCurrencyPackMenu.IsDataPending
	 * 		Flags  -> ()
	 */
	bool URBCurrencyPackMenu::IsDataPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCurrencyPackMenu.IsDataPending");
		
		URBCurrencyPackMenu_IsDataPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCurrencyPackMenu.GetCurrencyPackItems
	 * 		Flags  -> ()
	 */
	TArray<struct FCurrencyPackMenuItem> URBCurrencyPackMenu::GetCurrencyPackItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCurrencyPackMenu.GetCurrencyPackItems");
		
		URBCurrencyPackMenu_GetCurrencyPackItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCurrencyPackMenu.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBCurrencyPackMenu::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCurrencyPackMenu.Event_Refresh");
		
		URBCurrencyPackMenu_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCurrencyPackMenu.Event_CompletedPurchase
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCurrencyPackMenuItem                       Item                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBCurrencyPackMenu::Event_CompletedPurchase(const struct FCurrencyPackMenuItem& Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCurrencyPackMenu.Event_CompletedPurchase");
		
		URBCurrencyPackMenu_Event_CompletedPurchase_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCurrencyPackMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCurrencyPackMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCurrencyPackMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomActionAnimInstance.TriggerCustomAction
	 * 		Flags  -> ()
	 */
	void URBCustomActionAnimInstance::TriggerCustomAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomActionAnimInstance.TriggerCustomAction");
		
		URBCustomActionAnimInstance_TriggerCustomAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomActionAnimInstance.CustomActionDone
	 * 		Flags  -> ()
	 */
	void URBCustomActionAnimInstance::CustomActionDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomActionAnimInstance.CustomActionDone");
		
		URBCustomActionAnimInstance_CustomActionDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCustomActionAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCustomActionAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCustomActionAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBCustomizationInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBCustomizationInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCustomizationInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCutsceneMenu.OnInputKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInputEvent                                        EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGamepad                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCutsceneMenu::OnInputKey(const struct FKey& Key, EInputEvent EventType, bool bGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCutsceneMenu.OnInputKey");
		
		URBCutsceneMenu_OnInputKey_Params params {};
		params.Key = Key;
		params.EventType = EventType;
		params.bGamepad = bGamepad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCutsceneMenu.Event_ShowSkipPrompt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldStartHideTimer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBCutsceneMenu::Event_ShowSkipPrompt(bool bShouldStartHideTimer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCutsceneMenu.Event_ShowSkipPrompt");
		
		URBCutsceneMenu_Event_ShowSkipPrompt_Params params {};
		params.bShouldStartHideTimer = bShouldStartHideTimer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCutsceneMenu.Event_EndCutsceneRequested
	 * 		Flags  -> ()
	 */
	void URBCutsceneMenu::Event_EndCutsceneRequested()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCutsceneMenu.Event_EndCutsceneRequested");
		
		URBCutsceneMenu_Event_EndCutsceneRequested_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCutsceneMenu.EndCutscene
	 * 		Flags  -> ()
	 */
	void URBCutsceneMenu::EndCutscene()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCutsceneMenu.EndCutscene");
		
		URBCutsceneMenu_EndCutscene_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCutsceneMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCutsceneMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCutsceneMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageableComponent.OnRep_NumberOfProjectileHit
	 * 		Flags  -> ()
	 */
	void URBDamageableComponent::OnRep_NumberOfProjectileHit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageableComponent.OnRep_NumberOfProjectileHit");
		
		URBDamageableComponent_OnRep_NumberOfProjectileHit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageableComponent.OnRep_NumberOfHits
	 * 		Flags  -> ()
	 */
	void URBDamageableComponent::OnRep_NumberOfHits()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageableComponent.OnRep_NumberOfHits");
		
		URBDamageableComponent_OnRep_NumberOfHits_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageableComponent.OnRep_Durability
	 * 		Flags  -> ()
	 */
	void URBDamageableComponent::OnRep_Durability()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageableComponent.OnRep_Durability");
		
		URBDamageableComponent_OnRep_Durability_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageableComponent.OnRep_CanBeDamaged
	 * 		Flags  -> ()
	 */
	void URBDamageableComponent::OnRep_CanBeDamaged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageableComponent.OnRep_CanBeDamaged");
		
		URBDamageableComponent_OnRep_CanBeDamaged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageableComponent.IsDestroyed
	 * 		Flags  -> ()
	 */
	bool URBDamageableComponent::IsDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageableComponent.IsDestroyed");
		
		URBDamageableComponent_IsDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageableComponent.GetNumberOfHits
	 * 		Flags  -> ()
	 */
	int32_t URBDamageableComponent::GetNumberOfHits()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageableComponent.GetNumberOfHits");
		
		URBDamageableComponent_GetNumberOfHits_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageableComponent.GetMaxDurability
	 * 		Flags  -> ()
	 */
	float URBDamageableComponent::GetMaxDurability()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageableComponent.GetMaxDurability");
		
		URBDamageableComponent_GetMaxDurability_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageableComponent.GetDurability
	 * 		Flags  -> ()
	 */
	float URBDamageableComponent::GetDurability()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageableComponent.GetDurability");
		
		URBDamageableComponent_GetDurability_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageableComponent.CanBeDamaged
	 * 		Flags  -> ()
	 */
	bool URBDamageableComponent::CanBeDamaged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageableComponent.CanBeDamaged");
		
		URBDamageableComponent_CanBeDamaged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageableComponent.BP_SetCanBeDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bCanBeDamagedValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBDamageableComponent::BP_SetCanBeDamaged(bool bCanBeDamagedValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageableComponent.BP_SetCanBeDamaged");
		
		URBDamageableComponent_BP_SetCanBeDamaged_Params params {};
		params.bCanBeDamagedValue = bCanBeDamagedValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageableComponent.BP_GetDurabilityRatio
	 * 		Flags  -> ()
	 */
	float URBDamageableComponent::BP_GetDurabilityRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageableComponent.BP_GetDurabilityRatio");
		
		URBDamageableComponent_BP_GetDurabilityRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBDamageableComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBDamageableComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDamageableComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageBoxComponent.OnRep_IsDamageEnabled
	 * 		Flags  -> ()
	 */
	void URBDamageBoxComponent::OnRep_IsDamageEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageBoxComponent.OnRep_IsDamageEnabled");
		
		URBDamageBoxComponent_OnRep_IsDamageEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageBoxComponent.IsDamageEnabledChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBDamageBoxComponent::IsDamageEnabledChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageBoxComponent.IsDamageEnabledChangedCallback");
		
		URBDamageBoxComponent_IsDamageEnabledChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageBoxComponent.IsDamageEnabled
	 * 		Flags  -> ()
	 */
	bool URBDamageBoxComponent::IsDamageEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageBoxComponent.IsDamageEnabled");
		
		URBDamageBoxComponent_IsDamageEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageBoxComponent.ComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBDamageBoxComponent::ComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageBoxComponent.ComponentBeginOverlap");
		
		URBDamageBoxComponent_ComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDamageBoxComponent.BP_GetHurtingPlayers
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class ARBPlayer*>                           outHurtingPlayers                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void URBDamageBoxComponent::BP_GetHurtingPlayers(TArray<class ARBPlayer*>* outHurtingPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDamageBoxComponent.BP_GetHurtingPlayers");
		
		URBDamageBoxComponent_BP_GetHurtingPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outHurtingPlayers != nullptr)
			*outHurtingPlayers = params.outHurtingPlayers;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBDamageBoxComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBDamageBoxComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDamageBoxComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDarknessVolume.OnRep_CurrentlyEnabled
	 * 		Flags  -> ()
	 */
	void ARBDarknessVolume::OnRep_CurrentlyEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDarknessVolume.OnRep_CurrentlyEnabled");
		
		ARBDarknessVolume_OnRep_CurrentlyEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDarknessVolume.IsEnabled
	 * 		Flags  -> ()
	 */
	bool ARBDarknessVolume::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDarknessVolume.IsEnabled");
		
		ARBDarknessVolume_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDarknessVolume.EndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDarknessVolume::EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDarknessVolume.EndOverlap");
		
		ARBDarknessVolume_EndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDarknessVolume.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabledValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDarknessVolume::BP_SetEnabled(bool bEnabledValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDarknessVolume.BP_SetEnabled");
		
		ARBDarknessVolume_BP_SetEnabled_Params params {};
		params.bEnabledValue = bEnabledValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDarknessVolume.BeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBDarknessVolume::BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDarknessVolume.BeginOverlap");
		
		ARBDarknessVolume_BeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBDarknessVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBDarknessVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDarknessVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBDeadBodyConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBDeadBodyConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDeadBodyConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeadBodySpawnLocationComponent.BP_IsPlayingJumpScareAnim
	 * 		Flags  -> ()
	 */
	bool URBDeadBodySpawnLocationComponent::BP_IsPlayingJumpScareAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeadBodySpawnLocationComponent.BP_IsPlayingJumpScareAnim");
		
		URBDeadBodySpawnLocationComponent_BP_IsPlayingJumpScareAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeadBodySpawnLocationComponent.BP_GetCurrentDeadBodyAnimSequence
	 * 		Flags  -> ()
	 */
	class UAnimSequenceBase* URBDeadBodySpawnLocationComponent::BP_GetCurrentDeadBodyAnimSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeadBodySpawnLocationComponent.BP_GetCurrentDeadBodyAnimSequence");
		
		URBDeadBodySpawnLocationComponent_BP_GetCurrentDeadBodyAnimSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBDeadBodySpawnLocationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBDeadBodySpawnLocationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDeadBodySpawnLocationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeadBodyContainer.SetSkeletalMeshTickEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDeadBodyContainer::SetSkeletalMeshTickEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeadBodyContainer.SetSkeletalMeshTickEnabled");
		
		ARBDeadBodyContainer_SetSkeletalMeshTickEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeadBodyContainer.OnRep_MovedDeadBodySequence
	 * 		Flags  -> ()
	 */
	void ARBDeadBodyContainer::OnRep_MovedDeadBodySequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeadBodyContainer.OnRep_MovedDeadBodySequence");
		
		ARBDeadBodyContainer_OnRep_MovedDeadBodySequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeadBodyContainer.Event_OnNotifyPlayRigSequence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimationAsset*                             AnimToPlay                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDeadBodyContainer::Event_OnNotifyPlayRigSequence(class UAnimationAsset* AnimToPlay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeadBodyContainer.Event_OnNotifyPlayRigSequence");
		
		ARBDeadBodyContainer_Event_OnNotifyPlayRigSequence_Params params {};
		params.AnimToPlay = AnimToPlay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeadBodyContainer.Event_OnMovedDeadBodySequenceChanged
	 * 		Flags  -> ()
	 */
	void ARBDeadBodyContainer::Event_OnMovedDeadBodySequenceChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeadBodyContainer.Event_OnMovedDeadBodySequenceChanged");
		
		ARBDeadBodyContainer_Event_OnMovedDeadBodySequenceChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeadBodyContainer.Event_OnCustomizationChanged
	 * 		Flags  -> ()
	 */
	void ARBDeadBodyContainer::Event_OnCustomizationChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeadBodyContainer.Event_OnCustomizationChanged");
		
		ARBDeadBodyContainer_Event_OnCustomizationChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeadBodyContainer.BP_ApplyRandomCustomization
	 * 		Flags  -> ()
	 */
	void ARBDeadBodyContainer::BP_ApplyRandomCustomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeadBodyContainer.BP_ApplyRandomCustomization");
		
		ARBDeadBodyContainer_BP_ApplyRandomCustomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBDeadBodyContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBDeadBodyContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDeadBodyContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeadRepulsionBoxComponent.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabledValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBDeadRepulsionBoxComponent::BP_SetEnabled(bool bEnabledValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeadRepulsionBoxComponent.BP_SetEnabled");
		
		URBDeadRepulsionBoxComponent_BP_SetEnabled_Params params {};
		params.bEnabledValue = bEnabledValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBDeadRepulsionBoxComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBDeadRepulsionBoxComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDeadRepulsionBoxComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBDelayObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBDelayObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDelayObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeployableSkillItem.OnRep_State
	 * 		Flags  -> ()
	 */
	void ARBDeployableSkillItem::OnRep_State()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeployableSkillItem.OnRep_State");
		
		ARBDeployableSkillItem_OnRep_State_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeployableSkillItem.OnDeployDelayFinished_Server
	 * 		Flags  -> ()
	 */
	void ARBDeployableSkillItem::OnDeployDelayFinished_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeployableSkillItem.OnDeployDelayFinished_Server");
		
		ARBDeployableSkillItem_OnDeployDelayFinished_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeployableSkillItem.OnComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBDeployableSkillItem::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeployableSkillItem.OnComponentBeginOverlap");
		
		ARBDeployableSkillItem_OnComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeployableSkillItem.Multicast_OnDeploy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   deployer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Transform                                                  (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBDeployableSkillItem::Multicast_OnDeploy(class ARBPlayer* deployer, const struct FTransform& Transform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeployableSkillItem.Multicast_OnDeploy");
		
		ARBDeployableSkillItem_Multicast_OnDeploy_Params params {};
		params.deployer = deployer;
		params.Transform = Transform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeployableSkillItem.GetZoneDuration
	 * 		Flags  -> ()
	 */
	float ARBDeployableSkillItem::GetZoneDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeployableSkillItem.GetZoneDuration");
		
		ARBDeployableSkillItem_GetZoneDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeployableSkillItem.GetMinDeployTime
	 * 		Flags  -> ()
	 */
	float ARBDeployableSkillItem::GetMinDeployTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeployableSkillItem.GetMinDeployTime");
		
		ARBDeployableSkillItem_GetMinDeployTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeployableSkillItem.GetImpactRadius
	 * 		Flags  -> ()
	 */
	float ARBDeployableSkillItem::GetImpactRadius()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeployableSkillItem.GetImpactRadius");
		
		ARBDeployableSkillItem_GetImpactRadius_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeployableSkillItem.Event_OnPlaced
	 * 		Flags  -> ()
	 */
	void ARBDeployableSkillItem::Event_OnPlaced()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeployableSkillItem.Event_OnPlaced");
		
		ARBDeployableSkillItem_Event_OnPlaced_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeployableSkillItem.Event_OnExpiredUnactivated
	 * 		Flags  -> ()
	 */
	void ARBDeployableSkillItem::Event_OnExpiredUnactivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeployableSkillItem.Event_OnExpiredUnactivated");
		
		ARBDeployableSkillItem_Event_OnExpiredUnactivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeployableSkillItem.Event_OnDeployed
	 * 		Flags  -> ()
	 */
	void ARBDeployableSkillItem::Event_OnDeployed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeployableSkillItem.Event_OnDeployed");
		
		ARBDeployableSkillItem_Event_OnDeployed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeployableSkillItem.Event_OnActivate
	 * 		Flags  -> ()
	 */
	void ARBDeployableSkillItem::Event_OnActivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeployableSkillItem.Event_OnActivate");
		
		ARBDeployableSkillItem_Event_OnActivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeployableSkillItem.Event_EffectFinished
	 * 		Flags  -> ()
	 */
	void ARBDeployableSkillItem::Event_EffectFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeployableSkillItem.Event_EffectFinished");
		
		ARBDeployableSkillItem_Event_EffectFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDeployableSkillItem.Deploy_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   deployer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Transform                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBDeployableSkillItem::Deploy_Server(class ARBPlayer* deployer, const struct FTransform& Transform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDeployableSkillItem.Deploy_Server");
		
		ARBDeployableSkillItem_Deploy_Server_Params params {};
		params.deployer = deployer;
		params.Transform = Transform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBDeployableSkillItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBDeployableSkillItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDeployableSkillItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHittableActor.OnDamaged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBDamageableComponent*                      damageComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsDestroyed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHittableActor::OnDamaged(class URBDamageableComponent* damageComponent, bool bIsDestroyed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHittableActor.OnDamaged");
		
		ARBHittableActor_OnDamaged_Params params {};
		params.damageComponent = damageComponent;
		params.bIsDestroyed = bIsDestroyed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHittableActor.OnBreak
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBDamageableComponent*                      damageComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHittableActor::OnBreak(class URBDamageableComponent* damageComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHittableActor.OnBreak");
		
		ARBHittableActor_OnBreak_Params params {};
		params.damageComponent = damageComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBHittableActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBHittableActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHittableActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDestructibleActor.BP_DisplaceInSphere
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERadialImpulseFalloff                              Falloff                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDamageSoundMaterial                               DamageSoundMaterial                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDestructibleActor::BP_DisplaceInSphere(const struct FVector& Origin, const struct FVector& Direction, float Radius, float strength, ERadialImpulseFalloff Falloff, EDamageSoundMaterial DamageSoundMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDestructibleActor.BP_DisplaceInSphere");
		
		ARBDestructibleActor_BP_DisplaceInSphere_Params params {};
		params.Origin = Origin;
		params.Direction = Direction;
		params.Radius = Radius;
		params.strength = strength;
		params.Falloff = Falloff;
		params.DamageSoundMaterial = DamageSoundMaterial;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDestructibleActor.BP_BreakInSphere
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERadialImpulseFalloff                              Falloff                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDamageSoundMaterial                               DamageSoundMaterial                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayBreakSound                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDestructibleActor::BP_BreakInSphere(const struct FVector& Origin, const struct FVector& Direction, float Radius, float strength, ERadialImpulseFalloff Falloff, EDamageSoundMaterial DamageSoundMaterial, bool bPlayBreakSound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDestructibleActor.BP_BreakInSphere");
		
		ARBDestructibleActor_BP_BreakInSphere_Params params {};
		params.Origin = Origin;
		params.Direction = Direction;
		params.Radius = Radius;
		params.strength = strength;
		params.Falloff = Falloff;
		params.DamageSoundMaterial = DamageSoundMaterial;
		params.bPlayBreakSound = bPlayBreakSound;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBDestructibleActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBDestructibleActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDestructibleActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDestructibleComponent.WakeComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOneFrame                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBDestructibleComponent::WakeComponent(bool bOneFrame)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDestructibleComponent.WakeComponent");
		
		URBDestructibleComponent_WakeComponent_Params params {};
		params.bOneFrame = bOneFrame;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDestructibleComponent.SnapToState
	 * 		Flags  -> ()
	 */
	void URBDestructibleComponent::SnapToState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDestructibleComponent.SnapToState");
		
		URBDestructibleComponent_SnapToState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDestructibleComponent.ScheduleSleepComponent
	 * 		Flags  -> ()
	 */
	void URBDestructibleComponent::ScheduleSleepComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDestructibleComponent.ScheduleSleepComponent");
		
		URBDestructibleComponent_ScheduleSleepComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDestructibleComponent.OnRep_NumberOfHits
	 * 		Flags  -> ()
	 */
	void URBDestructibleComponent::OnRep_NumberOfHits()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDestructibleComponent.OnRep_NumberOfHits");
		
		URBDestructibleComponent_OnRep_NumberOfHits_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDestructibleComponent.OnRep_InitialTransforms
	 * 		Flags  -> ()
	 */
	void URBDestructibleComponent::OnRep_InitialTransforms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDestructibleComponent.OnRep_InitialTransforms");
		
		URBDestructibleComponent_OnRep_InitialTransforms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDestructibleComponent.OnNumberOfHitsChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBDestructibleComponent::OnNumberOfHitsChanged(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDestructibleComponent.OnNumberOfHitsChanged");
		
		URBDestructibleComponent_OnNumberOfHitsChanged_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDestructibleComponent.BP_Displacement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERadialImpulseFalloff                              Falloff                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBDestructibleComponent::BP_Displacement(const struct FVector& Origin, const struct FVector& Direction, float Radius, float strength, ERadialImpulseFalloff Falloff)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDestructibleComponent.BP_Displacement");
		
		URBDestructibleComponent_BP_Displacement_Params params {};
		params.Origin = Origin;
		params.Direction = Direction;
		params.Radius = Radius;
		params.strength = strength;
		params.Falloff = Falloff;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDestructibleComponent.BP_BreakNearBone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERadialImpulseFalloff                              Falloff                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBDestructibleComponent::BP_BreakNearBone(const class FName& BoneName, const struct FVector& Direction, float Radius, float strength, ERadialImpulseFalloff Falloff)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDestructibleComponent.BP_BreakNearBone");
		
		URBDestructibleComponent_BP_BreakNearBone_Params params {};
		params.BoneName = BoneName;
		params.Direction = Direction;
		params.Radius = Radius;
		params.strength = strength;
		params.Falloff = Falloff;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDestructibleComponent.BP_BreakInSphere
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERadialImpulseFalloff                              Falloff                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBDestructibleComponent::BP_BreakInSphere(const struct FVector& Origin, const struct FVector& Direction, float Radius, float strength, ERadialImpulseFalloff Falloff)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDestructibleComponent.BP_BreakInSphere");
		
		URBDestructibleComponent_BP_BreakInSphere_Params params {};
		params.Origin = Origin;
		params.Direction = Direction;
		params.Radius = Radius;
		params.strength = strength;
		params.Falloff = Falloff;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDestructibleComponent.BP_BreakBones
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FName>                                BoneNames                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBDestructibleComponent::BP_BreakBones(TArray<class FName> BoneNames, const struct FVector& Direction, float strength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDestructibleComponent.BP_BreakBones");
		
		URBDestructibleComponent_BP_BreakBones_Params params {};
		params.BoneNames = BoneNames;
		params.Direction = Direction;
		params.strength = strength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBDestructibleComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBDestructibleComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDestructibleComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBDestructiblePhysicalMaterial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBDestructiblePhysicalMaterial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDestructiblePhysicalMaterial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDestructibleWall.SetActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewActiveValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDestructibleWall::SetActive(bool bNewActiveValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDestructibleWall.SetActive");
		
		ARBDestructibleWall_SetActive_Params params {};
		params.bNewActiveValue = bNewActiveValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBDestructibleWall.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBDestructibleWall::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDestructibleWall");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDisplayMessageZoneComponent.OnRep_CurrentlyEnabled
	 * 		Flags  -> ()
	 */
	void URBDisplayMessageZoneComponent::OnRep_CurrentlyEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDisplayMessageZoneComponent.OnRep_CurrentlyEnabled");
		
		URBDisplayMessageZoneComponent_OnRep_CurrentlyEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDisplayMessageZoneComponent.IsEnabled
	 * 		Flags  -> ()
	 */
	bool URBDisplayMessageZoneComponent::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDisplayMessageZoneComponent.IsEnabled");
		
		URBDisplayMessageZoneComponent_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDisplayMessageZoneComponent.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInteractible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBDisplayMessageZoneComponent::BP_SetEnabled(bool bInteractible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDisplayMessageZoneComponent.BP_SetEnabled");
		
		URBDisplayMessageZoneComponent_BP_SetEnabled_Params params {};
		params.bInteractible = bInteractible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBDisplayMessageZoneComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBDisplayMessageZoneComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDisplayMessageZoneComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBDizzinessConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBDizzinessConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDizzinessConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBDocumentsWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBDocumentsWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDocumentsWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDoorReplaceClass.OnReplacedDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBDoor*                                     door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBDoorReplaceClass::OnReplacedDoor(class ARBDoor* door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDoorReplaceClass.OnReplacedDoor");
		
		URBDoorReplaceClass_OnReplacedDoor_Params params {};
		params.door = door;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBDoorReplaceClass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBDoorReplaceClass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDoorReplaceClass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBDoorLockerRandomActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBDoorLockerRandomActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDoorLockerRandomActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDressablePipe.ApplyMaterial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBDressablePipe::ApplyMaterial(class UMaterialInterface* Material)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDressablePipe.ApplyMaterial");
		
		URBDressablePipe_ApplyMaterial_Params params {};
		params.Material = Material;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBDressablePipe.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBDressablePipe::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDressablePipe");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDynamicObstacle.OnRep_IsActivated
	 * 		Flags  -> ()
	 */
	void ARBDynamicObstacle::OnRep_IsActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDynamicObstacle.OnRep_IsActivated");
		
		ARBDynamicObstacle_OnRep_IsActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDynamicObstacle.OnRep_Enabled
	 * 		Flags  -> ()
	 */
	void ARBDynamicObstacle::OnRep_Enabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDynamicObstacle.OnRep_Enabled");
		
		ARBDynamicObstacle_OnRep_Enabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDynamicObstacle.OnRep_DynamicObstacleDestroyed
	 * 		Flags  -> ()
	 */
	void ARBDynamicObstacle::OnRep_DynamicObstacleDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDynamicObstacle.OnRep_DynamicObstacleDestroyed");
		
		ARBDynamicObstacle_OnRep_DynamicObstacleDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDynamicObstacle.Multicast_ForceActivateDynamicObstacle
	 * 		Flags  -> ()
	 */
	void ARBDynamicObstacle::Multicast_ForceActivateDynamicObstacle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDynamicObstacle.Multicast_ForceActivateDynamicObstacle");
		
		ARBDynamicObstacle_Multicast_ForceActivateDynamicObstacle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDynamicObstacle.IsActivatedChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBDynamicObstacle::IsActivatedChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDynamicObstacle.IsActivatedChangedCallback");
		
		ARBDynamicObstacle_IsActivatedChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDynamicObstacle.Event_OnDynamicObstacleDestroyed
	 * 		Flags  -> ()
	 */
	void ARBDynamicObstacle::Event_OnDynamicObstacleDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDynamicObstacle.Event_OnDynamicObstacleDestroyed");
		
		ARBDynamicObstacle_Event_OnDynamicObstacleDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDynamicObstacle.BP_Reset
	 * 		Flags  -> ()
	 */
	void ARBDynamicObstacle::BP_Reset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDynamicObstacle.BP_Reset");
		
		ARBDynamicObstacle_BP_Reset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBDynamicObstacle.BP_ActivateDynamicObstacle
	 * 		Flags  -> ()
	 */
	void ARBDynamicObstacle::BP_ActivateDynamicObstacle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBDynamicObstacle.BP_ActivateDynamicObstacle");
		
		ARBDynamicObstacle_BP_ActivateDynamicObstacle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBDynamicObstacle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBDynamicObstacle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDynamicObstacle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorClearanceCollisionBoxComponent.OnEditorPostLoad
	 * 		Flags  -> ()
	 */
	void URBEditorClearanceCollisionBoxComponent::OnEditorPostLoad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorClearanceCollisionBoxComponent.OnEditorPostLoad");
		
		URBEditorClearanceCollisionBoxComponent_OnEditorPostLoad_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorClearanceCollisionBoxComponent.GetClearancePlayerLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBEditorClearanceCollisionBoxComponent::GetClearancePlayerLocation(class ARBPawn* Pawn, struct FVector* OutLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorClearanceCollisionBoxComponent.GetClearancePlayerLocation");
		
		URBEditorClearanceCollisionBoxComponent_GetClearancePlayerLocation_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorClearanceCollisionBoxComponent.GetClearanceBottomLocation
	 * 		Flags  -> ()
	 */
	struct FVector URBEditorClearanceCollisionBoxComponent::GetClearanceBottomLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorClearanceCollisionBoxComponent.GetClearanceBottomLocation");
		
		URBEditorClearanceCollisionBoxComponent_GetClearanceBottomLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorClearanceCollisionBoxComponent.Event_OnPostEditorLoad
	 * 		Flags  -> ()
	 */
	void URBEditorClearanceCollisionBoxComponent::Event_OnPostEditorLoad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorClearanceCollisionBoxComponent.Event_OnPostEditorLoad");
		
		URBEditorClearanceCollisionBoxComponent_Event_OnPostEditorLoad_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorClearanceCollisionBoxComponent.Editor_SetSettingFromPlayerLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              finalCapsuleGroundOffset                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBEditorClearanceCollisionBoxComponent::Editor_SetSettingFromPlayerLocation(float finalCapsuleGroundOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorClearanceCollisionBoxComponent.Editor_SetSettingFromPlayerLocation");
		
		URBEditorClearanceCollisionBoxComponent_Editor_SetSettingFromPlayerLocation_Params params {};
		params.finalCapsuleGroundOffset = finalCapsuleGroundOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorClearanceCollisionBoxComponent.Editor_SetSettingFromPlayerInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              finalCapsuleGroundOffset                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBEditorClearanceCollisionBoxComponent::Editor_SetSettingFromPlayerInteraction(class UObject* Interactable, ESpecialMove specialMove, float finalCapsuleGroundOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorClearanceCollisionBoxComponent.Editor_SetSettingFromPlayerInteraction");
		
		URBEditorClearanceCollisionBoxComponent_Editor_SetSettingFromPlayerInteraction_Params params {};
		params.Interactable = Interactable;
		params.specialMove = specialMove;
		params.finalCapsuleGroundOffset = finalCapsuleGroundOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorClearanceCollisionBoxComponent.Editor_SetSettingFromCustomLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              finalCapsuleGroundOffset                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBEditorClearanceCollisionBoxComponent::Editor_SetSettingFromCustomLocation(const struct FVector& Location, float finalCapsuleGroundOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorClearanceCollisionBoxComponent.Editor_SetSettingFromCustomLocation");
		
		URBEditorClearanceCollisionBoxComponent_Editor_SetSettingFromCustomLocation_Params params {};
		params.Location = Location;
		params.finalCapsuleGroundOffset = finalCapsuleGroundOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBEditorClearanceCollisionBoxComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBEditorClearanceCollisionBoxComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBEditorClearanceCollisionBoxComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorMapCheckable.BP_PrepareMapCheck
	 * 		Flags  -> ()
	 */
	void URBEditorMapCheckable::BP_PrepareMapCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorMapCheckable.BP_PrepareMapCheck");
		
		URBEditorMapCheckable_BP_PrepareMapCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorMapCheckable.BP_MapCheck
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMapCheckType                                      checkType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      outErrorMsg                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBEditorMapCheckable::BP_MapCheck(EMapCheckType checkType, class FString* outErrorMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorMapCheckable.BP_MapCheck");
		
		URBEditorMapCheckable_BP_MapCheck_Params params {};
		params.checkType = checkType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outErrorMsg != nullptr)
			*outErrorMsg = params.outErrorMsg;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBEditorMapCheckable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBEditorMapCheckable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBEditorMapCheckable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBEditorSelectedPreviewComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBEditorSelectedPreviewComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBEditorSelectedPreviewComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBEditorTickableActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBEditorTickableActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBEditorTickableActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorUtilityInterface.TickSelected
	 * 		Flags  -> ()
	 */
	void URBEditorUtilityInterface::TickSelected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorUtilityInterface.TickSelected");
		
		URBEditorUtilityInterface_TickSelected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorUtilityInterface.PostEditMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFinished                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBEditorUtilityInterface::PostEditMove(bool bFinished)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorUtilityInterface.PostEditMove");
		
		URBEditorUtilityInterface_PostEditMove_Params params {};
		params.bFinished = bFinished;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorUtilityInterface.PostEditChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        PropertyName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBEditorUtilityInterface::PostEditChange(const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorUtilityInterface.PostEditChange");
		
		URBEditorUtilityInterface_PostEditChange_Params params {};
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorUtilityInterface.PostDuplicated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      duplicationParent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBEditorUtilityInterface::PostDuplicated(class AActor* duplicationParent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorUtilityInterface.PostDuplicated");
		
		URBEditorUtilityInterface_PostDuplicated_Params params {};
		params.duplicationParent = duplicationParent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorUtilityInterface.PostAddedToLevel
	 * 		Flags  -> ()
	 */
	void URBEditorUtilityInterface::PostAddedToLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorUtilityInterface.PostAddedToLevel");
		
		URBEditorUtilityInterface_PostAddedToLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorUtilityInterface.OnPostActorsPasted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              pastedActors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBEditorUtilityInterface::OnPostActorsPasted(TArray<class AActor*> pastedActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorUtilityInterface.OnPostActorsPasted");
		
		URBEditorUtilityInterface_OnPostActorsPasted_Params params {};
		params.pastedActors = pastedActors;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorUtilityInterface.OnEditorPostLoad
	 * 		Flags  -> ()
	 */
	void URBEditorUtilityInterface::OnEditorPostLoad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorUtilityInterface.OnEditorPostLoad");
		
		URBEditorUtilityInterface_OnEditorPostLoad_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEditorUtilityInterface.FixUp
	 * 		Flags  -> ()
	 */
	bool URBEditorUtilityInterface::FixUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEditorUtilityInterface.FixUp");
		
		URBEditorUtilityInterface_FixUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBEditorUtilityInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBEditorUtilityInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBEditorUtilityInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectricFloorTrapComponent.SetMasterTrap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBElectricFloorTrapComponent*               newMasterTrap                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBElectricFloorTrapComponent::SetMasterTrap(class URBElectricFloorTrapComponent* newMasterTrap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectricFloorTrapComponent.SetMasterTrap");
		
		URBElectricFloorTrapComponent_SetMasterTrap_Params params {};
		params.newMasterTrap = newMasterTrap;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectricFloorTrapComponent.OnRep_ElectricFloorTrapState
	 * 		Flags  -> ()
	 */
	void URBElectricFloorTrapComponent::OnRep_ElectricFloorTrapState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectricFloorTrapComponent.OnRep_ElectricFloorTrapState");
		
		URBElectricFloorTrapComponent_OnRep_ElectricFloorTrapState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectricFloorTrapComponent.OnNPCBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBElectricFloorTrapComponent::OnNPCBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectricFloorTrapComponent.OnNPCBeginOverlap");
		
		URBElectricFloorTrapComponent_OnNPCBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectricFloorTrapComponent.ElectricFloorTrapStateChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBElectricFloorTrapComponent::ElectricFloorTrapStateChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectricFloorTrapComponent.ElectricFloorTrapStateChangedCallback");
		
		URBElectricFloorTrapComponent_ElectricFloorTrapStateChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectricFloorTrapComponent.BP_BreakTrap
	 * 		Flags  -> ()
	 */
	void URBElectricFloorTrapComponent::BP_BreakTrap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectricFloorTrapComponent.BP_BreakTrap");
		
		URBElectricFloorTrapComponent_BP_BreakTrap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBElectricFloorTrapComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBElectricFloorTrapComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBElectricFloorTrapComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionDevice.OnRep_OnStartedChanged
	 * 		Flags  -> ()
	 */
	void ARBElectrocutionDevice::OnRep_OnStartedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionDevice.OnRep_OnStartedChanged");
		
		ARBElectrocutionDevice_OnRep_OnStartedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionDevice.OnRep_OnCompletedChanged
	 * 		Flags  -> ()
	 */
	void ARBElectrocutionDevice::OnRep_OnCompletedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionDevice.OnRep_OnCompletedChanged");
		
		ARBElectrocutionDevice_OnRep_OnCompletedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionDevice.GetNumberOfActivePlayers
	 * 		Flags  -> ()
	 */
	int32_t ARBElectrocutionDevice::GetNumberOfActivePlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionDevice.GetNumberOfActivePlayers");
		
		ARBElectrocutionDevice_GetNumberOfActivePlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionDevice.GetLinkedCoordinator
	 * 		Flags  -> ()
	 */
	class ARBElectrocutionObjectiveCoordinator* ARBElectrocutionDevice::GetLinkedCoordinator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionDevice.GetLinkedCoordinator");
		
		ARBElectrocutionDevice_GetLinkedCoordinator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionDevice.GetCurrentVoltageRatio
	 * 		Flags  -> ()
	 */
	float ARBElectrocutionDevice::GetCurrentVoltageRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionDevice.GetCurrentVoltageRatio");
		
		ARBElectrocutionDevice_GetCurrentVoltageRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionDevice.Event_OnStartedChanged
	 * 		Flags  -> ()
	 */
	void ARBElectrocutionDevice::Event_OnStartedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionDevice.Event_OnStartedChanged");
		
		ARBElectrocutionDevice_Event_OnStartedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionDevice.Event_OnPlayerOverloading
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBElectrocutionSwitchPanelComponent*        panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBElectrocutionDevice::Event_OnPlayerOverloading(class URBElectrocutionSwitchPanelComponent* panel, class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionDevice.Event_OnPlayerOverloading");
		
		ARBElectrocutionDevice_Event_OnPlayerOverloading_Params params {};
		params.panel = panel;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionDevice.Event_OnCurrentVoltageChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              currentVoltage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBElectrocutionDevice::Event_OnCurrentVoltageChanged(float currentVoltage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionDevice.Event_OnCurrentVoltageChanged");
		
		ARBElectrocutionDevice_Event_OnCurrentVoltageChanged_Params params {};
		params.currentVoltage = currentVoltage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionDevice.Event_OnCompletedChanged
	 * 		Flags  -> ()
	 */
	void ARBElectrocutionDevice::Event_OnCompletedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionDevice.Event_OnCompletedChanged");
		
		ARBElectrocutionDevice_Event_OnCompletedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionDevice.Event_OnActivePanelRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBElectrocutionSwitchPanelComponent*        panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBElectrocutionDevice::Event_OnActivePanelRemoved(class URBElectrocutionSwitchPanelComponent* panel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionDevice.Event_OnActivePanelRemoved");
		
		ARBElectrocutionDevice_Event_OnActivePanelRemoved_Params params {};
		params.panel = panel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionDevice.Event_OnActivePanelAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBElectrocutionSwitchPanelComponent*        panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBElectrocutionDevice::Event_OnActivePanelAdded(class URBElectrocutionSwitchPanelComponent* panel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionDevice.Event_OnActivePanelAdded");
		
		ARBElectrocutionDevice_Event_OnActivePanelAdded_Params params {};
		params.panel = panel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBElectrocutionDevice.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBElectrocutionDevice::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBElectrocutionDevice");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionObjectiveCoordinator.OnRep_CurrentVoltage
	 * 		Flags  -> ()
	 */
	void ARBElectrocutionObjectiveCoordinator::OnRep_CurrentVoltage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionObjectiveCoordinator.OnRep_CurrentVoltage");
		
		ARBElectrocutionObjectiveCoordinator_OnRep_CurrentVoltage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionObjectiveCoordinator.OnPanelPawnInteractingChangedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     pawnInteracting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBElectrocutionObjectiveCoordinator::OnPanelPawnInteractingChangedEvent(class URBInteractiblePanelComponent* panel, class ARBPawn* pawnInteracting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionObjectiveCoordinator.OnPanelPawnInteractingChangedEvent");
		
		ARBElectrocutionObjectiveCoordinator_OnPanelPawnInteractingChangedEvent_Params params {};
		params.panel = panel;
		params.pawnInteracting = pawnInteracting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionObjectiveCoordinator.GetNumberOfActivePlayers
	 * 		Flags  -> ()
	 */
	float ARBElectrocutionObjectiveCoordinator::GetNumberOfActivePlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionObjectiveCoordinator.GetNumberOfActivePlayers");
		
		ARBElectrocutionObjectiveCoordinator_GetNumberOfActivePlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionObjectiveCoordinator.GetCurrentVoltageRatio
	 * 		Flags  -> ()
	 */
	float ARBElectrocutionObjectiveCoordinator::GetCurrentVoltageRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionObjectiveCoordinator.GetCurrentVoltageRatio");
		
		ARBElectrocutionObjectiveCoordinator_GetCurrentVoltageRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBElectrocutionObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBElectrocutionObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBElectrocutionObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionSwitchPanelComponent.OnRep_SwitchState
	 * 		Flags  -> ()
	 */
	void URBElectrocutionSwitchPanelComponent::OnRep_SwitchState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionSwitchPanelComponent.OnRep_SwitchState");
		
		URBElectrocutionSwitchPanelComponent_OnRep_SwitchState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionSwitchPanelComponent.IsInActiveState
	 * 		Flags  -> ()
	 */
	bool URBElectrocutionSwitchPanelComponent::IsInActiveState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionSwitchPanelComponent.IsInActiveState");
		
		URBElectrocutionSwitchPanelComponent_IsInActiveState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionSwitchPanelComponent.GetSwitchActiveRatio
	 * 		Flags  -> ()
	 */
	float URBElectrocutionSwitchPanelComponent::GetSwitchActiveRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionSwitchPanelComponent.GetSwitchActiveRatio");
		
		URBElectrocutionSwitchPanelComponent_GetSwitchActiveRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionSwitchPanelComponent.GetActiveToOverloadedRatio
	 * 		Flags  -> ()
	 */
	float URBElectrocutionSwitchPanelComponent::GetActiveToOverloadedRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionSwitchPanelComponent.GetActiveToOverloadedRatio");
		
		URBElectrocutionSwitchPanelComponent_GetActiveToOverloadedRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionSwitchPanelComponent.Event_OnSwitchStateChanged
	 * 		Flags  -> ()
	 */
	void URBElectrocutionSwitchPanelComponent::Event_OnSwitchStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionSwitchPanelComponent.Event_OnSwitchStateChanged");
		
		URBElectrocutionSwitchPanelComponent_Event_OnSwitchStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBElectrocutionSwitchPanelComponent.Event_OnActiveStateChanged
	 * 		Flags  -> ()
	 */
	void URBElectrocutionSwitchPanelComponent::Event_OnActiveStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBElectrocutionSwitchPanelComponent.Event_OnActiveStateChanged");
		
		URBElectrocutionSwitchPanelComponent_Event_OnActiveStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBElectrocutionSwitchPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBElectrocutionSwitchPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBElectrocutionSwitchPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpWidget.BP_AdjustToAnchor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPopUpAnchorWidget*                        anchorWidget                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUsePopupCenter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPopUpWidget::BP_AdjustToAnchor(class URBPopUpAnchorWidget* anchorWidget, bool bUsePopupCenter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpWidget.BP_AdjustToAnchor");
		
		URBPopUpWidget_BP_AdjustToAnchor_Params params {};
		params.anchorWidget = anchorWidget;
		params.bUsePopupCenter = bUsePopupCenter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPopUpWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPopUpWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPopUpWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpConfirmWidget.Event_InitializePopup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        TitleText                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        MainText                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        ConfirmText                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBPopUpConfirmWidget::Event_InitializePopup(const class FText& TitleText, const class FText& MainText, const class FText& ConfirmText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpConfirmWidget.Event_InitializePopup");
		
		URBPopUpConfirmWidget_Event_InitializePopup_Params params {};
		params.TitleText = TitleText;
		params.MainText = MainText;
		params.ConfirmText = ConfirmText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpConfirmWidget.BP_Confirm
	 * 		Flags  -> ()
	 */
	void URBPopUpConfirmWidget::BP_Confirm()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpConfirmWidget.BP_Confirm");
		
		URBPopUpConfirmWidget_BP_Confirm_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPopUpConfirmWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPopUpConfirmWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPopUpConfirmWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBErrorConfirmPopUpWidget.InitializeErrorPopup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        errorCauseMessage                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      errorCodeString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBErrorConfirmPopUpWidget::InitializeErrorPopup(const class FText& Message, const class FText& errorCauseMessage, const class FString& errorCodeString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBErrorConfirmPopUpWidget.InitializeErrorPopup");
		
		URBErrorConfirmPopUpWidget_InitializeErrorPopup_Params params {};
		params.Message = Message;
		params.errorCauseMessage = errorCauseMessage;
		params.errorCodeString = errorCodeString;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBErrorConfirmPopUpWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBErrorConfirmPopUpWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBErrorConfirmPopUpWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEvalCorridor.OnPlayerInitReplicated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBEvalCorridor::OnPlayerInitReplicated(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEvalCorridor.OnPlayerInitReplicated");
		
		ARBEvalCorridor_OnPlayerInitReplicated_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEvalCorridor.OnComponentEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBEvalCorridor::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEvalCorridor.OnComponentEndOverlap");
		
		ARBEvalCorridor_OnComponentEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEvalCorridor.OnComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBEvalCorridor::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEvalCorridor.OnComponentBeginOverlap");
		
		ARBEvalCorridor_OnComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEvalCorridor.Event_OnLocalPlayerExited
	 * 		Flags  -> ()
	 */
	void ARBEvalCorridor::Event_OnLocalPlayerExited()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEvalCorridor.Event_OnLocalPlayerExited");
		
		ARBEvalCorridor_Event_OnLocalPlayerExited_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEvalCorridor.Event_OnLocalPlayerEntered
	 * 		Flags  -> ()
	 */
	void ARBEvalCorridor::Event_OnLocalPlayerEntered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEvalCorridor.Event_OnLocalPlayerEntered");
		
		ARBEvalCorridor_Event_OnLocalPlayerEntered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBEvalCorridor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBEvalCorridor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBEvalCorridor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEvalCorridorEntrance.OnComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBEvalCorridorEntrance::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEvalCorridorEntrance.OnComponentBeginOverlap");
		
		ARBEvalCorridorEntrance_OnComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEvalCorridorEntrance.Event_OnLocallyClosedChanged
	 * 		Flags  -> ()
	 */
	void ARBEvalCorridorEntrance::Event_OnLocallyClosedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEvalCorridorEntrance.Event_OnLocallyClosedChanged");
		
		ARBEvalCorridorEntrance_Event_OnLocallyClosedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBEvalCorridorEntrance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBEvalCorridorEntrance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBEvalCorridorEntrance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEvalCorridorExit.OnComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBEvalCorridorExit::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEvalCorridorExit.OnComponentBeginOverlap");
		
		ARBEvalCorridorExit_OnComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEvalCorridorExit.Event_OnLocalPlayerEntered
	 * 		Flags  -> ()
	 */
	void ARBEvalCorridorExit::Event_OnLocalPlayerEntered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEvalCorridorExit.Event_OnLocalPlayerEntered");
		
		ARBEvalCorridorExit_Event_OnLocalPlayerEntered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBEvalCorridorExit.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBEvalCorridorExit::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBEvalCorridorExit");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEvalCorridorHelperComponent.Multicast_ScheduleCollisionEnabledForPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              executionTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSkipLocalPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBEvalCorridorHelperComponent::Multicast_ScheduleCollisionEnabledForPlayer(class ARBPlayer* Player, bool bEnabled, float executionTime, bool bSkipLocalPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEvalCorridorHelperComponent.Multicast_ScheduleCollisionEnabledForPlayer");
		
		URBEvalCorridorHelperComponent_Multicast_ScheduleCollisionEnabledForPlayer_Params params {};
		params.Player = Player;
		params.bEnabled = bEnabled;
		params.executionTime = executionTime;
		params.bSkipLocalPlayer = bSkipLocalPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEvalCorridorHelperComponent.BP_ScheduleCollisionEnabledLocalPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBEvalCorridorHelperComponent::BP_ScheduleCollisionEnabledLocalPlayer(bool bEnabled, float delay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEvalCorridorHelperComponent.BP_ScheduleCollisionEnabledLocalPlayer");
		
		URBEvalCorridorHelperComponent_BP_ScheduleCollisionEnabledLocalPlayer_Params params {};
		params.bEnabled = bEnabled;
		params.delay = delay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBEvalCorridorHelperComponent.BP_ScheduleCollisionEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBEvalCorridorHelperComponent::BP_ScheduleCollisionEnabled(class ARBPlayer* Player, bool bEnabled, float delay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBEvalCorridorHelperComponent.BP_ScheduleCollisionEnabled");
		
		URBEvalCorridorHelperComponent_BP_ScheduleCollisionEnabled_Params params {};
		params.Player = Player;
		params.bEnabled = bEnabled;
		params.delay = delay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBEvalCorridorHelperComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBEvalCorridorHelperComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBEvalCorridorHelperComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBBaseExitStageObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBBaseExitStageObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBaseExitStageObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExitStageObjectiveCoordinator.OnRep_ObjectiveState
	 * 		Flags  -> ()
	 */
	void ARBExitStageObjectiveCoordinator::OnRep_ObjectiveState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExitStageObjectiveCoordinator.OnRep_ObjectiveState");
		
		ARBExitStageObjectiveCoordinator_OnRep_ObjectiveState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExitStageObjectiveCoordinator.OnPlayerSimpleDoAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBInteractibleComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBExitStageObjectiveCoordinator::OnPlayerSimpleDoAction(class ARBPawn* Player, class URBInteractibleComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExitStageObjectiveCoordinator.OnPlayerSimpleDoAction");
		
		ARBExitStageObjectiveCoordinator_OnPlayerSimpleDoAction_Params params {};
		params.Player = Player;
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExitStageObjectiveCoordinator.OnPlayerRevived
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   instigatorActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   subjectActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBExitStageObjectiveCoordinator::OnPlayerRevived(class ARBPlayer* instigatorActor, class ARBPlayer* subjectActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExitStageObjectiveCoordinator.OnPlayerRevived");
		
		ARBExitStageObjectiveCoordinator_OnPlayerRevived_Params params {};
		params.instigatorActor = instigatorActor;
		params.subjectActor = subjectActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExitStageObjectiveCoordinator.OnPawnRespawned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBExitStageObjectiveCoordinator::OnPawnRespawned(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExitStageObjectiveCoordinator.OnPawnRespawned");
		
		ARBExitStageObjectiveCoordinator_OnPawnRespawned_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExitStageObjectiveCoordinator.OnPawnKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     instigatorActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     subjectActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBExitStageObjectiveCoordinator::OnPawnKilled(class ARBPawn* instigatorActor, class ARBPawn* subjectActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExitStageObjectiveCoordinator.OnPawnKilled");
		
		ARBExitStageObjectiveCoordinator_OnPawnKilled_Params params {};
		params.instigatorActor = instigatorActor;
		params.subjectActor = subjectActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExitStageObjectiveCoordinator.OnOperatingFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBOperatableComponent*                      Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBExitStageObjectiveCoordinator::OnOperatingFinished(class URBOperatableComponent* Component, class ARBPawn* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExitStageObjectiveCoordinator.OnOperatingFinished");
		
		ARBExitStageObjectiveCoordinator_OnOperatingFinished_Params params {};
		params.Component = Component;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExitStageObjectiveCoordinator.OnGamePhaseUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGamePhase                                         gamePhase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBExitStageObjectiveCoordinator::OnGamePhaseUpdated(EGamePhase gamePhase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExitStageObjectiveCoordinator.OnGamePhaseUpdated");
		
		ARBExitStageObjectiveCoordinator_OnGamePhaseUpdated_Params params {};
		params.gamePhase = gamePhase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExitStageObjectiveCoordinator.Event_OnExitStageObjectiveStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EExitStageObjectiveState                           objectiveState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBExitStageObjectiveCoordinator::Event_OnExitStageObjectiveStateChanged(EExitStageObjectiveState objectiveState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExitStageObjectiveCoordinator.Event_OnExitStageObjectiveStateChanged");
		
		ARBExitStageObjectiveCoordinator_Event_OnExitStageObjectiveStateChanged_Params params {};
		params.objectiveState = objectiveState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBExitStageObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBExitStageObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBExitStageObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReleaseExitStageObjectiveCoordinator.OnCreditsMenuPopped
	 * 		Flags  -> ()
	 */
	void ARBReleaseExitStageObjectiveCoordinator::OnCreditsMenuPopped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReleaseExitStageObjectiveCoordinator.OnCreditsMenuPopped");
		
		ARBReleaseExitStageObjectiveCoordinator_OnCreditsMenuPopped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBReleaseExitStageObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBReleaseExitStageObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBReleaseExitStageObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.StartMatchCountdown
	 * 		Flags  -> ()
	 */
	void URBExperimentBoardMenu::StartMatchCountdown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.StartMatchCountdown");
		
		URBExperimentBoardMenu_StartMatchCountdown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.SetTrialId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBExperimentBoardMenu::SetTrialId(const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.SetTrialId");
		
		URBExperimentBoardMenu_SetTrialId_Params params {};
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.SetStageName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        StageName                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBExperimentBoardMenu::SetStageName(const class FName& StageName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.SetStageName");
		
		URBExperimentBoardMenu_SetStageName_Params params {};
		params.StageName = StageName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.SetMissionName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        MissionName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBExperimentBoardMenu::SetMissionName(const class FName& MissionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.SetMissionName");
		
		URBExperimentBoardMenu_SetMissionName_Params params {};
		params.MissionName = MissionName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.SetGameDifficulty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGameDifficulty                                    GameDifficulty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBExperimentBoardMenu::SetGameDifficulty(EGameDifficulty GameDifficulty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.SetGameDifficulty");
		
		URBExperimentBoardMenu_SetGameDifficulty_Params params {};
		params.GameDifficulty = GameDifficulty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.SaveMatchSettings
	 * 		Flags  -> ()
	 */
	void URBExperimentBoardMenu::SaveMatchSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.SaveMatchSettings");
		
		URBExperimentBoardMenu_SaveMatchSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.OnMatchStateUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMatchState                                 MatchState                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBExperimentBoardMenu::OnMatchStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchState& MatchState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.OnMatchStateUpdated");
		
		URBExperimentBoardMenu_OnMatchStateUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.MatchState = MatchState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.OnMatchSettingsUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FMatchSettings                              MatchSettings                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBExperimentBoardMenu::OnMatchSettingsUpdated(const struct FMatchSettings& MatchSettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.OnMatchSettingsUpdated");
		
		URBExperimentBoardMenu_OnMatchSettingsUpdated_Params params {};
		params.MatchSettings = MatchSettings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.IsMatchOwner
	 * 		Flags  -> ()
	 */
	bool URBExperimentBoardMenu::IsMatchOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.IsMatchOwner");
		
		URBExperimentBoardMenu_IsMatchOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.GetMatchSettings
	 * 		Flags  -> ()
	 */
	struct FMatchSettings URBExperimentBoardMenu::GetMatchSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.GetMatchSettings");
		
		URBExperimentBoardMenu_GetMatchSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.GetMatchCurrentPlayerCount
	 * 		Flags  -> ()
	 */
	int32_t URBExperimentBoardMenu::GetMatchCurrentPlayerCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.GetMatchCurrentPlayerCount");
		
		URBExperimentBoardMenu_GetMatchCurrentPlayerCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBExperimentBoardMenu::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.Event_Refresh");
		
		URBExperimentBoardMenu_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.CanStartMatch
	 * 		Flags  -> ()
	 */
	bool URBExperimentBoardMenu::CanStartMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.CanStartMatch");
		
		URBExperimentBoardMenu_CanStartMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.CancelMatchCountdown
	 * 		Flags  -> ()
	 */
	void URBExperimentBoardMenu::CancelMatchCountdown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.CancelMatchCountdown");
		
		URBExperimentBoardMenu_CancelMatchCountdown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentBoardMenu.CanCancelMatch
	 * 		Flags  -> ()
	 */
	bool URBExperimentBoardMenu::CanCancelMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentBoardMenu.CanCancelMatch");
		
		URBExperimentBoardMenu_CanCancelMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBExperimentBoardMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBExperimentBoardMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBExperimentBoardMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameModePersistentData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameModePersistentData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameModePersistentData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBExperimentPersistentData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBExperimentPersistentData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBExperimentPersistentData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPhotoFinishEntry.Event_Setup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FEndStagePlayerInfo                         Info                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBPhotoFinishEntry::Event_Setup(const struct FEndStagePlayerInfo& Info)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPhotoFinishEntry.Event_Setup");
		
		URBPhotoFinishEntry_Event_Setup_Params params {};
		params.Info = Info;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPhotoFinishEntry.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPhotoFinishEntry::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPhotoFinishEntry");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.OnPlayerLeftGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBExperimentResultScreen::OnPlayerLeftGame(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.OnPlayerLeftGame");
		
		URBExperimentResultScreen_OnPlayerLeftGame_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.OnLobbyGameSessionAvailable
	 * 		Flags  -> ()
	 */
	void URBExperimentResultScreen::OnLobbyGameSessionAvailable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.OnLobbyGameSessionAvailable");
		
		URBExperimentResultScreen_OnLobbyGameSessionAvailable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.OnLeaving
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerLeaveTarget                                 Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBExperimentResultScreen::OnLeaving(EPlayerLeaveTarget Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.OnLeaving");
		
		URBExperimentResultScreen_OnLeaving_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.OnGamePhaseUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGamePhase                                         gamePhase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBExperimentResultScreen::OnGamePhaseUpdated(EGamePhase gamePhase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.OnGamePhaseUpdated");
		
		URBExperimentResultScreen_OnGamePhaseUpdated_Params params {};
		params.gamePhase = gamePhase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.OnDrawHud
	 * 		Flags  -> ()
	 */
	void URBExperimentResultScreen::OnDrawHud()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.OnDrawHud");
		
		URBExperimentResultScreen_OnDrawHud_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.Leave
	 * 		Flags  -> ()
	 */
	void URBExperimentResultScreen::Leave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.Leave");
		
		URBExperimentResultScreen_Leave_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.IsReturningToLobbyWithParty
	 * 		Flags  -> ()
	 */
	bool URBExperimentResultScreen::IsReturningToLobbyWithParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.IsReturningToLobbyWithParty");
		
		URBExperimentResultScreen_IsReturningToLobbyWithParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.InitSocialMenuScene
	 * 		Flags  -> ()
	 */
	void URBExperimentResultScreen::InitSocialMenuScene()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.InitSocialMenuScene");
		
		URBExperimentResultScreen_InitSocialMenuScene_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.GetSecondsRemaining
	 * 		Flags  -> ()
	 */
	int32_t URBExperimentResultScreen::GetSecondsRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.GetSecondsRemaining");
		
		URBExperimentResultScreen_GetSecondsRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.Event_UpdateReadyState
	 * 		Flags  -> ()
	 */
	void URBExperimentResultScreen::Event_UpdateReadyState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.Event_UpdateReadyState");
		
		URBExperimentResultScreen_Event_UpdateReadyState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.Event_StartAnimations
	 * 		Flags  -> ()
	 */
	void URBExperimentResultScreen::Event_StartAnimations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.Event_StartAnimations");
		
		URBExperimentResultScreen_Event_StartAnimations_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBExperimentResultScreen::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.Event_Refresh");
		
		URBExperimentResultScreen_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.ClearSocialMenuScene
	 * 		Flags  -> ()
	 */
	void URBExperimentResultScreen::ClearSocialMenuScene()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.ClearSocialMenuScene");
		
		URBExperimentResultScreen_ClearSocialMenuScene_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.ClearOverheadEntries
	 * 		Flags  -> ()
	 */
	void URBExperimentResultScreen::ClearOverheadEntries()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.ClearOverheadEntries");
		
		URBExperimentResultScreen_ClearOverheadEntries_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExperimentResultScreen.CanLeave
	 * 		Flags  -> ()
	 */
	bool URBExperimentResultScreen::CanLeave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExperimentResultScreen.CanLeave");
		
		URBExperimentResultScreen_CanLeave_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBExperimentResultScreen.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBExperimentResultScreen::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBExperimentResultScreen");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRandomizableActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRandomizableActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRandomizableActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExplosiveTrap.OnRep_ExplosionRatio
	 * 		Flags  -> ()
	 */
	void ARBExplosiveTrap::OnRep_ExplosionRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExplosiveTrap.OnRep_ExplosionRatio");
		
		ARBExplosiveTrap_OnRep_ExplosionRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExplosiveTrap.OnRep_Exploded
	 * 		Flags  -> ()
	 */
	void ARBExplosiveTrap::OnRep_Exploded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExplosiveTrap.OnRep_Exploded");
		
		ARBExplosiveTrap_OnRep_Exploded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExplosiveTrap.OnComponentEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBExplosiveTrap::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExplosiveTrap.OnComponentEndOverlap");
		
		ARBExplosiveTrap_OnComponentEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExplosiveTrap.OnComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBExplosiveTrap::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExplosiveTrap.OnComponentBeginOverlap");
		
		ARBExplosiveTrap_OnComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExplosiveTrap.Multicast_Explode
	 * 		Flags  -> ()
	 */
	void ARBExplosiveTrap::Multicast_Explode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExplosiveTrap.Multicast_Explode");
		
		ARBExplosiveTrap_Multicast_Explode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExplosiveTrap.Multicast_Disable
	 * 		Flags  -> ()
	 */
	void ARBExplosiveTrap::Multicast_Disable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExplosiveTrap.Multicast_Disable");
		
		ARBExplosiveTrap_Multicast_Disable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExplosiveTrap.Event_SnapToState
	 * 		Flags  -> ()
	 */
	void ARBExplosiveTrap::Event_SnapToState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExplosiveTrap.Event_SnapToState");
		
		ARBExplosiveTrap_Event_SnapToState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExplosiveTrap.Event_Explode
	 * 		Flags  -> ()
	 */
	void ARBExplosiveTrap::Event_Explode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExplosiveTrap.Event_Explode");
		
		ARBExplosiveTrap_Event_Explode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExplosiveTrap.Event_Disable
	 * 		Flags  -> ()
	 */
	void ARBExplosiveTrap::Event_Disable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExplosiveTrap.Event_Disable");
		
		ARBExplosiveTrap_Event_Disable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExplosiveTrap.Event_ActiveChanged
	 * 		Flags  -> ()
	 */
	void ARBExplosiveTrap::Event_ActiveChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExplosiveTrap.Event_ActiveChanged");
		
		ARBExplosiveTrap_Event_ActiveChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBExplosiveTrap.BP_ForceExplode
	 * 		Flags  -> ()
	 */
	void ARBExplosiveTrap::BP_ForceExplode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBExplosiveTrap.BP_ForceExplode");
		
		ARBExplosiveTrap_BP_ForceExplode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBExplosiveTrap.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBExplosiveTrap::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBExplosiveTrap");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBFaceAnimInstanceNPC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBFaceAnimInstanceNPC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFaceAnimInstanceNPC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBFaceAnimInstancePlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBFaceAnimInstancePlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFaceAnimInstancePlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFloorMaterialBoxComponent.OnRep_Enabled
	 * 		Flags  -> ()
	 */
	void URBFloorMaterialBoxComponent::OnRep_Enabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFloorMaterialBoxComponent.OnRep_Enabled");
		
		URBFloorMaterialBoxComponent_OnRep_Enabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFloorMaterialBoxComponent.EndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBFloorMaterialBoxComponent::EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFloorMaterialBoxComponent.EndOverlap");
		
		URBFloorMaterialBoxComponent_EndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFloorMaterialBoxComponent.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabledValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBFloorMaterialBoxComponent::BP_SetEnabled(bool bEnabledValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFloorMaterialBoxComponent.BP_SetEnabled");
		
		URBFloorMaterialBoxComponent_BP_SetEnabled_Params params {};
		params.bEnabledValue = bEnabledValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFloorMaterialBoxComponent.BeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBFloorMaterialBoxComponent::BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFloorMaterialBoxComponent.BeginOverlap");
		
		URBFloorMaterialBoxComponent_BeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBFloorMaterialBoxComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBFloorMaterialBoxComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFloorMaterialBoxComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBFloorMaterialOverride.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBFloorMaterialOverride::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFloorMaterialOverride");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFloorMaterialVolume.OnRep_RandomlyDisabled
	 * 		Flags  -> ()
	 */
	void ARBFloorMaterialVolume::OnRep_RandomlyDisabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFloorMaterialVolume.OnRep_RandomlyDisabled");
		
		ARBFloorMaterialVolume_OnRep_RandomlyDisabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFloorMaterialVolume.OnRep_Enabled
	 * 		Flags  -> ()
	 */
	void ARBFloorMaterialVolume::OnRep_Enabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFloorMaterialVolume.OnRep_Enabled");
		
		ARBFloorMaterialVolume_OnRep_Enabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFloorMaterialVolume.EndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBFloorMaterialVolume::EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFloorMaterialVolume.EndOverlap");
		
		ARBFloorMaterialVolume_EndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFloorMaterialVolume.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabledValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBFloorMaterialVolume::BP_SetEnabled(bool bEnabledValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFloorMaterialVolume.BP_SetEnabled");
		
		ARBFloorMaterialVolume_BP_SetEnabled_Params params {};
		params.bEnabledValue = bEnabledValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFloorMaterialVolume.BeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBFloorMaterialVolume::BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFloorMaterialVolume.BeginOverlap");
		
		ARBFloorMaterialVolume_BeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBFloorMaterialVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBFloorMaterialVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFloorMaterialVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBFocusPullingCameraActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBFocusPullingCameraActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFocusPullingCameraActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBFocusPullingCameraComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBFocusPullingCameraComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFocusPullingCameraComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFootStepGridComponent.ClearCurrentData
	 * 		Flags  -> ()
	 */
	void URBFootStepGridComponent::ClearCurrentData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFootStepGridComponent.ClearCurrentData");
		
		URBFootStepGridComponent_ClearCurrentData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFootStepGridComponent.ClearAllData
	 * 		Flags  -> ()
	 */
	void URBFootStepGridComponent::ClearAllData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFootStepGridComponent.ClearAllData");
		
		URBFootStepGridComponent_ClearAllData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBFootStepGridComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBFootStepGridComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFootStepGridComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFrequencyMatchKnobComponent.OnRep_PlayerOnKnob
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBFrequencyMatchKnobComponent::OnRep_PlayerOnKnob(class ARBPlayer* OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFrequencyMatchKnobComponent.OnRep_PlayerOnKnob");
		
		URBFrequencyMatchKnobComponent_OnRep_PlayerOnKnob_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFrequencyMatchKnobComponent.OnRep_IsCompleted
	 * 		Flags  -> ()
	 */
	void URBFrequencyMatchKnobComponent::OnRep_IsCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFrequencyMatchKnobComponent.OnRep_IsCompleted");
		
		URBFrequencyMatchKnobComponent_OnRep_IsCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFrequencyMatchKnobComponent.OnRep_CurrentRatio
	 * 		Flags  -> ()
	 */
	void URBFrequencyMatchKnobComponent::OnRep_CurrentRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFrequencyMatchKnobComponent.OnRep_CurrentRatio");
		
		URBFrequencyMatchKnobComponent_OnRep_CurrentRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFrequencyMatchKnobComponent.Multicast_InitializeKnobPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ratio                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBFrequencyMatchKnobComponent::Multicast_InitializeKnobPosition(float ratio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFrequencyMatchKnobComponent.Multicast_InitializeKnobPosition");
		
		URBFrequencyMatchKnobComponent_Multicast_InitializeKnobPosition_Params params {};
		params.ratio = ratio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFrequencyMatchKnobComponent.IsLocallyFocused
	 * 		Flags  -> ()
	 */
	bool URBFrequencyMatchKnobComponent::IsLocallyFocused()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFrequencyMatchKnobComponent.IsLocallyFocused");
		
		URBFrequencyMatchKnobComponent_IsLocallyFocused_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFrequencyMatchKnobComponent.GetIsCompletedForDisplay
	 * 		Flags  -> ()
	 */
	bool URBFrequencyMatchKnobComponent::GetIsCompletedForDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFrequencyMatchKnobComponent.GetIsCompletedForDisplay");
		
		URBFrequencyMatchKnobComponent_GetIsCompletedForDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFrequencyMatchKnobComponent.GetCurrentRatioForDisplay
	 * 		Flags  -> ()
	 */
	float URBFrequencyMatchKnobComponent::GetCurrentRatioForDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFrequencyMatchKnobComponent.GetCurrentRatioForDisplay");
		
		URBFrequencyMatchKnobComponent_GetCurrentRatioForDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFrequencyMatchKnobComponent.Event_OnPlayerOnKnobChanged
	 * 		Flags  -> ()
	 */
	void URBFrequencyMatchKnobComponent::Event_OnPlayerOnKnobChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFrequencyMatchKnobComponent.Event_OnPlayerOnKnobChanged");
		
		URBFrequencyMatchKnobComponent_Event_OnPlayerOnKnobChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFrequencyMatchKnobComponent.Event_OnLocallyFocusedChanged
	 * 		Flags  -> ()
	 */
	void URBFrequencyMatchKnobComponent::Event_OnLocallyFocusedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFrequencyMatchKnobComponent.Event_OnLocallyFocusedChanged");
		
		URBFrequencyMatchKnobComponent_Event_OnLocallyFocusedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFrequencyMatchKnobComponent.Event_OnIsCompletedChanged
	 * 		Flags  -> ()
	 */
	void URBFrequencyMatchKnobComponent::Event_OnIsCompletedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFrequencyMatchKnobComponent.Event_OnIsCompletedChanged");
		
		URBFrequencyMatchKnobComponent_Event_OnIsCompletedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFrequencyMatchKnobComponent.Event_OnCurrentRatioChanged
	 * 		Flags  -> ()
	 */
	void URBFrequencyMatchKnobComponent::Event_OnCurrentRatioChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFrequencyMatchKnobComponent.Event_OnCurrentRatioChanged");
		
		URBFrequencyMatchKnobComponent_Event_OnCurrentRatioChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBFrequencyMatchKnobComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBFrequencyMatchKnobComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFrequencyMatchKnobComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFrequencyMatchPanelComponent.OnRep_IsCompleted
	 * 		Flags  -> ()
	 */
	void URBFrequencyMatchPanelComponent::OnRep_IsCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFrequencyMatchPanelComponent.OnRep_IsCompleted");
		
		URBFrequencyMatchPanelComponent_OnRep_IsCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFrequencyMatchPanelComponent.OnCompletedGameplayCallback
	 * 		Flags  -> ()
	 */
	void URBFrequencyMatchPanelComponent::OnCompletedGameplayCallback()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFrequencyMatchPanelComponent.OnCompletedGameplayCallback");
		
		URBFrequencyMatchPanelComponent_OnCompletedGameplayCallback_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBFrequencyMatchPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBFrequencyMatchPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFrequencyMatchPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNotificationUserWidget.Refuse
	 * 		Flags  -> ()
	 */
	void URBNotificationUserWidget::Refuse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNotificationUserWidget.Refuse");
		
		URBNotificationUserWidget_Refuse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNotificationUserWidget.Hide
	 * 		Flags  -> ()
	 */
	void URBNotificationUserWidget::Hide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNotificationUserWidget.Hide");
		
		URBNotificationUserWidget_Hide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNotificationUserWidget.Hidden
	 * 		Flags  -> ()
	 */
	void URBNotificationUserWidget::Hidden()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNotificationUserWidget.Hidden");
		
		URBNotificationUserWidget_Hidden_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNotificationUserWidget.Event_UpdateDisplayTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DisplayTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              totalDisplayTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBNotificationUserWidget::Event_UpdateDisplayTime(float DisplayTime, float totalDisplayTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNotificationUserWidget.Event_UpdateDisplayTime");
		
		URBNotificationUserWidget_Event_UpdateDisplayTime_Params params {};
		params.DisplayTime = DisplayTime;
		params.totalDisplayTime = totalDisplayTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNotificationUserWidget.Event_Show
	 * 		Flags  -> ()
	 */
	void URBNotificationUserWidget::Event_Show()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNotificationUserWidget.Event_Show");
		
		URBNotificationUserWidget_Event_Show_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNotificationUserWidget.Event_Refused
	 * 		Flags  -> ()
	 */
	void URBNotificationUserWidget::Event_Refused()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNotificationUserWidget.Event_Refused");
		
		URBNotificationUserWidget_Event_Refused_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNotificationUserWidget.Event_Hide
	 * 		Flags  -> ()
	 */
	void URBNotificationUserWidget::Event_Hide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNotificationUserWidget.Event_Hide");
		
		URBNotificationUserWidget_Event_Hide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNotificationUserWidget.Event_Blocked
	 * 		Flags  -> ()
	 */
	void URBNotificationUserWidget::Event_Blocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNotificationUserWidget.Event_Blocked");
		
		URBNotificationUserWidget_Event_Blocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNotificationUserWidget.Event_Accepted
	 * 		Flags  -> ()
	 */
	void URBNotificationUserWidget::Event_Accepted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNotificationUserWidget.Event_Accepted");
		
		URBNotificationUserWidget_Event_Accepted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNotificationUserWidget.Block
	 * 		Flags  -> ()
	 */
	void URBNotificationUserWidget::Block()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNotificationUserWidget.Block");
		
		URBNotificationUserWidget_Block_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNotificationUserWidget.Accept
	 * 		Flags  -> ()
	 */
	void URBNotificationUserWidget::Accept()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNotificationUserWidget.Accept");
		
		URBNotificationUserWidget_Accept_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNotificationUserWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNotificationUserWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNotificationUserWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBFriendInviteNotificationUserWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBFriendInviteNotificationUserWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFriendInviteNotificationUserWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBFunctionalTestManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBFunctionalTestManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFunctionalTestManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFXControlActor.BP_Deactivate
	 * 		Flags  -> ()
	 */
	void ARBFXControlActor::BP_Deactivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFXControlActor.BP_Deactivate");
		
		ARBFXControlActor_BP_Deactivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFXControlActor.BP_Activate
	 * 		Flags  -> ()
	 */
	void ARBFXControlActor::BP_Activate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFXControlActor.BP_Activate");
		
		ARBFXControlActor_BP_Activate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBFXControlActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBFXControlActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFXControlActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFXManager.SetBrightnessCalibrationMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHDR                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBFXManager::SetBrightnessCalibrationMode(bool bEnable, bool bHDR)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFXManager.SetBrightnessCalibrationMode");
		
		URBFXManager_SetBrightnessCalibrationMode_Params params {};
		params.bEnable = bEnable;
		params.bHDR = bHDR;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFXManager.EnableGameplayEffectsFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        controlName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBFXManager::EnableGameplayEffectsFor(const class FName& controlName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFXManager.EnableGameplayEffectsFor");
		
		URBFXManager_EnableGameplayEffectsFor_Params params {};
		params.controlName = controlName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFXManager.DisableGameplayEffectsFor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        controlName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBFXManager::DisableGameplayEffectsFor(const class FName& controlName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFXManager.DisableGameplayEffectsFor");
		
		URBFXManager_DisableGameplayEffectsFor_Params params {};
		params.controlName = controlName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFXManager.BP_StartAdditiveFOVAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCurveFloat*                                 FOVCurve                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBFXManager::BP_StartAdditiveFOVAnim(class UCurveFloat* FOVCurve)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFXManager.BP_StartAdditiveFOVAnim");
		
		URBFXManager_BP_StartAdditiveFOVAnim_Params params {};
		params.FOVCurve = FOVCurve;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBFXManager.BP_AreGameplayEffectsEnabled
	 * 		Flags  -> ()
	 */
	bool URBFXManager::BP_AreGameplayEffectsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBFXManager.BP_AreGameplayEffectsEnabled");
		
		URBFXManager_BP_AreGameplayEffectsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBFXManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBFXManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBFXManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_AllOfSubConditions.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_AllOfSubConditions::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_AllOfSubConditions");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_AnyOfSubConditions.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_AnyOfSubConditions::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_AnyOfSubConditions");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_AICondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_AICondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_AICondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameCondition_Blueprint.Event_EvaluateCondition
	 * 		Flags  -> ()
	 */
	bool URBGameCondition_Blueprint::Event_EvaluateCondition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameCondition_Blueprint.Event_EvaluateCondition");
		
		URBGameCondition_Blueprint_Event_EvaluateCondition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_Blueprint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_Blueprint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_Blueprint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_MinimumHealthyPlayers.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_MinimumHealthyPlayers::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_MinimumHealthyPlayers");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_MaxActiveBots.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_MaxActiveBots::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_MaxActiveBots");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_MaxBotsByType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_MaxBotsByType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_MaxBotsByType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_MaxBotsByTags.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_MaxBotsByTags::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_MaxBotsByTags");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_MaxParaspecialists.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_MaxParaspecialists::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_MaxParaspecialists");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_MaxPrimeAssets.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_MaxPrimeAssets::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_MaxPrimeAssets");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_StageTime.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_StageTime::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_StageTime");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_MinimumGameDifficulty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_MinimumGameDifficulty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_MinimumGameDifficulty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_Adversity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_Adversity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_Adversity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameCondition_TimeSinceLastSpecialSpawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameCondition_TimeSinceLastSpecialSpawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameCondition_TimeSinceLastSpecialSpawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameLoadOrderTestAgent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameLoadOrderTestAgent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameLoadOrderTestAgent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeBase.RespawnPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBController*                               RBController                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      StartSpot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayerSpawnType                                   SpawnType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBGameModeBase::RespawnPlayer(class ARBController* RBController, class AActor* StartSpot, EPlayerSpawnType SpawnType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeBase.RespawnPlayer");
		
		ARBGameModeBase_RespawnPlayer_Params params {};
		params.RBController = RBController;
		params.StartSpot = StartSpot;
		params.SpawnType = SpawnType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeBase.GetExpectedPlayerCount
	 * 		Flags  -> ()
	 */
	int32_t ARBGameModeBase::GetExpectedPlayerCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeBase.GetExpectedPlayerCount");
		
		ARBGameModeBase_GetExpectedPlayerCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGameModeBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGameModeBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameModeBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameMode.SetBackupPlayerRespawnPoint
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      respawnPoint                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameMode::SetBackupPlayerRespawnPoint(class AActor* respawnPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameMode.SetBackupPlayerRespawnPoint");
		
		ARBGameMode_SetBackupPlayerRespawnPoint_Params params {};
		params.respawnPoint = respawnPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameMode.OnPawnKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     instigatorActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     subjectActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameMode::OnPawnKilled(class ARBPawn* instigatorActor, class ARBPawn* subjectActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameMode.OnPawnKilled");
		
		ARBGameMode_OnPawnKilled_Params params {};
		params.instigatorActor = instigatorActor;
		params.subjectActor = subjectActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameMode.OnObjectiveCoordinatorStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBaseObjectiveCoordinator*                 coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EObjectiveCoordinatorState                         State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameMode::OnObjectiveCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* coordinator, EObjectiveCoordinatorState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameMode.OnObjectiveCoordinatorStateChanged");
		
		ARBGameMode_OnObjectiveCoordinatorStateChanged_Params params {};
		params.coordinator = coordinator;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameMode.IsStageStarted
	 * 		Flags  -> ()
	 */
	bool ARBGameMode::IsStageStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameMode.IsStageStarted");
		
		ARBGameMode_IsStageStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameMode.IsStageReady
	 * 		Flags  -> ()
	 */
	bool ARBGameMode::IsStageReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameMode.IsStageReady");
		
		ARBGameMode_IsStageReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameMode.HasAnyPlayerExitedStartingSAS
	 * 		Flags  -> ()
	 */
	bool ARBGameMode::HasAnyPlayerExitedStartingSAS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameMode.HasAnyPlayerExitedStartingSAS");
		
		ARBGameMode_HasAnyPlayerExitedStartingSAS_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameMode.GetPlayersReadyToRespawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class ARBController*>                       outPlayers                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ARBGameMode::GetPlayersReadyToRespawn(TArray<class ARBController*>* outPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameMode.GetPlayersReadyToRespawn");
		
		ARBGameMode_GetPlayersReadyToRespawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outPlayers != nullptr)
			*outPlayers = params.outPlayers;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameMode.Cheat_ForceMissionID
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        TrialId                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameMode::Cheat_ForceMissionID(const struct FRBMissionID& MissionID, const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameMode.Cheat_ForceMissionID");
		
		ARBGameMode_Cheat_ForceMissionID_Params params {};
		params.MissionID = MissionID;
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameMode.Cheat_ForceGamePhase
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGamePhase                                         gamePhase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameMode::Cheat_ForceGamePhase(EGamePhase gamePhase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameMode.Cheat_ForceGamePhase");
		
		ARBGameMode_Cheat_ForceGamePhase_Params params {};
		params.gamePhase = gamePhase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameMode.Cheat_ForceFailStage
	 * 		Flags  -> ()
	 */
	void ARBGameMode::Cheat_ForceFailStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameMode.Cheat_ForceFailStage");
		
		ARBGameMode_Cheat_ForceFailStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameMode.Cheat_DisableStageEnding
	 * 		Flags  -> ()
	 */
	void ARBGameMode::Cheat_DisableStageEnding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameMode.Cheat_DisableStageEnding");
		
		ARBGameMode_Cheat_DisableStageEnding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameMode.BP_GetCurrentStageID
	 * 		Flags  -> ()
	 */
	struct FRBStageID ARBGameMode::BP_GetCurrentStageID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameMode.BP_GetCurrentStageID");
		
		ARBGameMode_BP_GetCurrentStageID_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeLobby.StartRelease
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerController*                    RBLobbyPlayerController                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameModeLobby::StartRelease(class ARBLobbyPlayerController* RBLobbyPlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeLobby.StartRelease");
		
		ARBGameModeLobby_StartRelease_Params params {};
		params.RBLobbyPlayerController = RBLobbyPlayerController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeLobby.OnPawnKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     instigatorActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     subjectActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameModeLobby::OnPawnKilled(class ARBPawn* instigatorActor, class ARBPawn* subjectActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeLobby.OnPawnKilled");
		
		ARBGameModeLobby_OnPawnKilled_Params params {};
		params.instigatorActor = instigatorActor;
		params.subjectActor = subjectActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGameModeLobby.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGameModeLobby::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameModeLobby");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeMainMenu.RejoinSoloGameSession
	 * 		Flags  -> ()
	 */
	void ARBGameModeMainMenu::RejoinSoloGameSession()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeMainMenu.RejoinSoloGameSession");
		
		ARBGameModeMainMenu_RejoinSoloGameSession_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeMainMenu.RejoinParty
	 * 		Flags  -> ()
	 */
	void ARBGameModeMainMenu::RejoinParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeMainMenu.RejoinParty");
		
		ARBGameModeMainMenu_RejoinParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeMainMenu.OnOperationStatusChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bPending                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSucceeded                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameModeMainMenu::OnOperationStatusChanged(bool bPending, bool bSucceeded)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeMainMenu.OnOperationStatusChanged");
		
		ARBGameModeMainMenu_OnOperationStatusChanged_Params params {};
		params.bPending = bPending;
		params.bSucceeded = bSucceeded;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeMainMenu.OnMenuTransitionOutDone
	 * 		Flags  -> ()
	 */
	void ARBGameModeMainMenu::OnMenuTransitionOutDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeMainMenu.OnMenuTransitionOutDone");
		
		ARBGameModeMainMenu_OnMenuTransitionOutDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeMainMenu.OnMenuButtonClicked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMainMenuButton                                    Button                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameModeMainMenu::OnMenuButtonClicked(EMainMenuButton Button)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeMainMenu.OnMenuButtonClicked");
		
		ARBGameModeMainMenu_OnMenuButtonClicked_Params params {};
		params.Button = Button;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeMainMenu.OnInputKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInputEvent                                        EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGamepad                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameModeMainMenu::OnInputKey(const struct FKey& Key, EInputEvent EventType, bool bGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeMainMenu.OnInputKey");
		
		ARBGameModeMainMenu_OnInputKey_Params params {};
		params.Key = Key;
		params.EventType = EventType;
		params.bGamepad = bGamepad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeMainMenu.OnDisclaimerAcknowledged
	 * 		Flags  -> ()
	 */
	void ARBGameModeMainMenu::OnDisclaimerAcknowledged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeMainMenu.OnDisclaimerAcknowledged");
		
		ARBGameModeMainMenu_OnDisclaimerAcknowledged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeMainMenu.IsPlayEnabled
	 * 		Flags  -> ()
	 */
	bool ARBGameModeMainMenu::IsPlayEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeMainMenu.IsPlayEnabled");
		
		ARBGameModeMainMenu_IsPlayEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeMainMenu.CanRejoinSoloGameSession
	 * 		Flags  -> ()
	 */
	bool ARBGameModeMainMenu::CanRejoinSoloGameSession()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeMainMenu.CanRejoinSoloGameSession");
		
		ARBGameModeMainMenu_CanRejoinSoloGameSession_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeMainMenu.CanRejoinParty
	 * 		Flags  -> ()
	 */
	bool ARBGameModeMainMenu::CanRejoinParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeMainMenu.CanRejoinParty");
		
		ARBGameModeMainMenu_CanRejoinParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameModeMainMenu.CanPlay
	 * 		Flags  -> ()
	 */
	bool ARBGameModeMainMenu::CanPlay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameModeMainMenu.CanPlay");
		
		ARBGameModeMainMenu_CanPlay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGameModeMainMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGameModeMainMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameModeMainMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGamepadControlSchemeLayerEntry.UpdateIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTexture2D*                                  newIcon                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGamepadControlSchemeLayerEntry::UpdateIcon(class UTexture2D* newIcon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGamepadControlSchemeLayerEntry.UpdateIcon");
		
		URBGamepadControlSchemeLayerEntry_UpdateIcon_Params params {};
		params.newIcon = newIcon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGamepadControlSchemeLayerEntry.Event_UpdateDescription
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        newDescription                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBGamepadControlSchemeLayerEntry::Event_UpdateDescription(const class FText& newDescription)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGamepadControlSchemeLayerEntry.Event_UpdateDescription");
		
		URBGamepadControlSchemeLayerEntry_Event_UpdateDescription_Params params {};
		params.newDescription = newDescription;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGamepadControlSchemeLayerEntry.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGamepadControlSchemeLayerEntry::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGamepadControlSchemeLayerEntry");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGamepadControlSchemeLayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGamepadControlSchemeLayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGamepadControlSchemeLayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGamepadSpecificData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGamepadSpecificData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGamepadSpecificData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameplayAttributeManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameplayAttributeManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameplayAttributeManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameplayTriggerComponent.OnTriggeredChanged
	 * 		Flags  -> ()
	 */
	void URBGameplayTriggerComponent::OnTriggeredChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameplayTriggerComponent.OnTriggeredChanged");
		
		URBGameplayTriggerComponent_OnTriggeredChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameplayTriggerComponent.OnComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBGameplayTriggerComponent::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameplayTriggerComponent.OnComponentBeginOverlap");
		
		URBGameplayTriggerComponent_OnComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameplayTriggerComponent.OnActorOverlapped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameplayTriggerComponent::OnActorOverlapped(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameplayTriggerComponent.OnActorOverlapped");
		
		URBGameplayTriggerComponent_OnActorOverlapped_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameplayTriggerComponent.IsEnabled
	 * 		Flags  -> ()
	 */
	bool URBGameplayTriggerComponent::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameplayTriggerComponent.IsEnabled");
		
		URBGameplayTriggerComponent_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameplayTriggerComponent.GetOverlappingActors
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              out_Actors                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void URBGameplayTriggerComponent::GetOverlappingActors(TArray<class AActor*>* out_Actors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameplayTriggerComponent.GetOverlappingActors");
		
		URBGameplayTriggerComponent_GetOverlappingActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (out_Actors != nullptr)
			*out_Actors = params.out_Actors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameplayTriggerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameplayTriggerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameplayTriggerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameplayTriggerVolume.OnTriggeredEventBypass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBGameplayTriggerComponent*                 Trigger                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameplayTriggerVolume::OnTriggeredEventBypass(class URBGameplayTriggerComponent* Trigger)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameplayTriggerVolume.OnTriggeredEventBypass");
		
		ARBGameplayTriggerVolume_OnTriggeredEventBypass_Params params {};
		params.Trigger = Trigger;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameplayTriggerVolume.IsEnabled
	 * 		Flags  -> ()
	 */
	bool ARBGameplayTriggerVolume::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameplayTriggerVolume.IsEnabled");
		
		ARBGameplayTriggerVolume_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameplayTriggerVolume.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameplayTriggerVolume::BP_SetEnabled(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameplayTriggerVolume.BP_SetEnabled");
		
		ARBGameplayTriggerVolume_BP_SetEnabled_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameplayTriggerVolume.BP_Reset
	 * 		Flags  -> ()
	 */
	void ARBGameplayTriggerVolume::BP_Reset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameplayTriggerVolume.BP_Reset");
		
		ARBGameplayTriggerVolume_BP_Reset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGameplayTriggerVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGameplayTriggerVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameplayTriggerVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateBase.OnRep_LevelSeed
	 * 		Flags  -> ()
	 */
	void ARBGameStateBase::OnRep_LevelSeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateBase.OnRep_LevelSeed");
		
		ARBGameStateBase_OnRep_LevelSeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateBase.OnRep_FeatureSwitchOverrides
	 * 		Flags  -> ()
	 */
	void ARBGameStateBase::OnRep_FeatureSwitchOverrides()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateBase.OnRep_FeatureSwitchOverrides");
		
		ARBGameStateBase_OnRep_FeatureSwitchOverrides_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateBase.OnRep_ExpectedPlayerCount
	 * 		Flags  -> ()
	 */
	void ARBGameStateBase::OnRep_ExpectedPlayerCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateBase.OnRep_ExpectedPlayerCount");
		
		ARBGameStateBase_OnRep_ExpectedPlayerCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateBase.OnRep_EffectiveNumberOfPlayers
	 * 		Flags  -> ()
	 */
	void ARBGameStateBase::OnRep_EffectiveNumberOfPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateBase.OnRep_EffectiveNumberOfPlayers");
		
		ARBGameStateBase_OnRep_EffectiveNumberOfPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateBase.Multicast_StartClipboardCopyOfMsg
	 * 		Flags  -> ()
	 */
	void ARBGameStateBase::Multicast_StartClipboardCopyOfMsg()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateBase.Multicast_StartClipboardCopyOfMsg");
		
		ARBGameStateBase_Multicast_StartClipboardCopyOfMsg_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateBase.Multicast_PlayMurkoffAnnouncement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRBMurkoffAnnouncentAudioData>       murkoffAnnouncementAudioDatas                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMurkoffAnnouncentAudioData               stopAudioData                                              (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBGameStateBase::Multicast_PlayMurkoffAnnouncement(TArray<struct FRBMurkoffAnnouncentAudioData> murkoffAnnouncementAudioDatas, const struct FRBMurkoffAnnouncentAudioData& stopAudioData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateBase.Multicast_PlayMurkoffAnnouncement");
		
		ARBGameStateBase_Multicast_PlayMurkoffAnnouncement_Params params {};
		params.murkoffAnnouncementAudioDatas = murkoffAnnouncementAudioDatas;
		params.stopAudioData = stopAudioData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateBase.Multicast_OnPlayerRevived
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   instigatorActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   subjectActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameStateBase::Multicast_OnPlayerRevived(class ARBPlayer* instigatorActor, class ARBPlayer* subjectActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateBase.Multicast_OnPlayerRevived");
		
		ARBGameStateBase_Multicast_OnPlayerRevived_Params params {};
		params.instigatorActor = instigatorActor;
		params.subjectActor = subjectActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateBase.Multicast_FunctionalTestLog
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      serverMsg                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               failTest                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameStateBase::Multicast_FunctionalTestLog(const class FString& serverMsg, bool failTest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateBase.Multicast_FunctionalTestLog");
		
		ARBGameStateBase_Multicast_FunctionalTestLog_Params params {};
		params.serverMsg = serverMsg;
		params.failTest = failTest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateBase.Multicast_EndClipboardCopyOfMsg
	 * 		Flags  -> ()
	 */
	void ARBGameStateBase::Multicast_EndClipboardCopyOfMsg()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateBase.Multicast_EndClipboardCopyOfMsg");
		
		ARBGameStateBase_Multicast_EndClipboardCopyOfMsg_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateBase.GetGameSessionRegion
	 * 		Flags  -> ()
	 */
	class FString ARBGameStateBase::GetGameSessionRegion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateBase.GetGameSessionRegion");
		
		ARBGameStateBase_GetGameSessionRegion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateBase.BP_GetGameModePersistentData
	 * 		Flags  -> ()
	 */
	class URBGameModePersistentData* ARBGameStateBase::BP_GetGameModePersistentData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateBase.BP_GetGameModePersistentData");
		
		ARBGameStateBase_BP_GetGameModePersistentData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGameStateBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGameStateBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameStateBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.WasResetTimerSkipped
	 * 		Flags  -> ()
	 */
	bool ARBGameState::WasResetTimerSkipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.WasResetTimerSkipped");
		
		ARBGameState_WasResetTimerSkipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.WaitingForPlayers
	 * 		Flags  -> ()
	 */
	bool ARBGameState::WaitingForPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.WaitingForPlayers");
		
		ARBGameState_WaitingForPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.SetDrugSequenceCompleted
	 * 		Flags  -> ()
	 */
	void ARBGameState::SetDrugSequenceCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.SetDrugSequenceCompleted");
		
		ARBGameState_SetDrugSequenceCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.OnRep_ResetTimerSkipped
	 * 		Flags  -> ()
	 */
	void ARBGameState::OnRep_ResetTimerSkipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.OnRep_ResetTimerSkipped");
		
		ARBGameState_OnRep_ResetTimerSkipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.OnRep_LevelMusicPaused
	 * 		Flags  -> ()
	 */
	void ARBGameState::OnRep_LevelMusicPaused()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.OnRep_LevelMusicPaused");
		
		ARBGameState_OnRep_LevelMusicPaused_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.OnRep_GameStageInfo
	 * 		Flags  -> ()
	 */
	void ARBGameState::OnRep_GameStageInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.OnRep_GameStageInfo");
		
		ARBGameState_OnRep_GameStageInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.OnRep_GamePhase
	 * 		Flags  -> ()
	 */
	void ARBGameState::OnRep_GamePhase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.OnRep_GamePhase");
		
		ARBGameState_OnRep_GamePhase_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.OnRep_GameDifficulty
	 * 		Flags  -> ()
	 */
	void ARBGameState::OnRep_GameDifficulty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.OnRep_GameDifficulty");
		
		ARBGameState_OnRep_GameDifficulty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.OnRep_EndOfStageDamageTime
	 * 		Flags  -> ()
	 */
	void ARBGameState::OnRep_EndOfStageDamageTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.OnRep_EndOfStageDamageTime");
		
		ARBGameState_OnRep_EndOfStageDamageTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.OnRep_CurrentServerNarrativeMusicInfo
	 * 		Flags  -> ()
	 */
	void ARBGameState::OnRep_CurrentServerNarrativeMusicInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.OnRep_CurrentServerNarrativeMusicInfo");
		
		ARBGameState_OnRep_CurrentServerNarrativeMusicInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.OnRep_CurrentSAS
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBSAS*                                      oldSASValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameState::OnRep_CurrentSAS(class ARBSAS* oldSASValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.OnRep_CurrentSAS");
		
		ARBGameState_OnRep_CurrentSAS_Params params {};
		params.oldSASValue = oldSASValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.OnRep_CanPlayerRespawn
	 * 		Flags  -> ()
	 */
	void ARBGameState::OnRep_CanPlayerRespawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.OnRep_CanPlayerRespawn");
		
		ARBGameState_OnRep_CanPlayerRespawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.OnClientPopulateFinished
	 * 		Flags  -> ()
	 */
	void ARBGameState::OnClientPopulateFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.OnClientPopulateFinished");
		
		ARBGameState_OnClientPopulateFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.Multicast_ScareStinger
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      scareActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               StingerEvent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Range                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameState::Multicast_ScareStinger(class AActor* scareActor, class UAkAudioEvent* StingerEvent, const struct FVector& Location, float Range)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.Multicast_ScareStinger");
		
		ARBGameState_Multicast_ScareStinger_Params params {};
		params.scareActor = scareActor;
		params.StingerEvent = StingerEvent;
		params.Location = Location;
		params.Range = Range;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.Multicast_ApplyStageReset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FString>                              stageLevels                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBGameState::Multicast_ApplyStageReset(TArray<class FString> stageLevels)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.Multicast_ApplyStageReset");
		
		ARBGameState_Multicast_ApplyStageReset_Params params {};
		params.stageLevels = stageLevels;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.IsStageStarted
	 * 		Flags  -> ()
	 */
	bool ARBGameState::IsStageStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.IsStageStarted");
		
		ARBGameState_IsStageStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.IsStageReady
	 * 		Flags  -> ()
	 */
	bool ARBGameState::IsStageReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.IsStageReady");
		
		ARBGameState_IsStageReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.IsStagePrepared
	 * 		Flags  -> ()
	 */
	bool ARBGameState::IsStagePrepared()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.IsStagePrepared");
		
		ARBGameState_IsStagePrepared_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.IsSoloGame
	 * 		Flags  -> ()
	 */
	bool ARBGameState::IsSoloGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.IsSoloGame");
		
		ARBGameState_IsSoloGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.IsExperimentSuccess
	 * 		Flags  -> ()
	 */
	bool ARBGameState::IsExperimentSuccess()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.IsExperimentSuccess");
		
		ARBGameState_IsExperimentSuccess_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.IsExperimentStarted
	 * 		Flags  -> ()
	 */
	bool ARBGameState::IsExperimentStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.IsExperimentStarted");
		
		ARBGameState_IsExperimentStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.IsExperimentCompleted
	 * 		Flags  -> ()
	 */
	bool ARBGameState::IsExperimentCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.IsExperimentCompleted");
		
		ARBGameState_IsExperimentCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.IsEndOfStageDamageStarted
	 * 		Flags  -> ()
	 */
	bool ARBGameState::IsEndOfStageDamageStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.IsEndOfStageDamageStarted");
		
		ARBGameState_IsEndOfStageDamageStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.IsDrugSequenceCompleted
	 * 		Flags  -> ()
	 */
	bool ARBGameState::IsDrugSequenceCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.IsDrugSequenceCompleted");
		
		ARBGameState_IsDrugSequenceCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.GetTrialId
	 * 		Flags  -> ()
	 */
	class FName ARBGameState::GetTrialId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.GetTrialId");
		
		ARBGameState_GetTrialId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.GetStageID
	 * 		Flags  -> ()
	 */
	struct FRBStageID ARBGameState::GetStageID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.GetStageID");
		
		ARBGameState_GetStageID_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.GetMissionID
	 * 		Flags  -> ()
	 */
	struct FRBMissionID ARBGameState::GetMissionID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.GetMissionID");
		
		ARBGameState_GetMissionID_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameState.GetGameStageInfo
	 * 		Flags  -> ()
	 */
	struct FRBGameStageInfo ARBGameState::GetGameStageInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameState.GetGameStageInfo");
		
		ARBGameState_GetGameStageInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateLobby.OnRep_PlayerReleaseState
	 * 		Flags  -> ()
	 */
	void ARBGameStateLobby::OnRep_PlayerReleaseState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateLobby.OnRep_PlayerReleaseState");
		
		ARBGameStateLobby_OnRep_PlayerReleaseState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateLobby.OnRep_CharacterReleaseCount
	 * 		Flags  -> ()
	 */
	void ARBGameStateLobby::OnRep_CharacterReleaseCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateLobby.OnRep_CharacterReleaseCount");
		
		ARBGameStateLobby_OnRep_CharacterReleaseCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBGameStateLobby.OnPlayerReleaseStateUpdated__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlayerReleaseState                         PlayerReleaseState                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBGameStateLobby::OnPlayerReleaseStateUpdated__DelegateSignature(const struct FPlayerReleaseState& PlayerReleaseState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBGameStateLobby.OnPlayerReleaseStateUpdated__DelegateSignature");
		
		ARBGameStateLobby_OnPlayerReleaseStateUpdated__DelegateSignature_Params params {};
		params.PlayerReleaseState = PlayerReleaseState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBGameStateLobby.OnCharacterReleaseCountUpdated__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            characterReleaseCount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameStateLobby::OnCharacterReleaseCountUpdated__DelegateSignature(int32_t characterReleaseCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBGameStateLobby.OnCharacterReleaseCountUpdated__DelegateSignature");
		
		ARBGameStateLobby_OnCharacterReleaseCountUpdated__DelegateSignature_Params params {};
		params.characterReleaseCount = characterReleaseCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateLobby.Multicast_PlayLobbyAnnouncement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            announcementIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            announcementLineSeed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGameStateLobby::Multicast_PlayLobbyAnnouncement(int32_t announcementIndex, int32_t announcementLineSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateLobby.Multicast_PlayLobbyAnnouncement");
		
		ARBGameStateLobby_Multicast_PlayLobbyAnnouncement_Params params {};
		params.announcementIndex = announcementIndex;
		params.announcementLineSeed = announcementLineSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateLobby.IsPlayerReleasing
	 * 		Flags  -> ()
	 */
	bool ARBGameStateLobby::IsPlayerReleasing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateLobby.IsPlayerReleasing");
		
		ARBGameStateLobby_IsPlayerReleasing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateLobby.IsPlayerReleasePending
	 * 		Flags  -> ()
	 */
	bool ARBGameStateLobby::IsPlayerReleasePending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateLobby.IsPlayerReleasePending");
		
		ARBGameStateLobby_IsPlayerReleasePending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateLobby.GetPlayerReleaseState
	 * 		Flags  -> ()
	 */
	struct FPlayerReleaseState ARBGameStateLobby::GetPlayerReleaseState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateLobby.GetPlayerReleaseState");
		
		ARBGameStateLobby_GetPlayerReleaseState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateLobby.GetPlayerReleasePlayerState
	 * 		Flags  -> ()
	 */
	class ARBLobbyPlayerState* ARBGameStateLobby::GetPlayerReleasePlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateLobby.GetPlayerReleasePlayerState");
		
		ARBGameStateLobby_GetPlayerReleasePlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateLobby.GetPlayerReleaseExpirationServerTime
	 * 		Flags  -> ()
	 */
	float ARBGameStateLobby::GetPlayerReleaseExpirationServerTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateLobby.GetPlayerReleaseExpirationServerTime");
		
		ARBGameStateLobby_GetPlayerReleaseExpirationServerTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStateLobby.GetCharacterReleaseCount
	 * 		Flags  -> ()
	 */
	int32_t ARBGameStateLobby::GetCharacterReleaseCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStateLobby.GetCharacterReleaseCount");
		
		ARBGameStateLobby_GetCharacterReleaseCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGameStateLobby.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGameStateLobby::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameStateLobby");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGameStateMainMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGameStateMainMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameStateMainMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMissionInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMissionInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMissionInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBStageInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBStageInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBStageInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStructureConfig.IsReleaseTrial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBGameStructureConfig::IsReleaseTrial(const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStructureConfig.IsReleaseTrial");
		
		URBGameStructureConfig_IsReleaseTrial_Params params {};
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStructureConfig.GetVariatorInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBVariatorInfo* URBGameStructureConfig::GetVariatorInfo(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStructureConfig.GetVariatorInfo");
		
		URBGameStructureConfig_GetVariatorInfo_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStructureConfig.GetTrials
	 * 		Flags  -> ()
	 */
	TArray<struct FRBTrialInfoRow> URBGameStructureConfig::GetTrials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStructureConfig.GetTrials");
		
		URBGameStructureConfig_GetTrials_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStructureConfig.GetTrialInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBTrialInfoRow URBGameStructureConfig::GetTrialInfo(const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStructureConfig.GetTrialInfo");
		
		URBGameStructureConfig_GetTrialInfo_Params params {};
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStructureConfig.GetStageInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        StageID                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBStageInfo* URBGameStructureConfig::GetStageInfo(const class FName& StageID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStructureConfig.GetStageInfo");
		
		URBGameStructureConfig_GetStageInfo_Params params {};
		params.StageID = StageID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStructureConfig.GetProgramTrials
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ProgramId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FRBTrialInfoRow> URBGameStructureConfig::GetProgramTrials(const class FName& ProgramId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStructureConfig.GetProgramTrials");
		
		URBGameStructureConfig_GetProgramTrials_Params params {};
		params.ProgramId = ProgramId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStructureConfig.GetPrograms
	 * 		Flags  -> ()
	 */
	TArray<struct FRBProgramInfoRow> URBGameStructureConfig::GetPrograms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStructureConfig.GetPrograms");
		
		URBGameStructureConfig_GetPrograms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStructureConfig.GetProgramInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ProgramId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBProgramInfoRow URBGameStructureConfig::GetProgramInfo(const class FName& ProgramId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStructureConfig.GetProgramInfo");
		
		URBGameStructureConfig_GetProgramInfo_Params params {};
		params.ProgramId = ProgramId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameStructureConfig.FindBestTrialInfoFromDetails
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EGameDifficulty                                    Difficulty                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBTrialInfoRow URBGameStructureConfig::FindBestTrialInfoFromDetails(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, EGameDifficulty Difficulty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameStructureConfig.FindBestTrialInfoFromDetails");
		
		URBGameStructureConfig_FindBestTrialInfoFromDetails_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		params.Difficulty = Difficulty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameStructureConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameStructureConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameStructureConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSaveGameBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSaveGameBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSaveGameBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.UnBlock
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProfileId                                  ProfileId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::UnBlock(const struct FProfileId& ProfileId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.UnBlock");
		
		URBGameUserPreferences_UnBlock_Params params {};
		params.ProfileId = ProfileId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.ShouldShowSubtitles
	 * 		Flags  -> ()
	 */
	bool URBGameUserPreferences::ShouldShowSubtitles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.ShouldShowSubtitles");
		
		URBGameUserPreferences_ShouldShowSubtitles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.ShouldShowHud
	 * 		Flags  -> ()
	 */
	bool URBGameUserPreferences::ShouldShowHud()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.ShouldShowHud");
		
		URBGameUserPreferences_ShouldShowHud_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetUsePushToTalk
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInUsePushTotalk                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetUsePushToTalk(bool bInUsePushTotalk)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetUsePushToTalk");
		
		URBGameUserPreferences_SetUsePushToTalk_Params params {};
		params.bInUsePushTotalk = bInUsePushTotalk;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetTutorialSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EUIFontSize                                        Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetTutorialSize(EUIFontSize Size)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetTutorialSize");
		
		URBGameUserPreferences_SetTutorialSize_Params params {};
		params.Size = Size;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetSubtitleSize
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EUIFontSize                                        Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetSubtitleSize(EUIFontSize Size)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetSubtitleSize");
		
		URBGameUserPreferences_SetSubtitleSize_Params params {};
		params.Size = Size;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetStickyRunEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInStickyRun                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsGamepadOption                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetStickyRunEnabled(bool bInStickyRun, bool bIsGamepadOption)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetStickyRunEnabled");
		
		URBGameUserPreferences_SetStickyRunEnabled_Params params {};
		params.bInStickyRun = bInStickyRun;
		params.bIsGamepadOption = bIsGamepadOption;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetShowSubtitles
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShow                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetShowSubtitles(bool bShow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetShowSubtitles");
		
		URBGameUserPreferences_SetShowSubtitles_Params params {};
		params.bShow = bShow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetShowHud
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShow                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetShowHud(bool bShow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetShowHud");
		
		URBGameUserPreferences_SetShowHud_Params params {};
		params.bShow = bShow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetSFXVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InSFXVolume                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApply                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetSFXVolume(float InSFXVolume, bool bApply)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetSFXVolume");
		
		URBGameUserPreferences_SetSFXVolume_Params params {};
		params.InSFXVolume = InSFXVolume;
		params.bApply = bApply;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetPlayerVoiceChatVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProfileId                                  ProfileId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetPlayerVoiceChatVolume(const struct FProfileId& ProfileId, float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetPlayerVoiceChatVolume");
		
		URBGameUserPreferences_SetPlayerVoiceChatVolume_Params params {};
		params.ProfileId = ProfileId;
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetPartyPrivacy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPartyPrivacy                                      privacy                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetPartyPrivacy(EPartyPrivacy privacy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetPartyPrivacy");
		
		URBGameUserPreferences_SetPartyPrivacy_Params params {};
		params.privacy = privacy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetPartyInviteFilter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PartyInviteFilter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetPartyInviteFilter(int32_t PartyInviteFilter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetPartyInviteFilter");
		
		URBGameUserPreferences_SetPartyInviteFilter_Params params {};
		params.PartyInviteFilter = PartyInviteFilter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetNormalizedBrightness
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetNormalizedBrightness(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetNormalizedBrightness");
		
		URBGameUserPreferences_SetNormalizedBrightness_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetMusicVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InMusicVolume                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApply                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetMusicVolume(float InMusicVolume, bool bApply)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetMusicVolume");
		
		URBGameUserPreferences_SetMusicVolume_Params params {};
		params.InMusicVolume = InMusicVolume;
		params.bApply = bApply;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetMotionBlurEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetMotionBlurEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetMotionBlurEnabled");
		
		URBGameUserPreferences_SetMotionBlurEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetMicrophoneVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              InMicrophoneVolume                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetMicrophoneVolume(float InMicrophoneVolume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetMicrophoneVolume");
		
		URBGameUserPreferences_SetMicrophoneVolume_Params params {};
		params.InMicrophoneVolume = InMicrophoneVolume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetMasterVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              MasterVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApply                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetMasterVolume(float MasterVolume, bool bApply)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetMasterVolume");
		
		URBGameUserPreferences_SetMasterVolume_Params params {};
		params.MasterVolume = MasterVolume;
		params.bApply = bApply;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetLookSensitivityMultiplier
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetLookSensitivityMultiplier(const struct FVector& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetLookSensitivityMultiplier");
		
		URBGameUserPreferences_SetLookSensitivityMultiplier_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetHDRUILevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Level                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetHDRUILevel(float Level)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetHDRUILevel");
		
		URBGameUserPreferences_SetHDRUILevel_Params params {};
		params.Level = Level;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetHDRPaperwhite
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            paperwhite                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetHDRPaperwhite(int32_t paperwhite)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetHDRPaperwhite");
		
		URBGameUserPreferences_SetHDRPaperwhite_Params params {};
		params.paperwhite = paperwhite;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetGlobalVoiceChatVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetGlobalVoiceChatVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetGlobalVoiceChatVolume");
		
		URBGameUserPreferences_SetGlobalVoiceChatVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetEnableVoiceChat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInEnableVoiceChat                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetEnableVoiceChat(bool bInEnableVoiceChat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetEnableVoiceChat");
		
		URBGameUserPreferences_SetEnableVoiceChat_Params params {};
		params.bInEnableVoiceChat = bInEnableVoiceChat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetEnableRegion
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      region                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetEnableRegion(const class FString& region, bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetEnableRegion");
		
		URBGameUserPreferences_SetEnableRegion_Params params {};
		params.region = region;
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetEnableCrossPlay
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnableCrossPlay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetEnableCrossPlay(bool bEnableCrossPlay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetEnableCrossPlay");
		
		URBGameUserPreferences_SetEnableCrossPlay_Params params {};
		params.bEnableCrossPlay = bEnableCrossPlay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetBrightnessSettingsToDefaults
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHDR                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetBrightnessSettingsToDefaults(bool bHDR)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetBrightnessSettingsToDefaults");
		
		URBGameUserPreferences_SetBrightnessSettingsToDefaults_Params params {};
		params.bHDR = bHDR;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetAutoHideItemInHandEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInAutoHideItemInHand                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetAutoHideItemInHandEnabled(bool bInAutoHideItemInHand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetAutoHideItemInHandEnabled");
		
		URBGameUserPreferences_SetAutoHideItemInHandEnabled_Params params {};
		params.bInAutoHideItemInHand = bInAutoHideItemInHand;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SetAllowPartyMemberInvites
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bAllowPartyMemberInvites                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::SetAllowPartyMemberInvites(bool bAllowPartyMemberInvites)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SetAllowPartyMemberInvites");
		
		URBGameUserPreferences_SetAllowPartyMemberInvites_Params params {};
		params.bAllowPartyMemberInvites = bAllowPartyMemberInvites;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.SaveSettings
	 * 		Flags  -> ()
	 */
	void URBGameUserPreferences::SaveSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.SaveSettings");
		
		URBGameUserPreferences_SaveSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.IsVoiceActivityDetectorAuto
	 * 		Flags  -> ()
	 */
	bool URBGameUserPreferences::IsVoiceActivityDetectorAuto()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.IsVoiceActivityDetectorAuto");
		
		URBGameUserPreferences_IsVoiceActivityDetectorAuto_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.IsStickyRunEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsGamepadOption                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBGameUserPreferences::IsStickyRunEnabled(bool bIsGamepadOption)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.IsStickyRunEnabled");
		
		URBGameUserPreferences_IsStickyRunEnabled_Params params {};
		params.bIsGamepadOption = bIsGamepadOption;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.IsRegionEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      region                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBGameUserPreferences::IsRegionEnabled(const class FString& region)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.IsRegionEnabled");
		
		URBGameUserPreferences_IsRegionEnabled_Params params {};
		params.region = region;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.IsMotionBlurEnabled
	 * 		Flags  -> ()
	 */
	bool URBGameUserPreferences::IsMotionBlurEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.IsMotionBlurEnabled");
		
		URBGameUserPreferences_IsMotionBlurEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.IsBlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProfileId                                  ProfileId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBGameUserPreferences::IsBlocked(const struct FProfileId& ProfileId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.IsBlocked");
		
		URBGameUserPreferences_IsBlocked_Params params {};
		params.ProfileId = ProfileId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.IsBindingInverted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        BindingName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBGameUserPreferences::IsBindingInverted(const class FName& BindingName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.IsBindingInverted");
		
		URBGameUserPreferences_IsBindingInverted_Params params {};
		params.BindingName = BindingName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.IsAutoHideItemInHandEnabled
	 * 		Flags  -> ()
	 */
	bool URBGameUserPreferences::IsAutoHideItemInHandEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.IsAutoHideItemInHandEnabled");
		
		URBGameUserPreferences_IsAutoHideItemInHandEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetVoiceActivityDetectorSensitivity
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetVoiceActivityDetectorSensitivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetVoiceActivityDetectorSensitivity");
		
		URBGameUserPreferences_GetVoiceActivityDetectorSensitivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetVoiceActivityDetectorNoiseFloor
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetVoiceActivityDetectorNoiseFloor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetVoiceActivityDetectorNoiseFloor");
		
		URBGameUserPreferences_GetVoiceActivityDetectorNoiseFloor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetVoiceActivityDetectorHangover
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetVoiceActivityDetectorHangover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetVoiceActivityDetectorHangover");
		
		URBGameUserPreferences_GetVoiceActivityDetectorHangover_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetUsePushToTalk
	 * 		Flags  -> ()
	 */
	bool URBGameUserPreferences::GetUsePushToTalk()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetUsePushToTalk");
		
		URBGameUserPreferences_GetUsePushToTalk_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetTutorialSize
	 * 		Flags  -> ()
	 */
	EUIFontSize URBGameUserPreferences::GetTutorialSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetTutorialSize");
		
		URBGameUserPreferences_GetTutorialSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetTextLanguage
	 * 		Flags  -> ()
	 */
	class FString URBGameUserPreferences::GetTextLanguage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetTextLanguage");
		
		URBGameUserPreferences_GetTextLanguage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetTeammateStatusOutsideViewDisplay
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetTeammateStatusOutsideViewDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetTeammateStatusOutsideViewDisplay");
		
		URBGameUserPreferences_GetTeammateStatusOutsideViewDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetTeammateStatusInWorldDisplay
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetTeammateStatusInWorldDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetTeammateStatusInWorldDisplay");
		
		URBGameUserPreferences_GetTeammateStatusInWorldDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetTeammateStatusHUDDisplay
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetTeammateStatusHUDDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetTeammateStatusHUDDisplay");
		
		URBGameUserPreferences_GetTeammateStatusHUDDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetSubtitlesLanguage
	 * 		Flags  -> ()
	 */
	class FString URBGameUserPreferences::GetSubtitlesLanguage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetSubtitlesLanguage");
		
		URBGameUserPreferences_GetSubtitlesLanguage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetSubtitleSize
	 * 		Flags  -> ()
	 */
	EUIFontSize URBGameUserPreferences::GetSubtitleSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetSubtitleSize");
		
		URBGameUserPreferences_GetSubtitleSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetSubtitlesBackground
	 * 		Flags  -> ()
	 */
	bool URBGameUserPreferences::GetSubtitlesBackground()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetSubtitlesBackground");
		
		URBGameUserPreferences_GetSubtitlesBackground_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetStaminaDisplay
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetStaminaDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetStaminaDisplay");
		
		URBGameUserPreferences_GetStaminaDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetShowSubtitles
	 * 		Flags  -> ()
	 */
	bool URBGameUserPreferences::GetShowSubtitles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetShowSubtitles");
		
		URBGameUserPreferences_GetShowSubtitles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetSanityDisplay
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetSanityDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetSanityDisplay");
		
		URBGameUserPreferences_GetSanityDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetPlayerVoiceChatVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProfileId                                  ProfileId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBGameUserPreferences::GetPlayerVoiceChatVolume(const struct FProfileId& ProfileId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetPlayerVoiceChatVolume");
		
		URBGameUserPreferences_GetPlayerVoiceChatVolume_Params params {};
		params.ProfileId = ProfileId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetPartyPrivacy
	 * 		Flags  -> ()
	 */
	EPartyPrivacy URBGameUserPreferences::GetPartyPrivacy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetPartyPrivacy");
		
		URBGameUserPreferences_GetPartyPrivacy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetPartyInviteFilter
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetPartyInviteFilter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetPartyInviteFilter");
		
		URBGameUserPreferences_GetPartyInviteFilter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetObjectiveDisplay
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetObjectiveDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetObjectiveDisplay");
		
		URBGameUserPreferences_GetObjectiveDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetNoiseDisplay
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetNoiseDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetNoiseDisplay");
		
		URBGameUserPreferences_GetNoiseDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetMusicVolume
	 * 		Flags  -> ()
	 */
	float URBGameUserPreferences::GetMusicVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetMusicVolume");
		
		URBGameUserPreferences_GetMusicVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetMicrophoneVolume
	 * 		Flags  -> ()
	 */
	float URBGameUserPreferences::GetMicrophoneVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetMicrophoneVolume");
		
		URBGameUserPreferences_GetMicrophoneVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetMasterVolume
	 * 		Flags  -> ()
	 */
	float URBGameUserPreferences::GetMasterVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetMasterVolume");
		
		URBGameUserPreferences_GetMasterVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetLookSensitivityMultiplier
	 * 		Flags  -> ()
	 */
	struct FVector URBGameUserPreferences::GetLookSensitivityMultiplier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetLookSensitivityMultiplier");
		
		URBGameUserPreferences_GetLookSensitivityMultiplier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetInventoryDisplay
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetInventoryDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetInventoryDisplay");
		
		URBGameUserPreferences_GetInventoryDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetInterfacePreset
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetInterfacePreset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetInterfacePreset");
		
		URBGameUserPreferences_GetInterfacePreset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetHealthDisplay
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetHealthDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetHealthDisplay");
		
		URBGameUserPreferences_GetHealthDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetGlobalVoiceChatVolume
	 * 		Flags  -> ()
	 */
	float URBGameUserPreferences::GetGlobalVoiceChatVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetGlobalVoiceChatVolume");
		
		URBGameUserPreferences_GetGlobalVoiceChatVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetFriendsOnlineStatusNotifications
	 * 		Flags  -> ()
	 */
	bool URBGameUserPreferences::GetFriendsOnlineStatusNotifications()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetFriendsOnlineStatusNotifications");
		
		URBGameUserPreferences_GetFriendsOnlineStatusNotifications_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetEnableVoiceChat
	 * 		Flags  -> ()
	 */
	bool URBGameUserPreferences::GetEnableVoiceChat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetEnableVoiceChat");
		
		URBGameUserPreferences_GetEnableVoiceChat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetEffectsVolume
	 * 		Flags  -> ()
	 */
	float URBGameUserPreferences::GetEffectsVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetEffectsVolume");
		
		URBGameUserPreferences_GetEffectsVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetDarknessDisplay
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetDarknessDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetDarknessDisplay");
		
		URBGameUserPreferences_GetDarknessDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetCrosshairDisplay
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserPreferences::GetCrosshairDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetCrosshairDisplay");
		
		URBGameUserPreferences_GetCrosshairDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetAudioLanguage
	 * 		Flags  -> ()
	 */
	class FString URBGameUserPreferences::GetAudioLanguage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetAudioLanguage");
		
		URBGameUserPreferences_GetAudioLanguage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.GetAllowFriendRequestNotifications
	 * 		Flags  -> ()
	 */
	bool URBGameUserPreferences::GetAllowFriendRequestNotifications()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.GetAllowFriendRequestNotifications");
		
		URBGameUserPreferences_GetAllowFriendRequestNotifications_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.CrossPlayEnabled
	 * 		Flags  -> ()
	 */
	bool URBGameUserPreferences::CrossPlayEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.CrossPlayEnabled");
		
		URBGameUserPreferences_CrossPlayEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.Block
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProfileId                                  ProfileId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserPreferences::Block(const struct FProfileId& ProfileId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.Block");
		
		URBGameUserPreferences_Block_Params params {};
		params.ProfileId = ProfileId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.ApplyVoiceChatAudioSettings
	 * 		Flags  -> ()
	 */
	void URBGameUserPreferences::ApplyVoiceChatAudioSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.ApplyVoiceChatAudioSettings");
		
		URBGameUserPreferences_ApplyVoiceChatAudioSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserPreferences.AllowPartyMemberInvites
	 * 		Flags  -> ()
	 */
	bool URBGameUserPreferences::AllowPartyMemberInvites()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserPreferences.AllowPartyMemberInvites");
		
		URBGameUserPreferences_AllowPartyMemberInvites_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameUserPreferences.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameUserPreferences::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameUserPreferences");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBInputSettings_AZERTY.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBInputSettings_AZERTY::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInputSettings_AZERTY");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.UpdateQualityFromPreset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            presetValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserSettings::UpdateQualityFromPreset(int32_t presetValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.UpdateQualityFromPreset");
		
		URBGameUserSettings_UpdateQualityFromPreset_Params params {};
		params.presetValue = presetValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.SetQualityPreset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            presetValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserSettings::SetQualityPreset(int32_t presetValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.SetQualityPreset");
		
		URBGameUserSettings_SetQualityPreset_Params params {};
		params.presetValue = presetValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.SetDirect3DVersion
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGraphicsRHI                                       d3DVersion                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGameUserSettings::SetDirect3DVersion(EGraphicsRHI d3DVersion)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.SetDirect3DVersion");
		
		URBGameUserSettings_SetDirect3DVersion_Params params {};
		params.d3DVersion = d3DVersion;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.IsMotionBlurEnabled
	 * 		Flags  -> ()
	 */
	bool URBGameUserSettings::IsMotionBlurEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.IsMotionBlurEnabled");
		
		URBGameUserSettings_IsMotionBlurEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.IsMotionBlurDirty
	 * 		Flags  -> ()
	 */
	bool URBGameUserSettings::IsMotionBlurDirty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.IsMotionBlurDirty");
		
		URBGameUserSettings_IsMotionBlurDirty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.HasRTHardware
	 * 		Flags  -> ()
	 */
	bool URBGameUserSettings::HasRTHardware()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.HasRTHardware");
		
		URBGameUserSettings_HasRTHardware_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.HasResolutionChanged
	 * 		Flags  -> ()
	 */
	bool URBGameUserSettings::HasResolutionChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.HasResolutionChanged");
		
		URBGameUserSettings_HasResolutionChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.GetWantedDirect3DVersion
	 * 		Flags  -> ()
	 */
	EGraphicsRHI URBGameUserSettings::GetWantedDirect3DVersion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.GetWantedDirect3DVersion");
		
		URBGameUserSettings_GetWantedDirect3DVersion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.GetSetDirect3DVersion
	 * 		Flags  -> ()
	 */
	EGraphicsRHI URBGameUserSettings::GetSetDirect3DVersion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.GetSetDirect3DVersion");
		
		URBGameUserSettings_GetSetDirect3DVersion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.GetRTShadowsQuality
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserSettings::GetRTShadowsQuality()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.GetRTShadowsQuality");
		
		URBGameUserSettings_GetRTShadowsQuality_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.GetRTReflectionsQuality
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserSettings::GetRTReflectionsQuality()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.GetRTReflectionsQuality");
		
		URBGameUserSettings_GetRTReflectionsQuality_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.GetRTEnabled
	 * 		Flags  -> ()
	 */
	bool URBGameUserSettings::GetRTEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.GetRTEnabled");
		
		URBGameUserSettings_GetRTEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.GetQualityPreset
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserSettings::GetQualityPreset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.GetQualityPreset");
		
		URBGameUserSettings_GetQualityPreset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.GetFSR2Quality
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserSettings::GetFSR2Quality()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.GetFSR2Quality");
		
		URBGameUserSettings_GetFSR2Quality_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.GetDLSSQuality
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserSettings::GetDLSSQuality()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.GetDLSSQuality");
		
		URBGameUserSettings_GetDLSSQuality_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.GetCurrentDirect3DVersion
	 * 		Flags  -> ()
	 */
	EGraphicsRHI URBGameUserSettings::GetCurrentDirect3DVersion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.GetCurrentDirect3DVersion");
		
		URBGameUserSettings_GetCurrentDirect3DVersion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.GetBrightness
	 * 		Flags  -> ()
	 */
	float URBGameUserSettings::GetBrightness()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.GetBrightness");
		
		URBGameUserSettings_GetBrightness_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.GetAntiAliasingQuality
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserSettings::GetAntiAliasingQuality()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.GetAntiAliasingQuality");
		
		URBGameUserSettings_GetAntiAliasingQuality_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGameUserSettings.ComputeQualityPreset
	 * 		Flags  -> ()
	 */
	int32_t URBGameUserSettings::ComputeQualityPreset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGameUserSettings.ComputeQualityPreset");
		
		URBGameUserSettings_ComputeQualityPreset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGameUserSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGameUserSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGameUserSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGarageDoor.OnRep_HasJack
	 * 		Flags  -> ()
	 */
	void ARBGarageDoor::OnRep_HasJack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGarageDoor.OnRep_HasJack");
		
		ARBGarageDoor_OnRep_HasJack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGarageDoor.HasJack
	 * 		Flags  -> ()
	 */
	bool ARBGarageDoor::HasJack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGarageDoor.HasJack");
		
		ARBGarageDoor_HasJack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGarageDoor.GetCoopIconOffset
	 * 		Flags  -> ()
	 */
	struct FVector ARBGarageDoor::GetCoopIconOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGarageDoor.GetCoopIconOffset");
		
		ARBGarageDoor_GetCoopIconOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGarageDoor.Event_OnJackHoldingStop
	 * 		Flags  -> ()
	 */
	void ARBGarageDoor::Event_OnJackHoldingStop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGarageDoor.Event_OnJackHoldingStop");
		
		ARBGarageDoor_Event_OnJackHoldingStop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGarageDoor.Event_OnJackHoldingStart
	 * 		Flags  -> ()
	 */
	void ARBGarageDoor::Event_OnJackHoldingStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGarageDoor.Event_OnJackHoldingStart");
		
		ARBGarageDoor_Event_OnJackHoldingStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGarageDoor.ConstructGarageDoor
	 * 		Flags  -> ()
	 */
	void ARBGarageDoor::ConstructGarageDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGarageDoor.ConstructGarageDoor");
		
		ARBGarageDoor_ConstructGarageDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGarageDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGarageDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGarageDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGasTrapComponent.UntriggerGasTrap_Server
	 * 		Flags  -> ()
	 */
	void URBGasTrapComponent::UntriggerGasTrap_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGasTrapComponent.UntriggerGasTrap_Server");
		
		URBGasTrapComponent_UntriggerGasTrap_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGasTrapComponent.TriggerGasTrap_Server
	 * 		Flags  -> ()
	 */
	void URBGasTrapComponent::TriggerGasTrap_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGasTrapComponent.TriggerGasTrap_Server");
		
		URBGasTrapComponent_TriggerGasTrap_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGasTrapComponent.SnapToState
	 * 		Flags  -> ()
	 */
	void URBGasTrapComponent::SnapToState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGasTrapComponent.SnapToState");
		
		URBGasTrapComponent_SnapToState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGasTrapComponent.OnTrapEndOverlap_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGasTrapComponent::OnTrapEndOverlap_Server(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGasTrapComponent.OnTrapEndOverlap_Server");
		
		URBGasTrapComponent_OnTrapEndOverlap_Server_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGasTrapComponent.OnTrapBeginOverlap_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBGasTrapComponent::OnTrapBeginOverlap_Server(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGasTrapComponent.OnTrapBeginOverlap_Server");
		
		URBGasTrapComponent_OnTrapBeginOverlap_Server_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGasTrapComponent.OnRep_ScheduledEnabled
	 * 		Flags  -> ()
	 */
	void URBGasTrapComponent::OnRep_ScheduledEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGasTrapComponent.OnRep_ScheduledEnabled");
		
		URBGasTrapComponent_OnRep_ScheduledEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGasTrapComponent.EnabledChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGasTrapComponent::EnabledChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGasTrapComponent.EnabledChangedCallback");
		
		URBGasTrapComponent_EnabledChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGasTrapComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGasTrapComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGasTrapComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.OnRep_PreFueled
	 * 		Flags  -> ()
	 */
	void ARBGeneratorMultiObjectiveActor::OnRep_PreFueled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.OnRep_PreFueled");
		
		ARBGeneratorMultiObjectiveActor_OnRep_PreFueled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.OnRep_IsInteractible
	 * 		Flags  -> ()
	 */
	void ARBGeneratorMultiObjectiveActor::OnRep_IsInteractible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.OnRep_IsInteractible");
		
		ARBGeneratorMultiObjectiveActor_OnRep_IsInteractible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.OnRep_IsCompleted
	 * 		Flags  -> ()
	 */
	void ARBGeneratorMultiObjectiveActor::OnRep_IsCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.OnRep_IsCompleted");
		
		ARBGeneratorMultiObjectiveActor_OnRep_IsCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.OnPanelStateChanged_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     pawnInteracting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGeneratorMultiObjectiveActor::OnPanelStateChanged_Server(class URBInteractiblePanelComponent* panel, class ARBPawn* pawnInteracting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.OnPanelStateChanged_Server");
		
		ARBGeneratorMultiObjectiveActor_OnPanelStateChanged_Server_Params params {};
		params.panel = panel;
		params.pawnInteracting = pawnInteracting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.Multicast_OnBreak
	 * 		Flags  -> ()
	 */
	void ARBGeneratorMultiObjectiveActor::Multicast_OnBreak()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.Multicast_OnBreak");
		
		ARBGeneratorMultiObjectiveActor_Multicast_OnBreak_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.IsRightElectricPanelCompleted
	 * 		Flags  -> ()
	 */
	bool ARBGeneratorMultiObjectiveActor::IsRightElectricPanelCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.IsRightElectricPanelCompleted");
		
		ARBGeneratorMultiObjectiveActor_IsRightElectricPanelCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.IsLeftElectricPanelCompleted
	 * 		Flags  -> ()
	 */
	bool ARBGeneratorMultiObjectiveActor::IsLeftElectricPanelCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.IsLeftElectricPanelCompleted");
		
		ARBGeneratorMultiObjectiveActor_IsLeftElectricPanelCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.IsGasReservoirFilled
	 * 		Flags  -> ()
	 */
	bool ARBGeneratorMultiObjectiveActor::IsGasReservoirFilled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.IsGasReservoirFilled");
		
		ARBGeneratorMultiObjectiveActor_IsGasReservoirFilled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.IsCrankCompleted
	 * 		Flags  -> ()
	 */
	bool ARBGeneratorMultiObjectiveActor::IsCrankCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.IsCrankCompleted");
		
		ARBGeneratorMultiObjectiveActor_IsCrankCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.ForceComplete
	 * 		Flags  -> ()
	 */
	void ARBGeneratorMultiObjectiveActor::ForceComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.ForceComplete");
		
		ARBGeneratorMultiObjectiveActor_ForceComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.Event_OnPreFueledStateChanged
	 * 		Flags  -> ()
	 */
	void ARBGeneratorMultiObjectiveActor::Event_OnPreFueledStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.Event_OnPreFueledStateChanged");
		
		ARBGeneratorMultiObjectiveActor_Event_OnPreFueledStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.Event_OnInteractibleStateChanged
	 * 		Flags  -> ()
	 */
	void ARBGeneratorMultiObjectiveActor::Event_OnInteractibleStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.Event_OnInteractibleStateChanged");
		
		ARBGeneratorMultiObjectiveActor_Event_OnInteractibleStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.Event_OnCompletionStateChanged
	 * 		Flags  -> ()
	 */
	void ARBGeneratorMultiObjectiveActor::Event_OnCompletionStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.Event_OnCompletionStateChanged");
		
		ARBGeneratorMultiObjectiveActor_Event_OnCompletionStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.Event_OnBreak
	 * 		Flags  -> ()
	 */
	void ARBGeneratorMultiObjectiveActor::Event_OnBreak()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.Event_OnBreak");
		
		ARBGeneratorMultiObjectiveActor_Event_OnBreak_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorMultiObjectiveActor.Break_Server
	 * 		Flags  -> ()
	 */
	void ARBGeneratorMultiObjectiveActor::Break_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorMultiObjectiveActor.Break_Server");
		
		ARBGeneratorMultiObjectiveActor_Break_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGeneratorMultiObjectiveActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGeneratorMultiObjectiveActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGeneratorMultiObjectiveActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeInteractObjectiveCoordinator.OnRep_LockingLargePickupsActors
	 * 		Flags  -> ()
	 */
	void ARBLargeInteractObjectiveCoordinator::OnRep_LockingLargePickupsActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeInteractObjectiveCoordinator.OnRep_LockingLargePickupsActors");
		
		ARBLargeInteractObjectiveCoordinator_OnRep_LockingLargePickupsActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeInteractObjectiveCoordinator.OnRep_AvailableLargePickups
	 * 		Flags  -> ()
	 */
	void ARBLargeInteractObjectiveCoordinator::OnRep_AvailableLargePickups()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeInteractObjectiveCoordinator.OnRep_AvailableLargePickups");
		
		ARBLargeInteractObjectiveCoordinator_OnRep_AvailableLargePickups_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeInteractObjectiveCoordinator.OnPickupHolderChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBLargePickup*                              largePickup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLargeInteractObjectiveCoordinator::OnPickupHolderChanged(class ARBPawn* Player, class ARBLargePickup* largePickup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeInteractObjectiveCoordinator.OnPickupHolderChanged");
		
		ARBLargeInteractObjectiveCoordinator_OnPickupHolderChanged_Params params {};
		params.Player = Player;
		params.largePickup = largePickup;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeInteractObjectiveCoordinator.OnLargePickupUsedOnObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBLargePickup*                              largePickup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBLargeObjectInteractionPanelComponent*     interactible                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLargeInteractObjectiveCoordinator::OnLargePickupUsedOnObject(class ARBPawn* interactor, class ARBLargePickup* largePickup, class URBLargeObjectInteractionPanelComponent* interactible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeInteractObjectiveCoordinator.OnLargePickupUsedOnObject");
		
		ARBLargeInteractObjectiveCoordinator_OnLargePickupUsedOnObject_Params params {};
		params.interactor = interactor;
		params.largePickup = largePickup;
		params.interactible = interactible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeInteractObjectiveCoordinator.OnLargeObjectInteractionDoAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBLargeObjectInteractionPanelComponent*     largeObjectPanel                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBLargePickup*                              largePickup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLargeInteractObjectiveCoordinator::OnLargeObjectInteractionDoAction(class URBLargeObjectInteractionPanelComponent* largeObjectPanel, class ARBLargePickup* largePickup, class ARBPawn* interactor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeInteractObjectiveCoordinator.OnLargeObjectInteractionDoAction");
		
		ARBLargeInteractObjectiveCoordinator_OnLargeObjectInteractionDoAction_Params params {};
		params.largeObjectPanel = largeObjectPanel;
		params.largePickup = largePickup;
		params.interactor = interactor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeInteractObjectiveCoordinator.OnInteractibleAddedToWorld
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBInteractible*                             interactible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLargeInteractObjectiveCoordinator::OnInteractibleAddedToWorld(class ARBInteractible* interactible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeInteractObjectiveCoordinator.OnInteractibleAddedToWorld");
		
		ARBLargeInteractObjectiveCoordinator_OnInteractibleAddedToWorld_Params params {};
		params.interactible = interactible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargeInteractObjectiveCoordinator.GetAvailableLargePickups
	 * 		Flags  -> ()
	 */
	TArray<class ARBLargePickup*> ARBLargeInteractObjectiveCoordinator::GetAvailableLargePickups()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargeInteractObjectiveCoordinator.GetAvailableLargePickups");
		
		ARBLargeInteractObjectiveCoordinator_GetAvailableLargePickups_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBLargeInteractObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBLargeInteractObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLargeInteractObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorObjectiveCoordinator.OnRep_AllGeneratorRefueled
	 * 		Flags  -> ()
	 */
	void ARBGeneratorObjectiveCoordinator::OnRep_AllGeneratorRefueled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorObjectiveCoordinator.OnRep_AllGeneratorRefueled");
		
		ARBGeneratorObjectiveCoordinator_OnRep_AllGeneratorRefueled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorObjectiveCoordinator.OnGeneratorCompletedStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBGeneratorMultiObjectiveActor*             generator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBGeneratorObjectiveCoordinator::OnGeneratorCompletedStateChanged(class ARBGeneratorMultiObjectiveActor* generator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorObjectiveCoordinator.OnGeneratorCompletedStateChanged");
		
		ARBGeneratorObjectiveCoordinator_OnGeneratorCompletedStateChanged_Params params {};
		params.generator = generator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGeneratorObjectiveCoordinator.AreAllGeneratorFueled
	 * 		Flags  -> ()
	 */
	bool ARBGeneratorObjectiveCoordinator::AreAllGeneratorFueled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGeneratorObjectiveCoordinator.AreAllGeneratorFueled");
		
		ARBGeneratorObjectiveCoordinator_AreAllGeneratorFueled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGeneratorObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGeneratorObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGeneratorObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.UpdateVisibility
	 * 		Flags  -> ()
	 */
	void URBHUDElementWidget::UpdateVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.UpdateVisibility");
		
		URBHUDElementWidget_UpdateVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.ShouldShowBase
	 * 		Flags  -> ()
	 */
	bool URBHUDElementWidget::ShouldShowBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.ShouldShowBase");
		
		URBHUDElementWidget_ShouldShowBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.ShouldShow
	 * 		Flags  -> ()
	 */
	bool URBHUDElementWidget::ShouldShow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.ShouldShow");
		
		URBHUDElementWidget_ShouldShow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.ShouldForceShow
	 * 		Flags  -> ()
	 */
	bool URBHUDElementWidget::ShouldForceShow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.ShouldForceShow");
		
		URBHUDElementWidget_ShouldForceShow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.SetForcedShow
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               forcedShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDElementWidget::SetForcedShow(bool forcedShow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.SetForcedShow");
		
		URBHUDElementWidget_SetForcedShow_Params params {};
		params.forcedShow = forcedShow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.IsInValidHudMode
	 * 		Flags  -> ()
	 */
	bool URBHUDElementWidget::IsInValidHudMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.IsInValidHudMode");
		
		URBHUDElementWidget_IsInValidHudMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.GetWatchedPlayer
	 * 		Flags  -> ()
	 */
	class ARBPlayer* URBHUDElementWidget::GetWatchedPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.GetWatchedPlayer");
		
		URBHUDElementWidget_GetWatchedPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.GetHUDOpacity
	 * 		Flags  -> ()
	 */
	float URBHUDElementWidget::GetHUDOpacity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.GetHUDOpacity");
		
		URBHUDElementWidget_GetHUDOpacity_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.ForceShowForDuration
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDElementWidget::ForceShowForDuration(float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.ForceShowForDuration");
		
		URBHUDElementWidget_ForceShowForDuration_Params params {};
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.Event_Show
	 * 		Flags  -> ()
	 */
	void URBHUDElementWidget::Event_Show()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.Event_Show");
		
		URBHUDElementWidget_Event_Show_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.Event_OnWatchedPlayerChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   oldPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   NewPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDElementWidget::Event_OnWatchedPlayerChanged(class ARBPlayer* oldPlayer, class ARBPlayer* NewPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.Event_OnWatchedPlayerChanged");
		
		URBHUDElementWidget_Event_OnWatchedPlayerChanged_Params params {};
		params.oldPlayer = oldPlayer;
		params.NewPlayer = NewPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.Event_OnSpectatedPlayerChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   newSpectatedlPlayer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDElementWidget::Event_OnSpectatedPlayerChanged(class ARBPlayer* newSpectatedlPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.Event_OnSpectatedPlayerChanged");
		
		URBHUDElementWidget_Event_OnSpectatedPlayerChanged_Params params {};
		params.newSpectatedlPlayer = newSpectatedlPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.Event_OnResetHud
	 * 		Flags  -> ()
	 */
	void URBHUDElementWidget::Event_OnResetHud()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.Event_OnResetHud");
		
		URBHUDElementWidget_Event_OnResetHud_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.Event_OnLocalPlayerChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   oldLocalPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   newLocalPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDElementWidget::Event_OnLocalPlayerChanged(class ARBPlayer* oldLocalPlayer, class ARBPlayer* newLocalPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.Event_OnLocalPlayerChanged");
		
		URBHUDElementWidget_Event_OnLocalPlayerChanged_Params params {};
		params.oldLocalPlayer = oldLocalPlayer;
		params.newLocalPlayer = newLocalPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.Event_OnHudModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHudMode                                           newHudMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDElementWidget::Event_OnHudModeChanged(EHudMode newHudMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.Event_OnHudModeChanged");
		
		URBHUDElementWidget_Event_OnHudModeChanged_Params params {};
		params.newHudMode = newHudMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDElementWidget.Event_Hide
	 * 		Flags  -> ()
	 */
	void URBHUDElementWidget::Event_Hide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDElementWidget.Event_Hide");
		
		URBHUDElementWidget_Event_Hide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDElementWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDElementWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDElementWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRadialMenuBase.OnShow
	 * 		Flags  -> ()
	 */
	void URBRadialMenuBase::OnShow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRadialMenuBase.OnShow");
		
		URBRadialMenuBase_OnShow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRadialMenuBase.OnHide
	 * 		Flags  -> ()
	 */
	void URBRadialMenuBase::OnHide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRadialMenuBase.OnHide");
		
		URBRadialMenuBase_OnHide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRadialMenuBase.OnAddToSimulatedMouseLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector2D                                   amount                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRadialMenuBase::OnAddToSimulatedMouseLocation(const struct FVector2D& amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRadialMenuBase.OnAddToSimulatedMouseLocation");
		
		URBRadialMenuBase_OnAddToSimulatedMouseLocation_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRadialMenuBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRadialMenuBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRadialMenuBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGenericRadialMenu.Event_HighlightWheel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            wheelIndexValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGenericRadialMenu::Event_HighlightWheel(int32_t wheelIndexValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGenericRadialMenu.Event_HighlightWheel");
		
		URBGenericRadialMenu_Event_HighlightWheel_Params params {};
		params.wheelIndexValue = wheelIndexValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGenericRadialMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGenericRadialMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGenericRadialMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGhostAnimInstance.OnGhostAnimNotify
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGhostAnimEvent                                    animEvent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        animEventName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGhostAnimInstance::OnGhostAnimNotify(EGhostAnimEvent animEvent, const class FName& animEventName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGhostAnimInstance.OnGhostAnimNotify");
		
		URBGhostAnimInstance_OnGhostAnimNotify_Params params {};
		params.animEvent = animEvent;
		params.animEventName = animEventName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGhostAnimInstance.GetInteractableActor
	 * 		Flags  -> ()
	 */
	class AActor* URBGhostAnimInstance::GetInteractableActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGhostAnimInstance.GetInteractableActor");
		
		URBGhostAnimInstance_GetInteractableActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGhostAnimInstance.FinishGhost
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGhostFinishReason                                 finishReason                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            GhostFinishCustomReason                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBGhostAnimInstance::FinishGhost(EGhostFinishReason finishReason, int32_t GhostFinishCustomReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGhostAnimInstance.FinishGhost");
		
		URBGhostAnimInstance_FinishGhost_Params params {};
		params.finishReason = finishReason;
		params.GhostFinishCustomReason = GhostFinishCustomReason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGhostAnimInstance.BP_InitializeGhost
	 * 		Flags  -> ()
	 */
	void URBGhostAnimInstance::BP_InitializeGhost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGhostAnimInstance.BP_InitializeGhost");
		
		URBGhostAnimInstance_BP_InitializeGhost_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGhostAnimInstance.BP_ClearGhost
	 * 		Flags  -> ()
	 */
	void URBGhostAnimInstance::BP_ClearGhost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGhostAnimInstance.BP_ClearGhost");
		
		URBGhostAnimInstance_BP_ClearGhost_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGhostAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGhostAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGhostAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGlassFloorTrap.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGlassFloorTrap::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGlassFloorTrap");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGlobalAIConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGlobalAIConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGlobalAIConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAIDirectorConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAIDirectorConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAIDirectorConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNPCConfigRedirectors.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNPCConfigRedirectors::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNPCConfigRedirectors");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGlobalAnimConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGlobalAnimConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGlobalAnimConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGlobalAudioConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGlobalAudioConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGlobalAudioConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGlobalUIConfig.GetRandomRewardPoolDisplayDetails
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        RandomRewardPoolId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRandomRewardPoolDisplayDetails URBGlobalUIConfig::GetRandomRewardPoolDisplayDetails(const class FName& RandomRewardPoolId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGlobalUIConfig.GetRandomRewardPoolDisplayDetails");
		
		URBGlobalUIConfig_GetRandomRewardPoolDisplayDetails_Params params {};
		params.RandomRewardPoolId = RandomRewardPoolId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGlobalUIConfig.GetNPCSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMetaNPCType                                       NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FMetaNPCSettings URBGlobalUIConfig::GetNPCSettings(EMetaNPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGlobalUIConfig.GetNPCSettings");
		
		URBGlobalUIConfig_GetNPCSettings_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGlobalUIConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGlobalUIConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGlobalUIConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBGroundPushable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBGroundPushable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGroundPushable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.SetMaxDisplayNameLength
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            maxDisplayNameLength                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGroupStatusEntryWidget::SetMaxDisplayNameLength(int32_t maxDisplayNameLength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.SetMaxDisplayNameLength");
		
		URBGroupStatusEntryWidget_SetMaxDisplayNameLength_Params params {};
		params.maxDisplayNameLength = maxDisplayNameLength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.OnPlayerVoiceChatVolumeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProfileId                                  ProfileId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGroupStatusEntryWidget::OnPlayerVoiceChatVolumeChanged(const struct FProfileId& ProfileId, float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.OnPlayerVoiceChatVolumeChanged");
		
		URBGroupStatusEntryWidget_OnPlayerVoiceChatVolumeChanged_Params params {};
		params.ProfileId = ProfileId;
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.OnPlayerIndicatorUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerIndicatorType                               playerIndicatorType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              timeLeft                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              progress                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGroupStatusEntryWidget::OnPlayerIndicatorUpdated(EPlayerIndicatorType playerIndicatorType, float timeLeft, float progress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.OnPlayerIndicatorUpdated");
		
		URBGroupStatusEntryWidget_OnPlayerIndicatorUpdated_Params params {};
		params.playerIndicatorType = playerIndicatorType;
		params.timeLeft = timeLeft;
		params.progress = progress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.OnInventoryUpdated
	 * 		Flags  -> ()
	 */
	void URBGroupStatusEntryWidget::OnInventoryUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.OnInventoryUpdated");
		
		URBGroupStatusEntryWidget_OnInventoryUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.OnHealthUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGroupStatusEntryWidget::OnHealthUpdated(float newHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.OnHealthUpdated");
		
		URBGroupStatusEntryWidget_OnHealthUpdated_Params params {};
		params.newHealth = newHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.OnCurrentLoadoutChanged
	 * 		Flags  -> ()
	 */
	void URBGroupStatusEntryWidget::OnCurrentLoadoutChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.OnCurrentLoadoutChanged");
		
		URBGroupStatusEntryWidget_OnCurrentLoadoutChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.IsVoiceChatConnected
	 * 		Flags  -> ()
	 */
	bool URBGroupStatusEntryWidget::IsVoiceChatConnected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.IsVoiceChatConnected");
		
		URBGroupStatusEntryWidget_IsVoiceChatConnected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.IsSpeaking
	 * 		Flags  -> ()
	 */
	bool URBGroupStatusEntryWidget::IsSpeaking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.IsSpeaking");
		
		URBGroupStatusEntryWidget_IsSpeaking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.IsPartyOwner
	 * 		Flags  -> ()
	 */
	bool URBGroupStatusEntryWidget::IsPartyOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.IsPartyOwner");
		
		URBGroupStatusEntryWidget_IsPartyOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.IsMuted
	 * 		Flags  -> ()
	 */
	bool URBGroupStatusEntryWidget::IsMuted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.IsMuted");
		
		URBGroupStatusEntryWidget_IsMuted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.IsGloballyMuted
	 * 		Flags  -> ()
	 */
	bool URBGroupStatusEntryWidget::IsGloballyMuted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.IsGloballyMuted");
		
		URBGroupStatusEntryWidget_IsGloballyMuted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.IsBlocked
	 * 		Flags  -> ()
	 */
	bool URBGroupStatusEntryWidget::IsBlocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.IsBlocked");
		
		URBGroupStatusEntryWidget_IsBlocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.HasVoiceChatEnabled
	 * 		Flags  -> ()
	 */
	bool URBGroupStatusEntryWidget::HasVoiceChatEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.HasVoiceChatEnabled");
		
		URBGroupStatusEntryWidget_HasVoiceChatEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.GetPlayerState
	 * 		Flags  -> ()
	 */
	class ARBPlayerState* URBGroupStatusEntryWidget::GetPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.GetPlayerState");
		
		URBGroupStatusEntryWidget_GetPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.GetPlayerIndicatorType
	 * 		Flags  -> ()
	 */
	EPlayerIndicatorType URBGroupStatusEntryWidget::GetPlayerIndicatorType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.GetPlayerIndicatorType");
		
		URBGroupStatusEntryWidget_GetPlayerIndicatorType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.GetPlayerIndicatorTimeLeft
	 * 		Flags  -> ()
	 */
	float URBGroupStatusEntryWidget::GetPlayerIndicatorTimeLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.GetPlayerIndicatorTimeLeft");
		
		URBGroupStatusEntryWidget_GetPlayerIndicatorTimeLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.GetPlayerIndicatorIconProgress
	 * 		Flags  -> ()
	 */
	float URBGroupStatusEntryWidget::GetPlayerIndicatorIconProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.GetPlayerIndicatorIconProgress");
		
		URBGroupStatusEntryWidget_GetPlayerIndicatorIconProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.GetMaxDisplayNameLength
	 * 		Flags  -> ()
	 */
	int32_t URBGroupStatusEntryWidget::GetMaxDisplayNameLength()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.GetMaxDisplayNameLength");
		
		URBGroupStatusEntryWidget_GetMaxDisplayNameLength_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.GetDisplayName
	 * 		Flags  -> ()
	 */
	class FString URBGroupStatusEntryWidget::GetDisplayName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.GetDisplayName");
		
		URBGroupStatusEntryWidget_GetDisplayName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.GetActiveSkillType
	 * 		Flags  -> ()
	 */
	EActiveSkillType URBGroupStatusEntryWidget::GetActiveSkillType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.GetActiveSkillType");
		
		URBGroupStatusEntryWidget_GetActiveSkillType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.Event_Refresh_ObjectiveItemsCount
	 * 		Flags  -> ()
	 */
	void URBGroupStatusEntryWidget::Event_Refresh_ObjectiveItemsCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.Event_Refresh_ObjectiveItemsCount");
		
		URBGroupStatusEntryWidget_Event_Refresh_ObjectiveItemsCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.Event_Refresh_MaxHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newMaxHealth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGroupStatusEntryWidget::Event_Refresh_MaxHealth(float newMaxHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.Event_Refresh_MaxHealth");
		
		URBGroupStatusEntryWidget_Event_Refresh_MaxHealth_Params params {};
		params.newMaxHealth = newMaxHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.Event_Refresh_Health
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               skipAnim                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGroupStatusEntryWidget::Event_Refresh_Health(float newHealth, bool skipAnim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.Event_Refresh_Health");
		
		URBGroupStatusEntryWidget_Event_Refresh_Health_Params params {};
		params.newHealth = newHealth;
		params.skipAnim = skipAnim;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.Event_Refresh_Audio
	 * 		Flags  -> ()
	 */
	void URBGroupStatusEntryWidget::Event_Refresh_Audio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.Event_Refresh_Audio");
		
		URBGroupStatusEntryWidget_Event_Refresh_Audio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBGroupStatusEntryWidget::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.Event_Refresh");
		
		URBGroupStatusEntryWidget_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.Event_PlayerStatusUpdated
	 * 		Flags  -> ()
	 */
	void URBGroupStatusEntryWidget::Event_PlayerStatusUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.Event_PlayerStatusUpdated");
		
		URBGroupStatusEntryWidget_Event_PlayerStatusUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.Event_OnPlayerSASChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBSAS*                                      currentSAS                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBGroupStatusEntryWidget::Event_OnPlayerSASChanged(class ARBPlayerState* RBPlayerState, class ARBSAS* currentSAS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.Event_OnPlayerSASChanged");
		
		URBGroupStatusEntryWidget_Event_OnPlayerSASChanged_Params params {};
		params.RBPlayerState = RBPlayerState;
		params.currentSAS = currentSAS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusEntryWidget.Event_MaxDisplayNameLengthUpdated
	 * 		Flags  -> ()
	 */
	void URBGroupStatusEntryWidget::Event_MaxDisplayNameLengthUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusEntryWidget.Event_MaxDisplayNameLengthUpdated");
		
		URBGroupStatusEntryWidget_Event_MaxDisplayNameLengthUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGroupStatusEntryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGroupStatusEntryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGroupStatusEntryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusWidget.GetEntries
	 * 		Flags  -> ()
	 */
	TArray<class URBGroupStatusEntryWidget*> URBGroupStatusWidget::GetEntries()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusWidget.GetEntries");
		
		URBGroupStatusWidget_GetEntries_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBGroupStatusWidget.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBGroupStatusWidget::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBGroupStatusWidget.Event_Refresh");
		
		URBGroupStatusWidget_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBGroupStatusWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBGroupStatusWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBGroupStatusWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.OnStageStartedPawnTimestampChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHackPanelComponent::OnStageStartedPawnTimestampChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.OnStageStartedPawnTimestampChangedCallback");
		
		URBHackPanelComponent_OnStageStartedPawnTimestampChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.OnRep_StageStartedPawnTimestamp
	 * 		Flags  -> ()
	 */
	void URBHackPanelComponent::OnRep_StageStartedPawnTimestamp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.OnRep_StageStartedPawnTimestamp");
		
		URBHackPanelComponent_OnRep_StageStartedPawnTimestamp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.OnRep_QuadrantStates
	 * 		Flags  -> ()
	 */
	void URBHackPanelComponent::OnRep_QuadrantStates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.OnRep_QuadrantStates");
		
		URBHackPanelComponent_OnRep_QuadrantStates_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.OnRep_NumberOfTripLeft
	 * 		Flags  -> ()
	 */
	void URBHackPanelComponent::OnRep_NumberOfTripLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.OnRep_NumberOfTripLeft");
		
		URBHackPanelComponent_OnRep_NumberOfTripLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.OnRep_LastRatio
	 * 		Flags  -> ()
	 */
	void URBHackPanelComponent::OnRep_LastRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.OnRep_LastRatio");
		
		URBHackPanelComponent_OnRep_LastRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.OnNumberOfTripLeftChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHackPanelComponent::OnNumberOfTripLeftChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.OnNumberOfTripLeftChangedCallback");
		
		URBHackPanelComponent_OnNumberOfTripLeftChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.OnLastRatioChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHackPanelComponent::OnLastRatioChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.OnLastRatioChangedCallback");
		
		URBHackPanelComponent_OnLastRatioChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.Multicast_SetInteractionPawnTimestamp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              interactionPawnTimeStamp                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              needleRatio                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHackPanelComponent::Multicast_SetInteractionPawnTimestamp(float interactionPawnTimeStamp, float needleRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.Multicast_SetInteractionPawnTimestamp");
		
		URBHackPanelComponent_Multicast_SetInteractionPawnTimestamp_Params params {};
		params.interactionPawnTimeStamp = interactionPawnTimeStamp;
		params.needleRatio = needleRatio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.Multicast_OnStageSucceeded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHackPanelComponent::Multicast_OnStageSucceeded(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.Multicast_OnStageSucceeded");
		
		URBHackPanelComponent_Multicast_OnStageSucceeded_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.Multicast_OnStageStarted
	 * 		Flags  -> ()
	 */
	void URBHackPanelComponent::Multicast_OnStageStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.Multicast_OnStageStarted");
		
		URBHackPanelComponent_Multicast_OnStageStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.Multicast_OnStageSoftFail
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHackPanelComponent::Multicast_OnStageSoftFail(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.Multicast_OnStageSoftFail");
		
		URBHackPanelComponent_Multicast_OnStageSoftFail_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.Multicast_OnStageNeutral
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHackPanelComponent::Multicast_OnStageNeutral(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.Multicast_OnStageNeutral");
		
		URBHackPanelComponent_Multicast_OnStageNeutral_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.Multicast_OnStageFailed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHackPanelComponent::Multicast_OnStageFailed(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.Multicast_OnStageFailed");
		
		URBHackPanelComponent_Multicast_OnStageFailed_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.Multicast_OnPanelSucceeded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHackPanelComponent::Multicast_OnPanelSucceeded(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.Multicast_OnPanelSucceeded");
		
		URBHackPanelComponent_Multicast_OnPanelSucceeded_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.Multicast_OnBrokenByProjectile
	 * 		Flags  -> ()
	 */
	void URBHackPanelComponent::Multicast_OnBrokenByProjectile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.Multicast_OnBrokenByProjectile");
		
		URBHackPanelComponent_Multicast_OnBrokenByProjectile_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.BP_TemporaryDisable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHackPanelComponent::BP_TemporaryDisable(float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.BP_TemporaryDisable");
		
		URBHackPanelComponent_BP_TemporaryDisable_Params params {};
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.BP_OnUnlockAnimationDone
	 * 		Flags  -> ()
	 */
	void URBHackPanelComponent::BP_OnUnlockAnimationDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.BP_OnUnlockAnimationDone");
		
		URBHackPanelComponent_BP_OnUnlockAnimationDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHackPanelComponent.BP_GetNumberOfStageLeft
	 * 		Flags  -> ()
	 */
	int32_t URBHackPanelComponent::BP_GetNumberOfStageLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHackPanelComponent.BP_GetNumberOfStageLeft");
		
		URBHackPanelComponent_BP_GetNumberOfStageLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHackPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHackPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHackPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHallucinationConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHallucinationConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHallucinationConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHalluCfg_AlteredControls.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHalluCfg_AlteredControls::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHalluCfg_AlteredControls");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHalluCfg_Psychosis.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHalluCfg_Psychosis::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHalluCfg_Psychosis");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHalluCfg_LSDEffectBurst.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHalluCfg_LSDEffectBurst::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHalluCfg_LSDEffectBurst");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHalluCfg_DizzynessBurst.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHalluCfg_DizzynessBurst::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHalluCfg_DizzynessBurst");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPsychosisBraketsCfg.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPsychosisBraketsCfg::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPsychosisBraketsCfg");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBBaseSpectreCfg.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBBaseSpectreCfg::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBBaseSpectreCfg");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSpectreCfg.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSpectreCfg::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSpectreCfg");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPsychosisSpookCfg.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPsychosisSpookCfg::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPsychosisSpookCfg");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHallucinationManager.OnGamePhaseUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGamePhase                                         gamePhase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHallucinationManager::OnGamePhaseUpdated(EGamePhase gamePhase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHallucinationManager.OnGamePhaseUpdated");
		
		ARBHallucinationManager_OnGamePhaseUpdated_Params params {};
		params.gamePhase = gamePhase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHallucinationManager.Multicast_SetBracketsConfigOverride
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPsychosisBraketsCfg*                      Config                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHallucinationManager::Multicast_SetBracketsConfigOverride(class URBPsychosisBraketsCfg* Config)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHallucinationManager.Multicast_SetBracketsConfigOverride");
		
		ARBHallucinationManager_Multicast_SetBracketsConfigOverride_Params params {};
		params.Config = Config;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHallucinationManager.Multicast_ReplaceSpectreConfig
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSpectreCfg*                               Config                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHallucinationManager::Multicast_ReplaceSpectreConfig(class URBSpectreCfg* Config)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHallucinationManager.Multicast_ReplaceSpectreConfig");
		
		ARBHallucinationManager_Multicast_ReplaceSpectreConfig_Params params {};
		params.Config = Config;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHallucinationManager.GetMaxBracketAmount
	 * 		Flags  -> ()
	 */
	int32_t ARBHallucinationManager::GetMaxBracketAmount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHallucinationManager.GetMaxBracketAmount");
		
		ARBHallucinationManager_GetMaxBracketAmount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHallucinationManager.Event_Init
	 * 		Flags  -> ()
	 */
	void ARBHallucinationManager::Event_Init()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHallucinationManager.Event_Init");
		
		ARBHallucinationManager_Event_Init_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHallucinationManager.Event_HallucinationStopped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHallucinationData                          halluData                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBHallucinationManager::Event_HallucinationStopped(const struct FHallucinationData& halluData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHallucinationManager.Event_HallucinationStopped");
		
		ARBHallucinationManager_Event_HallucinationStopped_Params params {};
		params.halluData = halluData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHallucinationManager.Event_HallucinationStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHallucinationData                          halluData                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBHallucinationManager::Event_HallucinationStarted(const struct FHallucinationData& halluData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHallucinationManager.Event_HallucinationStarted");
		
		ARBHallucinationManager_Event_HallucinationStarted_Params params {};
		params.halluData = halluData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHallucinationManager.BP_SetBracketsConfigOverride
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPsychosisBraketsCfg*                      Config                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHallucinationManager::BP_SetBracketsConfigOverride(class URBPsychosisBraketsCfg* Config)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHallucinationManager.BP_SetBracketsConfigOverride");
		
		ARBHallucinationManager_BP_SetBracketsConfigOverride_Params params {};
		params.Config = Config;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHallucinationManager.BP_ReplaceSpectreConfig
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSpectreCfg*                               Config                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHallucinationManager::BP_ReplaceSpectreConfig(class URBSpectreCfg* Config)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHallucinationManager.BP_ReplaceSpectreConfig");
		
		ARBHallucinationManager_BP_ReplaceSpectreConfig_Params params {};
		params.Config = Config;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBHallucinationManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBHallucinationManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHallucinationManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHingedSceneComponent.OnComponentEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHingedSceneComponent::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHingedSceneComponent.OnComponentEndOverlap");
		
		URBHingedSceneComponent_OnComponentEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHingedSceneComponent.OnComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBHingedSceneComponent::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHingedSceneComponent.OnComponentBeginOverlap");
		
		URBHingedSceneComponent_OnComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHingedSceneComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHingedSceneComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHingedSceneComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHitNPCObjectiveCoordinator.OnRep_CurrentRoundCompletion
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHitNPCObjectiveCoordinator::OnRep_CurrentRoundCompletion(float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHitNPCObjectiveCoordinator.OnRep_CurrentRoundCompletion");
		
		ARBHitNPCObjectiveCoordinator_OnRep_CurrentRoundCompletion_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHitNPCObjectiveCoordinator.OnNPCHitByProjectile
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     thrower                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Projectile                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsHeadshot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHitNPCObjectiveCoordinator::OnNPCHitByProjectile(class ARBNPC* Target, class ARBPawn* thrower, class AActor* Projectile, bool bIsHeadshot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHitNPCObjectiveCoordinator.OnNPCHitByProjectile");
		
		ARBHitNPCObjectiveCoordinator_OnNPCHitByProjectile_Params params {};
		params.Target = Target;
		params.thrower = thrower;
		params.Projectile = Projectile;
		params.bIsHeadshot = bIsHeadshot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHitNPCObjectiveCoordinator.Multicast_OnNextRoundStarted
	 * 		Flags  -> ()
	 */
	void ARBHitNPCObjectiveCoordinator::Multicast_OnNextRoundStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHitNPCObjectiveCoordinator.Multicast_OnNextRoundStarted");
		
		ARBHitNPCObjectiveCoordinator_Multicast_OnNextRoundStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHitNPCObjectiveCoordinator.Event_OnNPCHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHeadshot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHitNPCObjectiveCoordinator::Event_OnNPCHit(class ARBNPC* NPC, bool bHeadshot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHitNPCObjectiveCoordinator.Event_OnNPCHit");
		
		ARBHitNPCObjectiveCoordinator_Event_OnNPCHit_Params params {};
		params.NPC = NPC;
		params.bHeadshot = bHeadshot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBHitNPCObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBHitNPCObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHitNPCObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.ShouldBPTick
	 * 		Flags  -> ()
	 */
	bool ARBLargePickup::ShouldBPTick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.ShouldBPTick");
		
		ARBLargePickup_ShouldBPTick_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.OnWorldFullyLoaded_Implementation
	 * 		Flags  -> ()
	 */
	void ARBLargePickup::OnWorldFullyLoaded_Implementation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.OnWorldFullyLoaded_Implementation");
		
		ARBLargePickup_OnWorldFullyLoaded_Implementation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.OnUsedOnObjectChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLargePickup::OnUsedOnObjectChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.OnUsedOnObjectChangedCallback");
		
		ARBLargePickup_OnUsedOnObjectChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.OnRep_UsedOnObject
	 * 		Flags  -> ()
	 */
	void ARBLargePickup::OnRep_UsedOnObject()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.OnRep_UsedOnObject");
		
		ARBLargePickup_OnRep_UsedOnObject_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.OnRep_Toss
	 * 		Flags  -> ()
	 */
	void ARBLargePickup::OnRep_Toss()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.OnRep_Toss");
		
		ARBLargePickup_OnRep_Toss_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.OnRep_PickupTransform
	 * 		Flags  -> ()
	 */
	void ARBLargePickup::OnRep_PickupTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.OnRep_PickupTransform");
		
		ARBLargePickup_OnRep_PickupTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.OnRep_HoldingPawn
	 * 		Flags  -> ()
	 */
	void ARBLargePickup::OnRep_HoldingPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.OnRep_HoldingPawn");
		
		ARBLargePickup_OnRep_HoldingPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.OnPickupTransformChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLargePickup::OnPickupTransformChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.OnPickupTransformChangedCallback");
		
		ARBLargePickup_OnPickupTransformChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.OnHoldingPawnChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLargePickup::OnHoldingPawnChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.OnHoldingPawnChangedCallback");
		
		ARBLargePickup_OnHoldingPawnChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.IsUsedOnObject
	 * 		Flags  -> ()
	 */

	UFunction* fnIsUsedOnObject = nullptr;
	bool ARBLargePickup::IsUsedOnObject()
	{
		if (!fnIsUsedOnObject)
			fnIsUsedOnObject = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.IsUsedOnObject");
		
		ARBLargePickup_IsUsedOnObject_Params params {};
		
		auto flags = fnIsUsedOnObject->FunctionFlags;
		UObject::ProcessEvent(fnIsUsedOnObject, &params);
		fnIsUsedOnObject->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.IsUsable
	 * 		Flags  -> ()
	 */
	bool ARBLargePickup::IsUsable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.IsUsable");
		
		ARBLargePickup_IsUsable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.IsConsideredActiveForObjective
	 * 		Flags  -> ()
	 */
	bool ARBLargePickup::IsConsideredActiveForObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.IsConsideredActiveForObjective");
		
		ARBLargePickup_IsConsideredActiveForObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.GetUsedOnObject
	 * 		Flags  -> ()
	 */
	class URBLargeObjectInteractionPanelComponent* ARBLargePickup::GetUsedOnObject()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.GetUsedOnObject");
		
		ARBLargePickup_GetUsedOnObject_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.GetHoldingPlayer
	 * 		Flags  -> ()
	 */
	class ARBPlayer* ARBLargePickup::GetHoldingPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.GetHoldingPlayer");
		
		ARBLargePickup_GetHoldingPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.GetHoldingPawn
	 * 		Flags  -> ()
	 */
	class ARBPawn* ARBLargePickup::GetHoldingPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.GetHoldingPawn");
		
		ARBLargePickup_GetHoldingPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.GetCustomPickupInteractionText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        out_CustomInteractionText                                  (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool ARBLargePickup::GetCustomPickupInteractionText(class ARBPlayer* Player, class FText* out_CustomInteractionText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.GetCustomPickupInteractionText");
		
		ARBLargePickup_GetCustomPickupInteractionText_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (out_CustomInteractionText != nullptr)
			*out_CustomInteractionText = params.out_CustomInteractionText;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.GetCustomDropInteractionText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        out_CustomInteractionText                                  (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool ARBLargePickup::GetCustomDropInteractionText(class ARBPlayer* Player, class FText* out_CustomInteractionText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.GetCustomDropInteractionText");
		
		ARBLargePickup_GetCustomDropInteractionText_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (out_CustomInteractionText != nullptr)
			*out_CustomInteractionText = params.out_CustomInteractionText;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.Event_OnUsedOnInteractible
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBLargeObjectInteractionPanelComponent*     interactible                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLargePickup::Event_OnUsedOnInteractible(class ARBPawn* interactor, class URBLargeObjectInteractionPanelComponent* interactible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.Event_OnUsedOnInteractible");
		
		ARBLargePickup_Event_OnUsedOnInteractible_Params params {};
		params.interactor = interactor;
		params.interactible = interactible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.BP_ShouldPlayAnimAfterAdjustPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBLargePickup::BP_ShouldPlayAnimAfterAdjustPosition(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.BP_ShouldPlayAnimAfterAdjustPosition");
		
		ARBLargePickup_BP_ShouldPlayAnimAfterAdjustPosition_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.BP_SetDesiredTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                                  desiredTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLargePickup::BP_SetDesiredTransform(const struct FTransform& desiredTransform, float delay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.BP_SetDesiredTransform");
		
		ARBLargePickup_BP_SetDesiredTransform_Params params {};
		params.desiredTransform = desiredTransform;
		params.delay = delay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.BP_PlaySequence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequence*                               Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLargePickup::BP_PlaySequence(class UAnimSequence* Sequence)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.BP_PlaySequence");
		
		ARBLargePickup_BP_PlaySequence_Params params {};
		params.Sequence = Sequence;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLargePickup.BP_OnHoldingPawnChanged
	 * 		Flags  -> ()
	 */
	void ARBLargePickup::BP_OnHoldingPawnChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLargePickup.BP_OnHoldingPawnChanged");
		
		ARBLargePickup_BP_OnHoldingPawnChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBLargePickup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBLargePickup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLargePickup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotato.OnRep_ObjectiveProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHotPotato::OnRep_ObjectiveProgress(float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotato.OnRep_ObjectiveProgress");
		
		ARBHotPotato_OnRep_ObjectiveProgress_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotato.OnRep_IsDamageTimerActive
	 * 		Flags  -> ()
	 */
	void ARBHotPotato::OnRep_IsDamageTimerActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotato.OnRep_IsDamageTimerActive");
		
		ARBHotPotato_OnRep_IsDamageTimerActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotato.OnRep_HotPotatoState
	 * 		Flags  -> ()
	 */
	void ARBHotPotato::OnRep_HotPotatoState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotato.OnRep_HotPotatoState");
		
		ARBHotPotato_OnRep_HotPotatoState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotato.IsHotPotatoEnabled
	 * 		Flags  -> ()
	 */
	bool ARBHotPotato::IsHotPotatoEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotato.IsHotPotatoEnabled");
		
		ARBHotPotato_IsHotPotatoEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotato.IsHotPotatoCompletedOrExpired
	 * 		Flags  -> ()
	 */
	bool ARBHotPotato::IsHotPotatoCompletedOrExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotato.IsHotPotatoCompletedOrExpired");
		
		ARBHotPotato_IsHotPotatoCompletedOrExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotato.IsHotPotatoActivated
	 * 		Flags  -> ()
	 */
	bool ARBHotPotato::IsHotPotatoActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotato.IsHotPotatoActivated");
		
		ARBHotPotato_IsHotPotatoActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotato.Event_OnStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHotPotatoState                                    newState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHotPotato::Event_OnStateChanged(EHotPotatoState newState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotato.Event_OnStateChanged");
		
		ARBHotPotato_Event_OnStateChanged_Params params {};
		params.newState = newState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotato.Event_OnObjectiveProgressChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newProgress                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              oldProgress                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHotPotato::Event_OnObjectiveProgressChanged(float newProgress, float oldProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotato.Event_OnObjectiveProgressChanged");
		
		ARBHotPotato_Event_OnObjectiveProgressChanged_Params params {};
		params.newProgress = newProgress;
		params.oldProgress = oldProgress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotato.Event_OnIsDamageTimerActiveChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               isDamageTimerActive                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHotPotato::Event_OnIsDamageTimerActiveChanged(bool isDamageTimerActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotato.Event_OnIsDamageTimerActiveChanged");
		
		ARBHotPotato_Event_OnIsDamageTimerActiveChanged_Params params {};
		params.isDamageTimerActive = isDamageTimerActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBHotPotato.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBHotPotato::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHotPotato");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBDistanceHotPotato.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBDistanceHotPotato::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDistanceHotPotato");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotatoObjectiveCoordinator.OnRep_CurrentHotPotatos
	 * 		Flags  -> ()
	 */
	void ARBHotPotatoObjectiveCoordinator::OnRep_CurrentHotPotatos()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotatoObjectiveCoordinator.OnRep_CurrentHotPotatos");
		
		ARBHotPotatoObjectiveCoordinator_OnRep_CurrentHotPotatos_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotatoObjectiveCoordinator.OnHotPotatoStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBHotPotato*                                hotPotato                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EHotPotatoState                                    newState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHotPotatoObjectiveCoordinator::OnHotPotatoStateChanged(class ARBHotPotato* hotPotato, EHotPotatoState newState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotatoObjectiveCoordinator.OnHotPotatoStateChanged");
		
		ARBHotPotatoObjectiveCoordinator_OnHotPotatoStateChanged_Params params {};
		params.hotPotato = hotPotato;
		params.newState = newState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotatoObjectiveCoordinator.OnHotPotatoObjectiveProgressChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBHotPotato*                                hotPotato                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              newProgress                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHotPotatoObjectiveCoordinator::OnHotPotatoObjectiveProgressChanged(class ARBHotPotato* hotPotato, float newProgress, float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotatoObjectiveCoordinator.OnHotPotatoObjectiveProgressChanged");
		
		ARBHotPotatoObjectiveCoordinator_OnHotPotatoObjectiveProgressChanged_Params params {};
		params.hotPotato = hotPotato;
		params.newProgress = newProgress;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotatoObjectiveCoordinator.Multicast_OnNewHotPotatoSpawned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBHotPotato*                                newHotPotato                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHotPotatoObjectiveCoordinator::Multicast_OnNewHotPotatoSpawned(class ARBHotPotato* newHotPotato)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotatoObjectiveCoordinator.Multicast_OnNewHotPotatoSpawned");
		
		ARBHotPotatoObjectiveCoordinator_Multicast_OnNewHotPotatoSpawned_Params params {};
		params.newHotPotato = newHotPotato;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBHotPotatoObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBHotPotatoObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHotPotatoObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotatoSpawner.OnRep_SpawnedHotPotato
	 * 		Flags  -> ()
	 */
	void ARBHotPotatoSpawner::OnRep_SpawnedHotPotato()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotatoSpawner.OnRep_SpawnedHotPotato");
		
		ARBHotPotatoSpawner_OnRep_SpawnedHotPotato_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotatoSpawner.OnRep_HasPotatoMoved
	 * 		Flags  -> ()
	 */
	void ARBHotPotatoSpawner::OnRep_HasPotatoMoved()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotatoSpawner.OnRep_HasPotatoMoved");
		
		ARBHotPotatoSpawner_OnRep_HasPotatoMoved_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotatoSpawner.OnRep_HasPotatoCompleted
	 * 		Flags  -> ()
	 */
	void ARBHotPotatoSpawner::OnRep_HasPotatoCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotatoSpawner.OnRep_HasPotatoCompleted");
		
		ARBHotPotatoSpawner_OnRep_HasPotatoCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotatoSpawner.OnPickupHolderChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBLargePickup*                              largePickup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHotPotatoSpawner::OnPickupHolderChanged(class ARBPawn* Pawn, class ARBLargePickup* largePickup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotatoSpawner.OnPickupHolderChanged");
		
		ARBHotPotatoSpawner_OnPickupHolderChanged_Params params {};
		params.Pawn = Pawn;
		params.largePickup = largePickup;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotatoSpawner.OnHotPotatoStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBHotPotato*                                hotPotato                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EHotPotatoState                                    newState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHotPotatoSpawner::OnHotPotatoStateChanged(class ARBHotPotato* hotPotato, EHotPotatoState newState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotatoSpawner.OnHotPotatoStateChanged");
		
		ARBHotPotatoSpawner_OnHotPotatoStateChanged_Params params {};
		params.hotPotato = hotPotato;
		params.newState = newState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotatoSpawner.Event_OnSpawnedHotPotato
	 * 		Flags  -> ()
	 */
	void ARBHotPotatoSpawner::Event_OnSpawnedHotPotato()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotatoSpawner.Event_OnSpawnedHotPotato");
		
		ARBHotPotatoSpawner_Event_OnSpawnedHotPotato_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotatoSpawner.Event_OnPotatoMoved
	 * 		Flags  -> ()
	 */
	void ARBHotPotatoSpawner::Event_OnPotatoMoved()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotatoSpawner.Event_OnPotatoMoved");
		
		ARBHotPotatoSpawner_Event_OnPotatoMoved_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHotPotatoSpawner.Event_OnPotatoCompleted
	 * 		Flags  -> ()
	 */
	void ARBHotPotatoSpawner::Event_OnPotatoCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHotPotatoSpawner.Event_OnPotatoCompleted");
		
		ARBHotPotatoSpawner_Event_OnPotatoCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBHotPotatoSpawner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBHotPotatoSpawner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHotPotatoSpawner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMinigameProgressHUDOwner.GetHUDMinigameProgressRatio
	 * 		Flags  -> ()
	 */
	float URBMinigameProgressHUDOwner::GetHUDMinigameProgressRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMinigameProgressHUDOwner.GetHUDMinigameProgressRatio");
		
		URBMinigameProgressHUDOwner_GetHUDMinigameProgressRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMinigameProgressHUDOwner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMinigameProgressHUDOwner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMinigameProgressHUDOwner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.UpdateWorldIconProjection
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SizeX                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SizeY                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOutsideOfRange                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              outsideRangeDirectionAngle                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector ARBHUD::UpdateWorldIconProjection(int32_t Index, int32_t SizeX, int32_t SizeY, bool* bOutsideOfRange, float* outsideRangeDirectionAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.UpdateWorldIconProjection");
		
		ARBHUD_UpdateWorldIconProjection_Params params {};
		params.Index = Index;
		params.SizeX = SizeX;
		params.SizeY = SizeY;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bOutsideOfRange != nullptr)
			*bOutsideOfRange = params.bOutsideOfRange;
		if (outsideRangeDirectionAngle != nullptr)
			*outsideRangeDirectionAngle = params.outsideRangeDirectionAngle;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.StopTransitionFeedback
	 * 		Flags  -> ()
	 */
	void ARBHUD::StopTransitionFeedback()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.StopTransitionFeedback");
		
		ARBHUD_StopTransitionFeedback_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.ShouldDisplayExtraInfo
	 * 		Flags  -> ()
	 */
	bool ARBHUD::ShouldDisplayExtraInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.ShouldDisplayExtraInfo");
		
		ARBHUD_ShouldDisplayExtraInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.SetForcedConsideredInSASForHUD
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsForcedConsideredInSAS                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::SetForcedConsideredInSASForHUD(bool bIsForcedConsideredInSAS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.SetForcedConsideredInSASForHUD");
		
		ARBHUD_SetForcedConsideredInSASForHUD_Params params {};
		params.bIsForcedConsideredInSAS = bIsForcedConsideredInSAS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.PlayerActionStatusChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerActionStatus                                status                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::PlayerActionStatusChanged__DelegateSignature(EPlayerActionStatus status)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.PlayerActionStatusChanged__DelegateSignature");
		
		ARBHUD_PlayerActionStatusChanged__DelegateSignature_Params params {};
		params.status = status;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnUpdateInventoryDisplay__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBHUD::OnUpdateInventoryDisplay__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnUpdateInventoryDisplay__DelegateSignature");
		
		ARBHUD_OnUpdateInventoryDisplay__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnToggledPsychosisDebug__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::OnToggledPsychosisDebug__DelegateSignature(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnToggledPsychosisDebug__DelegateSignature");
		
		ARBHUD_OnToggledPsychosisDebug__DelegateSignature_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.OnStartSpectatingPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::OnStartSpectatingPlayer(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.OnStartSpectatingPlayer");
		
		ARBHUD_OnStartSpectatingPlayer_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.OnStageEnded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               isRestarting                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::OnStageEnded(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, bool isRestarting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.OnStageEnded");
		
		ARBHUD_OnStageEnded_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		params.isRestarting = isRestarting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnShowTutorialMessage__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::OnShowTutorialMessage__DelegateSignature(const class FText& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnShowTutorialMessage__DelegateSignature");
		
		ARBHUD_OnShowTutorialMessage__DelegateSignature_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnShowTalkWheel__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBHUD::OnShowTalkWheel__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnShowTalkWheel__DelegateSignature");
		
		ARBHUD_OnShowTalkWheel__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnShowInventoryWheel__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInventoryWheelMode                                Mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::OnShowInventoryWheel__DelegateSignature(EInventoryWheelMode Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnShowInventoryWheel__DelegateSignature");
		
		ARBHUD_OnShowInventoryWheel__DelegateSignature_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnShowHUDTutorial__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHUDTutorialTextData                        tutorialData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::OnShowHUDTutorial__DelegateSignature(const struct FHUDTutorialTextData& tutorialData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnShowHUDTutorial__DelegateSignature");
		
		ARBHUD_OnShowHUDTutorial__DelegateSignature_Params params {};
		params.tutorialData = tutorialData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnShowGameMessage__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        gameMessage                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EGameMessageCategory                               messageCategory                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EGameObjectiveType                                 gameObjectiveType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameMessageAudioParams                     audioParams                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::OnShowGameMessage__DelegateSignature(const class FText& gameMessage, EGameMessageCategory messageCategory, EGameObjectiveType gameObjectiveType, const struct FGameMessageAudioParams& audioParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnShowGameMessage__DelegateSignature");
		
		ARBHUD_OnShowGameMessage__DelegateSignature_Params params {};
		params.gameMessage = gameMessage;
		params.messageCategory = messageCategory;
		params.gameObjectiveType = gameObjectiveType;
		params.audioParams = audioParams;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnShowEndOfStageScreen__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FEndStageInfo                               screenInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::OnShowEndOfStageScreen__DelegateSignature(const struct FEndStageInfo& screenInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnShowEndOfStageScreen__DelegateSignature");
		
		ARBHUD_OnShowEndOfStageScreen__DelegateSignature_Params params {};
		params.screenInfo = screenInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnRequestDisplayObjectiveHUD__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBHUD::OnRequestDisplayObjectiveHUD__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnRequestDisplayObjectiveHUD__DelegateSignature");
		
		ARBHUD_OnRequestDisplayObjectiveHUD__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnMinigameProgressHUDOwnerChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      progressOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::OnMinigameProgressHUDOwnerChanged__DelegateSignature(class AActor* progressOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnMinigameProgressHUDOwnerChanged__DelegateSignature");
		
		ARBHUD_OnMinigameProgressHUDOwnerChanged__DelegateSignature_Params params {};
		params.progressOwner = progressOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.OnLocalPlayerInit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::OnLocalPlayerInit(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.OnLocalPlayerInit");
		
		ARBHUD_OnLocalPlayerInit_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.OnLeaveSpectatorMode
	 * 		Flags  -> ()
	 */
	void ARBHUD::OnLeaveSpectatorMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.OnLeaveSpectatorMode");
		
		ARBHUD_OnLeaveSpectatorMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnInventoryWheelIndexChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::OnInventoryWheelIndexChanged__DelegateSignature(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnInventoryWheelIndexChanged__DelegateSignature");
		
		ARBHUD_OnInventoryWheelIndexChanged__DelegateSignature_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnHudUserConfigChanged__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBHUD::OnHudUserConfigChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnHudUserConfigChanged__DelegateSignature");
		
		ARBHUD_OnHudUserConfigChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnHudActionProgressChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newProgress                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::OnHudActionProgressChanged__DelegateSignature(float newProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnHudActionProgressChanged__DelegateSignature");
		
		ARBHUD_OnHudActionProgressChanged__DelegateSignature_Params params {};
		params.newProgress = newProgress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnHideTutorialMessage__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBHUD::OnHideTutorialMessage__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnHideTutorialMessage__DelegateSignature");
		
		ARBHUD_OnHideTutorialMessage__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnHideTalkWheel__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBHUD::OnHideTalkWheel__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnHideTalkWheel__DelegateSignature");
		
		ARBHUD_OnHideTalkWheel__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnHideInventoryWheel__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBHUD::OnHideInventoryWheel__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnHideInventoryWheel__DelegateSignature");
		
		ARBHUD_OnHideInventoryWheel__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnHideHUDTutorial__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBHUD::OnHideHUDTutorial__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnHideHUDTutorial__DelegateSignature");
		
		ARBHUD_OnHideHUDTutorial__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnDrawHud__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBHUD::OnDrawHud__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnDrawHud__DelegateSignature");
		
		ARBHUD_OnDrawHud__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBHUD.OnAddToSimulatedMouseLocation__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector2D                                   amount                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::OnAddToSimulatedMouseLocation__DelegateSignature(const struct FVector2D& amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBHUD.OnAddToSimulatedMouseLocation__DelegateSignature");
		
		ARBHUD_OnAddToSimulatedMouseLocation__DelegateSignature_Params params {};
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.GetStageIntroRemainingTime
	 * 		Flags  -> ()
	 */
	float ARBHUD::GetStageIntroRemainingTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.GetStageIntroRemainingTime");
		
		ARBHUD_GetStageIntroRemainingTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.GetMinigameProgressHUDOwner
	 * 		Flags  -> ()
	 */
	class AActor* ARBHUD::GetMinigameProgressHUDOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.GetMinigameProgressHUDOwner");
		
		ARBHUD_GetMinigameProgressHUDOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.EnableIconTypes
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EWorldIconType                                     Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::EnableIconTypes(EWorldIconType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.EnableIconTypes");
		
		ARBHUD_EnableIconTypes_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.DisableIconTypes
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EWorldIconType                                     Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::DisableIconTypes(EWorldIconType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.DisableIconTypes");
		
		ARBHUD_DisableIconTypes_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.BP_TryClearMinigameProgressHUDOwner
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      progressOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::BP_TryClearMinigameProgressHUDOwner(class AActor* progressOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.BP_TryClearMinigameProgressHUDOwner");
		
		ARBHUD_BP_TryClearMinigameProgressHUDOwner_Params params {};
		params.progressOwner = progressOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.BP_ShouldDrawWorldIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOutsideOfRange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBHUD::BP_ShouldDrawWorldIcon(int32_t Index, bool bOutsideOfRange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.BP_ShouldDrawWorldIcon");
		
		ARBHUD_BP_ShouldDrawWorldIcon_Params params {};
		params.Index = Index;
		params.bOutsideOfRange = bOutsideOfRange;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.BP_SetMinigameProgressHUDOwner
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      progressOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::BP_SetMinigameProgressHUDOwner(class AActor* progressOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.BP_SetMinigameProgressHUDOwner");
		
		ARBHUD_BP_SetMinigameProgressHUDOwner_Params params {};
		params.progressOwner = progressOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.BP_SetAlwaysDisplayGotoIcons
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               alwaysDisplayGotoIcons                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::BP_SetAlwaysDisplayGotoIcons(bool alwaysDisplayGotoIcons)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.BP_SetAlwaysDisplayGotoIcons");
		
		ARBHUD_BP_SetAlwaysDisplayGotoIcons_Params params {};
		params.alwaysDisplayGotoIcons = alwaysDisplayGotoIcons;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.BP_RemoveWorldIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::BP_RemoveWorldIcon(const class FName& ID, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.BP_RemoveWorldIcon");
		
		ARBHUD_BP_RemoveWorldIcon_Params params {};
		params.ID = ID;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.BP_GetWorldIconNum
	 * 		Flags  -> ()
	 */
	int32_t ARBHUD::BP_GetWorldIconNum()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.BP_GetWorldIconNum");
		
		ARBHUD_BP_GetWorldIconNum_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.BP_GetPsychosisDebugHudEnabled
	 * 		Flags  -> ()
	 */
	bool ARBHUD::BP_GetPsychosisDebugHudEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.BP_GetPsychosisDebugHudEnabled");
		
		ARBHUD_BP_GetPsychosisDebugHudEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.BP_GetMaxTextCharacterWidth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      string                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ARBHUD::BP_GetMaxTextCharacterWidth(const class FString& string)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.BP_GetMaxTextCharacterWidth");
		
		ARBHUD_BP_GetMaxTextCharacterWidth_Params params {};
		params.string = string;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.BP_GetIconArrowOffset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ARBHUD::BP_GetIconArrowOffset(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.BP_GetIconArrowOffset");
		
		ARBHUD_BP_GetIconArrowOffset_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.BP_AddWorldIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              introDuration                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              fadeInDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              fadeOutDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EWorldIconType                                     iconType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              showDuration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::BP_AddWorldIcon(const class FName& ID, float introDuration, float fadeInDuration, float fadeOutDuration, EWorldIconType iconType, float showDuration, class AActor* Actor, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.BP_AddWorldIcon");
		
		ARBHUD_BP_AddWorldIcon_Params params {};
		params.ID = ID;
		params.introDuration = introDuration;
		params.fadeInDuration = fadeInDuration;
		params.fadeOutDuration = fadeOutDuration;
		params.iconType = iconType;
		params.showDuration = showDuration;
		params.Actor = Actor;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUD.AddStageIntroTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHUD::AddStageIntroTime(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUD.AddStageIntroTime");
		
		ARBHUD_AddStageIntroTime_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWorldIconWidget.Event_DrawHudUpdate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBWorldIconUpdateContext                   updateContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBHUDWorldIconWidget::Event_DrawHudUpdate(const struct FRBWorldIconUpdateContext& updateContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWorldIconWidget.Event_DrawHudUpdate");
		
		URBHUDWorldIconWidget_Event_DrawHudUpdate_Params params {};
		params.updateContext = updateContext;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDWorldIconWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDWorldIconWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDWorldIconWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDFriendlyDeviceIconWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDFriendlyDeviceIconWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDFriendlyDeviceIconWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDGenericInWorldIcon.Event_UpdateIconTexture
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTexture2D*                                  newTexture                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDGenericInWorldIcon::Event_UpdateIconTexture(class UTexture2D* newTexture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDGenericInWorldIcon.Event_UpdateIconTexture");
		
		URBHUDGenericInWorldIcon_Event_UpdateIconTexture_Params params {};
		params.newTexture = newTexture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDGenericInWorldIcon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDGenericInWorldIcon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDGenericInWorldIcon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDHealthBar.SetPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   NewPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDHealthBar::SetPlayer(class ARBPlayer* NewPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDHealthBar.SetPlayer");
		
		URBHUDHealthBar_SetPlayer_Params params {};
		params.NewPlayer = NewPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDHealthBar.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDHealthBar::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDHealthBar");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDInventoryItemEntry.SetEquippedItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEquipped                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDInventoryItemEntry::SetEquippedItem(bool bEquipped)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDInventoryItemEntry.SetEquippedItem");
		
		URBHUDInventoryItemEntry_SetEquippedItem_Params params {};
		params.bEquipped = bEquipped;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDInventoryItemEntry.DisplaySwap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldShow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDInventoryItemEntry::DisplaySwap(bool bShouldShow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDInventoryItemEntry.DisplaySwap");
		
		URBHUDInventoryItemEntry_DisplaySwap_Params params {};
		params.bShouldShow = bShouldShow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDInventoryItemEntry.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDInventoryItemEntry::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDInventoryItemEntry");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLinearInventory.OnInventoryUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInventoryUpdateEventType                          EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDLinearInventory::OnInventoryUpdated(EInventoryUpdateEventType EventType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLinearInventory.OnInventoryUpdated");
		
		URBHUDLinearInventory_OnInventoryUpdated_Params params {};
		params.EventType = EventType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLinearInventory.OnActiveSkillRestrictionChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               isRestricted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDLinearInventory::OnActiveSkillRestrictionChanged(bool isRestricted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLinearInventory.OnActiveSkillRestrictionChanged");
		
		URBHUDLinearInventory_OnActiveSkillRestrictionChanged_Params params {};
		params.isRestricted = isRestricted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLinearInventory.Event_UpdateEquippedItem
	 * 		Flags  -> ()
	 */
	void URBHUDLinearInventory::Event_UpdateEquippedItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLinearInventory.Event_UpdateEquippedItem");
		
		URBHUDLinearInventory_Event_UpdateEquippedItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLinearInventory.Event_RefreshPrompts
	 * 		Flags  -> ()
	 */
	void URBHUDLinearInventory::Event_RefreshPrompts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLinearInventory.Event_RefreshPrompts");
		
		URBHUDLinearInventory_Event_RefreshPrompts_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLinearInventory.Event_RefreshDarknessIndicator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               newDarknessState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDLinearInventory::Event_RefreshDarknessIndicator(bool newDarknessState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLinearInventory.Event_RefreshDarknessIndicator");
		
		URBHUDLinearInventory_Event_RefreshDarknessIndicator_Params params {};
		params.newDarknessState = newDarknessState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLinearInventory.Event_RefreshASRestriction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               isRestricted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDLinearInventory::Event_RefreshASRestriction(bool isRestricted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLinearInventory.Event_RefreshASRestriction");
		
		URBHUDLinearInventory_Event_RefreshASRestriction_Params params {};
		params.isRestricted = isRestricted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLinearInventory.Event_Refresh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInventoryUpdateEventType                          EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDLinearInventory::Event_Refresh(EInventoryUpdateEventType EventType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLinearInventory.Event_Refresh");
		
		URBHUDLinearInventory_Event_Refresh_Params params {};
		params.EventType = EventType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLinearInventory.Event_OnIsInCooldownChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBActiveSkill*                              ActiveSkill                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsInCooldown                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDLinearInventory::Event_OnIsInCooldownChanged(class ARBActiveSkill* ActiveSkill, bool bIsInCooldown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLinearInventory.Event_OnIsInCooldownChanged");
		
		URBHUDLinearInventory_Event_OnIsInCooldownChanged_Params params {};
		params.ActiveSkill = ActiveSkill;
		params.bIsInCooldown = bIsInCooldown;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDLinearInventory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDLinearInventory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDLinearInventory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLivesCounter.SetPlayerState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              NewPlayerState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDLivesCounter::SetPlayerState(class ARBPlayerState* NewPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLivesCounter.SetPlayerState");
		
		URBHUDLivesCounter_SetPlayerState_Params params {};
		params.NewPlayerState = NewPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLivesCounter.OnRemainingLivesChanged
	 * 		Flags  -> ()
	 */
	void URBHUDLivesCounter::OnRemainingLivesChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLivesCounter.OnRemainingLivesChanged");
		
		URBHUDLivesCounter_OnRemainingLivesChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLivesCounter.OnIsDeadChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsDead                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDLivesCounter::OnIsDeadChanged(bool bIsDead)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLivesCounter.OnIsDeadChanged");
		
		URBHUDLivesCounter_OnIsDeadChanged_Params params {};
		params.bIsDead = bIsDead;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLivesCounter.GetRemainingNumberOfLives
	 * 		Flags  -> ()
	 */
	int32_t URBHUDLivesCounter::GetRemainingNumberOfLives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLivesCounter.GetRemainingNumberOfLives");
		
		URBHUDLivesCounter_GetRemainingNumberOfLives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLivesCounter.GetMaxNumberOfLives
	 * 		Flags  -> ()
	 */
	int32_t URBHUDLivesCounter::GetMaxNumberOfLives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLivesCounter.GetMaxNumberOfLives");
		
		URBHUDLivesCounter_GetMaxNumberOfLives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDLivesCounter.Event_OnRemainingLivesChanged
	 * 		Flags  -> ()
	 */
	void URBHUDLivesCounter::Event_OnRemainingLivesChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDLivesCounter.Event_OnRemainingLivesChanged");
		
		URBHUDLivesCounter_Event_OnRemainingLivesChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDLivesCounter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDLivesCounter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDLivesCounter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDObjectiveInWorld.UpdateIconImage
	 * 		Flags  -> ()
	 */
	void URBHUDObjectiveInWorld::UpdateIconImage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDObjectiveInWorld.UpdateIconImage");
		
		URBHUDObjectiveInWorld_UpdateIconImage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDObjectiveInWorld.IsOwningActorPinged
	 * 		Flags  -> ()
	 */
	bool URBHUDObjectiveInWorld::IsOwningActorPinged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDObjectiveInWorld.IsOwningActorPinged");
		
		URBHUDObjectiveInWorld_IsOwningActorPinged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDObjectiveInWorld.GetStalkerCompletingTargets
	 * 		Flags  -> ()
	 */
	TArray<class AActor*> URBHUDObjectiveInWorld::GetStalkerCompletingTargets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDObjectiveInWorld.GetStalkerCompletingTargets");
		
		URBHUDObjectiveInWorld_GetStalkerCompletingTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDObjectiveInWorld.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDObjectiveInWorld::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDObjectiveInWorld");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDOverheadInfo.OnPlayerPartyStateUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              unused                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDOverheadInfo::OnPlayerPartyStateUpdated(class ARBPlayerState* unused)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDOverheadInfo.OnPlayerPartyStateUpdated");
		
		URBHUDOverheadInfo_OnPlayerPartyStateUpdated_Params params {};
		params.unused = unused;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDOverheadInfo.OnLastPossessedPlayerUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   LastPossessedPlayer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDOverheadInfo::OnLastPossessedPlayerUpdated(class ARBPlayer* LastPossessedPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDOverheadInfo.OnLastPossessedPlayerUpdated");
		
		URBHUDOverheadInfo_OnLastPossessedPlayerUpdated_Params params {};
		params.LastPossessedPlayer = LastPossessedPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDOverheadInfo.OnHUDSettingsModified
	 * 		Flags  -> ()
	 */
	void URBHUDOverheadInfo::OnHUDSettingsModified()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDOverheadInfo.OnHUDSettingsModified");
		
		URBHUDOverheadInfo_OnHUDSettingsModified_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDOverheadInfo.Event_PlayerStateUpdated
	 * 		Flags  -> ()
	 */
	void URBHUDOverheadInfo::Event_PlayerStateUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDOverheadInfo.Event_PlayerStateUpdated");
		
		URBHUDOverheadInfo_Event_PlayerStateUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDOverheadInfo.Event_PlayerPartyStateUpdated
	 * 		Flags  -> ()
	 */
	void URBHUDOverheadInfo::Event_PlayerPartyStateUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDOverheadInfo.Event_PlayerPartyStateUpdated");
		
		URBHUDOverheadInfo_Event_PlayerPartyStateUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDOverheadInfo.Event_PlayerMaxHealthChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newMaxHealth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDOverheadInfo::Event_PlayerMaxHealthChanged(float newMaxHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDOverheadInfo.Event_PlayerMaxHealthChanged");
		
		URBHUDOverheadInfo_Event_PlayerMaxHealthChanged_Params params {};
		params.newMaxHealth = newMaxHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDOverheadInfo.Event_PlayerIndicatorTypeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerIndicatorType                               playerIndicatorType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDOverheadInfo::Event_PlayerIndicatorTypeChanged(EPlayerIndicatorType playerIndicatorType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDOverheadInfo.Event_PlayerIndicatorTypeChanged");
		
		URBHUDOverheadInfo_Event_PlayerIndicatorTypeChanged_Params params {};
		params.playerIndicatorType = playerIndicatorType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDOverheadInfo.Event_PlayerHealthChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDOverheadInfo::Event_PlayerHealthChanged(float newHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDOverheadInfo.Event_PlayerHealthChanged");
		
		URBHUDOverheadInfo_Event_PlayerHealthChanged_Params params {};
		params.newHealth = newHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDOverheadInfo.Event_InventoryUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInventoryUpdateEventType                          InventoryEventType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDOverheadInfo::Event_InventoryUpdated(EInventoryUpdateEventType InventoryEventType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDOverheadInfo.Event_InventoryUpdated");
		
		URBHUDOverheadInfo_Event_InventoryUpdated_Params params {};
		params.InventoryEventType = InventoryEventType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDOverheadInfo.Event_ImposterUpdated
	 * 		Flags  -> ()
	 */
	void URBHUDOverheadInfo::Event_ImposterUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDOverheadInfo.Event_ImposterUpdated");
		
		URBHUDOverheadInfo_Event_ImposterUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDOverheadInfo.Event_HUDSettingsUpdated
	 * 		Flags  -> ()
	 */
	void URBHUDOverheadInfo::Event_HUDSettingsUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDOverheadInfo.Event_HUDSettingsUpdated");
		
		URBHUDOverheadInfo_Event_HUDSettingsUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDOverheadInfo.Event_CurrentLoadoutChanged
	 * 		Flags  -> ()
	 */
	void URBHUDOverheadInfo::Event_CurrentLoadoutChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDOverheadInfo.Event_CurrentLoadoutChanged");
		
		URBHUDOverheadInfo_Event_CurrentLoadoutChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDOverheadInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDOverheadInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDOverheadInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerInfo.SetPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   NewPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerInfo::SetPlayer(class ARBPlayer* NewPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerInfo.SetPlayer");
		
		URBHUDPlayerInfo_SetPlayer_Params params {};
		params.NewPlayer = NewPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerInfo.OnWatchedPlayerChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   oldPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerInfo::OnWatchedPlayerChanged(class ARBPlayer* oldPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerInfo.OnWatchedPlayerChanged");
		
		URBHUDPlayerInfo_OnWatchedPlayerChanged_Params params {};
		params.oldPlayer = oldPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerInfo.OnStaminaChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newStamina                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsExhausted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerInfo::OnStaminaChanged(float newStamina, bool bIsExhausted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerInfo.OnStaminaChanged");
		
		URBHUDPlayerInfo_OnStaminaChanged_Params params {};
		params.newStamina = newStamina;
		params.bIsExhausted = bIsExhausted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerInfo.OnPsychosisChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            newPsychosis                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            oldPsychosis                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerInfo::OnPsychosisChanged(int32_t newPsychosis, int32_t oldPsychosis)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerInfo.OnPsychosisChanged");
		
		URBHUDPlayerInfo_OnPsychosisChanged_Params params {};
		params.newPsychosis = newPsychosis;
		params.oldPsychosis = oldPsychosis;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerInfo.OnPlayerStatusChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerIndicatorType                               playerIndicatorType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerInfo::OnPlayerStatusChanged(EPlayerIndicatorType playerIndicatorType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerInfo.OnPlayerStatusChanged");
		
		URBHUDPlayerInfo_OnPlayerStatusChanged_Params params {};
		params.playerIndicatorType = playerIndicatorType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerInfo.OnMaxStaminaChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerInfo::OnMaxStaminaChanged(float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerInfo.OnMaxStaminaChanged");
		
		URBHUDPlayerInfo_OnMaxStaminaChanged_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerInfo.OnMaxHealthChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerInfo::OnMaxHealthChanged(float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerInfo.OnMaxHealthChanged");
		
		URBHUDPlayerInfo_OnMaxHealthChanged_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerInfo.OnMaxBatteryChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerInfo::OnMaxBatteryChanged(float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerInfo.OnMaxBatteryChanged");
		
		URBHUDPlayerInfo_OnMaxBatteryChanged_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerInfo.OnHealthUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncreased                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerInfo::OnHealthUpdated(float newHealth, bool bIncreased)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerInfo.OnHealthUpdated");
		
		URBHUDPlayerInfo_OnHealthUpdated_Params params {};
		params.newHealth = newHealth;
		params.bIncreased = bIncreased;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerInfo.OnBatteryLevelChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newBatteryLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerInfo::OnBatteryLevelChanged(float newBatteryLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerInfo.OnBatteryLevelChanged");
		
		URBHUDPlayerInfo_OnBatteryLevelChanged_Params params {};
		params.newBatteryLevel = newBatteryLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDPlayerInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDPlayerInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDPlayerInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerInfoBar.SetPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   NewPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerInfoBar::SetPlayer(class ARBPlayer* NewPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerInfoBar.SetPlayer");
		
		URBHUDPlayerInfoBar_SetPlayer_Params params {};
		params.NewPlayer = NewPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDPlayerInfoBar.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDPlayerInfoBar::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDPlayerInfoBar");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerPingIconWidget.SetupIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UTexture2D*                                  Icon                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerPingIconWidget::SetupIcon(class UTexture2D* Icon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerPingIconWidget.SetupIcon");
		
		URBHUDPlayerPingIconWidget_SetupIcon_Params params {};
		params.Icon = Icon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerPingIconWidget.IsSharedWithObjectiveIcon
	 * 		Flags  -> ()
	 */
	bool URBHUDPlayerPingIconWidget::IsSharedWithObjectiveIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerPingIconWidget.IsSharedWithObjectiveIcon");
		
		URBHUDPlayerPingIconWidget_IsSharedWithObjectiveIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDPlayerPingIconWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDPlayerPingIconWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDPlayerPingIconWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerStatus.SetPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   NewPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShouldBindStatusChanges                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerStatus::SetPlayer(class ARBPlayer* NewPlayer, bool bShouldBindStatusChanges)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerStatus.SetPlayer");
		
		URBHUDPlayerStatus_SetPlayer_Params params {};
		params.NewPlayer = NewPlayer;
		params.bShouldBindStatusChanges = bShouldBindStatusChanges;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerStatus.OnPlayerStatusChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerIndicatorType                               newPlayerStatus                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerStatus::OnPlayerStatusChanged(EPlayerIndicatorType newPlayerStatus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerStatus.OnPlayerStatusChanged");
		
		URBHUDPlayerStatus_OnPlayerStatusChanged_Params params {};
		params.newPlayerStatus = newPlayerStatus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDPlayerStatus.OnCompletingObjectiveChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               isCompletingObjective                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDPlayerStatus::OnCompletingObjectiveChanged(bool isCompletingObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDPlayerStatus.OnCompletingObjectiveChanged");
		
		URBHUDPlayerStatus_OnCompletingObjectiveChanged_Params params {};
		params.isCompletingObjective = isCompletingObjective;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDPlayerStatus.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDPlayerStatus::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDPlayerStatus");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDSelfDeadBodyIconWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDSelfDeadBodyIconWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDSelfDeadBodyIconWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDSpectatorInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDSpectatorInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDSpectatorInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDStaminaBar.SetPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   NewPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDStaminaBar::SetPlayer(class ARBPlayer* NewPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDStaminaBar.SetPlayer");
		
		URBHUDStaminaBar_SetPlayer_Params params {};
		params.NewPlayer = NewPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDStaminaBar.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDStaminaBar::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDStaminaBar");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_StartTransitionFeedback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              blackoutDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDWidget::Event_StartTransitionFeedback(float blackoutDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_StartTransitionFeedback");
		
		URBHUDWidget_Event_StartTransitionFeedback_Params params {};
		params.blackoutDuration = blackoutDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_ShowTalkWheel
	 * 		Flags  -> ()
	 */
	void URBHUDWidget::Event_ShowTalkWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_ShowTalkWheel");
		
		URBHUDWidget_Event_ShowTalkWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_ShowObjectiveIntroMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        objectiveText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBHUDWidget::Event_ShowObjectiveIntroMessage(const class FText& objectiveText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_ShowObjectiveIntroMessage");
		
		URBHUDWidget_Event_ShowObjectiveIntroMessage_Params params {};
		params.objectiveText = objectiveText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_ShowInventoryWheel
	 * 		Flags  -> ()
	 */
	void URBHUDWidget::Event_ShowInventoryWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_ShowInventoryWheel");
		
		URBHUDWidget_Event_ShowInventoryWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_ShowInteractionMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EGameMessageCategory                               GameMessageCategory                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDWidget::Event_ShowInteractionMessage(const class FText& Message, EGameMessageCategory GameMessageCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_ShowInteractionMessage");
		
		URBHUDWidget_Event_ShowInteractionMessage_Params params {};
		params.Message = Message;
		params.GameMessageCategory = GameMessageCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_ShowBadgeProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBBadgeHudProgressDisplayDetails           progress                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBHUDWidget::Event_ShowBadgeProgress(const struct FRBBadgeHudProgressDisplayDetails& progress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_ShowBadgeProgress");
		
		URBHUDWidget_Event_ShowBadgeProgress_Params params {};
		params.progress = progress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_OnSpectateNewPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDWidget::Event_OnSpectateNewPlayer(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_OnSpectateNewPlayer");
		
		URBHUDWidget_Event_OnSpectateNewPlayer_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_OnResetHud
	 * 		Flags  -> ()
	 */
	void URBHUDWidget::Event_OnResetHud()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_OnResetHud");
		
		URBHUDWidget_Event_OnResetHud_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_OnPlayAsPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDWidget::Event_OnPlayAsPlayer(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_OnPlayAsPlayer");
		
		URBHUDWidget_Event_OnPlayAsPlayer_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_OnHUDOpacityChanged
	 * 		Flags  -> ()
	 */
	void URBHUDWidget::Event_OnHUDOpacityChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_OnHUDOpacityChanged");
		
		URBHUDWidget_Event_OnHUDOpacityChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_OnHudModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHudMode                                           newHudMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBHUDWidget::Event_OnHudModeChanged(EHudMode newHudMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_OnHudModeChanged");
		
		URBHUDWidget_Event_OnHudModeChanged_Params params {};
		params.newHudMode = newHudMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_HideTalkWheel
	 * 		Flags  -> ()
	 */
	void URBHUDWidget::Event_HideTalkWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_HideTalkWheel");
		
		URBHUDWidget_Event_HideTalkWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_HideInventoryWheel
	 * 		Flags  -> ()
	 */
	void URBHUDWidget::Event_HideInventoryWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_HideInventoryWheel");
		
		URBHUDWidget_Event_HideInventoryWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_HideInteractionMessage
	 * 		Flags  -> ()
	 */
	void URBHUDWidget::Event_HideInteractionMessage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_HideInteractionMessage");
		
		URBHUDWidget_Event_HideInteractionMessage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_HideBadgeProgress
	 * 		Flags  -> ()
	 */
	void URBHUDWidget::Event_HideBadgeProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_HideBadgeProgress");
		
		URBHUDWidget_Event_HideBadgeProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.Event_ForceUpdateSwapIcons
	 * 		Flags  -> ()
	 */
	void URBHUDWidget::Event_ForceUpdateSwapIcons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.Event_ForceUpdateSwapIcons");
		
		URBHUDWidget_Event_ForceUpdateSwapIcons_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHUDWidget.BP_ClearAllObjectives
	 * 		Flags  -> ()
	 */
	void URBHUDWidget::BP_ClearAllObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHUDWidget.BP_ClearAllObjectives");
		
		URBHUDWidget_BP_ClearAllObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBHUDWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBHUDWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHUDWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHurtVolume.Toggle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabledValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBHurtVolume::Toggle(bool bEnabledValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHurtVolume.Toggle");
		
		ARBHurtVolume_Toggle_Params params {};
		params.bEnabledValue = bEnabledValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHurtVolume.OnRep_CurrentlyEnabled
	 * 		Flags  -> ()
	 */
	void ARBHurtVolume::OnRep_CurrentlyEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHurtVolume.OnRep_CurrentlyEnabled");
		
		ARBHurtVolume_OnRep_CurrentlyEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHurtVolume.OnPawnOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBHurtVolume::OnPawnOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHurtVolume.OnPawnOverlap");
		
		ARBHurtVolume_OnPawnOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBHurtVolume.IsEnabled
	 * 		Flags  -> ()
	 */
	bool ARBHurtVolume::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBHurtVolume.IsEnabled");
		
		ARBHurtVolume_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBHurtVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBHurtVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBHurtVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.TryPlayFacialAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      lineId                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBPawn::TryPlayFacialAnim(const class FString& lineId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.TryPlayFacialAnim");
		
		ARBPawn_TryPlayFacialAnim_Params params {};
		params.lineId = lineId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.TraversalNotify
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      meshComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBAnimNotify_Traversal*                     AnimNotify                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequenceBase*                           animationSequenceBase                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::TraversalNotify(class USkeletalMeshComponent* meshComp, class URBAnimNotify_Traversal* AnimNotify, class UAnimSequenceBase* animationSequenceBase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.TraversalNotify");
		
		ARBPawn_TraversalNotify_Params params {};
		params.meshComp = meshComp;
		params.AnimNotify = AnimNotify;
		params.animationSequenceBase = animationSequenceBase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.StopGhostAnimState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              blendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::StopGhostAnimState(float blendTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.StopGhostAnimState");
		
		ARBPawn_StopGhostAnimState_Params params {};
		params.blendTime = blendTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.StopFacialAnim
	 * 		Flags  -> ()
	 */
	void ARBPawn::StopFacialAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.StopFacialAnim");
		
		ARBPawn_StopFacialAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.StartGhostAnimState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      animInstanceClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              blendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::StartGhostAnimState(class UClass* animInstanceClass, float blendTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.StartGhostAnimState");
		
		ARBPawn_StartGhostAnimState_Params params {};
		params.animInstanceClass = animInstanceClass;
		params.blendTime = blendTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.SpecialMoveNotify
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      meshComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBAnimNotify_SpecialMove*                   AnimNotify                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::SpecialMoveNotify(class USkeletalMeshComponent* meshComp, class URBAnimNotify_SpecialMove* AnimNotify)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.SpecialMoveNotify");
		
		ARBPawn_SpecialMoveNotify_Params params {};
		params.meshComp = meshComp;
		params.AnimNotify = AnimNotify;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Server_SetFinishedGhostReason
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGhostFinishReason                                 finishReason                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            customFinishReason                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Server_SetFinishedGhostReason(EGhostFinishReason finishReason, int32_t customFinishReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Server_SetFinishedGhostReason");
		
		ARBPawn_Server_SetFinishedGhostReason_Params params {};
		params.finishReason = finishReason;
		params.customFinishReason = customFinishReason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Server_ResetPawn
	 * 		Flags  -> ()
	 */
	void ARBPawn::Server_ResetPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Server_ResetPawn");
		
		ARBPawn_Server_ResetPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.RemoveForcedDarknessSource_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::RemoveForcedDarknessSource_Server(class AActor* Source)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.RemoveForcedDarknessSource_Server");
		
		ARBPawn_RemoveForcedDarknessSource_Server_Params params {};
		params.Source = Source;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.PostCharacterMeshPoseUpdate
	 * 		Flags  -> ()
	 */
	void ARBPawn::PostCharacterMeshPoseUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.PostCharacterMeshPoseUpdate");
		
		ARBPawn_PostCharacterMeshPoseUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.OnRep_SlideFinished
	 * 		Flags  -> ()
	 */
	void ARBPawn::OnRep_SlideFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.OnRep_SlideFinished");
		
		ARBPawn_OnRep_SlideFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.OnRep_Repulsion
	 * 		Flags  -> ()
	 */
	void ARBPawn::OnRep_Repulsion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.OnRep_Repulsion");
		
		ARBPawn_OnRep_Repulsion_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.OnRep_PairedPawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     oldPairedPawn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::OnRep_PairedPawn(class ARBPawn* oldPairedPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.OnRep_PairedPawn");
		
		ARBPawn_OnRep_PairedPawn_Params params {};
		params.oldPairedPawn = oldPairedPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.OnRep_LocomotionMode_Callback
	 * 		Flags  -> ()
	 */
	void ARBPawn::OnRep_LocomotionMode_Callback()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.OnRep_LocomotionMode_Callback");
		
		ARBPawn_OnRep_LocomotionMode_Callback_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.OnRep_LocomotionMode
	 * 		Flags  -> ()
	 */
	void ARBPawn::OnRep_LocomotionMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.OnRep_LocomotionMode");
		
		ARBPawn_OnRep_LocomotionMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.OnRep_InDarkness
	 * 		Flags  -> ()
	 */
	void ARBPawn::OnRep_InDarkness()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.OnRep_InDarkness");
		
		ARBPawn_OnRep_InDarkness_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.OnRep_Health
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            oldHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::OnRep_Health(int32_t oldHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.OnRep_Health");
		
		ARBPawn_OnRep_Health_Params params {};
		params.oldHealth = oldHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.OnRep_CurrentInteractable
	 * 		Flags  -> ()
	 */
	void ARBPawn::OnRep_CurrentInteractable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.OnRep_CurrentInteractable");
		
		ARBPawn_OnRep_CurrentInteractable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.OnFootstep
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      meshComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeftFoot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::OnFootstep(class USkeletalMeshComponent* meshComp, bool bLeftFoot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.OnFootstep");
		
		ARBPawn_OnFootstep_Params params {};
		params.meshComp = meshComp;
		params.bLeftFoot = bLeftFoot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.OnDamageVolumeHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::OnDamageVolumeHit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.OnDamageVolumeHit");
		
		ARBPawn_OnDamageVolumeHit_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.OnCurrentInteractableChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::OnCurrentInteractableChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.OnCurrentInteractableChangedCallback");
		
		ARBPawn_OnCurrentInteractableChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_TraversalSlideDone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bHitWall                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_TraversalSlideDone(bool bHitWall)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_TraversalSlideDone");
		
		ARBPawn_Multicast_TraversalSlideDone_Params params {};
		params.bHitWall = bHitWall;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_SwitchLocomotionMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELocomotionMode                                    newLocomotionMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPredicted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_SwitchLocomotionMode(ELocomotionMode newLocomotionMode, bool bPredicted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_SwitchLocomotionMode");
		
		ARBPawn_Multicast_SwitchLocomotionMode_Params params {};
		params.newLocomotionMode = newLocomotionMode;
		params.bPredicted = bPredicted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_StartSpecialMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSpecialMoveMulticastData                   SpecialMoveData                                            (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_StartSpecialMove(const struct FSpecialMoveMulticastData& SpecialMoveData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_StartSpecialMove");
		
		ARBPawn_Multicast_StartSpecialMove_Params params {};
		params.SpecialMoveData = SpecialMoveData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_StartScriptedAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Forward                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBAnimRef                                  Animation                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        scriptedAttachName                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      scriptedAttachActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  scriptedAttachOffset                                       (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_StartScriptedAnimation(const struct FVector& Location, const struct FVector& Forward, const struct FRBAnimRef& Animation, const class FName& scriptedAttachName, class AActor* scriptedAttachActor, const struct FTransform& scriptedAttachOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_StartScriptedAnimation");
		
		ARBPawn_Multicast_StartScriptedAnimation_Params params {};
		params.Location = Location;
		params.Forward = Forward;
		params.Animation = Animation;
		params.scriptedAttachName = scriptedAttachName;
		params.scriptedAttachActor = scriptedAttachActor;
		params.scriptedAttachOffset = scriptedAttachOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_StartPairedMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     PairedPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSpecialMoveMulticastData                   SpecialMoveData                                            (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bPairedPawnIsLeader                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBasicDirection                                    Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_StartPairedMove(class ARBPawn* PairedPawn, const struct FSpecialMoveMulticastData& SpecialMoveData, bool bPairedPawnIsLeader, EBasicDirection Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_StartPairedMove");
		
		ARBPawn_Multicast_StartPairedMove_Params params {};
		params.PairedPawn = PairedPawn;
		params.SpecialMoveData = SpecialMoveData;
		params.bPairedPawnIsLeader = bPairedPawnIsLeader;
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_StartDoorInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBDoor*                                     door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDoorInteractionType                               doorInteractionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_StartDoorInteraction(class ARBDoor* door, EDoorInteractionType doorInteractionType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_StartDoorInteraction");
		
		ARBPawn_Multicast_StartDoorInteraction_Params params {};
		params.door = door;
		params.doorInteractionType = doorInteractionType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_StartBashDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBDoor*                                     door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBashDoorType                                      bashType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPredicted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     startCharLocation                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_StartBashDoor(class ARBDoor* door, EBashDoorType bashType, bool bPredicted, const struct FVector& startCharLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_StartBashDoor");
		
		ARBPawn_Multicast_StartBashDoor_Params params {};
		params.door = door;
		params.bashType = bashType;
		params.bPredicted = bPredicted;
		params.startCharLocation = startCharLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_SpecialMoveInterrupted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESpecialMove                                       specialMoveInterrupted                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPredicted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_SpecialMoveInterrupted(ESpecialMove specialMoveInterrupted, bool bPredicted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_SpecialMoveInterrupted");
		
		ARBPawn_Multicast_SpecialMoveInterrupted_Params params {};
		params.specialMoveInterrupted = specialMoveInterrupted;
		params.bPredicted = bPredicted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_SpecialMoveCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSpecialMoveMulticastData                   completedSpecialMoveData                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_SpecialMoveCompleted(const struct FSpecialMoveMulticastData& completedSpecialMoveData, bool bInterrupted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_SpecialMoveCompleted");
		
		ARBPawn_Multicast_SpecialMoveCompleted_Params params {};
		params.completedSpecialMoveData = completedSpecialMoveData;
		params.bInterrupted = bInterrupted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_SetSpecialMoveNextLocomotionMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            SpecialMoveIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ELocomotionMode                                    nextLocomotionMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_SetSpecialMoveNextLocomotionMode(int32_t SpecialMoveIndex, ESpecialMove specialMove, ELocomotionMode nextLocomotionMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_SetSpecialMoveNextLocomotionMode");
		
		ARBPawn_Multicast_SetSpecialMoveNextLocomotionMode_Params params {};
		params.SpecialMoveIndex = SpecialMoveIndex;
		params.specialMove = specialMove;
		params.nextLocomotionMode = nextLocomotionMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_SetSpecialMoveInterruptedLocomotionMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            SpecialMoveIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ELocomotionMode                                    nextLocomotionMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_SetSpecialMoveInterruptedLocomotionMode(int32_t SpecialMoveIndex, ESpecialMove specialMove, ELocomotionMode nextLocomotionMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_SetSpecialMoveInterruptedLocomotionMode");
		
		ARBPawn_Multicast_SetSpecialMoveInterruptedLocomotionMode_Params params {};
		params.SpecialMoveIndex = SpecialMoveIndex;
		params.specialMove = specialMove;
		params.nextLocomotionMode = nextLocomotionMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_SetPairedPawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     PairedPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPairedPawnIsLeader                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_SetPairedPawn(class ARBPawn* PairedPawn, bool bPairedPawnIsLeader)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_SetPairedPawn");
		
		ARBPawn_Multicast_SetPairedPawn_Params params {};
		params.PairedPawn = PairedPawn;
		params.bPairedPawnIsLeader = bPairedPawnIsLeader;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_SetFinishedGhostReason
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGhostFinishReason                                 finishReason                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            customFinishReason                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPredicted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_SetFinishedGhostReason(EGhostFinishReason finishReason, int32_t customFinishReason, bool bPredicted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_SetFinishedGhostReason");
		
		ARBPawn_Multicast_SetFinishedGhostReason_Params params {};
		params.finishReason = finishReason;
		params.customFinishReason = customFinishReason;
		params.bPredicted = bPredicted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_SetCurrentInteractable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     newCurrentInteractable                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_SetCurrentInteractable(class UObject* newCurrentInteractable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_SetCurrentInteractable");
		
		ARBPawn_Multicast_SetCurrentInteractable_Params params {};
		params.newCurrentInteractable = newCurrentInteractable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_ScheduleSpecialMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledSpecialMoveData                   ScheduledSpecialMoveData                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_ScheduleSpecialMove(const struct FScheduledSpecialMoveData& ScheduledSpecialMoveData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_ScheduleSpecialMove");
		
		ARBPawn_Multicast_ScheduleSpecialMove_Params params {};
		params.ScheduledSpecialMoveData = ScheduledSpecialMoveData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_ScheduleLocomotionMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ELocomotionMode                                    newLocomotionMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PawnTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              serverTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_ScheduleLocomotionMode(ELocomotionMode newLocomotionMode, float PawnTime, float serverTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_ScheduleLocomotionMode");
		
		ARBPawn_Multicast_ScheduleLocomotionMode_Params params {};
		params.newLocomotionMode = newLocomotionMode;
		params.PawnTime = PawnTime;
		params.serverTime = serverTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_ScheduleCompleteSpecialMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              PawnTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              serverTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SpecialMoveSubType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_ScheduleCompleteSpecialMove(float PawnTime, float serverTime, ESpecialMove specialMove, int32_t SpecialMoveSubType, bool bInterrupted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_ScheduleCompleteSpecialMove");
		
		ARBPawn_Multicast_ScheduleCompleteSpecialMove_Params params {};
		params.PawnTime = PawnTime;
		params.serverTime = serverTime;
		params.specialMove = specialMove;
		params.SpecialMoveSubType = SpecialMoveSubType;
		params.bInterrupted = bInterrupted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_ScheduleBlendOutControl
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              blendOutDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWaitForAction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ScheduledPawnTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              serverTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              specialMoveEndPawnTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              specialMoveEndServerTime                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_ScheduleBlendOutControl(float blendOutDuration, bool bWaitForAction, float ScheduledPawnTime, float serverTime, float specialMoveEndPawnTime, float specialMoveEndServerTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_ScheduleBlendOutControl");
		
		ARBPawn_Multicast_ScheduleBlendOutControl_Params params {};
		params.blendOutDuration = blendOutDuration;
		params.bWaitForAction = bWaitForAction;
		params.ScheduledPawnTime = ScheduledPawnTime;
		params.serverTime = serverTime;
		params.specialMoveEndPawnTime = specialMoveEndPawnTime;
		params.specialMoveEndServerTime = specialMoveEndServerTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_ResetPawn
	 * 		Flags  -> ()
	 */
	void ARBPawn::Multicast_ResetPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_ResetPawn");
		
		ARBPawn_Multicast_ResetPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_QueueProceduralAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProceduralTranslationAnimData              animData                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_QueueProceduralAnim(const struct FProceduralTranslationAnimData& animData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_QueueProceduralAnim");
		
		ARBPawn_Multicast_QueueProceduralAnim_Params params {};
		params.animData = animData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_OnTakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 dmgInfo                                                    (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_OnTakeDamage(const struct FDamageInfo& dmgInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_OnTakeDamage");
		
		ARBPawn_Multicast_OnTakeDamage_Params params {};
		params.dmgInfo = dmgInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_OnDie
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_OnDie(class ARBPawn* killer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_OnDie");
		
		ARBPawn_Multicast_OnDie_Params params {};
		params.killer = killer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_KnockbackPawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Direction                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_KnockbackPawn(const struct FVector& Direction, float strength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_KnockbackPawn");
		
		ARBPawn_Multicast_KnockbackPawn_Params params {};
		params.Direction = Direction;
		params.strength = strength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_InteruptCurrentAction
	 * 		Flags  -> ()
	 */
	void ARBPawn::Multicast_InteruptCurrentAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_InteruptCurrentAction");
		
		ARBPawn_Multicast_InteruptCurrentAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_ExitCinematicMode
	 * 		Flags  -> ()
	 */
	void ARBPawn::Multicast_ExitCinematicMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_ExitCinematicMode");
		
		ARBPawn_Multicast_ExitCinematicMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_DoActionBashDoor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBDoor*                                     door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_DoActionBashDoor(class ARBDoor* door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_DoActionBashDoor");
		
		ARBPawn_Multicast_DoActionBashDoor_Params params {};
		params.door = door;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_BlendOutActiveSpecialMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              blendOutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SpecialMoveIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_BlendOutActiveSpecialMove(float blendOutTime, int32_t SpecialMoveIndex, ESpecialMove specialMove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_BlendOutActiveSpecialMove");
		
		ARBPawn_Multicast_BlendOutActiveSpecialMove_Params params {};
		params.blendOutTime = blendOutTime;
		params.SpecialMoveIndex = SpecialMoveIndex;
		params.specialMove = specialMove;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_BashBreakableObstacle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBreakableObstacle*                        breakableObstacle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_BashBreakableObstacle(class ARBBreakableObstacle* breakableObstacle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_BashBreakableObstacle");
		
		ARBPawn_Multicast_BashBreakableObstacle_Params params {};
		params.breakableObstacle = breakableObstacle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_AddServerBreadcrumb
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPawnBreadcrumb                             newBreadcrumb                                              (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_AddServerBreadcrumb(const struct FPawnBreadcrumb& newBreadcrumb)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_AddServerBreadcrumb");
		
		ARBPawn_Multicast_AddServerBreadcrumb_Params params {};
		params.newBreadcrumb = newBreadcrumb;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Multicast_AddExternalImpulse
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Impulse                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Multicast_AddExternalImpulse(const struct FVector& Impulse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Multicast_AddExternalImpulse");
		
		ARBPawn_Multicast_AddExternalImpulse_Params params {};
		params.Impulse = Impulse;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.IsRunning
	 * 		Flags  -> ()
	 */
	bool ARBPawn::IsRunning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.IsRunning");
		
		ARBPawn_IsRunning_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.IsConsideredDead
	 * 		Flags  -> ()
	 */
	bool ARBPawn::IsConsideredDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.IsConsideredDead");
		
		ARBPawn_IsConsideredDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.IsCarryingLargePickup
	 * 		Flags  -> ()
	 */
	bool ARBPawn::IsCarryingLargePickup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.IsCarryingLargePickup");
		
		ARBPawn_IsCarryingLargePickup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.HasRecentlyBeenSpawned
	 * 		Flags  -> ()
	 */
	bool ARBPawn::HasRecentlyBeenSpawned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.HasRecentlyBeenSpawned");
		
		ARBPawn_HasRecentlyBeenSpawned_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.HasGhostAnimActive
	 * 		Flags  -> ()
	 */
	bool ARBPawn::HasGhostAnimActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.HasGhostAnimActive");
		
		ARBPawn_HasGhostAnimActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.GhostAnimTransition
	 * 		Flags  -> ()
	 */
	bool ARBPawn::GhostAnimTransition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.GhostAnimTransition");
		
		ARBPawn_GhostAnimTransition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.GetGhostAnimBP
	 * 		Flags  -> ()
	 */
	class URBGhostAnimInstance* ARBPawn::GetGhostAnimBP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.GetGhostAnimBP");
		
		ARBPawn_GetGhostAnimBP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.GetFacePoseAsset
	 * 		Flags  -> ()
	 */
	class UPoseAsset* ARBPawn::GetFacePoseAsset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.GetFacePoseAsset");
		
		ARBPawn_GetFacePoseAsset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.GetFaceFXSkeletalMeshComponent
	 * 		Flags  -> ()
	 */
	class USkeletalMeshComponent* ARBPawn::GetFaceFXSkeletalMeshComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.GetFaceFXSkeletalMeshComponent");
		
		ARBPawn_GetFaceFXSkeletalMeshComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.GetCarriedLargePickup
	 * 		Flags  -> ()
	 */
	class ARBLargePickup* ARBPawn::GetCarriedLargePickup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.GetCarriedLargePickup");
		
		ARBPawn_GetCarriedLargePickup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.GetAnimInstance
	 * 		Flags  -> ()
	 */
	class URBAnimInstance* ARBPawn::GetAnimInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.GetAnimInstance");
		
		ARBPawn_GetAnimInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Event_OnTakeDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FDamageInfo                                 Info                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Event_OnTakeDamage(const struct FDamageInfo& Info)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Event_OnTakeDamage");
		
		ARBPawn_Event_OnTakeDamage_Params params {};
		params.Info = Info;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Event_OnStopSeeThroughWallMeshSwap
	 * 		Flags  -> ()
	 */
	void ARBPawn::Event_OnStopSeeThroughWallMeshSwap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Event_OnStopSeeThroughWallMeshSwap");
		
		ARBPawn_Event_OnStopSeeThroughWallMeshSwap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Event_OnStartSeeThroughWallMeshSwap
	 * 		Flags  -> ()
	 */
	void ARBPawn::Event_OnStartSeeThroughWallMeshSwap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Event_OnStartSeeThroughWallMeshSwap");
		
		ARBPawn_Event_OnStartSeeThroughWallMeshSwap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Event_OnFootstep
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FFootstepData                               FootstepData                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Event_OnFootstep(const struct FFootstepData& FootstepData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Event_OnFootstep");
		
		ARBPawn_Event_OnFootstep_Params params {};
		params.FootstepData = FootstepData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Event_OnDie
	 * 		Flags  -> ()
	 */
	void ARBPawn::Event_OnDie()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Event_OnDie");
		
		ARBPawn_Event_OnDie_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.Event_HealthUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncreased                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::Event_HealthUpdated(float newHealth, bool bIncreased)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.Event_HealthUpdated");
		
		ARBPawn_Event_HealthUpdated_Params params {};
		params.newHealth = newHealth;
		params.bIncreased = bIncreased;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.ClearGhostAnimInstance
	 * 		Flags  -> ()
	 */
	void ARBPawn::ClearGhostAnimInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.ClearGhostAnimInstance");
		
		ARBPawn_ClearGhostAnimInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_TemporaryAttachComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SocketName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::BP_TemporaryAttachComponent(class USceneComponent* Component, const class FName& SocketName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_TemporaryAttachComponent");
		
		ARBPawn_BP_TemporaryAttachComponent_Params params {};
		params.Component = Component;
		params.SocketName = SocketName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_StartSpecialMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     targetPosition                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     targetDirection                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPredicted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::BP_StartSpecialMove(ESpecialMove specialMove, const struct FVector& targetPosition, const struct FVector& targetDirection, bool bPredicted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_StartSpecialMove");
		
		ARBPawn_BP_StartSpecialMove_Params params {};
		params.specialMove = specialMove;
		params.targetPosition = targetPosition;
		params.targetDirection = targetDirection;
		params.bPredicted = bPredicted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_StartScriptedAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Forward                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBAnimRef                                  Animation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        scriptedAttachBone                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      scriptedAttachActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  scriptedAttachOffset                                       (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::BP_StartScriptedAnimation(const struct FVector& Location, const struct FVector& Forward, const struct FRBAnimRef& Animation, const class FName& scriptedAttachBone, class AActor* scriptedAttachActor, const struct FTransform& scriptedAttachOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_StartScriptedAnimation");
		
		ARBPawn_BP_StartScriptedAnimation_Params params {};
		params.Location = Location;
		params.Forward = Forward;
		params.Animation = Animation;
		params.scriptedAttachBone = scriptedAttachBone;
		params.scriptedAttachActor = scriptedAttachActor;
		params.scriptedAttachOffset = scriptedAttachOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_SpecialMoveNotify
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESpecialMoveNotifyType                             notifyType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::BP_SpecialMoveNotify(ESpecialMoveNotifyType notifyType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_SpecialMoveNotify");
		
		ARBPawn_BP_SpecialMoveNotify_Params params {};
		params.notifyType = notifyType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_RemoveTemporaryComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSnapBack                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::BP_RemoveTemporaryComponent(class USceneComponent* Component, bool bSnapBack)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_RemoveTemporaryComponent");
		
		ARBPawn_BP_RemoveTemporaryComponent_Params params {};
		params.Component = Component;
		params.bSnapBack = bSnapBack;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_PlayVoiceAkEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::BP_PlayVoiceAkEvent(class UAkAudioEvent* akEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_PlayVoiceAkEvent");
		
		ARBPawn_BP_PlayVoiceAkEvent_Params params {};
		params.akEvent = akEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_PlaySpecialMoveAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequenceBase*                           AnimSeq                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              blendIn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              blendOut                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::BP_PlaySpecialMoveAnim(class UAnimSequenceBase* AnimSeq, float blendIn, float blendOut, float PlayRate, float StartTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_PlaySpecialMoveAnim");
		
		ARBPawn_BP_PlaySpecialMoveAnim_Params params {};
		params.AnimSeq = AnimSeq;
		params.blendIn = blendIn;
		params.blendOut = blendOut;
		params.PlayRate = PlayRate;
		params.StartTime = StartTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_PlayAkEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::BP_PlayAkEvent(class UAkAudioEvent* akEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_PlayAkEvent");
		
		ARBPawn_BP_PlayAkEvent_Params params {};
		params.akEvent = akEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_IsInFirstPerson
	 * 		Flags  -> ()
	 */
	bool ARBPawn::BP_IsInFirstPerson()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_IsInFirstPerson");
		
		ARBPawn_BP_IsInFirstPerson_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_IsDoingSpecialMove
	 * 		Flags  -> ()
	 */
	bool ARBPawn::BP_IsDoingSpecialMove()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_IsDoingSpecialMove");
		
		ARBPawn_BP_IsDoingSpecialMove_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_IsConsideredCrouched
	 * 		Flags  -> ()
	 */
	bool ARBPawn::BP_IsConsideredCrouched()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_IsConsideredCrouched");
		
		ARBPawn_BP_IsConsideredCrouched_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_GetSpecialMoveSubtype
	 * 		Flags  -> ()
	 */
	unsigned char ARBPawn::BP_GetSpecialMoveSubtype()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_GetSpecialMoveSubtype");
		
		ARBPawn_BP_GetSpecialMoveSubtype_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_GetSpecialMove
	 * 		Flags  -> ()
	 */
	ESpecialMove ARBPawn::BP_GetSpecialMove()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_GetSpecialMove");
		
		ARBPawn_BP_GetSpecialMove_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_GetRandomSelector
	 * 		Flags  -> ()
	 */
	int32_t ARBPawn::BP_GetRandomSelector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_GetRandomSelector");
		
		ARBPawn_BP_GetRandomSelector_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_GetPawnTargetLocation
	 * 		Flags  -> ()
	 */
	struct FVector ARBPawn::BP_GetPawnTargetLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_GetPawnTargetLocation");
		
		ARBPawn_BP_GetPawnTargetLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_GetPawnTargetForward
	 * 		Flags  -> ()
	 */
	struct FVector ARBPawn::BP_GetPawnTargetForward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_GetPawnTargetForward");
		
		ARBPawn_BP_GetPawnTargetForward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_GetMaxHealth
	 * 		Flags  -> ()
	 */
	float ARBPawn::BP_GetMaxHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_GetMaxHealth");
		
		ARBPawn_BP_GetMaxHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_GetDebugPawnName
	 * 		Flags  -> ()
	 */
	class FString ARBPawn::BP_GetDebugPawnName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_GetDebugPawnName");
		
		ARBPawn_BP_GetDebugPawnName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_GetCurrentInteractibleActor
	 * 		Flags  -> ()
	 */
	class AActor* ARBPawn::BP_GetCurrentInteractibleActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_GetCurrentInteractibleActor");
		
		ARBPawn_BP_GetCurrentInteractibleActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_GetCurrentARBInteractible
	 * 		Flags  -> ()
	 */
	class ARBInteractible* ARBPawn::BP_GetCurrentARBInteractible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_GetCurrentARBInteractible");
		
		ARBPawn_BP_GetCurrentARBInteractible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_ForceDropLargeObject
	 * 		Flags  -> ()
	 */
	void ARBPawn::BP_ForceDropLargeObject()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_ForceDropLargeObject");
		
		ARBPawn_BP_ForceDropLargeObject_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_ExitCinematicMode
	 * 		Flags  -> ()
	 */
	void ARBPawn::BP_ExitCinematicMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_ExitCinematicMode");
		
		ARBPawn_BP_ExitCinematicMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_EnterCinematicMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		ELocomotionMode                                    exitLocomotionMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::BP_EnterCinematicMode(const struct FVector& Location, const struct FRotator& Rotation, ELocomotionMode exitLocomotionMode, bool bTeleport)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_EnterCinematicMode");
		
		ARBPawn_BP_EnterCinematicMode_Params params {};
		params.Location = Location;
		params.Rotation = Rotation;
		params.exitLocomotionMode = exitLocomotionMode;
		params.bTeleport = bTeleport;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_Die
	 * 		Flags  -> ()
	 */
	void ARBPawn::BP_Die()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_Die");
		
		ARBPawn_BP_Die_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_DetachTemporaryComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::BP_DetachTemporaryComponent(class USceneComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_DetachTemporaryComponent");
		
		ARBPawn_BP_DetachTemporaryComponent_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_DEBUG_TryInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     Interactable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::BP_DEBUG_TryInteraction(class UObject* Interactable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_DEBUG_TryInteraction");
		
		ARBPawn_BP_DEBUG_TryInteraction_Params params {};
		params.Interactable = Interactable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_DamageParams
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDamageType                                        dmgType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDamageParameters ARBPawn::BP_DamageParams(EDamageType dmgType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_DamageParams");
		
		ARBPawn_BP_DamageParams_Params params {};
		params.dmgType = dmgType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.BP_AddHealth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              healthToAdd                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::BP_AddHealth(float healthToAdd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.BP_AddHealth");
		
		ARBPawn_BP_AddHealth_Params params {};
		params.healthToAdd = healthToAdd;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawn.AddForcedDarknessSource_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPawn::AddForcedDarknessSource_Server(class AActor* Source)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawn.AddForcedDarknessSource_Server");
		
		ARBPawn_AddForcedDarknessSource_Server_Params params {};
		params.Source = Source;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.SetupEditorAudioState
	 * 		Flags  -> ()
	 */
	void ARBNPC::SetupEditorAudioState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.SetupEditorAudioState");
		
		ARBNPC_SetupEditorAudioState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.OnRep_VoiceType
	 * 		Flags  -> ()
	 */
	void ARBNPC::OnRep_VoiceType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.OnRep_VoiceType");
		
		ARBNPC_OnRep_VoiceType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.OnRep_ScriptedAnim
	 * 		Flags  -> ()
	 */
	void ARBNPC::OnRep_ScriptedAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.OnRep_ScriptedAnim");
		
		ARBNPC_OnRep_ScriptedAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.OnRep_CanShowSpectre
	 * 		Flags  -> ()
	 */
	void ARBNPC::OnRep_CanShowSpectre()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.OnRep_CanShowSpectre");
		
		ARBNPC_OnRep_CanShowSpectre_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.OnRep_AmbientIdle
	 * 		Flags  -> ()
	 */
	void ARBNPC::OnRep_AmbientIdle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.OnRep_AmbientIdle");
		
		ARBNPC_OnRep_AmbientIdle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.OnRep_AllowPlayerPing
	 * 		Flags  -> ()
	 */
	void ARBNPC::OnRep_AllowPlayerPing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.OnRep_AllowPlayerPing");
		
		ARBNPC_OnRep_AllowPlayerPing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.OnRep_AffectedByGrenadeStun
	 * 		Flags  -> ()
	 */
	void ARBNPC::OnRep_AffectedByGrenadeStun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.OnRep_AffectedByGrenadeStun");
		
		ARBNPC_OnRep_AffectedByGrenadeStun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.OnRep_AffectedByBlindPaint
	 * 		Flags  -> ()
	 */
	void ARBNPC::OnRep_AffectedByBlindPaint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.OnRep_AffectedByBlindPaint");
		
		ARBNPC_OnRep_AffectedByBlindPaint_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.OnPlayingFullBodyIdleBreakerStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bPlayingFullBodyIdleBreaker                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::OnPlayingFullBodyIdleBreakerStateChanged(bool bPlayingFullBodyIdleBreaker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.OnPlayingFullBodyIdleBreakerStateChanged");
		
		ARBNPC_OnPlayingFullBodyIdleBreakerStateChanged_Params params {};
		params.bPlayingFullBodyIdleBreaker = bPlayingFullBodyIdleBreaker;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.OnCanShowSpectreChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::OnCanShowSpectreChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.OnCanShowSpectreChangedCallback");
		
		ARBNPC_OnCanShowSpectreChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_UpdateReplicatedNPCConfig
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNPCReplicatedConfig                        configData                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_UpdateReplicatedNPCConfig(const struct FNPCReplicatedConfig& configData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_UpdateReplicatedNPCConfig");
		
		ARBNPC_Multicast_UpdateReplicatedNPCConfig_Params params {};
		params.configData = configData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_TriggerScriptedVO
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAkAudioEvent*                               AudioEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVOPriority                                        VOPriority                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_TriggerScriptedVO(class UAkAudioEvent* AudioEvent, EVOPriority VOPriority, uint32_t RandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_TriggerScriptedVO");
		
		ARBNPC_Multicast_TriggerScriptedVO_Params params {};
		params.AudioEvent = AudioEvent;
		params.VOPriority = VOPriority;
		params.RandomSeed = RandomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_TriggerContextualVO
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EVOContext                                         VOContext                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_TriggerContextualVO(EVOContext VOContext, uint32_t RandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_TriggerContextualVO");
		
		ARBNPC_Multicast_TriggerContextualVO_Params params {};
		params.VOContext = VOContext;
		params.RandomSeed = RandomSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_TraversalMoveStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTraversalMoveData                          moveData                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_TraversalMoveStarted(const struct FTraversalMoveData& moveData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_TraversalMoveStarted");
		
		ARBNPC_Multicast_TraversalMoveStarted_Params params {};
		params.moveData = moveData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_TeleportTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     DestLocation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    DestRotation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bNoCheck                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_TeleportTo(const struct FVector& DestLocation, const struct FRotator& DestRotation, bool bNoCheck)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_TeleportTo");
		
		ARBNPC_Multicast_TeleportTo_Params params {};
		params.DestLocation = DestLocation;
		params.DestRotation = DestRotation;
		params.bNoCheck = bNoCheck;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_StartTurnOnSpot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNPCTurnOnSpotData                          turnOnSpot                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_StartTurnOnSpot(const struct FNPCTurnOnSpotData& turnOnSpot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_StartTurnOnSpot");
		
		ARBNPC_Multicast_StartTurnOnSpot_Params params {};
		params.turnOnSpot = turnOnSpot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_StartSpecialMoveOrientedToActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESpecialMove                                       specialMoveType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_StartSpecialMoveOrientedToActor(ESpecialMove specialMoveType, class AActor* TargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_StartSpecialMoveOrientedToActor");
		
		ARBNPC_Multicast_StartSpecialMoveOrientedToActor_Params params {};
		params.specialMoveType = specialMoveType;
		params.TargetActor = TargetActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_StartSabotageAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     sabotageInteractableTarget                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_StartSabotageAction(class UObject* sabotageInteractableTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_StartSabotageAction");
		
		ARBNPC_Multicast_StartSabotageAction_Params params {};
		params.sabotageInteractableTarget = sabotageInteractableTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_StartRelativeYawSpecialMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESpecialMove                                       relYawSpecialMove                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RelativeYaw                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_StartRelativeYawSpecialMove(ESpecialMove relYawSpecialMove, float RelativeYaw)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_StartRelativeYawSpecialMove");
		
		ARBNPC_Multicast_StartRelativeYawSpecialMove_Params params {};
		params.relYawSpecialMove = relYawSpecialMove;
		params.RelativeYaw = RelativeYaw;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_StartInvestigationAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNPCInvestigationData                       InvestigationData                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_StartInvestigationAction(const struct FNPCInvestigationData& InvestigationData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_StartInvestigationAction");
		
		ARBNPC_Multicast_StartInvestigationAction_Params params {};
		params.InvestigationData = InvestigationData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_StartHidespotPeeking
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBHidespotComponent*                        hidespot                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               peekingAnim                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_StartHidespotPeeking(class URBHidespotComponent* hidespot, class UAnimSequence* peekingAnim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_StartHidespotPeeking");
		
		ARBNPC_Multicast_StartHidespotPeeking_Params params {};
		params.hidespot = hidespot;
		params.peekingAnim = peekingAnim;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_StartFixedDurationSpecialMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESpecialMove                                       specialMoveType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ExpirationServerTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_StartFixedDurationSpecialMove(ESpecialMove specialMoveType, float ExpirationServerTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_StartFixedDurationSpecialMove");
		
		ARBNPC_Multicast_StartFixedDurationSpecialMove_Params params {};
		params.specialMoveType = specialMoveType;
		params.ExpirationServerTime = ExpirationServerTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_StartAttackMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     StartPos                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     startDir                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FNPCAttackParams                            attackParams                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_StartAttackMove(const struct FVector& StartPos, const struct FVector& startDir, const struct FNPCAttackParams& attackParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_StartAttackMove");
		
		ARBNPC_Multicast_StartAttackMove_Params params {};
		params.StartPos = StartPos;
		params.startDir = startDir;
		params.attackParams = attackParams;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_SleeperScream
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequence*                               AnimSeq                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNoScream                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              screamDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_SleeperScream(class UAnimSequence* AnimSeq, bool bNoScream, float screamDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_SleeperScream");
		
		ARBNPC_Multicast_SleeperScream_Params params {};
		params.AnimSeq = AnimSeq;
		params.bNoScream = bNoScream;
		params.screamDuration = screamDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_SleeperDisturbed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequence*                               AnimSeq                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_SleeperDisturbed(class UAnimSequence* AnimSeq)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_SleeperDisturbed");
		
		ARBNPC_Multicast_SleeperDisturbed_Params params {};
		params.AnimSeq = AnimSeq;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_SetBlindPaintStateStyle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bAgitated                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_SetBlindPaintStateStyle(bool bAgitated)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_SetBlindPaintStateStyle");
		
		ARBNPC_Multicast_SetBlindPaintStateStyle_Params params {};
		params.bAgitated = bAgitated;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_PlayWeaponImpactParticles
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FVector>                             impactPoints                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    impactRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_PlayWeaponImpactParticles(TArray<struct FVector> impactPoints, const struct FRotator& impactRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_PlayWeaponImpactParticles");
		
		ARBNPC_Multicast_PlayWeaponImpactParticles_Params params {};
		params.impactPoints = impactPoints;
		params.impactRotation = impactRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_PlayWaypointAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequence*                               AnimSeq                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoopAnim                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetPos                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetDir                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_PlayWaypointAnim(class UAnimSequence* AnimSeq, bool bLoopAnim, const struct FVector& TargetPos, const struct FVector& TargetDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_PlayWaypointAnim");
		
		ARBNPC_Multicast_PlayWaypointAnim_Params params {};
		params.AnimSeq = AnimSeq;
		params.bLoopAnim = bLoopAnim;
		params.TargetPos = TargetPos;
		params.TargetDir = TargetDir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_PlayStartled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNPCStartleData                             startleData                                                (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_PlayStartled(const struct FNPCStartleData& startleData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_PlayStartled");
		
		ARBNPC_Multicast_PlayStartled_Params params {};
		params.startleData = startleData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_PlaySingleShotAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequence*                               AnimSeq                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetPos                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetDir                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_PlaySingleShotAnim(class UAnimSequence* AnimSeq, const struct FVector& TargetPos, const struct FVector& TargetDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_PlaySingleShotAnim");
		
		ARBNPC_Multicast_PlaySingleShotAnim_Params params {};
		params.AnimSeq = AnimSeq;
		params.TargetPos = TargetPos;
		params.TargetDir = TargetDir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_PlayPullFromHidespot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPairedTwoPhaseAnimData                     animData                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   grabbedPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBHidespotComponent*                        hidespot                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetPos                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetDir                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_PlayPullFromHidespot(const struct FPairedTwoPhaseAnimData& animData, class ARBPlayer* grabbedPlayer, class URBHidespotComponent* hidespot, const struct FVector& TargetPos, const struct FVector& TargetDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_PlayPullFromHidespot");
		
		ARBNPC_Multicast_PlayPullFromHidespot_Params params {};
		params.animData = animData;
		params.grabbedPlayer = grabbedPlayer;
		params.hidespot = hidespot;
		params.TargetPos = TargetPos;
		params.TargetDir = TargetDir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_PlayNPCHitReaction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNPCHitReactionParams                       Params                                                     (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_PlayNPCHitReaction(const struct FNPCHitReactionParams& Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_PlayNPCHitReaction");
		
		ARBNPC_Multicast_PlayNPCHitReaction_Params params {};
		params.Params = Params;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_PlayGrab
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPairedTwoPhaseAnimData                     animData                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   grabbedPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetPos                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetDir                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_PlayGrab(const struct FPairedTwoPhaseAnimData& animData, class ARBPlayer* grabbedPlayer, const struct FVector& TargetPos, const struct FVector& TargetDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_PlayGrab");
		
		ARBNPC_Multicast_PlayGrab_Params params {};
		params.animData = animData;
		params.grabbedPlayer = grabbedPlayer;
		params.TargetPos = TargetPos;
		params.TargetDir = TargetDir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_PlayAmbientStationExitAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UAnimSequence*                               AnimSeq                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_PlayAmbientStationExitAnim(class UAnimSequence* AnimSeq)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_PlayAmbientStationExitAnim");
		
		ARBNPC_Multicast_PlayAmbientStationExitAnim_Params params {};
		params.AnimSeq = AnimSeq;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_PerformStandardFatality
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FStandardFatalityData                       fatalityData                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_PerformStandardFatality(const struct FStandardFatalityData& fatalityData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_PerformStandardFatality");
		
		ARBNPC_Multicast_PerformStandardFatality_Params params {};
		params.fatalityData = fatalityData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_OverrideAnimRefs
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBAnimReferences*                           overrideAnimRefs                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_OverrideAnimRefs(class URBAnimReferences* overrideAnimRefs)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_OverrideAnimRefs");
		
		ARBNPC_Multicast_OverrideAnimRefs_Params params {};
		params.overrideAnimRefs = overrideAnimRefs;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_OnFinishedExitingMonsterCloset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBMonsterCloset*                            Closet                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayVO                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_OnFinishedExitingMonsterCloset(class ARBMonsterCloset* Closet, bool bPlayVO)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_OnFinishedExitingMonsterCloset");
		
		ARBNPC_Multicast_OnFinishedExitingMonsterCloset_Params params {};
		params.Closet = Closet;
		params.bPlayVO = bPlayVO;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_OnDealtWeaponDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     otherPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     DamageLocation                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_OnDealtWeaponDamage(class ARBPawn* otherPawn, const struct FVector& DamageLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_OnDealtWeaponDamage");
		
		ARBNPC_Multicast_OnDealtWeaponDamage_Params params {};
		params.otherPawn = otherPawn;
		params.DamageLocation = DamageLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_OnDealtUnarmedDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     otherPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        damageSourceBone                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_OnDealtUnarmedDamage(class ARBPawn* otherPawn, const class FName& damageSourceBone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_OnDealtUnarmedDamage");
		
		ARBNPC_Multicast_OnDealtUnarmedDamage_Params params {};
		params.otherPawn = otherPawn;
		params.damageSourceBone = damageSourceBone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_InterruptHidespotPeeking
	 * 		Flags  -> ()
	 */
	void ARBNPC::Multicast_InterruptHidespotPeeking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_InterruptHidespotPeeking");
		
		ARBNPC_Multicast_InterruptHidespotPeeking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_GroundAndPoundPlayerEscape
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   escapingPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               pouncerAnim                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               PlayerAnim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBThrowableWeapon*                          escapeItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_GroundAndPoundPlayerEscape(class ARBPlayer* escapingPlayer, class UAnimSequence* pouncerAnim, class UAnimSequence* PlayerAnim, class ARBThrowableWeapon* escapeItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_GroundAndPoundPlayerEscape");
		
		ARBNPC_Multicast_GroundAndPoundPlayerEscape_Params params {};
		params.escapingPlayer = escapingPlayer;
		params.pouncerAnim = pouncerAnim;
		params.PlayerAnim = PlayerAnim;
		params.escapeItem = escapeItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_GroundAndPoundInterrupted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   pinnedPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              npcToInterrupterRelativeYaw                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_GroundAndPoundInterrupted(class ARBPlayer* pinnedPlayer, float npcToInterrupterRelativeYaw)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_GroundAndPoundInterrupted");
		
		ARBNPC_Multicast_GroundAndPoundInterrupted_Params params {};
		params.pinnedPlayer = pinnedPlayer;
		params.npcToInterrupterRelativeYaw = npcToInterrupterRelativeYaw;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_ExitMonsterCloset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBMonsterCloset*                            Closet                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_ExitMonsterCloset(class ARBMonsterCloset* Closet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_ExitMonsterCloset");
		
		ARBNPC_Multicast_ExitMonsterCloset_Params params {};
		params.Closet = Closet;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_ExitGrenadeStun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetDir                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_ExitGrenadeStun(const struct FVector& Location, const struct FVector& TargetDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_ExitGrenadeStun");
		
		ARBNPC_Multicast_ExitGrenadeStun_Params params {};
		params.Location = Location;
		params.TargetDir = TargetDir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_EnterMonsterCloset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBMonsterCloset*                            Closet                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_EnterMonsterCloset(class ARBMonsterCloset* Closet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_EnterMonsterCloset");
		
		ARBNPC_Multicast_EnterMonsterCloset_Params params {};
		params.Closet = Closet;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_EnterHealSlowdownState
	 * 		Flags  -> ()
	 */
	void ARBNPC::Multicast_EnterHealSlowdownState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_EnterHealSlowdownState");
		
		ARBNPC_Multicast_EnterHealSlowdownState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_EnterGroundAndPoundAttacker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetPos                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetDir                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               enterGnPAnimSeq                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_EnterGroundAndPoundAttacker(class ARBPawn* Victim, const struct FVector& TargetPos, const struct FVector& TargetDir, class UAnimSequence* enterGnPAnimSeq)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_EnterGroundAndPoundAttacker");
		
		ARBNPC_Multicast_EnterGroundAndPoundAttacker_Params params {};
		params.Victim = Victim;
		params.TargetPos = TargetPos;
		params.TargetDir = TargetDir;
		params.enterGnPAnimSeq = enterGnPAnimSeq;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_EnterGrenadeStun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              stunDuration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetDir                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_EnterGrenadeStun(float stunDuration, const struct FVector& Location, const struct FVector& TargetDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_EnterGrenadeStun");
		
		ARBNPC_Multicast_EnterGrenadeStun_Params params {};
		params.stunDuration = stunDuration;
		params.Location = Location;
		params.TargetDir = TargetDir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_EnterBlindPaintState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              relYawToPaint                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     StartLocation                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     startDir                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_EnterBlindPaintState(float relYawToPaint, const struct FVector& StartLocation, const struct FVector& startDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_EnterBlindPaintState");
		
		ARBNPC_Multicast_EnterBlindPaintState_Params params {};
		params.relYawToPaint = relYawToPaint;
		params.StartLocation = StartLocation;
		params.startDir = startDir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_EnterAmbientStation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBAmbientStationComponent*                  AmbientStation                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bImmediate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     entryLocation                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     entryForward                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_EnterAmbientStation(class URBAmbientStationComponent* AmbientStation, bool bImmediate, const struct FVector& entryLocation, const struct FVector& entryForward)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_EnterAmbientStation");
		
		ARBNPC_Multicast_EnterAmbientStation_Params params {};
		params.AmbientStation = AmbientStation;
		params.bImmediate = bImmediate;
		params.entryLocation = entryLocation;
		params.entryForward = entryForward;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_DoorPass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNPCDoorInteractionData                     doorPass                                                   (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_DoorPass(const struct FNPCDoorInteractionData& doorPass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_DoorPass");
		
		ARBNPC_Multicast_DoorPass_Params params {};
		params.doorPass = doorPass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_DoorInvestigate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNPCDoorInvestigationParams                 doorInvParams                                              (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_DoorInvestigate(const struct FNPCDoorInvestigationParams& doorInvParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_DoorInvestigate");
		
		ARBNPC_Multicast_DoorInvestigate_Params params {};
		params.doorInvParams = doorInvParams;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_CycleBreaker
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENPCAnimStyle                                      breakerAnimStyle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            randomSelector                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_CycleBreaker(ENPCAnimStyle breakerAnimStyle, int32_t randomSelector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_CycleBreaker");
		
		ARBNPC_Multicast_CycleBreaker_Params params {};
		params.breakerAnimStyle = breakerAnimStyle;
		params.randomSelector = randomSelector;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_CompleteNPCSpecialMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESpecialMove                                       specialMoveCompleted                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              specialMoveEndVelocityOverride                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_CompleteNPCSpecialMove(ESpecialMove specialMoveCompleted, float specialMoveEndVelocityOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_CompleteNPCSpecialMove");
		
		ARBNPC_Multicast_CompleteNPCSpecialMove_Params params {};
		params.specialMoveCompleted = specialMoveCompleted;
		params.specialMoveEndVelocityOverride = specialMoveEndVelocityOverride;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_AnimatedStop
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNPCAnimatedStopData                        stopData                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_AnimatedStop(const struct FNPCAnimatedStopData& stopData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_AnimatedStop");
		
		ARBNPC_Multicast_AnimatedStop_Params params {};
		params.stopData = stopData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_AnimatedStart
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNPCAnimatedStartData                       startData                                                  (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_AnimatedStart(const struct FNPCAnimatedStartData& startData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_AnimatedStart");
		
		ARBNPC_Multicast_AnimatedStart_Params params {};
		params.startData = startData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Multicast_AlignToMark
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     AlignPos                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              alignYaw                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              blendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Multicast_AlignToMark(const struct FVector& AlignPos, float alignYaw, float blendTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Multicast_AlignToMark");
		
		ARBNPC_Multicast_AlignToMark_Params params {};
		params.AlignPos = AlignPos;
		params.alignYaw = alignYaw;
		params.blendTime = blendTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.IsUsingConfigVoiceType
	 * 		Flags  -> ()
	 */
	bool ARBNPC::IsUsingConfigVoiceType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.IsUsingConfigVoiceType");
		
		ARBNPC_IsUsingConfigVoiceType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.IsLocalSpectre
	 * 		Flags  -> ()
	 */
	bool ARBNPC::IsLocalSpectre()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.IsLocalSpectre");
		
		ARBNPC_IsLocalSpectre_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.IsForcedCustomizationSex
	 * 		Flags  -> ()
	 */
	bool ARBNPC::IsForcedCustomizationSex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.IsForcedCustomizationSex");
		
		ARBNPC_IsForcedCustomizationSex_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.IsForcedCustomizationFemale
	 * 		Flags  -> ()
	 */
	bool ARBNPC::IsForcedCustomizationFemale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.IsForcedCustomizationFemale");
		
		ARBNPC_IsForcedCustomizationFemale_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.IsAHiddenSpectre
	 * 		Flags  -> ()
	 */
	bool ARBNPC::IsAHiddenSpectre()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.IsAHiddenSpectre");
		
		ARBNPC_IsAHiddenSpectre_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.HasDoneGoryDeath
	 * 		Flags  -> ()
	 */
	bool ARBNPC::HasDoneGoryDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.HasDoneGoryDeath");
		
		ARBNPC_HasDoneGoryDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.GetWeaponType
	 * 		Flags  -> ()
	 */
	ENPCWeapon ARBNPC::GetWeaponType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.GetWeaponType");
		
		ARBNPC_GetWeaponType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.GetFoleySwitchOverride
	 * 		Flags  -> ()
	 */
	class FName ARBNPC::GetFoleySwitchOverride()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.GetFoleySwitchOverride");
		
		ARBNPC_GetFoleySwitchOverride_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.GetAttachedScriptedAnimStation
	 * 		Flags  -> ()
	 */
	class ARBScriptedAnimStation* ARBNPC::GetAttachedScriptedAnimStation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.GetAttachedScriptedAnimStation");
		
		ARBNPC_GetAttachedScriptedAnimStation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.GetAmbientStationComponent
	 * 		Flags  -> ()
	 */
	class URBAmbientStationComponent* ARBNPC::GetAmbientStationComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.GetAmbientStationComponent");
		
		ARBNPC_GetAmbientStationComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_PlayHitReactionEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     attackLoc                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    effectRotation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Event_PlayHitReactionEffects(const struct FVector& attackLoc, const struct FRotator& effectRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_PlayHitReactionEffects");
		
		ARBNPC_Event_PlayHitReactionEffects_Params params {};
		params.attackLoc = attackLoc;
		params.effectRotation = effectRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnWeaponVisible
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENPCWeapon                                         weaponType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBNPCWeapon*                                weaponActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Event_OnWeaponVisible(ENPCWeapon weaponType, class ARBNPCWeapon* weaponActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnWeaponVisible");
		
		ARBNPC_Event_OnWeaponVisible_Params params {};
		params.weaponType = weaponType;
		params.weaponActor = weaponActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnWeaponHidden
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENPCWeapon                                         weaponType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBNPCWeapon*                                weaponActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Event_OnWeaponHidden(ENPCWeapon weaponType, class ARBNPCWeapon* weaponActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnWeaponHidden");
		
		ARBNPC_Event_OnWeaponHidden_Params params {};
		params.weaponType = weaponType;
		params.weaponActor = weaponActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnStartPusherAttack
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Event_OnStartPusherAttack(class ARBPlayer* Victim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnStartPusherAttack");
		
		ARBNPC_Event_OnStartPusherAttack_Params params {};
		params.Victim = Victim;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnStartGrenadeStun
	 * 		Flags  -> ()
	 */
	void ARBNPC::Event_OnStartGrenadeStun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnStartGrenadeStun");
		
		ARBNPC_Event_OnStartGrenadeStun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnStartBlindPaintState
	 * 		Flags  -> ()
	 */
	void ARBNPC::Event_OnStartBlindPaintState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnStartBlindPaintState");
		
		ARBNPC_Event_OnStartBlindPaintState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnSpectreVisualTypeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EAISpectreVisualType                               oldType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAISpectreVisualType                               NewType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Event_OnSpectreVisualTypeChanged(EAISpectreVisualType oldType, EAISpectreVisualType NewType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnSpectreVisualTypeChanged");
		
		ARBNPC_Event_OnSpectreVisualTypeChanged_Params params {};
		params.oldType = oldType;
		params.NewType = NewType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnSpectreVisibilityChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldBeVisible                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Event_OnSpectreVisibilityChanged(bool bShouldBeVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnSpectreVisibilityChanged");
		
		ARBNPC_Event_OnSpectreVisibilityChanged_Params params {};
		params.bShouldBeVisible = bShouldBeVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnSpectreOutroSpecialMoveStarted
	 * 		Flags  -> ()
	 */
	void ARBNPC::Event_OnSpectreOutroSpecialMoveStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnSpectreOutroSpecialMoveStarted");
		
		ARBNPC_Event_OnSpectreOutroSpecialMoveStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnSpectreIntroSpecialMoveStarted
	 * 		Flags  -> ()
	 */
	void ARBNPC::Event_OnSpectreIntroSpecialMoveStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnSpectreIntroSpecialMoveStarted");
		
		ARBNPC_Event_OnSpectreIntroSpecialMoveStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnScreamerSonicStun
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     headLocation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Event_OnScreamerSonicStun(const struct FVector& headLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnScreamerSonicStun");
		
		ARBNPC_Event_OnScreamerSonicStun_Params params {};
		params.headLocation = headLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnHeadBoom
	 * 		Flags  -> ()
	 */
	void ARBNPC::Event_OnHeadBoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnHeadBoom");
		
		ARBNPC_Event_OnHeadBoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnEndGrenadeStun
	 * 		Flags  -> ()
	 */
	void ARBNPC::Event_OnEndGrenadeStun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnEndGrenadeStun");
		
		ARBNPC_Event_OnEndGrenadeStun_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnEndBlindPaintState
	 * 		Flags  -> ()
	 */
	void ARBNPC::Event_OnEndBlindPaintState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnEndBlindPaintState");
		
		ARBNPC_Event_OnEndBlindPaintState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnDealtWeaponDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     otherPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     DamageLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Event_OnDealtWeaponDamage(class ARBPawn* otherPawn, const struct FVector& DamageLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnDealtWeaponDamage");
		
		ARBNPC_Event_OnDealtWeaponDamage_Params params {};
		params.otherPawn = otherPawn;
		params.DamageLocation = DamageLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnDealtUnarmedDamage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     otherPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        damageSourceBone                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Event_OnDealtUnarmedDamage(class ARBPawn* otherPawn, const class FName& damageSourceBone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnDealtUnarmedDamage");
		
		ARBNPC_Event_OnDealtUnarmedDamage_Params params {};
		params.otherPawn = otherPawn;
		params.damageSourceBone = damageSourceBone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.Event_OnAIEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EAIEvent                                           EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      relevantActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::Event_OnAIEvent(EAIEvent EventType, class AActor* relevantActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.Event_OnAIEvent");
		
		ARBNPC_Event_OnAIEvent_Params params {};
		params.EventType = EventType;
		params.relevantActor = relevantActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.CanTriggerSoundTraps
	 * 		Flags  -> ()
	 */
	bool ARBNPC::CanTriggerSoundTraps()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.CanTriggerSoundTraps");
		
		ARBNPC_CanTriggerSoundTraps_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.BP_TestHitReaction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENPCHitReactionType                                hitReactionType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitDirection                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::BP_TestHitReaction(ENPCHitReactionType hitReactionType, const struct FVector& HitDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.BP_TestHitReaction");
		
		ARBNPC_BP_TestHitReaction_Params params {};
		params.hitReactionType = hitReactionType;
		params.HitDirection = HitDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.BP_TeleportTo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     DestLocation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    DestRotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bNoCheck                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::BP_TeleportTo(const struct FVector& DestLocation, const struct FRotator& DestRotation, bool bNoCheck)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.BP_TeleportTo");
		
		ARBNPC_BP_TeleportTo_Params params {};
		params.DestLocation = DestLocation;
		params.DestRotation = DestRotation;
		params.bNoCheck = bNoCheck;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.BP_SetVoiceType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      VoiceType                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::BP_SetVoiceType(const class FString& VoiceType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.BP_SetVoiceType");
		
		ARBNPC_BP_SetVoiceType_Params params {};
		params.VoiceType = VoiceType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.BP_OnCharacterAssembled
	 * 		Flags  -> ()
	 */
	void ARBNPC::BP_OnCharacterAssembled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.BP_OnCharacterAssembled");
		
		ARBNPC_BP_OnCharacterAssembled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.BP_GetWeaponActor
	 * 		Flags  -> ()
	 */
	class ARBNPCWeapon* ARBNPC::BP_GetWeaponActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.BP_GetWeaponActor");
		
		ARBNPC_BP_GetWeaponActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPC.BP_DamageNPC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDamageType                                        dmgType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      SrcActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DmgAmount                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanKill                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanKnockdown                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPC::BP_DamageNPC(EDamageType dmgType, class AActor* SrcActor, float DmgAmount, bool bCanKill, bool bCanKnockdown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPC.BP_DamageNPC");
		
		ARBNPC_BP_DamageNPC_Params params {};
		params.dmgType = dmgType;
		params.SrcActor = SrcActor;
		params.DmgAmount = DmgAmount;
		params.bCanKill = bCanKill;
		params.bCanKnockdown = bCanKnockdown;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBNPC.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBNPC::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNPC");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBImposter.OnRep_OverheadDetails
	 * 		Flags  -> ()
	 */
	void ARBImposter::OnRep_OverheadDetails()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBImposter.OnRep_OverheadDetails");
		
		ARBImposter_OnRep_OverheadDetails_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBImposter.OnRep_CustomizationInfo
	 * 		Flags  -> ()
	 */
	void ARBImposter::OnRep_CustomizationInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBImposter.OnRep_CustomizationInfo");
		
		ARBImposter_OnRep_CustomizationInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBImposter.Event_SetCustomization
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBPlayerCustomizationInfo                  newCustomization                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBImposter::Event_SetCustomization(const struct FRBPlayerCustomizationInfo& newCustomization)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBImposter.Event_SetCustomization");
		
		ARBImposter_Event_SetCustomization_Params params {};
		params.newCustomization = newCustomization;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBImposter.BP_GetCustomizationInfo
	 * 		Flags  -> ()
	 */
	struct FRBPlayerCustomizationInfo ARBImposter::BP_GetCustomizationInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBImposter.BP_GetCustomizationInfo");
		
		ARBImposter_BP_GetCustomizationInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBImposter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBImposter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBImposter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInGameMenuWidget.OnMenuCancelPressed
	 * 		Flags  -> ()
	 */
	void URBInGameMenuWidget::OnMenuCancelPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInGameMenuWidget.OnMenuCancelPressed");
		
		URBInGameMenuWidget_OnMenuCancelPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInGameMenuWidget.GetSocialMenuManager
	 * 		Flags  -> ()
	 */
	class URBSocialMenuManager* URBInGameMenuWidget::GetSocialMenuManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInGameMenuWidget.GetSocialMenuManager");
		
		URBInGameMenuWidget_GetSocialMenuManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInGameMenuWidget.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBInGameMenuWidget::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInGameMenuWidget.Event_Refresh");
		
		URBInGameMenuWidget_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBInGameMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBInGameMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInGameMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBInputIcon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBInputIcon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInputIcon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractable.TestPhysicsClearance
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactorPawn                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBInteractable::TestPhysicsClearance(class ARBPawn* interactorPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractable.TestPhysicsClearance");
		
		URBInteractable_TestPhysicsClearance_Params params {};
		params.interactorPawn = interactorPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractable.StartInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactorPawn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBInteractable::StartInteraction(class ARBPawn* interactorPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractable.StartInteraction");
		
		URBInteractable_StartInteraction_Params params {};
		params.interactorPawn = interactorPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractable.SnapToState
	 * 		Flags  -> ()
	 */
	void URBInteractable::SnapToState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractable.SnapToState");
		
		URBInteractable_SnapToState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractable.PostInteractionSoundEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     pawnInteractor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               akEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInteractable::PostInteractionSoundEvent(class ARBPawn* pawnInteractor, class UAkAudioEvent* akEvent, class UObject* Source)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractable.PostInteractionSoundEvent");
		
		URBInteractable_PostInteractionSoundEvent_Params params {};
		params.pawnInteractor = pawnInteractor;
		params.akEvent = akEvent;
		params.Source = Source;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractable.PlaySpecialMoveAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactorPawn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBInteractable::PlaySpecialMoveAnimation(class ARBPawn* interactorPawn, ESpecialMove specialMove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractable.PlaySpecialMoveAnimation");
		
		URBInteractable_PlaySpecialMoveAnimation_Params params {};
		params.interactorPawn = interactorPawn;
		params.specialMove = specialMove;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractable.OnPawnSpecialMoveStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInteractable::OnPawnSpecialMoveStarted(class ARBPawn* Pawn, ESpecialMove specialMove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractable.OnPawnSpecialMoveStarted");
		
		URBInteractable_OnPawnSpecialMoveStarted_Params params {};
		params.Pawn = Pawn;
		params.specialMove = specialMove;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractable.OnPawnSpecialMoveCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInteractable::OnPawnSpecialMoveCompleted(class ARBPawn* Pawn, ESpecialMove specialMove, bool bInterrupted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractable.OnPawnSpecialMoveCompleted");
		
		URBInteractable_OnPawnSpecialMoveCompleted_Params params {};
		params.Pawn = Pawn;
		params.specialMove = specialMove;
		params.bInterrupted = bInterrupted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractable.OnPawnPlaySpecialMoveAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInteractable::OnPawnPlaySpecialMoveAnimation(class ARBPawn* Pawn, ESpecialMove specialMove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractable.OnPawnPlaySpecialMoveAnimation");
		
		URBInteractable_OnPawnPlaySpecialMoveAnimation_Params params {};
		params.Pawn = Pawn;
		params.specialMove = specialMove;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractable.OnPawnDoSpecialMoveAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInteractable::OnPawnDoSpecialMoveAction(class ARBPawn* Pawn, ESpecialMove specialMove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractable.OnPawnDoSpecialMoveAction");
		
		URBInteractable_OnPawnDoSpecialMoveAction_Params params {};
		params.Pawn = Pawn;
		params.specialMove = specialMove;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractable.IsInteractionPossible
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactorPawn                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBInteractable::IsInteractionPossible(class ARBPawn* interactorPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractable.IsInteractionPossible");
		
		URBInteractable_IsInteractionPossible_Params params {};
		params.interactorPawn = interactorPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractable.IsInteractionInputTriggered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   interactor                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBInteractable::IsInteractionInputTriggered(class ARBPlayer* interactor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractable.IsInteractionInputTriggered");
		
		URBInteractable_IsInteractionInputTriggered_Params params {};
		params.interactor = interactor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractable.GetInteractionPawnLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     outDirection                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBInteractable::GetInteractionPawnLocation(class ARBPawn* Pawn, ESpecialMove specialMove, struct FVector* OutLocation, struct FVector* outDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractable.GetInteractionPawnLocation");
		
		URBInteractable_GetInteractionPawnLocation_Params params {};
		params.Pawn = Pawn;
		params.specialMove = specialMove;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		if (outDirection != nullptr)
			*outDirection = params.outDirection;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractable.EndInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bPredicted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     interactorPawn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBInteractable::EndInteraction(bool bPredicted, class ARBPawn* interactorPawn, bool bInterrupted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractable.EndInteraction");
		
		URBInteractable_EndInteraction_Params params {};
		params.bPredicted = bPredicted;
		params.interactorPawn = interactorPawn;
		params.bInterrupted = bInterrupted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBInteractable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBInteractable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInteractable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBInteractionPlaneComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBInteractionPlaneComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInteractionPlaneComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBItemInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBItemInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBItemInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBItemProhibitedInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBItemProhibitedInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBItemProhibitedInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBQuestGiverInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBQuestGiverInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBQuestGiverInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBReleaseCharacterInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBReleaseCharacterInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBReleaseCharacterInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCellInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCellInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCellInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLargeObjectInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLargeObjectInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLargeObjectInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPsychosisInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPsychosisInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPsychosisInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCollectibleDocumentInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCollectibleDocumentInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCollectibleDocumentInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBDisabledInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBDisabledInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBDisabledInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCompletedCoordinatorInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCompletedCoordinatorInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCompletedCoordinatorInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBInteractiveCorpse.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBInteractiveCorpse::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInteractiveCorpse");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractivePanelObjectiveCoordinator.OnPanelPawnInteractingChangedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     pawnInteracting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractivePanelObjectiveCoordinator::OnPanelPawnInteractingChangedEvent(class URBInteractiblePanelComponent* panel, class ARBPawn* pawnInteracting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractivePanelObjectiveCoordinator.OnPanelPawnInteractingChangedEvent");
		
		ARBInteractivePanelObjectiveCoordinator_OnPanelPawnInteractingChangedEvent_Params params {};
		params.panel = panel;
		params.pawnInteracting = pawnInteracting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInteractivePanelObjectiveCoordinator.OnPanelActiveChangedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     pawnInteracting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInteractivePanelObjectiveCoordinator::OnPanelActiveChangedEvent(class URBInteractiblePanelComponent* panel, class ARBPawn* pawnInteracting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInteractivePanelObjectiveCoordinator.OnPanelActiveChangedEvent");
		
		ARBInteractivePanelObjectiveCoordinator_OnPanelActiveChangedEvent_Params params {};
		params.panel = panel;
		params.pawnInteracting = pawnInteracting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBInteractivePanelObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBInteractivePanelObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInteractivePanelObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBIntercomSoundComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBIntercomSoundComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBIntercomSoundComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleHoldPanelComponent.OnRep_HoldCompleted
	 * 		Flags  -> ()
	 */
	void URBSimpleHoldPanelComponent::OnRep_HoldCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleHoldPanelComponent.OnRep_HoldCompleted");
		
		URBSimpleHoldPanelComponent_OnRep_HoldCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleHoldPanelComponent.OnRep_AccumulatedInteractionTime
	 * 		Flags  -> ()
	 */
	void URBSimpleHoldPanelComponent::OnRep_AccumulatedInteractionTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleHoldPanelComponent.OnRep_AccumulatedInteractionTime");
		
		URBSimpleHoldPanelComponent_OnRep_AccumulatedInteractionTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleHoldPanelComponent.OnHoldCompletedChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSimpleHoldPanelComponent::OnHoldCompletedChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleHoldPanelComponent.OnHoldCompletedChangedCallback");
		
		URBSimpleHoldPanelComponent_OnHoldCompletedChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleHoldPanelComponent.OnAccumulatedInteractionTimeChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSimpleHoldPanelComponent::OnAccumulatedInteractionTimeChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleHoldPanelComponent.OnAccumulatedInteractionTimeChangedCallback");
		
		URBSimpleHoldPanelComponent_OnAccumulatedInteractionTimeChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleHoldPanelComponent.IsHoldCompleted
	 * 		Flags  -> ()
	 */
	bool URBSimpleHoldPanelComponent::IsHoldCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleHoldPanelComponent.IsHoldCompleted");
		
		URBSimpleHoldPanelComponent_IsHoldCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleHoldPanelComponent.GetHeldTime
	 * 		Flags  -> ()
	 */
	float URBSimpleHoldPanelComponent::GetHeldTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleHoldPanelComponent.GetHeldTime");
		
		URBSimpleHoldPanelComponent_GetHeldTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleHoldPanelComponent.Event_OnAccumulatedInteractionTimeChanged
	 * 		Flags  -> ()
	 */
	void URBSimpleHoldPanelComponent::Event_OnAccumulatedInteractionTimeChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleHoldPanelComponent.Event_OnAccumulatedInteractionTimeChanged");
		
		URBSimpleHoldPanelComponent_Event_OnAccumulatedInteractionTimeChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleHoldPanelComponent.BP_GetProgressRatio
	 * 		Flags  -> ()
	 */
	float URBSimpleHoldPanelComponent::BP_GetProgressRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleHoldPanelComponent.BP_GetProgressRatio");
		
		URBSimpleHoldPanelComponent_BP_GetProgressRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSimpleHoldPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSimpleHoldPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSimpleHoldPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryItemInteractionPanelComponent.OnRep_OverrideItemClass
	 * 		Flags  -> ()
	 */
	void URBInventoryItemInteractionPanelComponent::OnRep_OverrideItemClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryItemInteractionPanelComponent.OnRep_OverrideItemClass");
		
		URBInventoryItemInteractionPanelComponent_OnRep_OverrideItemClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryItemInteractionPanelComponent.OnRep_NumberOfItemsUsed
	 * 		Flags  -> ()
	 */
	void URBInventoryItemInteractionPanelComponent::OnRep_NumberOfItemsUsed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryItemInteractionPanelComponent.OnRep_NumberOfItemsUsed");
		
		URBInventoryItemInteractionPanelComponent_OnRep_NumberOfItemsUsed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryItemInteractionPanelComponent.OnRep_NumberOfItemsRequired
	 * 		Flags  -> ()
	 */
	void URBInventoryItemInteractionPanelComponent::OnRep_NumberOfItemsRequired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryItemInteractionPanelComponent.OnRep_NumberOfItemsRequired");
		
		URBInventoryItemInteractionPanelComponent_OnRep_NumberOfItemsRequired_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryItemInteractionPanelComponent.GetItemFromPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactorPawn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBPickup* URBInventoryItemInteractionPanelComponent::GetItemFromPlayer(class ARBPawn* interactorPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryItemInteractionPanelComponent.GetItemFromPlayer");
		
		URBInventoryItemInteractionPanelComponent_GetItemFromPlayer_Params params {};
		params.interactorPawn = interactorPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryItemInteractionPanelComponent.GetItemDropRef
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   pickup                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USceneComponent* URBInventoryItemInteractionPanelComponent::GetItemDropRef(class ARBPickup* pickup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryItemInteractionPanelComponent.GetItemDropRef");
		
		URBInventoryItemInteractionPanelComponent_GetItemDropRef_Params params {};
		params.pickup = pickup;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryItemInteractionPanelComponent.BP_UseInventoryItemPredicted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   pickup                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     interactorPawn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInventoryItemInteractionPanelComponent::BP_UseInventoryItemPredicted(class ARBPickup* pickup, class ARBPawn* interactorPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryItemInteractionPanelComponent.BP_UseInventoryItemPredicted");
		
		URBInventoryItemInteractionPanelComponent_BP_UseInventoryItemPredicted_Params params {};
		params.pickup = pickup;
		params.interactorPawn = interactorPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBInventoryItemInteractionPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBInventoryItemInteractionPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInventoryItemInteractionPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryWheel.OnShowInventoryWheel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInventoryWheelMode                                Mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInventoryWheel::OnShowInventoryWheel(EInventoryWheelMode Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryWheel.OnShowInventoryWheel");
		
		URBInventoryWheel_OnShowInventoryWheel_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryWheel.OnSelectedItemChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInventoryWheel::OnSelectedItemChanged(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryWheel.OnSelectedItemChanged");
		
		URBInventoryWheel_OnSelectedItemChanged_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryWheel.OnInventoryUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EInventoryUpdateEventType                          EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBInventoryWheel::OnInventoryUpdated(EInventoryUpdateEventType EventType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryWheel.OnInventoryUpdated");
		
		URBInventoryWheel_OnInventoryUpdated_Params params {};
		params.EventType = EventType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryWheel.OnHideInventoryWheel
	 * 		Flags  -> ()
	 */
	void URBInventoryWheel::OnHideInventoryWheel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryWheel.OnHideInventoryWheel");
		
		URBInventoryWheel_OnHideInventoryWheel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryWheel.OnAddedToSimulatedMouseLocation
	 * 		Flags  -> ()
	 */
	void URBInventoryWheel::OnAddedToSimulatedMouseLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryWheel.OnAddedToSimulatedMouseLocation");
		
		URBInventoryWheel_OnAddedToSimulatedMouseLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryWheel.Event_WheelModeChanged
	 * 		Flags  -> ()
	 */
	void URBInventoryWheel::Event_WheelModeChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryWheel.Event_WheelModeChanged");
		
		URBInventoryWheel_Event_WheelModeChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryWheel.Event_UpdateSelectedCategory
	 * 		Flags  -> ()
	 */
	void URBInventoryWheel::Event_UpdateSelectedCategory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryWheel.Event_UpdateSelectedCategory");
		
		URBInventoryWheel_Event_UpdateSelectedCategory_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryWheel.Event_UpdateEquippedItem
	 * 		Flags  -> ()
	 */
	void URBInventoryWheel::Event_UpdateEquippedItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryWheel.Event_UpdateEquippedItem");
		
		URBInventoryWheel_Event_UpdateEquippedItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryWheel.Event_SelectionAngleChanged
	 * 		Flags  -> ()
	 */
	void URBInventoryWheel::Event_SelectionAngleChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryWheel.Event_SelectionAngleChanged");
		
		URBInventoryWheel_Event_SelectionAngleChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInventoryWheel.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBInventoryWheel::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInventoryWheel.Event_Refresh");
		
		URBInventoryWheel_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBInventoryWheel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBInventoryWheel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInventoryWheel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBInvestigationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBInvestigationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInvestigationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBInvestigationPoint.Event_OnInvestigate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBInvestigationPoint::Event_OnInvestigate(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBInvestigationPoint.Event_OnInvestigate");
		
		ARBInvestigationPoint_Event_OnInvestigate_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBInvestigationPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBInvestigationPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBInvestigationPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBItemActiveSkill.OnItemThrown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBThrowableWeapon*                          thrownItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBItemActiveSkill::OnItemThrown(class ARBThrowableWeapon* thrownItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBItemActiveSkill.OnItemThrown");
		
		ARBItemActiveSkill_OnItemThrown_Params params {};
		params.thrownItem = thrownItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBItemActiveSkill.OnItemDeployed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBDeployableSkillItem*                      thrownItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBItemActiveSkill::OnItemDeployed(class ARBDeployableSkillItem* thrownItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBItemActiveSkill.OnItemDeployed");
		
		ARBItemActiveSkill_OnItemDeployed_Params params {};
		params.thrownItem = thrownItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBItemActiveSkill.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBItemActiveSkill::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBItemActiveSkill");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBItemSpawningManagerConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBItemSpawningManagerConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBItemSpawningManagerConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBItemSpawningManager.GetItemClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemType                                          ItemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* ARBItemSpawningManager::GetItemClass(EItemType ItemType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBItemSpawningManager.GetItemClass");
		
		ARBItemSpawningManager_GetItemClass_Params params {};
		params.ItemType = ItemType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBItemSpawningManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBItemSpawningManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBItemSpawningManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBJumpScareTriggerable.TryTriggerScareStinger
	 * 		Flags  -> ()
	 */
	void ARBJumpScareTriggerable::TryTriggerScareStinger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBJumpScareTriggerable.TryTriggerScareStinger");
		
		ARBJumpScareTriggerable_TryTriggerScareStinger_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBJumpScareTriggerable.OnTriggerBoxOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBJumpScareTriggerable::OnTriggerBoxOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBJumpScareTriggerable.OnTriggerBoxOverlap");
		
		ARBJumpScareTriggerable_OnTriggerBoxOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBJumpScareTriggerable.OnRoomEntered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBJumpScareTriggerable::OnRoomEntered(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBJumpScareTriggerable.OnRoomEntered");
		
		ARBJumpScareTriggerable_OnRoomEntered_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBJumpScareTriggerable.Multicast_SetIgnoreStinger
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIgnore                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBJumpScareTriggerable::Multicast_SetIgnoreStinger(bool bIgnore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBJumpScareTriggerable.Multicast_SetIgnoreStinger");
		
		ARBJumpScareTriggerable_Multicast_SetIgnoreStinger_Params params {};
		params.bIgnore = bIgnore;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBJumpScareTriggerable.InitializeLinkedRoom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBRoomAssociationComponent*                 roomAssociationComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBJumpScareTriggerable::InitializeLinkedRoom(class URBRoomAssociationComponent* roomAssociationComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBJumpScareTriggerable.InitializeLinkedRoom");
		
		ARBJumpScareTriggerable_InitializeLinkedRoom_Params params {};
		params.roomAssociationComponent = roomAssociationComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBJumpScareTriggerable.GetScareStingerLocation
	 * 		Flags  -> ()
	 */
	struct FVector ARBJumpScareTriggerable::GetScareStingerLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBJumpScareTriggerable.GetScareStingerLocation");
		
		ARBJumpScareTriggerable_GetScareStingerLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBJumpScareTriggerable.CanTriggerScareJump
	 * 		Flags  -> ()
	 */
	bool ARBJumpScareTriggerable::CanTriggerScareJump()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBJumpScareTriggerable.CanTriggerScareJump");
		
		ARBJumpScareTriggerable_CanTriggerScareJump_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBJumpScareTriggerable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBJumpScareTriggerable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBJumpScareTriggerable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLargeObjectGhostAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLargeObjectGhostAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLargeObjectGhostAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLastGameSessionDetails.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLastGameSessionDetails::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLastGameSessionDetails");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBLeashMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBLeashMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLeashMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineActor.SetLink
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBSplineActor*                              NextMarker                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSplineActor::SetLink(class ARBSplineActor* NextMarker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineActor.SetLink");
		
		ARBSplineActor_SetLink_Params params {};
		params.NextMarker = NextMarker;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSplineActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSplineActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSplineActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLedgeMarker.Validate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bDebug                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLedgeMarker::Validate(bool bDebug)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLedgeMarker.Validate");
		
		ARBLedgeMarker_Validate_Params params {};
		params.bDebug = bDebug;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLedgeMarker.UnlinkPrevious
	 * 		Flags  -> ()
	 */
	void ARBLedgeMarker::UnlinkPrevious()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLedgeMarker.UnlinkPrevious");
		
		ARBLedgeMarker_UnlinkPrevious_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLedgeMarker.UnlinkNext
	 * 		Flags  -> ()
	 */
	void ARBLedgeMarker::UnlinkNext()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLedgeMarker.UnlinkNext");
		
		ARBLedgeMarker_UnlinkNext_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLedgeMarker.SetCanBeUsedByAI
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               canBeUsedByAI                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLedgeMarker::SetCanBeUsedByAI(bool canBeUsedByAI)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLedgeMarker.SetCanBeUsedByAI");
		
		ARBLedgeMarker_SetCanBeUsedByAI_Params params {};
		params.canBeUsedByAI = canBeUsedByAI;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLedgeMarker.SelectPrevious
	 * 		Flags  -> ()
	 */
	void ARBLedgeMarker::SelectPrevious()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLedgeMarker.SelectPrevious");
		
		ARBLedgeMarker_SelectPrevious_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLedgeMarker.SelectNext
	 * 		Flags  -> ()
	 */
	void ARBLedgeMarker::SelectNext()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLedgeMarker.SelectNext");
		
		ARBLedgeMarker_SelectNext_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLedgeMarker.SelectGroup
	 * 		Flags  -> ()
	 */
	void ARBLedgeMarker::SelectGroup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLedgeMarker.SelectGroup");
		
		ARBLedgeMarker_SelectGroup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLedgeMarker.GotoPrevious
	 * 		Flags  -> ()
	 */
	void ARBLedgeMarker::GotoPrevious()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLedgeMarker.GotoPrevious");
		
		ARBLedgeMarker_GotoPrevious_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLedgeMarker.GotoNext
	 * 		Flags  -> ()
	 */
	void ARBLedgeMarker::GotoNext()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLedgeMarker.GotoNext");
		
		ARBLedgeMarker_GotoNext_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLedgeMarker.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabledValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLedgeMarker::BP_SetEnabled(bool bEnabledValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLedgeMarker.BP_SetEnabled");
		
		ARBLedgeMarker_BP_SetEnabled_Params params {};
		params.bEnabledValue = bEnabledValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBLedgeMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBLedgeMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLedgeMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLevelScriptActor.OnWorldLoadingFinished
	 * 		Flags  -> ()
	 */
	void ARBLevelScriptActor::OnWorldLoadingFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLevelScriptActor.OnWorldLoadingFinished");
		
		ARBLevelScriptActor_OnWorldLoadingFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLevelScriptActor.OnStageStartedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBLevelScriptActor::OnStageStartedCallback(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLevelScriptActor.OnStageStartedCallback");
		
		ARBLevelScriptActor_OnStageStartedCallback_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLevelScriptActor.OnStageStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (Parm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void ARBLevelScriptActor::OnStageStarted(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLevelScriptActor.OnStageStarted");
		
		ARBLevelScriptActor_OnStageStarted_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLevelScriptActor.OnStageReadyCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBLevelScriptActor::OnStageReadyCallback(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLevelScriptActor.OnStageReadyCallback");
		
		ARBLevelScriptActor_OnStageReadyCallback_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLevelScriptActor.OnStageReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (Parm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void ARBLevelScriptActor::OnStageReady(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLevelScriptActor.OnStageReady");
		
		ARBLevelScriptActor_OnStageReady_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLevelScriptActor.OnStageEndedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsFail                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLevelScriptActor::OnStageEndedCallback(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, bool bIsFail)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLevelScriptActor.OnStageEndedCallback");
		
		ARBLevelScriptActor_OnStageEndedCallback_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		params.bIsFail = bIsFail;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLevelScriptActor.OnStageEnded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (Parm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsFail                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLevelScriptActor::OnStageEnded(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, bool bIsFail)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLevelScriptActor.OnStageEnded");
		
		ARBLevelScriptActor_OnStageEnded_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		params.bIsFail = bIsFail;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLevelScriptActor.OnPopulatingFinished
	 * 		Flags  -> ()
	 */
	void ARBLevelScriptActor::OnPopulatingFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLevelScriptActor.OnPopulatingFinished");
		
		ARBLevelScriptActor_OnPopulatingFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLevelScriptActor.OnObjectiveCoordinatorStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBaseObjectiveCoordinator*                 coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EObjectiveCoordinatorState                         State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLevelScriptActor::OnObjectiveCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* coordinator, EObjectiveCoordinatorState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLevelScriptActor.OnObjectiveCoordinatorStateChanged");
		
		ARBLevelScriptActor_OnObjectiveCoordinatorStateChanged_Params params {};
		params.coordinator = coordinator;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLevelScriptActor.OnCoordinatorStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBaseObjectiveCoordinator*                 coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsApplyingCheats                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLevelScriptActor::OnCoordinatorStarted(class ARBBaseObjectiveCoordinator* coordinator, bool bIsApplyingCheats)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLevelScriptActor.OnCoordinatorStarted");
		
		ARBLevelScriptActor_OnCoordinatorStarted_Params params {};
		params.coordinator = coordinator;
		params.bIsApplyingCheats = bIsApplyingCheats;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLevelScriptActor.OnCoordinatorCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBaseObjectiveCoordinator*                 coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsApplyingCheats                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLevelScriptActor::OnCoordinatorCompleted(class ARBBaseObjectiveCoordinator* coordinator, bool bIsApplyingCheats)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLevelScriptActor.OnCoordinatorCompleted");
		
		ARBLevelScriptActor_OnCoordinatorCompleted_Params params {};
		params.coordinator = coordinator;
		params.bIsApplyingCheats = bIsApplyingCheats;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLevelScriptActor.OnAIDirectorSpawnedBotCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBNPC*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLevelScriptActor::OnAIDirectorSpawnedBotCallback(class ARBBot* bot, class ARBNPC* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLevelScriptActor.OnAIDirectorSpawnedBotCallback");
		
		ARBLevelScriptActor_OnAIDirectorSpawnedBotCallback_Params params {};
		params.bot = bot;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLevelScriptActor.OnAIDirectorSpawnedBot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBNPC*                                      Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLevelScriptActor::OnAIDirectorSpawnedBot(class ARBBot* bot, class ARBNPC* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLevelScriptActor.OnAIDirectorSpawnedBot");
		
		ARBLevelScriptActor_OnAIDirectorSpawnedBot_Params params {};
		params.bot = bot;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBLevelScriptActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBLevelScriptActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLevelScriptActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLight.UpdateColors
	 * 		Flags  -> ()
	 */
	void ARBLight::UpdateColors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLight.UpdateColors");
		
		ARBLight_UpdateColors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLight.UpdateAffectsWorld
	 * 		Flags  -> ()
	 */
	void ARBLight::UpdateAffectsWorld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLight.UpdateAffectsWorld");
		
		ARBLight_UpdateAffectsWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLight.PlayAnimationCurve
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UCurveFloat*                                 newAnimCurve                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Looping                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLight::PlayAnimationCurve(class UCurveFloat* newAnimCurve, bool Looping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLight.PlayAnimationCurve");
		
		ARBLight_PlayAnimationCurve_Params params {};
		params.newAnimCurve = newAnimCurve;
		params.Looping = Looping;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLight.OnRep_LightMode
	 * 		Flags  -> ()
	 */
	void ARBLight::OnRep_LightMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLight.OnRep_LightMode");
		
		ARBLight_OnRep_LightMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLight.OnRep_Color
	 * 		Flags  -> ()
	 */
	void ARBLight::OnRep_Color()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLight.OnRep_Color");
		
		ARBLight_OnRep_Color_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLight.OnRep_AnimationCurveData
	 * 		Flags  -> ()
	 */
	void ARBLight::OnRep_AnimationCurveData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLight.OnRep_AnimationCurveData");
		
		ARBLight_OnRep_AnimationCurveData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLight.OnLightMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            newLightMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLight::OnLightMode(int32_t newLightMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLight.OnLightMode");
		
		ARBLight_OnLightMode_Params params {};
		params.newLightMode = newLightMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLight.OnBPConstruction
	 * 		Flags  -> ()
	 */
	void ARBLight::OnBPConstruction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLight.OnBPConstruction");
		
		ARBLight_OnBPConstruction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLight.GetOldLightValues
	 * 		Flags  -> ()
	 */
	void ARBLight::GetOldLightValues()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLight.GetOldLightValues");
		
		ARBLight_GetOldLightValues_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLight.BP_SetLightColor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLinearColor                                newColor                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLight::BP_SetLightColor(const struct FLinearColor& newColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLight.BP_SetLightColor");
		
		ARBLight_BP_SetLightColor_Params params {};
		params.newColor = newColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBLight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBLight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSpotLightComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSpotLightComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSpotLightComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLineOfSightTrigger.BP_EnableTrigger
	 * 		Flags  -> ()
	 */
	void ARBLineOfSightTrigger::BP_EnableTrigger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLineOfSightTrigger.BP_EnableTrigger");
		
		ARBLineOfSightTrigger_BP_EnableTrigger_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLineOfSightTrigger.BP_DisableTrigger
	 * 		Flags  -> ()
	 */
	void ARBLineOfSightTrigger::BP_DisableTrigger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLineOfSightTrigger.BP_DisableTrigger");
		
		ARBLineOfSightTrigger_BP_DisableTrigger_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBLineOfSightTrigger.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBLineOfSightTrigger::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLineOfSightTrigger");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLoadingScreenWidget.Event_StopLoadingScreen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               skipOutro                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLoadingScreenWidget::Event_StopLoadingScreen(bool skipOutro)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLoadingScreenWidget.Event_StopLoadingScreen");
		
		URBLoadingScreenWidget_Event_StopLoadingScreen_Params params {};
		params.skipOutro = skipOutro;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLoadingScreenWidget.Event_StartLoadingScreen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               skipIntro                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLoadingScreenWidget::Event_StartLoadingScreen(bool skipIntro)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLoadingScreenWidget.Event_StartLoadingScreen");
		
		URBLoadingScreenWidget_Event_StartLoadingScreen_Params params {};
		params.skipIntro = skipIntro;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLoadingScreenWidget.BP_OnLoadingScreenOutroCompleted
	 * 		Flags  -> ()
	 */
	void URBLoadingScreenWidget::BP_OnLoadingScreenOutroCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLoadingScreenWidget.BP_OnLoadingScreenOutroCompleted");
		
		URBLoadingScreenWidget_BP_OnLoadingScreenOutroCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLoadingScreenWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLoadingScreenWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLoadingScreenWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLoadoutValidationCondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLoadoutValidationCondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLoadoutValidationCondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLoadoutValidationConditionGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLoadoutValidationConditionGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLoadoutValidationConditionGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBActiveSkillValidationCondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBActiveSkillValidationCondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBActiveSkillValidationCondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLobbyData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLobbyData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLobbyData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyFakeReagent.TryPlayFacialAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      lineId                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBLobbyFakeReagent::TryPlayFacialAnim(const class FString& lineId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyFakeReagent.TryPlayFacialAnim");
		
		ARBLobbyFakeReagent_TryPlayFacialAnim_Params params {};
		params.lineId = lineId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyFakeReagent.GetFaceFXSkeletalMeshComponent
	 * 		Flags  -> ()
	 */
	class USkeletalMeshComponent* ARBLobbyFakeReagent::GetFaceFXSkeletalMeshComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyFakeReagent.GetFaceFXSkeletalMeshComponent");
		
		ARBLobbyFakeReagent_GetFaceFXSkeletalMeshComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBLobbyFakeReagent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBLobbyFakeReagent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLobbyFakeReagent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.SetMatchFixedSeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            fixedSeed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::SetMatchFixedSeed(int32_t fixedSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.SetMatchFixedSeed");
		
		ARBLobbyPlayerController_SetMatchFixedSeed_Params params {};
		params.fixedSeed = fixedSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.SetMatchFixedPlayerCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            fixedPlayerCount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::SetMatchFixedPlayerCount(int32_t fixedPlayerCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.SetMatchFixedPlayerCount");
		
		ARBLobbyPlayerController_SetMatchFixedPlayerCount_Params params {};
		params.fixedPlayerCount = fixedPlayerCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_UpdatePlayerCellCustomization
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRBPlayerCellCustomizationEntry>     playerCellCustomization                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Server_UpdatePlayerCellCustomization(TArray<struct FRBPlayerCellCustomizationEntry> playerCellCustomization)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_UpdatePlayerCellCustomization");
		
		ARBLobbyPlayerController_Server_UpdatePlayerCellCustomization_Params params {};
		params.playerCellCustomization = playerCellCustomization;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_UpdateMatchSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FMatchSettings                              MatchSettings                                              (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Server_UpdateMatchSettings(const struct FMatchSettings& MatchSettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_UpdateMatchSettings");
		
		ARBLobbyPlayerController_Server_UpdateMatchSettings_Params params {};
		params.MatchSettings = MatchSettings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_StartMatchCountdown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class ARBLobbyPlayerState*>                 members                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FMatchSettings                              MatchSettings                                              (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseLongCancelGracePeriod                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Server_StartMatchCountdown(TArray<class ARBLobbyPlayerState*> members, const struct FMatchSettings& MatchSettings, bool bUseLongCancelGracePeriod)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_StartMatchCountdown");
		
		ARBLobbyPlayerController_Server_StartMatchCountdown_Params params {};
		params.members = members;
		params.MatchSettings = MatchSettings;
		params.bUseLongCancelGracePeriod = bUseLongCancelGracePeriod;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_RequestTravelToPendingMatch
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Server_RequestTravelToPendingMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_RequestTravelToPendingMatch");
		
		ARBLobbyPlayerController_Server_RequestTravelToPendingMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_RequestReleaseCurrentCharacter
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Server_RequestReleaseCurrentCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_RequestReleaseCurrentCharacter");
		
		ARBLobbyPlayerController_Server_RequestReleaseCurrentCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_ReportWaitForPartyFailed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            errorFacility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ErrorCode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Server_ReportWaitForPartyFailed(int32_t errorFacility, int32_t ErrorCode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_ReportWaitForPartyFailed");
		
		ARBLobbyPlayerController_Server_ReportWaitForPartyFailed_Params params {};
		params.errorFacility = errorFacility;
		params.ErrorCode = ErrorCode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_ReportWaitForMatchFailed
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Server_ReportWaitForMatchFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_ReportWaitForMatchFailed");
		
		ARBLobbyPlayerController_Server_ReportWaitForMatchFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_ReportPartyFound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            partySize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Server_ReportPartyFound(int32_t partySize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_ReportPartyFound");
		
		ARBLobbyPlayerController_Server_ReportPartyFound_Params params {};
		params.partySize = partySize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_ReportMatchFound
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Server_ReportMatchFound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_ReportMatchFound");
		
		ARBLobbyPlayerController_Server_ReportMatchFound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_OnDLCConcentPackPurchased
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Server_OnDLCConcentPackPurchased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_OnDLCConcentPackPurchased");
		
		ARBLobbyPlayerController_Server_OnDLCConcentPackPurchased_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_FindPartyForGroup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class ARBLobbyPlayerState*>                 members                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        ProgramId                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FProfileId>                          lastPartyFindProfileIds                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Server_FindPartyForGroup(TArray<class ARBLobbyPlayerState*> members, const class FName& ProgramId, const class FName& TrialId, TArray<struct FProfileId> lastPartyFindProfileIds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_FindPartyForGroup");
		
		ARBLobbyPlayerController_Server_FindPartyForGroup_Params params {};
		params.members = members;
		params.ProgramId = ProgramId;
		params.TrialId = TrialId;
		params.lastPartyFindProfileIds = lastPartyFindProfileIds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_Debug_SetMatchFixedSeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            fixedSeed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Server_Debug_SetMatchFixedSeed(int32_t fixedSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_Debug_SetMatchFixedSeed");
		
		ARBLobbyPlayerController_Server_Debug_SetMatchFixedSeed_Params params {};
		params.fixedSeed = fixedSeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_Debug_SetMatchFixedPlayerCount
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            fixedPlayerCount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Server_Debug_SetMatchFixedPlayerCount(int32_t fixedPlayerCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_Debug_SetMatchFixedPlayerCount");
		
		ARBLobbyPlayerController_Server_Debug_SetMatchFixedPlayerCount_Params params {};
		params.fixedPlayerCount = fixedPlayerCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_Cheat_StartRelease
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Server_Cheat_StartRelease()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_Cheat_StartRelease");
		
		ARBLobbyPlayerController_Server_Cheat_StartRelease_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_Cheat_PersistPlayerProgression
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Server_Cheat_PersistPlayerProgression()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_Cheat_PersistPlayerProgression");
		
		ARBLobbyPlayerController_Server_Cheat_PersistPlayerProgression_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_Cheat_ForceAssignCell
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Server_Cheat_ForceAssignCell()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_Cheat_ForceAssignCell");
		
		ARBLobbyPlayerController_Server_Cheat_ForceAssignCell_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_Cheat_EnableAutoBackfill
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Server_Cheat_EnableAutoBackfill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_Cheat_EnableAutoBackfill");
		
		ARBLobbyPlayerController_Server_Cheat_EnableAutoBackfill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_Cheat_DisableAutoBackfill
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Server_Cheat_DisableAutoBackfill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_Cheat_DisableAutoBackfill");
		
		ARBLobbyPlayerController_Server_Cheat_DisableAutoBackfill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_CancelMatchCountdown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMatchCancelationReason                            Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Server_CancelMatchCountdown(EMatchCancelationReason Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_CancelMatchCountdown");
		
		ARBLobbyPlayerController_Server_CancelMatchCountdown_Params params {};
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Server_CancelFindParty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMatchCancelationReason                            Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Server_CancelFindParty(EMatchCancelationReason Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Server_CancelFindParty");
		
		ARBLobbyPlayerController_Server_CancelFindParty_Params params {};
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.RequestTravelToPendingMatch
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::RequestTravelToPendingMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.RequestTravelToPendingMatch");
		
		ARBLobbyPlayerController_RequestTravelToPendingMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.RequestReleaseCurrentCharacter
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::RequestReleaseCurrentCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.RequestReleaseCurrentCharacter");
		
		ARBLobbyPlayerController_RequestReleaseCurrentCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.OnPlayerStateMatchStateUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMatchState                                 MatchState                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::OnPlayerStateMatchStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchState& MatchState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.OnPlayerStateMatchStateUpdated");
		
		ARBLobbyPlayerController_OnPlayerStateMatchStateUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.MatchState = MatchState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.OnPlayerStateFindPartyStateUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FFindPartyState                             FindPartyState                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::OnPlayerStateFindPartyStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FFindPartyState& FindPartyState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.OnPlayerStateFindPartyStateUpdated");
		
		ARBLobbyPlayerController_OnPlayerStateFindPartyStateUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.FindPartyState = FindPartyState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.OnPlayerReleaseStateUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlayerReleaseState                         PlayerReleaseState                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::OnPlayerReleaseStateUpdated(const struct FPlayerReleaseState& PlayerReleaseState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.OnPlayerReleaseStateUpdated");
		
		ARBLobbyPlayerController_OnPlayerReleaseStateUpdated_Params params {};
		params.PlayerReleaseState = PlayerReleaseState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.OnPlayerReleaseAvailableServerTimeUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              playerReleaseAvailableServerTime                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::OnPlayerReleaseAvailableServerTimeUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, float playerReleaseAvailableServerTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.OnPlayerReleaseAvailableServerTimeUpdated");
		
		ARBLobbyPlayerController_OnPlayerReleaseAvailableServerTimeUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.playerReleaseAvailableServerTime = playerReleaseAvailableServerTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.OnPlayerCellUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayerCell*                               PlayerCell                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::OnPlayerCellUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, class ARBPlayerCell* PlayerCell)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.OnPlayerCellUpdated");
		
		ARBLobbyPlayerController_OnPlayerCellUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.PlayerCell = PlayerCell;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.OnPartyOwnerMatchSettingsUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMatchSettings                              MatchSettings                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::OnPartyOwnerMatchSettingsUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchSettings& MatchSettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.OnPartyOwnerMatchSettingsUpdated");
		
		ARBLobbyPlayerController_OnPartyOwnerMatchSettingsUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.MatchSettings = MatchSettings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.OnEvalCorridorUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBEvalCorridor*                             evalCorridor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::OnEvalCorridorUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, class ARBEvalCorridor* evalCorridor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.OnEvalCorridorUpdated");
		
		ARBLobbyPlayerController_OnEvalCorridorUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.evalCorridor = evalCorridor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.IsPlayerInOwnCell
	 * 		Flags  -> ()
	 */
	bool ARBLobbyPlayerController::IsPlayerInOwnCell()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.IsPlayerInOwnCell");
		
		ARBLobbyPlayerController_IsPlayerInOwnCell_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.GetMatchFixedSeed
	 * 		Flags  -> ()
	 */
	int32_t ARBLobbyPlayerController::GetMatchFixedSeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.GetMatchFixedSeed");
		
		ARBLobbyPlayerController_GetMatchFixedSeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.GetMatchFixedPlayerCount
	 * 		Flags  -> ()
	 */
	int32_t ARBLobbyPlayerController::GetMatchFixedPlayerCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.GetMatchFixedPlayerCount");
		
		ARBLobbyPlayerController_GetMatchFixedPlayerCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.GetClientTravelSource
	 * 		Flags  -> ()
	 */
	EClientTravelSource ARBLobbyPlayerController::GetClientTravelSource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.GetClientTravelSource");
		
		ARBLobbyPlayerController_GetClientTravelSource_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Event_OnMatchStateUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMatchState                                 MatchState                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Event_OnMatchStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchState& MatchState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Event_OnMatchStateUpdated");
		
		ARBLobbyPlayerController_Event_OnMatchStateUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.MatchState = MatchState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Event_OnMatchSettingsUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FMatchSettings                              MatchSettings                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Event_OnMatchSettingsUpdated(const struct FMatchSettings& MatchSettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Event_OnMatchSettingsUpdated");
		
		ARBLobbyPlayerController_Event_OnMatchSettingsUpdated_Params params {};
		params.MatchSettings = MatchSettings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Event_OnMatchReady
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Event_OnMatchReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Event_OnMatchReady");
		
		ARBLobbyPlayerController_Event_OnMatchReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Event_OnFindPartyStateUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FFindPartyState                             FindPartyState                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Event_OnFindPartyStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FFindPartyState& FindPartyState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Event_OnFindPartyStateUpdated");
		
		ARBLobbyPlayerController_Event_OnFindPartyStateUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.FindPartyState = FindPartyState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Event_OnFailedTravelToPendingMatch
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Event_OnFailedTravelToPendingMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Event_OnFailedTravelToPendingMatch");
		
		ARBLobbyPlayerController_Event_OnFailedTravelToPendingMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Client_WaitForParty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      TicketId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      MatchmakingConfigurationName                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FProfileId>                          groupMembers                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        ProgramId                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Client_WaitForParty(const class FString& TicketId, const class FString& MatchmakingConfigurationName, TArray<struct FProfileId> groupMembers, const class FName& ProgramId, const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Client_WaitForParty");
		
		ARBLobbyPlayerController_Client_WaitForParty_Params params {};
		params.TicketId = TicketId;
		params.MatchmakingConfigurationName = MatchmakingConfigurationName;
		params.groupMembers = groupMembers;
		params.ProgramId = ProgramId;
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Client_WaitForMatchPlacement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      placementId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Client_WaitForMatchPlacement(const class FString& placementId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Client_WaitForMatchPlacement");
		
		ARBLobbyPlayerController_Client_WaitForMatchPlacement_Params params {};
		params.placementId = placementId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Client_TravelToPendingMatch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bForced                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Client_TravelToPendingMatch(bool bForced)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Client_TravelToPendingMatch");
		
		ARBLobbyPlayerController_Client_TravelToPendingMatch_Params params {};
		params.bForced = bForced;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Client_ReadyToTravelToMatch
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Client_ReadyToTravelToMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Client_ReadyToTravelToMatch");
		
		ARBLobbyPlayerController_Client_ReadyToTravelToMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Client_MatchFound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      RegionName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      GameSessionId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ipAddress                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           Port                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      playerSessionId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Client_MatchFound(const class FString& RegionName, const class FString& GameSessionId, const class FString& ipAddress, uint32_t Port, const class FString& playerSessionId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Client_MatchFound");
		
		ARBLobbyPlayerController_Client_MatchFound_Params params {};
		params.RegionName = RegionName;
		params.GameSessionId = GameSessionId;
		params.ipAddress = ipAddress;
		params.Port = Port;
		params.playerSessionId = playerSessionId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Client_MatchCanceled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMatchCancelationReason                            Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            errorFacility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ErrorCode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Client_MatchCanceled(EMatchCancelationReason Reason, int32_t errorFacility, int32_t ErrorCode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Client_MatchCanceled");
		
		ARBLobbyPlayerController_Client_MatchCanceled_Params params {};
		params.Reason = Reason;
		params.errorFacility = errorFacility;
		params.ErrorCode = ErrorCode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Client_FindPartyCanceled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMatchCancelationReason                            Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            errorFacility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ErrorCode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerController::Client_FindPartyCanceled(EMatchCancelationReason Reason, int32_t errorFacility, int32_t ErrorCode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Client_FindPartyCanceled");
		
		ARBLobbyPlayerController_Client_FindPartyCanceled_Params params {};
		params.Reason = Reason;
		params.errorFacility = errorFacility;
		params.ErrorCode = ErrorCode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Client_FailTravelToPendingMatch
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Client_FailTravelToPendingMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Client_FailTravelToPendingMatch");
		
		ARBLobbyPlayerController_Client_FailTravelToPendingMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.Client_CharacterReleased
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerController::Client_CharacterReleased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.Client_CharacterReleased");
		
		ARBLobbyPlayerController_Client_CharacterReleased_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerController.CanReleaseCharacter
	 * 		Flags  -> ()
	 */
	bool ARBLobbyPlayerController::CanReleaseCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerController.CanReleaseCharacter");
		
		ARBLobbyPlayerController_CanReleaseCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBLobbyPlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBLobbyPlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLobbyPlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.Server_SetClientPopulateStarted
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::Server_SetClientPopulateStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.Server_SetClientPopulateStarted");
		
		ARBPlayerState_Server_SetClientPopulateStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.Server_OnPlayerReplicated
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::Server_OnPlayerReplicated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.Server_OnPlayerReplicated");
		
		ARBPlayerState_Server_OnPlayerReplicated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnVoiceChatPrivilegeStatusChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnVoiceChatPrivilegeStatusChanged__DelegateSignature(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnVoiceChatPrivilegeStatusChanged__DelegateSignature");
		
		ARBPlayerState_OnVoiceChatPrivilegeStatusChanged__DelegateSignature_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnVoiceChatEnabledChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnVoiceChatEnabledChanged__DelegateSignature(class ARBPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnVoiceChatEnabledChanged__DelegateSignature");
		
		ARBPlayerState_OnVoiceChatEnabledChanged__DelegateSignature_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnUnlockedItemsChanged__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnUnlockedItemsChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnUnlockedItemsChanged__DelegateSignature");
		
		ARBPlayerState_OnUnlockedItemsChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_Xp
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_Xp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_Xp");
		
		ARBPlayerState_OnRep_Xp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_VoiceChatEnabled
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_VoiceChatEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_VoiceChatEnabled");
		
		ARBPlayerState_OnRep_VoiceChatEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_UpgradeEffects
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_UpgradeEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_UpgradeEffects");
		
		ARBPlayerState_OnRep_UpgradeEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_Spectator
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_Spectator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_Spectator");
		
		ARBPlayerState_OnRep_Spectator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_Score
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_Score()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_Score");
		
		ARBPlayerState_OnRep_Score_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_RemainingSelfRevives
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            previousRemainingSelfRevives                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnRep_RemainingSelfRevives(int32_t previousRemainingSelfRevives)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_RemainingSelfRevives");
		
		ARBPlayerState_OnRep_RemainingSelfRevives_Params params {};
		params.previousRemainingSelfRevives = previousRemainingSelfRevives;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_RemainingRespawns
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            previousRemainingRespawns                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnRep_RemainingRespawns(int32_t previousRemainingRespawns)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_RemainingRespawns");
		
		ARBPlayerState_OnRep_RemainingRespawns_Params params {};
		params.previousRemainingRespawns = previousRemainingRespawns;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_ReleaseCount
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_ReleaseCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_ReleaseCount");
		
		ARBPlayerState_OnRep_ReleaseCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_ReadyForStageReset
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_ReadyForStageReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_ReadyForStageReset");
		
		ARBPlayerState_OnRep_ReadyForStageReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_PlayerLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            oldPlayerLevel                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnRep_PlayerLevel(int32_t oldPlayerLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_PlayerLevel");
		
		ARBPlayerState_OnRep_PlayerLevel_Params params {};
		params.oldPlayerLevel = oldPlayerLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_PartyState
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_PartyState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_PartyState");
		
		ARBPlayerState_OnRep_PartyState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_LeaveTarget
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_LeaveTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_LeaveTarget");
		
		ARBPlayerState_OnRep_LeaveTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_LastPossessedPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   oldLastPossessedPlayer                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnRep_LastPossessedPlayer(class ARBPlayer* oldLastPossessedPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_LastPossessedPlayer");
		
		ARBPlayerState_OnRep_LastPossessedPlayer_Params params {};
		params.oldLastPossessedPlayer = oldLastPossessedPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_IsOnlineInitialized
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_IsOnlineInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_IsOnlineInitialized");
		
		ARBPlayerState_OnRep_IsOnlineInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_IsInMenu
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_IsInMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_IsInMenu");
		
		ARBPlayerState_OnRep_IsInMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_IsDead
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_IsDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_IsDead");
		
		ARBPlayerState_OnRep_IsDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_InmateId
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_InmateId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_InmateId");
		
		ARBPlayerState_OnRep_InmateId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_HasVoiceChatPrivilege
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_HasVoiceChatPrivilege()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_HasVoiceChatPrivilege");
		
		ARBPlayerState_OnRep_HasVoiceChatPrivilege_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_HasBeenReplicated
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_HasBeenReplicated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_HasBeenReplicated");
		
		ARBPlayerState_OnRep_HasBeenReplicated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_CustomizationInfo
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_CustomizationInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_CustomizationInfo");
		
		ARBPlayerState_OnRep_CustomizationInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_CurrentSAS
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_CurrentSAS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_CurrentSAS");
		
		ARBPlayerState_OnRep_CurrentSAS_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_CurrentLoadout
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_CurrentLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_CurrentLoadout");
		
		ARBPlayerState_OnRep_CurrentLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_CurrencyEntries
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_CurrencyEntries()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_CurrencyEntries");
		
		ARBPlayerState_OnRep_CurrencyEntries_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_AcquiredProfileItems
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_AcquiredProfileItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_AcquiredProfileItems");
		
		ARBPlayerState_OnRep_AcquiredProfileItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnRep_AcquiredCharacterItems
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRep_AcquiredCharacterItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnRep_AcquiredCharacterItems");
		
		ARBPlayerState_OnRep_AcquiredCharacterItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnRemainingLivesChanged__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnRemainingLivesChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnRemainingLivesChanged__DelegateSignature");
		
		ARBPlayerState_OnRemainingLivesChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnReadyForStageResetChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsReady                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnReadyForStageResetChanged__DelegateSignature(class ARBPlayerState* RBPlayerState, bool IsReady)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnReadyForStageResetChanged__DelegateSignature");
		
		ARBPlayerState_OnReadyForStageResetChanged__DelegateSignature_Params params {};
		params.RBPlayerState = RBPlayerState;
		params.IsReady = IsReady;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnPlayerXpChanged__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnPlayerXpChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnPlayerXpChanged__DelegateSignature");
		
		ARBPlayerState_OnPlayerXpChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnPlayerUpgradesChanged__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnPlayerUpgradesChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnPlayerUpgradesChanged__DelegateSignature");
		
		ARBPlayerState_OnPlayerUpgradesChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnPlayerScoreChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            scoreXp                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnPlayerScoreChanged__DelegateSignature(class ARBPlayerState* RBPlayerState, int32_t Score, int32_t scoreXp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnPlayerScoreChanged__DelegateSignature");
		
		ARBPlayerState_OnPlayerScoreChanged__DelegateSignature_Params params {};
		params.RBPlayerState = RBPlayerState;
		params.Score = Score;
		params.scoreXp = scoreXp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnPlayerSASChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBSAS*                                      currentSAS                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnPlayerSASChanged__DelegateSignature(class ARBPlayerState* RBPlayerState, class ARBSAS* currentSAS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnPlayerSASChanged__DelegateSignature");
		
		ARBPlayerState_OnPlayerSASChanged__DelegateSignature_Params params {};
		params.RBPlayerState = RBPlayerState;
		params.currentSAS = currentSAS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnPlayerProgressionReceived__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnPlayerProgressionReceived__DelegateSignature(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnPlayerProgressionReceived__DelegateSignature");
		
		ARBPlayerState_OnPlayerProgressionReceived__DelegateSignature_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnPlayerPartyStateUpdated__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnPlayerPartyStateUpdated__DelegateSignature(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnPlayerPartyStateUpdated__DelegateSignature");
		
		ARBPlayerState_OnPlayerPartyStateUpdated__DelegateSignature_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnPlayerMaxHealthChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newMaxHealth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnPlayerMaxHealthChanged__DelegateSignature(float newMaxHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnPlayerMaxHealthChanged__DelegateSignature");
		
		ARBPlayerState_OnPlayerMaxHealthChanged__DelegateSignature_Params params {};
		params.newMaxHealth = newMaxHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnPlayerLevelChanged__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnPlayerLevelChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnPlayerLevelChanged__DelegateSignature");
		
		ARBPlayerState_OnPlayerLevelChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnPlayerIndicatorUpdated__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerIndicatorType                               playerIndicatorType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              timeLeft                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              progress                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnPlayerIndicatorUpdated__DelegateSignature(EPlayerIndicatorType playerIndicatorType, float timeLeft, float progress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnPlayerIndicatorUpdated__DelegateSignature");
		
		ARBPlayerState_OnPlayerIndicatorUpdated__DelegateSignature_Params params {};
		params.playerIndicatorType = playerIndicatorType;
		params.timeLeft = timeLeft;
		params.progress = progress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnPlayerHealthChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              newHealth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnPlayerHealthChanged__DelegateSignature(float newHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnPlayerHealthChanged__DelegateSignature");
		
		ARBPlayerState_OnPlayerHealthChanged__DelegateSignature_Params params {};
		params.newHealth = newHealth;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnPlayerEvent__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerEvent                                       EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnPlayerEvent__DelegateSignature(EPlayerEvent EventType, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnPlayerEvent__DelegateSignature");
		
		ARBPlayerState_OnPlayerEvent__DelegateSignature_Params params {};
		params.EventType = EventType;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnPlayerCustomizationUpdated__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBPlayerCustomizationInfo                  customizationInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnPlayerCustomizationUpdated__DelegateSignature(const struct FRBPlayerCustomizationInfo& customizationInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnPlayerCustomizationUpdated__DelegateSignature");
		
		ARBPlayerState_OnPlayerCustomizationUpdated__DelegateSignature_Params params {};
		params.customizationInfo = customizationInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnIsSpectatorChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               isSpectator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnIsSpectatorChanged__DelegateSignature(bool isSpectator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnIsSpectatorChanged__DelegateSignature");
		
		ARBPlayerState_OnIsSpectatorChanged__DelegateSignature_Params params {};
		params.isSpectator = isSpectator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnIsDeadChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               isDead                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnIsDeadChanged__DelegateSignature(bool isDead)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnIsDeadChanged__DelegateSignature");
		
		ARBPlayerState_OnIsDeadChanged__DelegateSignature_Params params {};
		params.isDead = isDead;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnInventoryUpdated__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnInventoryUpdated__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnInventoryUpdated__DelegateSignature");
		
		ARBPlayerState_OnInventoryUpdated__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.OnFeatureSwitchOverridesUpdated
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnFeatureSwitchOverridesUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.OnFeatureSwitchOverridesUpdated");
		
		ARBPlayerState_OnFeatureSwitchOverridesUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnEnteredHidespot__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBHidespotComponent*                        hidespotComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnEnteredHidespot__DelegateSignature(class URBHidespotComponent* hidespotComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnEnteredHidespot__DelegateSignature");
		
		ARBPlayerState_OnEnteredHidespot__DelegateSignature_Params params {};
		params.hidespotComponent = hidespotComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnCurrentLoadoutChanged__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnCurrentLoadoutChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnCurrentLoadoutChanged__DelegateSignature");
		
		ARBPlayerState_OnCurrentLoadoutChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnCurrencyGained__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECurrencyType                                      currencyType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::OnCurrencyGained__DelegateSignature(ECurrencyType currencyType, int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnCurrencyGained__DelegateSignature");
		
		ARBPlayerState_OnCurrencyGained__DelegateSignature_Params params {};
		params.currencyType = currencyType;
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnCurrenciesChanged__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnCurrenciesChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnCurrenciesChanged__DelegateSignature");
		
		ARBPlayerState_OnCurrenciesChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnActiveSkillActorInitialized__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnActiveSkillActorInitialized__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnActiveSkillActorInitialized__DelegateSignature");
		
		ARBPlayerState_OnActiveSkillActorInitialized__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayerState.OnAcquiredItemsChanged__DelegateSignature
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::OnAcquiredItemsChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayerState.OnAcquiredItemsChanged__DelegateSignature");
		
		ARBPlayerState_OnAcquiredItemsChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.Multicast_NotifyRemainingRespawnChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerState::Multicast_NotifyRemainingRespawnChanged(int32_t OldValue, int32_t NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.Multicast_NotifyRemainingRespawnChanged");
		
		ARBPlayerState_Multicast_NotifyRemainingRespawnChanged_Params params {};
		params.OldValue = OldValue;
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.Multicast_ClearGainedCurrencies
	 * 		Flags  -> ()
	 */
	void ARBPlayerState::Multicast_ClearGainedCurrencies()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.Multicast_ClearGainedCurrencies");
		
		ARBPlayerState_Multicast_ClearGainedCurrencies_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.IsPartyJoinable
	 * 		Flags  -> ()
	 */
	bool ARBPlayerState::IsPartyJoinable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.IsPartyJoinable");
		
		ARBPlayerState_IsPartyJoinable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.IsLeaving
	 * 		Flags  -> ()
	 */
	bool ARBPlayerState::IsLeaving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.IsLeaving");
		
		ARBPlayerState_IsLeaving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.IsItemAcquired
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ItemId                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBPlayerState::IsItemAcquired(const class FName& ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.IsItemAcquired");
		
		ARBPlayerState_IsItemAcquired_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.IsFemale
	 * 		Flags  -> ()
	 */
	bool ARBPlayerState::IsFemale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.IsFemale");
		
		ARBPlayerState_IsFemale_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.HasUpgradeEffect
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBPlayerState::HasUpgradeEffect(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.HasUpgradeEffect");
		
		ARBPlayerState_HasUpgradeEffect_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.HasCompletedTrial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPerfect                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBPlayerState::HasCompletedTrial(const class FName& ID, bool bPerfect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.HasCompletedTrial");
		
		ARBPlayerState_HasCompletedTrial_Params params {};
		params.ID = ID;
		params.bPerfect = bPerfect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.HasAttemptedTrial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBPlayerState::HasAttemptedTrial(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.HasAttemptedTrial");
		
		ARBPlayerState_HasAttemptedTrial_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetXp
	 * 		Flags  -> ()
	 */
	int32_t ARBPlayerState::GetXp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetXp");
		
		ARBPlayerState_GetXp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetVoiceCustomizationOption
	 * 		Flags  -> ()
	 */
	class URBVoiceCustomizationOption* ARBPlayerState::GetVoiceCustomizationOption()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetVoiceCustomizationOption");
		
		ARBPlayerState_GetVoiceCustomizationOption_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetSkinColorType
	 * 		Flags  -> ()
	 */
	ESkinColorType ARBPlayerState::GetSkinColorType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetSkinColorType");
		
		ARBPlayerState_GetSkinColorType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetSelectedActiveSkill
	 * 		Flags  -> ()
	 */
	EActiveSkillType ARBPlayerState::GetSelectedActiveSkill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetSelectedActiveSkill");
		
		ARBPlayerState_GetSelectedActiveSkill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetReleaseCount
	 * 		Flags  -> ()
	 */
	int32_t ARBPlayerState::GetReleaseCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetReleaseCount");
		
		ARBPlayerState_GetReleaseCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetProfileId
	 * 		Flags  -> ()
	 */
	struct FProfileId ARBPlayerState::GetProfileId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetProfileId");
		
		ARBPlayerState_GetProfileId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetPlayerLoadout
	 * 		Flags  -> ()
	 */
	struct FRBPlayerLoadout ARBPlayerState::GetPlayerLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetPlayerLoadout");
		
		ARBPlayerState_GetPlayerLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetPlayerLevel
	 * 		Flags  -> ()
	 */
	int32_t ARBPlayerState::GetPlayerLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetPlayerLevel");
		
		ARBPlayerState_GetPlayerLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetPlayerIconCustomizationOption
	 * 		Flags  -> ()
	 */
	class URBPlayerIconCustomizationOption* ARBPlayerState::GetPlayerIconCustomizationOption()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetPlayerIconCustomizationOption");
		
		ARBPlayerState_GetPlayerIconCustomizationOption_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetPlatformId
	 * 		Flags  -> ()
	 */
	class FString ARBPlayerState::GetPlatformId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetPlatformId");
		
		ARBPlayerState_GetPlatformId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetPlatform
	 * 		Flags  -> ()
	 */
	EProfilePlatform ARBPlayerState::GetPlatform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetPlatform");
		
		ARBPlayerState_GetPlatform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetPartyMemberCount
	 * 		Flags  -> ()
	 */
	int32_t ARBPlayerState::GetPartyMemberCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetPartyMemberCount");
		
		ARBPlayerState_GetPartyMemberCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetPartyId
	 * 		Flags  -> ()
	 */
	class FString ARBPlayerState::GetPartyId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetPartyId");
		
		ARBPlayerState_GetPartyId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetNumberOfUnlockedPerkSlots
	 * 		Flags  -> ()
	 */
	int32_t ARBPlayerState::GetNumberOfUnlockedPerkSlots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetNumberOfUnlockedPerkSlots");
		
		ARBPlayerState_GetNumberOfUnlockedPerkSlots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetNormalizedScore
	 * 		Flags  -> ()
	 */
	float ARBPlayerState::GetNormalizedScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetNormalizedScore");
		
		ARBPlayerState_GetNormalizedScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetLeaveTarget
	 * 		Flags  -> ()
	 */
	EPlayerLeaveTarget ARBPlayerState::GetLeaveTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetLeaveTarget");
		
		ARBPlayerState_GetLeaveTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetInmateId
	 * 		Flags  -> ()
	 */
	int32_t ARBPlayerState::GetInmateId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetInmateId");
		
		ARBPlayerState_GetInmateId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetGainedCurrencies
	 * 		Flags  -> ()
	 */
	TMap<ECurrencyType, int32_t> ARBPlayerState::GetGainedCurrencies()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetGainedCurrencies");
		
		ARBPlayerState_GetGainedCurrencies_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetFullPlayerId
	 * 		Flags  -> ()
	 */
	class FString ARBPlayerState::GetFullPlayerId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetFullPlayerId");
		
		ARBPlayerState_GetFullPlayerId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetExperimentTimePlayedSeconds
	 * 		Flags  -> ()
	 */
	int32_t ARBPlayerState::GetExperimentTimePlayedSeconds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetExperimentTimePlayedSeconds");
		
		ARBPlayerState_GetExperimentTimePlayedSeconds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetCustomizationOptionsBySlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerCustomizationSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBPlayerCustomizationOption* ARBPlayerState::GetCustomizationOptionsBySlot(EPlayerCustomizationSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetCustomizationOptionsBySlot");
		
		ARBPlayerState_GetCustomizationOptionsBySlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetCustomizationOptions
	 * 		Flags  -> ()
	 */
	TArray<class URBPlayerCustomizationOption*> ARBPlayerState::GetCustomizationOptions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetCustomizationOptions");
		
		ARBPlayerState_GetCustomizationOptions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetCustomizationLegendaryOutfit
	 * 		Flags  -> ()
	 */
	class URBCustomizationOutfit* ARBPlayerState::GetCustomizationLegendaryOutfit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetCustomizationLegendaryOutfit");
		
		ARBPlayerState_GetCustomizationLegendaryOutfit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetCustomizationInfo
	 * 		Flags  -> ()
	 */
	struct FRBPlayerCustomizationInfo ARBPlayerState::GetCustomizationInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetCustomizationInfo");
		
		ARBPlayerState_GetCustomizationInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetCurrency
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECurrencyType                                      currencyType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ARBPlayerState::GetCurrency(ECurrencyType currencyType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetCurrency");
		
		ARBPlayerState_GetCurrency_Params params {};
		params.currencyType = currencyType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.GetCharacterStartingReleaseCount
	 * 		Flags  -> ()
	 */
	int32_t ARBPlayerState::GetCharacterStartingReleaseCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.GetCharacterStartingReleaseCount");
		
		ARBPlayerState_GetCharacterStartingReleaseCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.BP_IsUpgradeAcquired
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        upgradeID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBPlayerState::BP_IsUpgradeAcquired(const class FName& upgradeID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.BP_IsUpgradeAcquired");
		
		ARBPlayerState_BP_IsUpgradeAcquired_Params params {};
		params.upgradeID = upgradeID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.BP_HasAcquiredActiveSkill
	 * 		Flags  -> ()
	 */
	bool ARBPlayerState::BP_HasAcquiredActiveSkill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.BP_HasAcquiredActiveSkill");
		
		ARBPlayerState_BP_HasAcquiredActiveSkill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.BP_GetUniqueID
	 * 		Flags  -> ()
	 */
	struct FUniqueNetIdRepl ARBPlayerState::BP_GetUniqueID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.BP_GetUniqueID");
		
		ARBPlayerState_BP_GetUniqueID_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerState.AreItemsAcquired
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FName>                                itemIds                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool ARBPlayerState::AreItemsAcquired(TArray<class FName> itemIds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerState.AreItemsAcquired");
		
		ARBPlayerState_AreItemsAcquired_Params params {};
		params.itemIds = itemIds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPlayerState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPlayerState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.SetReadyToTravelToMatch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInReadyToTravelToMatch                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerState::SetReadyToTravelToMatch(bool bInReadyToTravelToMatch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.SetReadyToTravelToMatch");
		
		ARBLobbyPlayerState_SetReadyToTravelToMatch_Params params {};
		params.bInReadyToTravelToMatch = bInReadyToTravelToMatch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.SetLeavingForMatch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInLeavingForMatch                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerState::SetLeavingForMatch(bool bInLeavingForMatch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.SetLeavingForMatch");
		
		ARBLobbyPlayerState_SetLeavingForMatch_Params params {};
		params.bInLeavingForMatch = bInLeavingForMatch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.SetAllReadyToTravelToMatch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInAllReadyToTravelToMatch                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerState::SetAllReadyToTravelToMatch(bool bInAllReadyToTravelToMatch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.SetAllReadyToTravelToMatch");
		
		ARBLobbyPlayerState_SetAllReadyToTravelToMatch_Params params {};
		params.bInAllReadyToTravelToMatch = bInAllReadyToTravelToMatch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.OnRep_PlayerReleaseAvailableServerTime
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerState::OnRep_PlayerReleaseAvailableServerTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.OnRep_PlayerReleaseAvailableServerTime");
		
		ARBLobbyPlayerState_OnRep_PlayerReleaseAvailableServerTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.OnRep_PlayerCellCustomization
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerState::OnRep_PlayerCellCustomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.OnRep_PlayerCellCustomization");
		
		ARBLobbyPlayerState_OnRep_PlayerCellCustomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.OnRep_PlayerCell
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerState::OnRep_PlayerCell()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.OnRep_PlayerCell");
		
		ARBLobbyPlayerState_OnRep_PlayerCell_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.OnRep_MatchState
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerState::OnRep_MatchState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.OnRep_MatchState");
		
		ARBLobbyPlayerState_OnRep_MatchState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.OnRep_MatchSettings
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerState::OnRep_MatchSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.OnRep_MatchSettings");
		
		ARBLobbyPlayerState_OnRep_MatchSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.OnRep_FindPartyState
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerState::OnRep_FindPartyState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.OnRep_FindPartyState");
		
		ARBLobbyPlayerState_OnRep_FindPartyState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.OnRep_EvalCorridor
	 * 		Flags  -> ()
	 */
	void ARBLobbyPlayerState::OnRep_EvalCorridor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.OnRep_EvalCorridor");
		
		ARBLobbyPlayerState_OnRep_EvalCorridor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBLobbyPlayerState.OnMatchSettingsUpdated__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMatchSettings                              MatchSettings                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyPlayerState::OnMatchSettingsUpdated__DelegateSignature(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchSettings& MatchSettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBLobbyPlayerState.OnMatchSettingsUpdated__DelegateSignature");
		
		ARBLobbyPlayerState_OnMatchSettingsUpdated__DelegateSignature_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.MatchSettings = MatchSettings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.IsReadyToTravelToMatch
	 * 		Flags  -> ()
	 */
	bool ARBLobbyPlayerState::IsReadyToTravelToMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.IsReadyToTravelToMatch");
		
		ARBLobbyPlayerState_IsReadyToTravelToMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.IsMatchCountdownStarted
	 * 		Flags  -> ()
	 */
	bool ARBLobbyPlayerState::IsMatchCountdownStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.IsMatchCountdownStarted");
		
		ARBLobbyPlayerState_IsMatchCountdownStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.IsLeavingForMatch
	 * 		Flags  -> ()
	 */
	bool ARBLobbyPlayerState::IsLeavingForMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.IsLeavingForMatch");
		
		ARBLobbyPlayerState_IsLeavingForMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.IsInEvalCorridor
	 * 		Flags  -> ()
	 */
	bool ARBLobbyPlayerState::IsInEvalCorridor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.IsInEvalCorridor");
		
		ARBLobbyPlayerState_IsInEvalCorridor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.IsFindingParty
	 * 		Flags  -> ()
	 */
	bool ARBLobbyPlayerState::IsFindingParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.IsFindingParty");
		
		ARBLobbyPlayerState_IsFindingParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.IsAllReadyToTravelToMatch
	 * 		Flags  -> ()
	 */
	bool ARBLobbyPlayerState::IsAllReadyToTravelToMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.IsAllReadyToTravelToMatch");
		
		ARBLobbyPlayerState_IsAllReadyToTravelToMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.GetRecentTrialList
	 * 		Flags  -> ()
	 */
	TArray<struct FEndStageInfo> ARBLobbyPlayerState::GetRecentTrialList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.GetRecentTrialList");
		
		ARBLobbyPlayerState_GetRecentTrialList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.GetPlayerReleaseAvailableServerTime
	 * 		Flags  -> ()
	 */
	float ARBLobbyPlayerState::GetPlayerReleaseAvailableServerTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.GetPlayerReleaseAvailableServerTime");
		
		ARBLobbyPlayerState_GetPlayerReleaseAvailableServerTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.GetPlayerCellCustomization
	 * 		Flags  -> ()
	 */
	TArray<struct FRBPlayerCellCustomizationEntry> ARBLobbyPlayerState::GetPlayerCellCustomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.GetPlayerCellCustomization");
		
		ARBLobbyPlayerState_GetPlayerCellCustomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.GetPlayerCell
	 * 		Flags  -> ()
	 */
	class ARBPlayerCell* ARBLobbyPlayerState::GetPlayerCell()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.GetPlayerCell");
		
		ARBLobbyPlayerState_GetPlayerCell_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.GetMatchState
	 * 		Flags  -> ()
	 */
	struct FMatchState ARBLobbyPlayerState::GetMatchState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.GetMatchState");
		
		ARBLobbyPlayerState_GetMatchState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.GetMatchStartServerTime
	 * 		Flags  -> ()
	 */
	float ARBLobbyPlayerState::GetMatchStartServerTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.GetMatchStartServerTime");
		
		ARBLobbyPlayerState_GetMatchStartServerTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.GetMatchSettings
	 * 		Flags  -> ()
	 */
	struct FMatchSettings ARBLobbyPlayerState::GetMatchSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.GetMatchSettings");
		
		ARBLobbyPlayerState_GetMatchSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.GetMatchOwner
	 * 		Flags  -> ()
	 */
	class ARBLobbyPlayerState* ARBLobbyPlayerState::GetMatchOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.GetMatchOwner");
		
		ARBLobbyPlayerState_GetMatchOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.GetMatchCancelationGracePeriodServerTime
	 * 		Flags  -> ()
	 */
	float ARBLobbyPlayerState::GetMatchCancelationGracePeriodServerTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.GetMatchCancelationGracePeriodServerTime");
		
		ARBLobbyPlayerState_GetMatchCancelationGracePeriodServerTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.GetFindPartyOwner
	 * 		Flags  -> ()
	 */
	class ARBLobbyPlayerState* ARBLobbyPlayerState::GetFindPartyOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.GetFindPartyOwner");
		
		ARBLobbyPlayerState_GetFindPartyOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.GetEvalCorridor
	 * 		Flags  -> ()
	 */
	class ARBEvalCorridor* ARBLobbyPlayerState::GetEvalCorridor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.GetEvalCorridor");
		
		ARBLobbyPlayerState_GetEvalCorridor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyPlayerState.CanFindPartyBeCanceled
	 * 		Flags  -> ()
	 */
	bool ARBLobbyPlayerState::CanFindPartyBeCanceled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyPlayerState.CanFindPartyBeCanceled");
		
		ARBLobbyPlayerState_CanFindPartyBeCanceled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBLobbyPlayerState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBLobbyPlayerState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLobbyPlayerState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyStatBoard.OnRep_Entries
	 * 		Flags  -> ()
	 */
	void ARBLobbyStatBoard::OnRep_Entries()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyStatBoard.OnRep_Entries");
		
		ARBLobbyStatBoard_OnRep_Entries_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyStatBoard.OnRep_CurrentStatConfigId
	 * 		Flags  -> ()
	 */
	void ARBLobbyStatBoard::OnRep_CurrentStatConfigId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyStatBoard.OnRep_CurrentStatConfigId");
		
		ARBLobbyStatBoard_OnRep_CurrentStatConfigId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyStatBoard.Event_Refresh
	 * 		Flags  -> ()
	 */
	void ARBLobbyStatBoard::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyStatBoard.Event_Refresh");
		
		ARBLobbyStatBoard_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyStatBoard.Event_EntryUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBLobbyStatBoardEntry                      Entry                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBLobbyStatBoard::Event_EntryUpdated(const struct FRBLobbyStatBoardEntry& Entry, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyStatBoard.Event_EntryUpdated");
		
		ARBLobbyStatBoard_Event_EntryUpdated_Params params {};
		params.Entry = Entry;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLobbyStatBoard.Event_CurrentStatUpdated
	 * 		Flags  -> ()
	 */
	void ARBLobbyStatBoard::Event_CurrentStatUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLobbyStatBoard.Event_CurrentStatUpdated");
		
		ARBLobbyStatBoard_Event_CurrentStatUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBLobbyStatBoard.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBLobbyStatBoard::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLobbyStatBoard");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLocalPlayerProximityComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLocalPlayerProximityComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLocalPlayerProximityComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLocalPlayerVisibilityComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLocalPlayerVisibilityComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLocalPlayerVisibilityComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLocalProfile.SetProgramSeenInMenu
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ProgramId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLocalProfile::SetProgramSeenInMenu(const class FName& ProgramId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLocalProfile.SetProgramSeenInMenu");
		
		URBLocalProfile_SetProgramSeenInMenu_Params params {};
		params.ProgramId = ProgramId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLocalProfile.SetLastTrialEvaluationInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTrialEvaluationInfo                        evaluationInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBLocalProfile::SetLastTrialEvaluationInfo(const struct FTrialEvaluationInfo& evaluationInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLocalProfile.SetLastTrialEvaluationInfo");
		
		URBLocalProfile_SetLastTrialEvaluationInfo_Params params {};
		params.evaluationInfo = evaluationInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLocalProfile.SetHasVisitedReleaseBooth
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLocalProfile::SetHasVisitedReleaseBooth(bool NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLocalProfile.SetHasVisitedReleaseBooth");
		
		URBLocalProfile_SetHasVisitedReleaseBooth_Params params {};
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLocalProfile.SetHasVisitedNPC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMetaNPCType                                       NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLocalProfile::SetHasVisitedNPC(EMetaNPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLocalProfile.SetHasVisitedNPC");
		
		URBLocalProfile_SetHasVisitedNPC_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLocalProfile.SetHasSeenDisclaimer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLocalProfile::SetHasSeenDisclaimer(bool NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLocalProfile.SetHasSeenDisclaimer");
		
		URBLocalProfile_SetHasSeenDisclaimer_Params params {};
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLocalProfile.SetHasItemBeenDisplayedInMenu
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        OnlineID                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLocalProfile::SetHasItemBeenDisplayedInMenu(const class FName& OnlineID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLocalProfile.SetHasItemBeenDisplayedInMenu");
		
		URBLocalProfile_SetHasItemBeenDisplayedInMenu_Params params {};
		params.OnlineID = OnlineID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLocalProfile.HasVisitedReleaseBooth
	 * 		Flags  -> ()
	 */
	bool URBLocalProfile::HasVisitedReleaseBooth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLocalProfile.HasVisitedReleaseBooth");
		
		URBLocalProfile_HasVisitedReleaseBooth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLocalProfile.HasVisitedNPC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMetaNPCType                                       NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBLocalProfile::HasVisitedNPC(EMetaNPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLocalProfile.HasVisitedNPC");
		
		URBLocalProfile_HasVisitedNPC_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLocalProfile.HasProgramBeenSeenInMenu
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ProgramId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBLocalProfile::HasProgramBeenSeenInMenu(const class FName& ProgramId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLocalProfile.HasProgramBeenSeenInMenu");
		
		URBLocalProfile_HasProgramBeenSeenInMenu_Params params {};
		params.ProgramId = ProgramId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLocalProfile.HasItemBeenDisplayedInMenu
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        OnlineID                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBLocalProfile::HasItemBeenDisplayedInMenu(const class FName& OnlineID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLocalProfile.HasItemBeenDisplayedInMenu");
		
		URBLocalProfile_HasItemBeenDisplayedInMenu_Params params {};
		params.OnlineID = OnlineID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLocalProfile.GetLastTrialEvaluationInfo
	 * 		Flags  -> ()
	 */
	struct FTrialEvaluationInfo URBLocalProfile::GetLastTrialEvaluationInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLocalProfile.GetLastTrialEvaluationInfo");
		
		URBLocalProfile_GetLastTrialEvaluationInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLocalProfile.ClearVisitedNPCs
	 * 		Flags  -> ()
	 */
	void URBLocalProfile::ClearVisitedNPCs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLocalProfile.ClearVisitedNPCs");
		
		URBLocalProfile_ClearVisitedNPCs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLocalProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLocalProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLocalProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLockable.Unlock
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLockable::Unlock(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLockable.Unlock");
		
		URBLockable_Unlock_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLockable.OnUnlocked
	 * 		Flags  -> ()
	 */
	void URBLockable::OnUnlocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLockable.OnUnlocked");
		
		URBLockable_OnUnlocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLockable.OnLocked
	 * 		Flags  -> ()
	 */
	void URBLockable::OnLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLockable.OnLocked");
		
		URBLockable_OnLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLockable.Lock
	 * 		Flags  -> ()
	 */
	void URBLockable::Lock()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLockable.Lock");
		
		URBLockable_Lock_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLockable.IsLocked
	 * 		Flags  -> ()
	 */
	bool URBLockable::IsLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLockable.IsLocked");
		
		URBLockable_IsLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLockable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLockable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLockable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBUnlockedInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBUnlockedInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBUnlockedInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBLookAtInterface.GetLookAtLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     outLookAtLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBLookAtInterface::GetLookAtLocation(struct FVector* outLookAtLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBLookAtInterface.GetLookAtLocation");
		
		URBLookAtInterface_GetLookAtLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outLookAtLocation != nullptr)
			*outLookAtLocation = params.outLookAtLocation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLookAtInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLookAtInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLookAtInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBLP.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBLP::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBLP");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMainMenuPlayerController.IsCrossplayEnabled
	 * 		Flags  -> ()
	 */
	bool ARBMainMenuPlayerController::IsCrossplayEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMainMenuPlayerController.IsCrossplayEnabled");
		
		ARBMainMenuPlayerController_IsCrossplayEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMainMenuPlayerController.FindTutorialServer
	 * 		Flags  -> ()
	 */
	void ARBMainMenuPlayerController::FindTutorialServer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMainMenuPlayerController.FindTutorialServer");
		
		ARBMainMenuPlayerController_FindTutorialServer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMainMenuPlayerController.FindHub
	 * 		Flags  -> ()
	 */
	void ARBMainMenuPlayerController::FindHub()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMainMenuPlayerController.FindHub");
		
		ARBMainMenuPlayerController_FindHub_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBMainMenuPlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBMainMenuPlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMainMenuPlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMatchAcceptanceNotificationUserWidget.GetPartyMemberCount
	 * 		Flags  -> ()
	 */
	int32_t URBMatchAcceptanceNotificationUserWidget::GetPartyMemberCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMatchAcceptanceNotificationUserWidget.GetPartyMemberCount");
		
		URBMatchAcceptanceNotificationUserWidget_GetPartyMemberCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMatchAcceptanceNotificationUserWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMatchAcceptanceNotificationUserWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMatchAcceptanceNotificationUserWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuBrightnessCalibration.OnEntryHovered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMenuOptionsEntry*                         Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuBrightnessCalibration::OnEntryHovered(class URBMenuOptionsEntry* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuBrightnessCalibration.OnEntryHovered");
		
		URBMenuBrightnessCalibration_OnEntryHovered_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuBrightnessCalibration.Event_SetToDefaults
	 * 		Flags  -> ()
	 */
	void URBMenuBrightnessCalibration::Event_SetToDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuBrightnessCalibration.Event_SetToDefaults");
		
		URBMenuBrightnessCalibration_Event_SetToDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuBrightnessCalibration.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuBrightnessCalibration::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuBrightnessCalibration");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.SetVisible
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMenuCharacter::SetVisible(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.SetVisible");
		
		ARBMenuCharacter_SetVisible_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.Setup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUnknown                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBPlayerCustomizationInfo                  customizationInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EActiveSkillType                                   ActiveSkillType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESocialMenuSceneActorSlot                          Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInIsFailureScene                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMenuCharacter::Setup(bool bVisible, bool bUnknown, const struct FRBPlayerCustomizationInfo& customizationInfo, EActiveSkillType ActiveSkillType, ESocialMenuSceneActorSlot Slot, class ARBPlayerState* RBPlayerState, bool bInIsFailureScene)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.Setup");
		
		ARBMenuCharacter_Setup_Params params {};
		params.bVisible = bVisible;
		params.bUnknown = bUnknown;
		params.customizationInfo = customizationInfo;
		params.ActiveSkillType = ActiveSkillType;
		params.Slot = Slot;
		params.RBPlayerState = RBPlayerState;
		params.bInIsFailureScene = bInIsFailureScene;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.IsWaitingForRessources
	 * 		Flags  -> ()
	 */
	bool ARBMenuCharacter::IsWaitingForRessources()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.IsWaitingForRessources");
		
		ARBMenuCharacter_IsWaitingForRessources_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.IsVisible
	 * 		Flags  -> ()
	 */
	bool ARBMenuCharacter::IsVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.IsVisible");
		
		ARBMenuCharacter_IsVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.IsUnknown
	 * 		Flags  -> ()
	 */
	bool ARBMenuCharacter::IsUnknown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.IsUnknown");
		
		ARBMenuCharacter_IsUnknown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.IsFailureScene
	 * 		Flags  -> ()
	 */
	bool ARBMenuCharacter::IsFailureScene()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.IsFailureScene");
		
		ARBMenuCharacter_IsFailureScene_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.GetSlot
	 * 		Flags  -> ()
	 */
	ESocialMenuSceneActorSlot ARBMenuCharacter::GetSlot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.GetSlot");
		
		ARBMenuCharacter_GetSlot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.GetCustomizationInfo
	 * 		Flags  -> ()
	 */
	struct FRBPlayerCustomizationInfo ARBMenuCharacter::GetCustomizationInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.GetCustomizationInfo");
		
		ARBMenuCharacter_GetCustomizationInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.GetAssociatedPlayerState
	 * 		Flags  -> ()
	 */
	class ARBPlayerState* ARBMenuCharacter::GetAssociatedPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.GetAssociatedPlayerState");
		
		ARBMenuCharacter_GetAssociatedPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.GetActiveSkillType
	 * 		Flags  -> ()
	 */
	EActiveSkillType ARBMenuCharacter::GetActiveSkillType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.GetActiveSkillType");
		
		ARBMenuCharacter_GetActiveSkillType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.Event_RefreshPlayerCustomization
	 * 		Flags  -> ()
	 */
	void ARBMenuCharacter::Event_RefreshPlayerCustomization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.Event_RefreshPlayerCustomization");
		
		ARBMenuCharacter_Event_RefreshPlayerCustomization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.Event_RefreshPlayerActiveSkill
	 * 		Flags  -> ()
	 */
	void ARBMenuCharacter::Event_RefreshPlayerActiveSkill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.Event_RefreshPlayerActiveSkill");
		
		ARBMenuCharacter_Event_RefreshPlayerActiveSkill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.Event_OnVisibleChanged
	 * 		Flags  -> ()
	 */
	void ARBMenuCharacter::Event_OnVisibleChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.Event_OnVisibleChanged");
		
		ARBMenuCharacter_Event_OnVisibleChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuCharacter.Event_OnSetup
	 * 		Flags  -> ()
	 */
	void ARBMenuCharacter::Event_OnSetup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuCharacter.Event_OnSetup");
		
		ARBMenuCharacter_Event_OnSetup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBMenuCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBMenuCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuControlBinding.SetToDefaults
	 * 		Flags  -> ()
	 */
	void URBMenuControlBinding::SetToDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuControlBinding.SetToDefaults");
		
		URBMenuControlBinding_SetToDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuControlBinding.OnInputKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EInputEvent                                        EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGamepad                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuControlBinding::OnInputKey(const struct FKey& Key, EInputEvent EventType, bool bGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuControlBinding.OnInputKey");
		
		URBMenuControlBinding_OnInputKey_Params params {};
		params.Key = Key;
		params.EventType = EventType;
		params.bGamepad = bGamepad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuControlBinding.InitBindingEntries
	 * 		Flags  -> ()
	 */
	void URBMenuControlBinding::InitBindingEntries()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuControlBinding.InitBindingEntries");
		
		URBMenuControlBinding_InitBindingEntries_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuControlBinding.HasAnyUnsavedChanges
	 * 		Flags  -> ()
	 */
	bool URBMenuControlBinding::HasAnyUnsavedChanges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuControlBinding.HasAnyUnsavedChanges");
		
		URBMenuControlBinding_HasAnyUnsavedChanges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuControlBinding.Event_UpdateRebindStatus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               isRebindInProgress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuControlBinding::Event_UpdateRebindStatus(bool isRebindInProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuControlBinding.Event_UpdateRebindStatus");
		
		URBMenuControlBinding_Event_UpdateRebindStatus_Params params {};
		params.isRebindInProgress = isRebindInProgress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuControlBinding.Event_OnBindingCaptureEnded
	 * 		Flags  -> ()
	 */
	void URBMenuControlBinding::Event_OnBindingCaptureEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuControlBinding.Event_OnBindingCaptureEnded");
		
		URBMenuControlBinding_Event_OnBindingCaptureEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuControlBinding.CaptureNewBinding
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMenuControlBindingEntry*                  Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuControlBinding::CaptureNewBinding(class URBMenuControlBindingEntry* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuControlBinding.CaptureNewBinding");
		
		URBMenuControlBinding_CaptureNewBinding_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuControlBinding.ApplyChanges
	 * 		Flags  -> ()
	 */
	void URBMenuControlBinding::ApplyChanges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuControlBinding.ApplyChanges");
		
		URBMenuControlBinding_ApplyChanges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuControlBinding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuControlBinding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuControlBinding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuControlBindingEntry.UpdateRebindStatus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsRebindInProgress                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuControlBindingEntry::UpdateRebindStatus(bool bIsRebindInProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuControlBindingEntry.UpdateRebindStatus");
		
		URBMenuControlBindingEntry_UpdateRebindStatus_Params params {};
		params.bIsRebindInProgress = bIsRebindInProgress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuControlBindingEntry.RevertCurrentChange
	 * 		Flags  -> ()
	 */
	void URBMenuControlBindingEntry::RevertCurrentChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuControlBindingEntry.RevertCurrentChange");
		
		URBMenuControlBindingEntry_RevertCurrentChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuControlBindingEntry.RefreshValue
	 * 		Flags  -> ()
	 */
	void URBMenuControlBindingEntry::RefreshValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuControlBindingEntry.RefreshValue");
		
		URBMenuControlBindingEntry_RefreshValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuControlBindingEntry.HasValueChanged
	 * 		Flags  -> ()
	 */
	bool URBMenuControlBindingEntry::HasValueChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuControlBindingEntry.HasValueChanged");
		
		URBMenuControlBindingEntry_HasValueChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuControlBindingEntry.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuControlBindingEntry::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuControlBindingEntry");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuGamepadControlScheme.UpdateApplyBtnVisibility
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               HasValueChanged                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuGamepadControlScheme::UpdateApplyBtnVisibility(bool HasValueChanged)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuGamepadControlScheme.UpdateApplyBtnVisibility");
		
		URBMenuGamepadControlScheme_UpdateApplyBtnVisibility_Params params {};
		params.HasValueChanged = HasValueChanged;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuGamepadControlScheme.RevertAllUnsavedChanges
	 * 		Flags  -> ()
	 */
	void URBMenuGamepadControlScheme::RevertAllUnsavedChanges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuGamepadControlScheme.RevertAllUnsavedChanges");
		
		URBMenuGamepadControlScheme_RevertAllUnsavedChanges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuGamepadControlScheme.OnOptionValueChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMenuOptionsEntry*                         Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuGamepadControlScheme::OnOptionValueChanged(class URBMenuOptionsEntry* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuGamepadControlScheme.OnOptionValueChanged");
		
		URBMenuGamepadControlScheme_OnOptionValueChanged_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuGamepadControlScheme.Event_UpdateDisplayedControlScheme
	 * 		Flags  -> ()
	 */
	void URBMenuGamepadControlScheme::Event_UpdateDisplayedControlScheme()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuGamepadControlScheme.Event_UpdateDisplayedControlScheme");
		
		URBMenuGamepadControlScheme_Event_UpdateDisplayedControlScheme_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuGamepadControlScheme.ApplyEntriesChanges
	 * 		Flags  -> ()
	 */
	void URBMenuGamepadControlScheme::ApplyEntriesChanges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuGamepadControlScheme.ApplyEntriesChanges");
		
		URBMenuGamepadControlScheme_ApplyEntriesChanges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuGamepadControlScheme.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuGamepadControlScheme::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuGamepadControlScheme");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuManager.ClearTransitionStack
	 * 		Flags  -> ()
	 */
	void URBMenuManager::ClearTransitionStack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuManager.ClearTransitionStack");
		
		URBMenuManager_ClearTransitionStack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuManager.BP_ShowError
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        SecondaryMessage                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      ErrorCode                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuManager::BP_ShowError(const class FText& Message, const class FText& SecondaryMessage, const class FString& ErrorCode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuManager.BP_ShowError");
		
		URBMenuManager_BP_ShowError_Params params {};
		params.Message = Message;
		params.SecondaryMessage = SecondaryMessage;
		params.ErrorCode = ErrorCode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuManager.BP_PushMenuPage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMenuWidget*                               Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuManager::BP_PushMenuPage(class URBMenuWidget* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuManager.BP_PushMenuPage");
		
		URBMenuManager_BP_PushMenuPage_Params params {};
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuManager.BP_PopMenuPage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMenuWidget*                               Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuManager::BP_PopMenuPage(class URBMenuWidget* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuManager.BP_PopMenuPage");
		
		URBMenuManager_BP_PopMenuPage_Params params {};
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuManager.BP_OnMenuTutorialSeen
	 * 		Flags  -> ()
	 */
	void URBMenuManager::BP_OnMenuTutorialSeen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuManager.BP_OnMenuTutorialSeen");
		
		URBMenuManager_BP_OnMenuTutorialSeen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuManager.BP_IsUsingGamepad
	 * 		Flags  -> ()
	 */
	bool URBMenuManager::BP_IsUsingGamepad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuManager.BP_IsUsingGamepad");
		
		URBMenuManager_BP_IsUsingGamepad_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuManager.BP_IsInMenu
	 * 		Flags  -> ()
	 */
	bool URBMenuManager::BP_IsInMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuManager.BP_IsInMenu");
		
		URBMenuManager_BP_IsInMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuManager.BP_GetMenuPage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      MenuClass                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBMenuWidget* URBMenuManager::BP_GetMenuPage(class UClass* MenuClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuManager.BP_GetMenuPage");
		
		URBMenuManager_BP_GetMenuPage_Params params {};
		params.MenuClass = MenuClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuManager.BP_GetCurrentPage
	 * 		Flags  -> ()
	 */
	class URBMenuWidget* URBMenuManager::BP_GetCurrentPage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuManager.BP_GetCurrentPage");
		
		URBMenuManager_BP_GetCurrentPage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptions.OnFullscreenOrDesktopSettingsChanged
	 * 		Flags  -> ()
	 */
	void URBMenuOptions::OnFullscreenOrDesktopSettingsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptions.OnFullscreenOrDesktopSettingsChanged");
		
		URBMenuOptions_OnFullscreenOrDesktopSettingsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptions.Event_RefreshAllEntries
	 * 		Flags  -> ()
	 */
	void URBMenuOptions::Event_RefreshAllEntries()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptions.Event_RefreshAllEntries");
		
		URBMenuOptions_Event_RefreshAllEntries_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuOptions.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuOptions::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuOptions");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsDescription.UpdateDescription
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FOptionData                                 OptionData                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsDescription::UpdateDescription(const struct FOptionData& OptionData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsDescription.UpdateDescription");
		
		URBMenuOptionsDescription_UpdateDescription_Params params {};
		params.OptionData = OptionData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuOptionsDescription.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuOptionsDescription::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuOptionsDescription");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.UpdateValueChanged
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsEntry::UpdateValueChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.UpdateValueChanged");
		
		URBMenuOptionsEntry_UpdateValueChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.SetEntryToDefaults
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsTabReset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsEntry::SetEntryToDefaults(bool bIsTabReset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.SetEntryToDefaults");
		
		URBMenuOptionsEntry_SetEntryToDefaults_Params params {};
		params.bIsTabReset = bIsTabReset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.RevertCurrentChange
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsEntry::RevertCurrentChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.RevertCurrentChange");
		
		URBMenuOptionsEntry_RevertCurrentChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.RefreshValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               forceUpdateSlider                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsEntry::RefreshValue(bool forceUpdateSlider)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.RefreshValue");
		
		URBMenuOptionsEntry_RefreshValue_Params params {};
		params.forceUpdateSlider = forceUpdateSlider;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.OnResolutionOrWindowModeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMenuOptionsEntry*                         Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsEntry::OnResolutionOrWindowModeChanged(class URBMenuOptionsEntry* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.OnResolutionOrWindowModeChanged");
		
		URBMenuOptionsEntry_OnResolutionOrWindowModeChanged_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.IsSubButton
	 * 		Flags  -> ()
	 */
	bool URBMenuOptionsEntry::IsSubButton()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.IsSubButton");
		
		URBMenuOptionsEntry_IsSubButton_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.IsSliderNormalised
	 * 		Flags  -> ()
	 */
	bool URBMenuOptionsEntry::IsSliderNormalised()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.IsSliderNormalised");
		
		URBMenuOptionsEntry_IsSliderNormalised_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.IsSlider
	 * 		Flags  -> ()
	 */
	bool URBMenuOptionsEntry::IsSlider()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.IsSlider");
		
		URBMenuOptionsEntry_IsSlider_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.HighlightEntry
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsEntry::HighlightEntry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.HighlightEntry");
		
		URBMenuOptionsEntry_HighlightEntry_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.GetSliderMin
	 * 		Flags  -> ()
	 */
	float URBMenuOptionsEntry::GetSliderMin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.GetSliderMin");
		
		URBMenuOptionsEntry_GetSliderMin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.GetSliderMax
	 * 		Flags  -> ()
	 */
	float URBMenuOptionsEntry::GetSliderMax()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.GetSliderMax");
		
		URBMenuOptionsEntry_GetSliderMax_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.GetMaxCountForOption
	 * 		Flags  -> ()
	 */
	int32_t URBMenuOptionsEntry::GetMaxCountForOption()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.GetMaxCountForOption");
		
		URBMenuOptionsEntry_GetMaxCountForOption_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.GetCurrentIndexOfOption
	 * 		Flags  -> ()
	 */
	int32_t URBMenuOptionsEntry::GetCurrentIndexOfOption()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.GetCurrentIndexOfOption");
		
		URBMenuOptionsEntry_GetCurrentIndexOfOption_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.Event_UpdateTitle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        newTitle                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsEntry::Event_UpdateTitle(const class FText& newTitle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.Event_UpdateTitle");
		
		URBMenuOptionsEntry_Event_UpdateTitle_Params params {};
		params.newTitle = newTitle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.Event_UpdateTextValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsEntry::Event_UpdateTextValue(const class FText& NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.Event_UpdateTextValue");
		
		URBMenuOptionsEntry_Event_UpdateTextValue_Params params {};
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.Event_UpdateSubButtonText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsEntry::Event_UpdateSubButtonText(const class FText& NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.Event_UpdateSubButtonText");
		
		URBMenuOptionsEntry_Event_UpdateSubButtonText_Params params {};
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.Event_UpdateSliderValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        textOverride                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsEntry::Event_UpdateSliderValue(float Value, const class FText& textOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.Event_UpdateSliderValue");
		
		URBMenuOptionsEntry_Event_UpdateSliderValue_Params params {};
		params.Value = Value;
		params.textOverride = textOverride;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.Event_RefreshEntry
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsEntry::Event_RefreshEntry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.Event_RefreshEntry");
		
		URBMenuOptionsEntry_Event_RefreshEntry_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.DownplayEntry
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsEntry::DownplayEntry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.DownplayEntry");
		
		URBMenuOptionsEntry_DownplayEntry_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.ChangeOptionValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               leftClicked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsEntry::ChangeOptionValue(float Value, bool leftClicked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.ChangeOptionValue");
		
		URBMenuOptionsEntry_ChangeOptionValue_Params params {};
		params.Value = Value;
		params.leftClicked = leftClicked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.CanBeEdited
	 * 		Flags  -> ()
	 */
	bool URBMenuOptionsEntry::CanBeEdited()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.CanBeEdited");
		
		URBMenuOptionsEntry_CanBeEdited_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsEntry.CanBeDisplayed
	 * 		Flags  -> ()
	 */
	bool URBMenuOptionsEntry::CanBeDisplayed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsEntry.CanBeDisplayed");
		
		URBMenuOptionsEntry_CanBeDisplayed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuOptionsEntry.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuOptionsEntry::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuOptionsEntry");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.SetToDefaults
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsTab::SetToDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.SetToDefaults");
		
		URBMenuOptionsTab_SetToDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.RunHardwareBenchmark
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsTab::RunHardwareBenchmark()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.RunHardwareBenchmark");
		
		URBMenuOptionsTab_RunHardwareBenchmark_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.RevertResolution
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsTab::RevertResolution()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.RevertResolution");
		
		URBMenuOptionsTab_RevertResolution_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.RevertAllUnsavedChanges
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsTab::RevertAllUnsavedChanges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.RevertAllUnsavedChanges");
		
		URBMenuOptionsTab_RevertAllUnsavedChanges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.OnVoiceChatSettingsUpdated
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsTab::OnVoiceChatSettingsUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.OnVoiceChatSettingsUpdated");
		
		URBMenuOptionsTab_OnVoiceChatSettingsUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.OnTabUnhovered
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsTab::OnTabUnhovered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.OnTabUnhovered");
		
		URBMenuOptionsTab_OnTabUnhovered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.OnSubButtonClicked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMenuOptionsEntry*                         Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsTab::OnSubButtonClicked(class URBMenuOptionsEntry* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.OnSubButtonClicked");
		
		URBMenuOptionsTab_OnSubButtonClicked_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.OnQualityValueUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsPreset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsTab::OnQualityValueUpdated(bool bIsPreset, int32_t NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.OnQualityValueUpdated");
		
		URBMenuOptionsTab_OnQualityValueUpdated_Params params {};
		params.bIsPreset = bIsPreset;
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.OnOptionValueChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMenuOptionsEntry*                         Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsTab::OnOptionValueChanged(class URBMenuOptionsEntry* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.OnOptionValueChanged");
		
		URBMenuOptionsTab_OnOptionValueChanged_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.OnlineCreateRegionsEntries
	 * 		Flags  -> ()
	 */
	class URBMenuOptionsEntry* URBMenuOptionsTab::OnlineCreateRegionsEntries()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.OnlineCreateRegionsEntries");
		
		URBMenuOptionsTab_OnlineCreateRegionsEntries_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.OnHUDPresetChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsPreset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsTab::OnHUDPresetChanged(bool bIsPreset, int32_t NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.OnHUDPresetChanged");
		
		URBMenuOptionsTab_OnHUDPresetChanged_Params params {};
		params.bIsPreset = bIsPreset;
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.OnEntryHovered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMenuOptionsEntry*                         Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsTab::OnEntryHovered(class URBMenuOptionsEntry* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.OnEntryHovered");
		
		URBMenuOptionsTab_OnEntryHovered_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.OnEntriesSet
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsTab::OnEntriesSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.OnEntriesSet");
		
		URBMenuOptionsTab_OnEntriesSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.HasUnsavedChanges
	 * 		Flags  -> ()
	 */
	bool URBMenuOptionsTab::HasUnsavedChanges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.HasUnsavedChanges");
		
		URBMenuOptionsTab_HasUnsavedChanges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.GetChangedOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FString>                              optionsNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsTab::GetChangedOptions(TArray<class FString>* optionsNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.GetChangedOptions");
		
		URBMenuOptionsTab_GetChangedOptions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (optionsNames != nullptr)
			*optionsNames = params.optionsNames;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.Event_ResolutionChanged
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsTab::Event_ResolutionChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.Event_ResolutionChanged");
		
		URBMenuOptionsTab_Event_ResolutionChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.Event_AddRegionEntry
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMenuOptionsEntry*                         Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuOptionsTab::Event_AddRegionEntry(class URBMenuOptionsEntry* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.Event_AddRegionEntry");
		
		URBMenuOptionsTab_Event_AddRegionEntry_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.ConfirmResolution
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsTab::ConfirmResolution()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.ConfirmResolution");
		
		URBMenuOptionsTab_ConfirmResolution_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuOptionsTab.ApplyEntriesChanges
	 * 		Flags  -> ()
	 */
	void URBMenuOptionsTab::ApplyEntriesChanges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuOptionsTab.ApplyEntriesChanges");
		
		URBMenuOptionsTab_ApplyEntriesChanges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuOptionsTab.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuOptionsTab::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuOptionsTab");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTransition.Event_TransitionOut
	 * 		Flags  -> ()
	 */
	void URBMenuTransition::Event_TransitionOut()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTransition.Event_TransitionOut");
		
		URBMenuTransition_Event_TransitionOut_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTransition.Event_TransitionIn
	 * 		Flags  -> ()
	 */
	void URBMenuTransition::Event_TransitionIn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTransition.Event_TransitionIn");
		
		URBMenuTransition_Event_TransitionIn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTransition.BP_TransitionOutDone
	 * 		Flags  -> ()
	 */
	void URBMenuTransition::BP_TransitionOutDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTransition.BP_TransitionOutDone");
		
		URBMenuTransition_BP_TransitionOutDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTransition.BP_TransitionInDone
	 * 		Flags  -> ()
	 */
	void URBMenuTransition::BP_TransitionInDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTransition.BP_TransitionInDone");
		
		URBMenuTransition_BP_TransitionInDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuTransition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuTransition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuTransition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabButton.SetSelected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInSelected                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMenuTabButton::SetSelected(bool bInSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabButton.SetSelected");
		
		URBMenuTabButton_SetSelected_Params params {};
		params.bInSelected = bInSelected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabButton.Event_OnSelectedChanged
	 * 		Flags  -> ()
	 */
	void URBMenuTabButton::Event_OnSelectedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabButton.Event_OnSelectedChanged");
		
		URBMenuTabButton_Event_OnSelectedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMenuTabButton.BP_ClickButton
	 * 		Flags  -> ()
	 */
	void URBMenuTabButton::BP_ClickButton()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMenuTabButton.BP_ClickButton");
		
		URBMenuTabButton_BP_ClickButton_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMenuTabButton.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMenuTabButton::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMenuTabButton");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMicrofilmPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMicrofilmPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMicrofilmPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMicTestOptionsEntryWidget.ToggleMicrophoneTest
	 * 		Flags  -> ()
	 */
	void URBMicTestOptionsEntryWidget::ToggleMicrophoneTest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMicTestOptionsEntryWidget.ToggleMicrophoneTest");
		
		URBMicTestOptionsEntryWidget_ToggleMicrophoneTest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMicTestOptionsEntryWidget.StopMicrophoneTest
	 * 		Flags  -> ()
	 */
	void URBMicTestOptionsEntryWidget::StopMicrophoneTest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMicTestOptionsEntryWidget.StopMicrophoneTest");
		
		URBMicTestOptionsEntryWidget_StopMicrophoneTest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMicTestOptionsEntryWidget.OnEchoChannelStateChanged
	 * 		Flags  -> ()
	 */
	void URBMicTestOptionsEntryWidget::OnEchoChannelStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMicTestOptionsEntryWidget.OnEchoChannelStateChanged");
		
		URBMicTestOptionsEntryWidget_OnEchoChannelStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMicTestOptionsEntryWidget.GetMicrophoneVolume
	 * 		Flags  -> ()
	 */
	float URBMicTestOptionsEntryWidget::GetMicrophoneVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMicTestOptionsEntryWidget.GetMicrophoneVolume");
		
		URBMicTestOptionsEntryWidget_GetMicrophoneVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMicTestOptionsEntryWidget.GetMicrophoneTestState
	 * 		Flags  -> ()
	 */
	ERBMicrophoneTestState URBMicTestOptionsEntryWidget::GetMicrophoneTestState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMicTestOptionsEntryWidget.GetMicrophoneTestState");
		
		URBMicTestOptionsEntryWidget_GetMicrophoneTestState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMicTestOptionsEntryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMicTestOptionsEntryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMicTestOptionsEntryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRoomComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRoomComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRoomComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMinigameRoomComponent.OnRep_Scheduled
	 * 		Flags  -> ()
	 */
	void URBMinigameRoomComponent::OnRep_Scheduled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMinigameRoomComponent.OnRep_Scheduled");
		
		URBMinigameRoomComponent_OnRep_Scheduled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMinigameRoomComponent.OnRep_MinigameState
	 * 		Flags  -> ()
	 */
	void URBMinigameRoomComponent::OnRep_MinigameState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMinigameRoomComponent.OnRep_MinigameState");
		
		URBMinigameRoomComponent_OnRep_MinigameState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMinigameRoomComponent.OnRep_MinigameScore
	 * 		Flags  -> ()
	 */
	void URBMinigameRoomComponent::OnRep_MinigameScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMinigameRoomComponent.OnRep_MinigameScore");
		
		URBMinigameRoomComponent_OnRep_MinigameScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMinigameRoomComponent.OnOperatableCompleted_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsOn                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBOperatable*                               operatable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMinigameRoomComponent::OnOperatableCompleted_Server(bool bIsOn, class ARBOperatable* operatable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMinigameRoomComponent.OnOperatableCompleted_Server");
		
		URBMinigameRoomComponent_OnOperatableCompleted_Server_Params params {};
		params.bIsOn = bIsOn;
		params.operatable = operatable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMinigameRoomComponent.OnMinigameScoreScoreChanged
	 * 		Flags  -> ()
	 */
	void URBMinigameRoomComponent::OnMinigameScoreScoreChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMinigameRoomComponent.OnMinigameScoreScoreChanged");
		
		URBMinigameRoomComponent_OnMinigameScoreScoreChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMinigameRoomComponent.OnDoorFullyUnlocked_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBDoor*                                     door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMinigameRoomComponent::OnDoorFullyUnlocked_Server(class ARBDoor* door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMinigameRoomComponent.OnDoorFullyUnlocked_Server");
		
		URBMinigameRoomComponent_OnDoorFullyUnlocked_Server_Params params {};
		params.door = door;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMinigameRoomComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMinigameRoomComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMinigameRoomComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMinigameRoomsObjectiveCoordinator.OnRep_CompletedMinigameRooms
	 * 		Flags  -> ()
	 */
	void ARBMinigameRoomsObjectiveCoordinator::OnRep_CompletedMinigameRooms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMinigameRoomsObjectiveCoordinator.OnRep_CompletedMinigameRooms");
		
		ARBMinigameRoomsObjectiveCoordinator_OnRep_CompletedMinigameRooms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMinigameRoomsObjectiveCoordinator.OnNumberOfItemUsedChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMinigameRoomsObjectiveCoordinator::OnNumberOfItemUsedChanged(class URBInteractiblePanelComponent* panel, class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMinigameRoomsObjectiveCoordinator.OnNumberOfItemUsedChanged");
		
		ARBMinigameRoomsObjectiveCoordinator_OnNumberOfItemUsedChanged_Params params {};
		params.panel = panel;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMinigameRoomsObjectiveCoordinator.OnMinigameRoomStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMinigameRoomComponent*                    minigameRoom                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMinigameRoomsObjectiveCoordinator::OnMinigameRoomStateChanged(class URBMinigameRoomComponent* minigameRoom)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMinigameRoomsObjectiveCoordinator.OnMinigameRoomStateChanged");
		
		ARBMinigameRoomsObjectiveCoordinator_OnMinigameRoomStateChanged_Params params {};
		params.minigameRoom = minigameRoom;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBMinigameRoomsObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBMinigameRoomsObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMinigameRoomsObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProjectile.OnRep_Launched
	 * 		Flags  -> ()
	 */
	void ARBProjectile::OnRep_Launched()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProjectile.OnRep_Launched");
		
		ARBProjectile_OnRep_Launched_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProjectile.DelayedDestroy
	 * 		Flags  -> ()
	 */
	void ARBProjectile::DelayedDestroy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProjectile.DelayedDestroy");
		
		ARBProjectile_DelayedDestroy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBProjectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMolotovProjectile.OnRep_FireStartedTimestamp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMolotovProjectile::OnRep_FireStartedTimestamp(float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMolotovProjectile.OnRep_FireStartedTimestamp");
		
		ARBMolotovProjectile_OnRep_FireStartedTimestamp_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMolotovProjectile.Event_OnFireStarted
	 * 		Flags  -> ()
	 */
	void ARBMolotovProjectile::Event_OnFireStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMolotovProjectile.Event_OnFireStarted");
		
		ARBMolotovProjectile_Event_OnFireStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMolotovProjectile.Event_OnFireFinished
	 * 		Flags  -> ()
	 */
	void ARBMolotovProjectile::Event_OnFireFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMolotovProjectile.Event_OnFireFinished");
		
		ARBMolotovProjectile_Event_OnFireFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBMolotovProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBMolotovProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMolotovProjectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterClosetReplaceClass.OnMonsterClosetReplaced_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBMonsterCloset*                            MonsterCloset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      replacementSource                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMonsterClosetReplaceClass::OnMonsterClosetReplaced_Server(class ARBMonsterCloset* MonsterCloset, class AActor* replacementSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterClosetReplaceClass.OnMonsterClosetReplaced_Server");
		
		URBMonsterClosetReplaceClass_OnMonsterClosetReplaced_Server_Params params {};
		params.MonsterCloset = MonsterCloset;
		params.replacementSource = replacementSource;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMonsterClosetReplaceClass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMonsterClosetReplaceClass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMonsterClosetReplaceClass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.SetDoorCollisionsForPawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMonsterCloset::SetDoorCollisionsForPawn(class ARBPawn* Pawn, bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.SetDoorCollisionsForPawn");
		
		ARBMonsterCloset_SetDoorCollisionsForPawn_Params params {};
		params.Pawn = Pawn;
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.OnSpawningZoneEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMonsterCloset::OnSpawningZoneEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.OnSpawningZoneEndOverlap");
		
		ARBMonsterCloset_OnSpawningZoneEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.OnSpawningZoneBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBMonsterCloset::OnSpawningZoneBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.OnSpawningZoneBeginOverlap");
		
		ARBMonsterCloset_OnSpawningZoneBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.OnRep_ShouldBeOpen
	 * 		Flags  -> ()
	 */
	void ARBMonsterCloset::OnRep_ShouldBeOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.OnRep_ShouldBeOpen");
		
		ARBMonsterCloset_OnRep_ShouldBeOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.OnRep_PlayerInCloset
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMonsterCloset::OnRep_PlayerInCloset(class ARBPlayer* OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.OnRep_PlayerInCloset");
		
		ARBMonsterCloset_OnRep_PlayerInCloset_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.OnRep_DynamicallyReplaced
	 * 		Flags  -> ()
	 */
	void ARBMonsterCloset::OnRep_DynamicallyReplaced()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.OnRep_DynamicallyReplaced");
		
		ARBMonsterCloset_OnRep_DynamicallyReplaced_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.OnRep_bSpawnWarningInProgress
	 * 		Flags  -> ()
	 */
	void ARBMonsterCloset::OnRep_bSpawnWarningInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.OnRep_bSpawnWarningInProgress");
		
		ARBMonsterCloset_OnRep_bSpawnWarningInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.OnPlayerRespawnTransitionFinished
	 * 		Flags  -> ()
	 */
	void ARBMonsterCloset::OnPlayerRespawnTransitionFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.OnPlayerRespawnTransitionFinished");
		
		ARBMonsterCloset_OnPlayerRespawnTransitionFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.Multicast_TriggerNPCSpawnAnnouncement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENPCType                                           NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMonsterCloset::Multicast_TriggerNPCSpawnAnnouncement(ENPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.Multicast_TriggerNPCSpawnAnnouncement");
		
		ARBMonsterCloset_Multicast_TriggerNPCSpawnAnnouncement_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.Event_TriggerNPCSpawnAnnouncement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ENPCType                                           NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMonsterCloset::Event_TriggerNPCSpawnAnnouncement(ENPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.Event_TriggerNPCSpawnAnnouncement");
		
		ARBMonsterCloset_Event_TriggerNPCSpawnAnnouncement_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.Event_SetNPCSpawnWarningActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bWarningActive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMonsterCloset::Event_SetNPCSpawnWarningActive(bool bWarningActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.Event_SetNPCSpawnWarningActive");
		
		ARBMonsterCloset_Event_SetNPCSpawnWarningActive_Params params {};
		params.bWarningActive = bWarningActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.Event_OnPlayerInClosetChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   oldPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMonsterCloset::Event_OnPlayerInClosetChanged(class ARBPlayer* oldPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.Event_OnPlayerInClosetChanged");
		
		ARBMonsterCloset_Event_OnPlayerInClosetChanged_Params params {};
		params.oldPlayer = oldPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.Event_OnNPCExit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMonsterCloset::Event_OnNPCExit(class ARBNPC* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.Event_OnNPCExit");
		
		ARBMonsterCloset_Event_OnNPCExit_Params params {};
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.Event_OnNPCEnter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMonsterCloset::Event_OnNPCEnter(class ARBNPC* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.Event_OnNPCEnter");
		
		ARBMonsterCloset_Event_OnNPCEnter_Params params {};
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.Event_ApplyOpenState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOpen                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMonsterCloset::Event_ApplyOpenState(bool bOpen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.Event_ApplyOpenState");
		
		ARBMonsterCloset_Event_ApplyOpenState_Params params {};
		params.bOpen = bOpen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.BP_Tick
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBMonsterCloset::BP_Tick(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.BP_Tick");
		
		ARBMonsterCloset_BP_Tick_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.BP_SetCurrentlyEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsEnabled                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBMonsterCloset::BP_SetCurrentlyEnabled(bool bIsEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.BP_SetCurrentlyEnabled");
		
		ARBMonsterCloset_BP_SetCurrentlyEnabled_Params params {};
		params.bIsEnabled = bIsEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.BP_FinishedOpening
	 * 		Flags  -> ()
	 */
	void ARBMonsterCloset::BP_FinishedOpening()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.BP_FinishedOpening");
		
		ARBMonsterCloset_BP_FinishedOpening_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMonsterCloset.BP_FinishedClosing
	 * 		Flags  -> ()
	 */
	void ARBMonsterCloset::BP_FinishedClosing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMonsterCloset.BP_FinishedClosing");
		
		ARBMonsterCloset_BP_FinishedClosing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBMonsterCloset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBMonsterCloset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMonsterCloset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMovieSubtitles.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMovieSubtitles::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMovieSubtitles");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMovieSubtitlePlayer.Update
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              TimeSeconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMovieSubtitlePlayer::Update(float TimeSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMovieSubtitlePlayer.Update");
		
		URBMovieSubtitlePlayer_Update_Params params {};
		params.TimeSeconds = TimeSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMovieSubtitlePlayer.Stop
	 * 		Flags  -> ()
	 */
	void URBMovieSubtitlePlayer::Stop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMovieSubtitlePlayer.Stop");
		
		URBMovieSubtitlePlayer_Stop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMovieSubtitlePlayer.Start
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBMovieSubtitles*                           movieSubtitles                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBMovieSubtitlePlayer::Start(class URBMovieSubtitles* movieSubtitles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMovieSubtitlePlayer.Start");
		
		URBMovieSubtitlePlayer_Start_Params params {};
		params.movieSubtitles = movieSubtitles;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBMovieSubtitlePlayer.IsStarted
	 * 		Flags  -> ()
	 */
	bool URBMovieSubtitlePlayer::IsStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBMovieSubtitlePlayer.IsStarted");
		
		URBMovieSubtitlePlayer_IsStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBMovieSubtitlePlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBMovieSubtitlePlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBMovieSubtitlePlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreen.OnRep_LinkedChannel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNarrativeScreenChannel*                   OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNarrativeScreen::OnRep_LinkedChannel(class ARBNarrativeScreenChannel* OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreen.OnRep_LinkedChannel");
		
		ARBNarrativeScreen_OnRep_LinkedChannel_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreen.OnRep_IsOn
	 * 		Flags  -> ()
	 */
	void ARBNarrativeScreen::OnRep_IsOn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreen.OnRep_IsOn");
		
		ARBNarrativeScreen_OnRep_IsOn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreen.OnRep_GlassShattered
	 * 		Flags  -> ()
	 */
	void ARBNarrativeScreen::OnRep_GlassShattered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreen.OnRep_GlassShattered");
		
		ARBNarrativeScreen_OnRep_GlassShattered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreen.IsCurrentlyPlaying
	 * 		Flags  -> ()
	 */
	bool ARBNarrativeScreen::IsCurrentlyPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreen.IsCurrentlyPlaying");
		
		ARBNarrativeScreen_IsCurrentlyPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreen.Event_OnLinkedStatusChanged
	 * 		Flags  -> ()
	 */
	void ARBNarrativeScreen::Event_OnLinkedStatusChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreen.Event_OnLinkedStatusChanged");
		
		ARBNarrativeScreen_Event_OnLinkedStatusChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreen.Event_OnIsOnChanged
	 * 		Flags  -> ()
	 */
	void ARBNarrativeScreen::Event_OnIsOnChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreen.Event_OnIsOnChanged");
		
		ARBNarrativeScreen_Event_OnIsOnChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreen.Event_OnGlassShatterStateChanged
	 * 		Flags  -> ()
	 */
	void ARBNarrativeScreen::Event_OnGlassShatterStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreen.Event_OnGlassShatterStateChanged");
		
		ARBNarrativeScreen_Event_OnGlassShatterStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreen.BP_SetTVOn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPropagateOnAllLinkedChannelTVs                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNarrativeScreen::BP_SetTVOn(bool bValue, bool bPropagateOnAllLinkedChannelTVs)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreen.BP_SetTVOn");
		
		ARBNarrativeScreen_BP_SetTVOn_Params params {};
		params.bValue = bValue;
		params.bPropagateOnAllLinkedChannelTVs = bPropagateOnAllLinkedChannelTVs;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreen.BP_SetTVChannel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNarrativeScreenChannel*                   Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNarrativeScreen::BP_SetTVChannel(class ARBNarrativeScreenChannel* Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreen.BP_SetTVChannel");
		
		ARBNarrativeScreen_BP_SetTVChannel_Params params {};
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBNarrativeScreen.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBNarrativeScreen::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNarrativeScreen");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreenChannel.OnRep_CurrentlyPlayingData
	 * 		Flags  -> ()
	 */
	void ARBNarrativeScreenChannel::OnRep_CurrentlyPlayingData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreenChannel.OnRep_CurrentlyPlayingData");
		
		ARBNarrativeScreenChannel_OnRep_CurrentlyPlayingData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreenChannel.IsCurrentlyPlaying
	 * 		Flags  -> ()
	 */
	bool ARBNarrativeScreenChannel::IsCurrentlyPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreenChannel.IsCurrentlyPlaying");
		
		ARBNarrativeScreenChannel_IsCurrentlyPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreenChannel.Event_OnLinkedScreenRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNarrativeScreen*                          linkedScreen                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNarrativeScreenChannel::Event_OnLinkedScreenRemoved(class ARBNarrativeScreen* linkedScreen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreenChannel.Event_OnLinkedScreenRemoved");
		
		ARBNarrativeScreenChannel_Event_OnLinkedScreenRemoved_Params params {};
		params.linkedScreen = linkedScreen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreenChannel.Event_OnLinkedScreenAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNarrativeScreen*                          linkedScreen                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNarrativeScreenChannel::Event_OnLinkedScreenAdded(class ARBNarrativeScreen* linkedScreen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreenChannel.Event_OnLinkedScreenAdded");
		
		ARBNarrativeScreenChannel_Event_OnLinkedScreenAdded_Params params {};
		params.linkedScreen = linkedScreen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreenChannel.Event_OnCurrentlyPlayingDataChanged
	 * 		Flags  -> ()
	 */
	void ARBNarrativeScreenChannel::Event_OnCurrentlyPlayingDataChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreenChannel.Event_OnCurrentlyPlayingDataChanged");
		
		ARBNarrativeScreenChannel_Event_OnCurrentlyPlayingDataChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreenChannel.BP_StopAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bClearQueue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNarrativeScreenChannel::BP_StopAnimation(bool bClearQueue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreenChannel.BP_StopAnimation");
		
		ARBNarrativeScreenChannel_BP_StopAnimation_Params params {};
		params.bClearQueue = bClearQueue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreenChannel.BP_SetAllLinkedTVsOn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNarrativeScreenChannel::BP_SetAllLinkedTVsOn(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreenChannel.BP_SetAllLinkedTVsOn");
		
		ARBNarrativeScreenChannel_BP_SetAllLinkedTVsOn_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreenChannel.BP_PlayAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNarrativeScreenAnimationData               playingData                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bQueueIfPlaying                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceAllLinkedTVsOn                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNarrativeScreenChannel::BP_PlayAnimation(const struct FNarrativeScreenAnimationData& playingData, bool bQueueIfPlaying, bool bForceAllLinkedTVsOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreenChannel.BP_PlayAnimation");
		
		ARBNarrativeScreenChannel_BP_PlayAnimation_Params params {};
		params.playingData = playingData;
		params.bQueueIfPlaying = bQueueIfPlaying;
		params.bForceAllLinkedTVsOn = bForceAllLinkedTVsOn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreenChannel.BP_NotifyAnimationStarted
	 * 		Flags  -> ()
	 */
	void ARBNarrativeScreenChannel::BP_NotifyAnimationStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreenChannel.BP_NotifyAnimationStarted");
		
		ARBNarrativeScreenChannel_BP_NotifyAnimationStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreenChannel.BP_NotifyAnimationFinished
	 * 		Flags  -> ()
	 */
	void ARBNarrativeScreenChannel::BP_NotifyAnimationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreenChannel.BP_NotifyAnimationFinished");
		
		ARBNarrativeScreenChannel_BP_NotifyAnimationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNarrativeScreenChannel.BP_GetLinkedScreens
	 * 		Flags  -> ()
	 */
	TArray<class ARBNarrativeScreen*> ARBNarrativeScreenChannel::BP_GetLinkedScreens()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNarrativeScreenChannel.BP_GetLinkedScreens");
		
		ARBNarrativeScreenChannel_BP_GetLinkedScreens_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBNarrativeScreenChannel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBNarrativeScreenChannel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNarrativeScreenChannel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNavLinkComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNavLinkComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNavLinkComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNDAOverlayWidget.Event_Setup
	 * 		Flags  -> ()
	 */
	void URBNDAOverlayWidget::Event_Setup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNDAOverlayWidget.Event_Setup");
		
		URBNDAOverlayWidget_Event_Setup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNDAOverlayWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNDAOverlayWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNDAOverlayWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSoundActor.StopAssociatedSound
	 * 		Flags  -> ()
	 */
	void ARBNetworkSoundActor::StopAssociatedSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSoundActor.StopAssociatedSound");
		
		ARBNetworkSoundActor_StopAssociatedSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSoundActor.SetSwitchState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNetworkSoundActor::SetSwitchState(const class FName& Name, const class FName& State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSoundActor.SetSwitchState");
		
		ARBNetworkSoundActor_SetSwitchState_Params params {};
		params.Name = Name;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSoundActor.SetRTPC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNetworkSoundActor::SetRTPC(const class FName& Name, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSoundActor.SetRTPC");
		
		ARBNetworkSoundActor_SetRTPC_Params params {};
		params.Name = Name;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSoundActor.PostAssociatedSound
	 * 		Flags  -> ()
	 */
	void ARBNetworkSoundActor::PostAssociatedSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSoundActor.PostAssociatedSound");
		
		ARBNetworkSoundActor_PostAssociatedSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSoundActor.OnRep_SwitchStateData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FNetworkSoundActorSwitchStateData>   oldSwitchStateData                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBNetworkSoundActor::OnRep_SwitchStateData(TArray<struct FNetworkSoundActorSwitchStateData> oldSwitchStateData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSoundActor.OnRep_SwitchStateData");
		
		ARBNetworkSoundActor_OnRep_SwitchStateData_Params params {};
		params.oldSwitchStateData = oldSwitchStateData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSoundActor.OnRep_RTPCData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FNetworkSoundActorRTPCData>          oldRTPCData                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBNetworkSoundActor::OnRep_RTPCData(TArray<struct FNetworkSoundActorRTPCData> oldRTPCData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSoundActor.OnRep_RTPCData");
		
		ARBNetworkSoundActor_OnRep_RTPCData_Params params {};
		params.oldRTPCData = oldRTPCData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSoundActor.OnRep_AssociatedSoundPlaying
	 * 		Flags  -> ()
	 */
	void ARBNetworkSoundActor::OnRep_AssociatedSoundPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSoundActor.OnRep_AssociatedSoundPlaying");
		
		ARBNetworkSoundActor_OnRep_AssociatedSoundPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBNetworkSoundActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBNetworkSoundActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNetworkSoundActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSyncComponent.OnRep_PlayingChanged
	 * 		Flags  -> ()
	 */
	void URBNetworkSyncComponent::OnRep_PlayingChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSyncComponent.OnRep_PlayingChanged");
		
		URBNetworkSyncComponent_OnRep_PlayingChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSyncComponent.BP_UntriggerNetworkSync
	 * 		Flags  -> ()
	 */
	void URBNetworkSyncComponent::BP_UntriggerNetworkSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSyncComponent.BP_UntriggerNetworkSync");
		
		URBNetworkSyncComponent_BP_UntriggerNetworkSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSyncComponent.BP_TriggerNetworkSync
	 * 		Flags  -> ()
	 */
	void URBNetworkSyncComponent::BP_TriggerNetworkSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSyncComponent.BP_TriggerNetworkSync");
		
		URBNetworkSyncComponent_BP_TriggerNetworkSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSyncComponent.BP_SlowToStop
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBNetworkSyncComponent::BP_SlowToStop(float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSyncComponent.BP_SlowToStop");
		
		URBNetworkSyncComponent_BP_SlowToStop_Params params {};
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSyncComponent.BP_ResetNetworkSync
	 * 		Flags  -> ()
	 */
	void URBNetworkSyncComponent::BP_ResetNetworkSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSyncComponent.BP_ResetNetworkSync");
		
		URBNetworkSyncComponent_BP_ResetNetworkSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSyncComponent.BP_IsStopped
	 * 		Flags  -> ()
	 */
	bool URBNetworkSyncComponent::BP_IsStopped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSyncComponent.BP_IsStopped");
		
		URBNetworkSyncComponent_BP_IsStopped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSyncComponent.BP_IsPlaying
	 * 		Flags  -> ()
	 */
	bool URBNetworkSyncComponent::BP_IsPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSyncComponent.BP_IsPlaying");
		
		URBNetworkSyncComponent_BP_IsPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSyncComponent.BP_IsFinished
	 * 		Flags  -> ()
	 */
	bool URBNetworkSyncComponent::BP_IsFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSyncComponent.BP_IsFinished");
		
		URBNetworkSyncComponent_BP_IsFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSyncComponent.BP_GetSyncValue
	 * 		Flags  -> ()
	 */
	float URBNetworkSyncComponent::BP_GetSyncValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSyncComponent.BP_GetSyncValue");
		
		URBNetworkSyncComponent_BP_GetSyncValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSyncComponent.BP_GetSyncRotationFromSequence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRotator>                            Sequence                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    OutRotation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBNetworkSyncComponent::BP_GetSyncRotationFromSequence(TArray<struct FRotator> Sequence, struct FRotator* OutRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSyncComponent.BP_GetSyncRotationFromSequence");
		
		URBNetworkSyncComponent_BP_GetSyncRotationFromSequence_Params params {};
		params.Sequence = Sequence;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutRotation != nullptr)
			*OutRotation = params.OutRotation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNetworkSyncComponent.BP_GetSyncLocationFromSequence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FVector>                             Sequence                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBNetworkSyncComponent::BP_GetSyncLocationFromSequence(TArray<struct FVector> Sequence, struct FVector* OutLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNetworkSyncComponent.BP_GetSyncLocationFromSequence");
		
		URBNetworkSyncComponent_BP_GetSyncLocationFromSequence_Params params {};
		params.Sequence = Sequence;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNetworkSyncComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNetworkSyncComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNetworkSyncComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNewsWidget.SetActiveItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBNewsWidget::SetActiveItem(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNewsWidget.SetActiveItem");
		
		URBNewsWidget_SetActiveItem_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNewsWidget.HasCTA
	 * 		Flags  -> ()
	 */
	bool URBNewsWidget::HasCTA()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNewsWidget.HasCTA");
		
		URBNewsWidget_HasCTA_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNewsWidget.GetTitle
	 * 		Flags  -> ()
	 */
	class FString URBNewsWidget::GetTitle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNewsWidget.GetTitle");
		
		URBNewsWidget_GetTitle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNewsWidget.GetNumItems
	 * 		Flags  -> ()
	 */
	int32_t URBNewsWidget::GetNumItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNewsWidget.GetNumItems");
		
		URBNewsWidget_GetNumItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNewsWidget.GetImage
	 * 		Flags  -> ()
	 */
	class UTexture2DDynamic* URBNewsWidget::GetImage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNewsWidget.GetImage");
		
		URBNewsWidget_GetImage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNewsWidget.GetHeaderBackgroundColor
	 * 		Flags  -> ()
	 */
	struct FLinearColor URBNewsWidget::GetHeaderBackgroundColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNewsWidget.GetHeaderBackgroundColor");
		
		URBNewsWidget_GetHeaderBackgroundColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNewsWidget.GetDescription
	 * 		Flags  -> ()
	 */
	class FString URBNewsWidget::GetDescription()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNewsWidget.GetDescription");
		
		URBNewsWidget_GetDescription_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNewsWidget.GetCurrentItemIndex
	 * 		Flags  -> ()
	 */
	int32_t URBNewsWidget::GetCurrentItemIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNewsWidget.GetCurrentItemIndex");
		
		URBNewsWidget_GetCurrentItemIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNewsWidget.GetBorderColor
	 * 		Flags  -> ()
	 */
	struct FLinearColor URBNewsWidget::GetBorderColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNewsWidget.GetBorderColor");
		
		URBNewsWidget_GetBorderColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNewsWidget.ExecuteCTA
	 * 		Flags  -> ()
	 */
	void URBNewsWidget::ExecuteCTA()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNewsWidget.ExecuteCTA");
		
		URBNewsWidget_ExecuteCTA_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNewsWidget.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBNewsWidget::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNewsWidget.Event_Refresh");
		
		URBNewsWidget_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNewsWidget.Event_NextItem
	 * 		Flags  -> ()
	 */
	void URBNewsWidget::Event_NextItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNewsWidget.Event_NextItem");
		
		URBNewsWidget_Event_NextItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNewsWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNewsWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNewsWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNPCWeaponList.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNPCWeaponList::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNPCWeaponList");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCDebugIconWidget.GetMeterValue
	 * 		Flags  -> ()
	 */
	float URBNPCDebugIconWidget::GetMeterValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCDebugIconWidget.GetMeterValue");
		
		URBNPCDebugIconWidget_GetMeterValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCDebugIconWidget.GetAwarenessStateType
	 * 		Flags  -> ()
	 */
	EAIAwarenessStateType URBNPCDebugIconWidget::GetAwarenessStateType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCDebugIconWidget.GetAwarenessStateType");
		
		URBNPCDebugIconWidget_GetAwarenessStateType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNPCDebugIconWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNPCDebugIconWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNPCDebugIconWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBNPCInterestPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBNPCInterestPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNPCInterestPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNPCInterestPointComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNPCInterestPointComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNPCInterestPointComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNPCArchetypeConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNPCArchetypeConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNPCArchetypeConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNPCRandomizationConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNPCRandomizationConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNPCRandomizationConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorDoor.OnRep_IsRetracted
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorDoor::OnRep_IsRetracted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorDoor.OnRep_IsRetracted");
		
		ARBNPCSeparatorDoor_OnRep_IsRetracted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorDoor.OnPlayerExitedTube
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPCSeparatorTube*                         tube                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorDoor::OnPlayerExitedTube(class ARBNPCSeparatorTube* tube, class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorDoor.OnPlayerExitedTube");
		
		ARBNPCSeparatorDoor_OnPlayerExitedTube_Params params {};
		params.tube = tube;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorDoor.OnOutsideSafetyComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorDoor::OnOutsideSafetyComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorDoor.OnOutsideSafetyComponentBeginOverlap");
		
		ARBNPCSeparatorDoor_OnOutsideSafetyComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorDoor.OnInsideSafetyComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorDoor::OnInsideSafetyComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorDoor.OnInsideSafetyComponentBeginOverlap");
		
		ARBNPCSeparatorDoor_OnInsideSafetyComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorDoor.Event_OnTubesInitialized
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorDoor::Event_OnTubesInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorDoor.Event_OnTubesInitialized");
		
		ARBNPCSeparatorDoor_Event_OnTubesInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorDoor.Event_OnIsRetractedChanged
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorDoor::Event_OnIsRetractedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorDoor.Event_OnIsRetractedChanged");
		
		ARBNPCSeparatorDoor_Event_OnIsRetractedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorDoor.BP_SetMaxNumberOfPassages_Internal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Number                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorDoor::BP_SetMaxNumberOfPassages_Internal(int32_t Number)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorDoor.BP_SetMaxNumberOfPassages_Internal");
		
		ARBNPCSeparatorDoor_BP_SetMaxNumberOfPassages_Internal_Params params {};
		params.Number = Number;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorDoor.BP_SetLocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorDoor::BP_SetLocked(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorDoor.BP_SetLocked");
		
		ARBNPCSeparatorDoor_BP_SetLocked_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorDoor.BP_SetDoorsRetracted_Internal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorDoor::BP_SetDoorsRetracted_Internal(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorDoor.BP_SetDoorsRetracted_Internal");
		
		ARBNPCSeparatorDoor_BP_SetDoorsRetracted_Internal_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorDoor.BP_SetDoorsCurrentDirection
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInsideToOutisde                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorDoor::BP_SetDoorsCurrentDirection(bool bInsideToOutisde)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorDoor.BP_SetDoorsCurrentDirection");
		
		ARBNPCSeparatorDoor_BP_SetDoorsCurrentDirection_Params params {};
		params.bInsideToOutisde = bInsideToOutisde;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorDoor.BP_ForceTubeDirection_Internal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInsideToOutisde                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorDoor::BP_ForceTubeDirection_Internal(bool bInsideToOutisde)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorDoor.BP_ForceTubeDirection_Internal");
		
		ARBNPCSeparatorDoor_BP_ForceTubeDirection_Internal_Params params {};
		params.bInsideToOutisde = bInsideToOutisde;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorDoor.BP_ClearForcedTubeDirection_Internal
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorDoor::BP_ClearForcedTubeDirection_Internal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorDoor.BP_ClearForcedTubeDirection_Internal");
		
		ARBNPCSeparatorDoor_BP_ClearForcedTubeDirection_Internal_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBNPCSeparatorDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBNPCSeparatorDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNPCSeparatorDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.UpdateTubeState_Server
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorTube::UpdateTubeState_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.UpdateTubeState_Server");
		
		ARBNPCSeparatorTube_UpdateTubeState_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.OnRep_TubeState
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorTube::OnRep_TubeState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.OnRep_TubeState");
		
		ARBNPCSeparatorTube_OnRep_TubeState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.OnRep_PlayersInside
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorTube::OnRep_PlayersInside()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.OnRep_PlayersInside");
		
		ARBNPCSeparatorTube_OnRep_PlayersInside_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.OnRep_IsRetracted
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorTube::OnRep_IsRetracted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.OnRep_IsRetracted");
		
		ARBNPCSeparatorTube_OnRep_IsRetracted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.OnRep_Islocked
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorTube::OnRep_Islocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.OnRep_Islocked");
		
		ARBNPCSeparatorTube_OnRep_Islocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.OnComponentCapsuleEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorTube::OnComponentCapsuleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.OnComponentCapsuleEndOverlap");
		
		ARBNPCSeparatorTube_OnComponentCapsuleEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.OnComponentCapsuleBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorTube::OnComponentCapsuleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.OnComponentCapsuleBeginOverlap");
		
		ARBNPCSeparatorTube_OnComponentCapsuleBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.OnComponentBoxBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorTube::OnComponentBoxBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.OnComponentBoxBeginOverlap");
		
		ARBNPCSeparatorTube_OnComponentBoxBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.Event_OnTubeStateChanged
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorTube::Event_OnTubeStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.Event_OnTubeStateChanged");
		
		ARBNPCSeparatorTube_Event_OnTubeStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.Event_OnPlayersInsideChanged
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorTube::Event_OnPlayersInsideChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.Event_OnPlayersInsideChanged");
		
		ARBNPCSeparatorTube_Event_OnPlayersInsideChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.Event_OnIsRetractedChanged
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorTube::Event_OnIsRetractedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.Event_OnIsRetractedChanged");
		
		ARBNPCSeparatorTube_Event_OnIsRetractedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.Event_OnIsLockedChanged
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorTube::Event_OnIsLockedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.Event_OnIsLockedChanged");
		
		ARBNPCSeparatorTube_Event_OnIsLockedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.BP_SetTubeState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESeparatorTubeState                                State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorTube::BP_SetTubeState(ESeparatorTubeState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.BP_SetTubeState");
		
		ARBNPCSeparatorTube_BP_SetTubeState_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.BP_SetMaxNumberOfPassages
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            MaxNumber                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bResetNumberOfPassages                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorTube::BP_SetMaxNumberOfPassages(int32_t MaxNumber, bool bResetNumberOfPassages)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.BP_SetMaxNumberOfPassages");
		
		ARBNPCSeparatorTube_BP_SetMaxNumberOfPassages_Params params {};
		params.MaxNumber = MaxNumber;
		params.bResetNumberOfPassages = bResetNumberOfPassages;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.BP_SetIsRetracted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorTube::BP_SetIsRetracted(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.BP_SetIsRetracted");
		
		ARBNPCSeparatorTube_BP_SetIsRetracted_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.BP_SetIsLocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorTube::BP_SetIsLocked(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.BP_SetIsLocked");
		
		ARBNPCSeparatorTube_BP_SetIsLocked_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.BP_SetForcedDirection
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInsideToOutside                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorTube::BP_SetForcedDirection(bool bInsideToOutside)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.BP_SetForcedDirection");
		
		ARBNPCSeparatorTube_BP_SetForcedDirection_Params params {};
		params.bInsideToOutside = bInsideToOutside;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.BP_SetDirection
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInsideToOutside                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCSeparatorTube::BP_SetDirection(bool bInsideToOutside)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.BP_SetDirection");
		
		ARBNPCSeparatorTube_BP_SetDirection_Params params {};
		params.bInsideToOutside = bInsideToOutside;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.BP_OnDoorAnimationStarted
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorTube::BP_OnDoorAnimationStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.BP_OnDoorAnimationStarted");
		
		ARBNPCSeparatorTube_BP_OnDoorAnimationStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.BP_OnDoorAnimationFinished
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorTube::BP_OnDoorAnimationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.BP_OnDoorAnimationFinished");
		
		ARBNPCSeparatorTube_BP_OnDoorAnimationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCSeparatorTube.BP_ClearForcedDirection
	 * 		Flags  -> ()
	 */
	void ARBNPCSeparatorTube::BP_ClearForcedDirection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCSeparatorTube.BP_ClearForcedDirection");
		
		ARBNPCSeparatorTube_BP_ClearForcedDirection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBNPCSeparatorTube.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBNPCSeparatorTube::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNPCSeparatorTube");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCShopUserWidget.SetMetaNpcType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMetaNPCType                                       metaNPCType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBNPCShopUserWidget::SetMetaNpcType(EMetaNPCType metaNPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCShopUserWidget.SetMetaNpcType");
		
		URBNPCShopUserWidget_SetMetaNpcType_Params params {};
		params.metaNPCType = metaNPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCShopUserWidget.OnRelevantDataChanged
	 * 		Flags  -> ()
	 */
	void URBNPCShopUserWidget::OnRelevantDataChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCShopUserWidget.OnRelevantDataChanged");
		
		URBNPCShopUserWidget_OnRelevantDataChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCShopUserWidget.GetMetaNPCType
	 * 		Flags  -> ()
	 */
	EMetaNPCType URBNPCShopUserWidget::GetMetaNPCType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCShopUserWidget.GetMetaNPCType");
		
		URBNPCShopUserWidget_GetMetaNPCType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCShopUserWidget.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBNPCShopUserWidget::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCShopUserWidget.Event_Refresh");
		
		URBNPCShopUserWidget_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCShopUserWidget.Event_OnMetaNpcTypeChanged
	 * 		Flags  -> ()
	 */
	void URBNPCShopUserWidget::Event_OnMetaNpcTypeChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCShopUserWidget.Event_OnMetaNpcTypeChanged");
		
		URBNPCShopUserWidget_Event_OnMetaNpcTypeChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNPCShopUserWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNPCShopUserWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNPCShopUserWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCWeapon.Event_OnUnhidden
	 * 		Flags  -> ()
	 */
	void ARBNPCWeapon::Event_OnUnhidden()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCWeapon.Event_OnUnhidden");
		
		ARBNPCWeapon_Event_OnUnhidden_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCWeapon.Event_OnHidden
	 * 		Flags  -> ()
	 */
	void ARBNPCWeapon::Event_OnHidden()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCWeapon.Event_OnHidden");
		
		ARBNPCWeapon_Event_OnHidden_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCWeapon.Event_DeactivateEffects
	 * 		Flags  -> ()
	 */
	void ARBNPCWeapon::Event_DeactivateEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCWeapon.Event_DeactivateEffects");
		
		ARBNPCWeapon_Event_DeactivateEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCWeapon.Event_ActivateEffects
	 * 		Flags  -> ()
	 */
	void ARBNPCWeapon::Event_ActivateEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCWeapon.Event_ActivateEffects");
		
		ARBNPCWeapon_Event_ActivateEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNPCWeapon.EquippedBy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBNPCWeapon::EquippedBy(class ARBNPC* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNPCWeapon.EquippedBy");
		
		ARBNPCWeapon_EquippedBy_Params params {};
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBNPCWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBNPCWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNPCWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNVComponent.TurnOn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bPowered                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBNVComponent::TurnOn(bool bPowered)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNVComponent.TurnOn");
		
		URBNVComponent_TurnOn_Params params {};
		params.bPowered = bPowered;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNVComponent.TurnOff
	 * 		Flags  -> ()
	 */
	void URBNVComponent::TurnOff()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNVComponent.TurnOff");
		
		URBNVComponent_TurnOff_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNVComponent.OnRep_NVState
	 * 		Flags  -> ()
	 */
	void URBNVComponent::OnRep_NVState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNVComponent.OnRep_NVState");
		
		URBNVComponent_OnRep_NVState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNVComponent.OnRep_IsBatteryLow
	 * 		Flags  -> ()
	 */
	void URBNVComponent::OnRep_IsBatteryLow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNVComponent.OnRep_IsBatteryLow");
		
		URBNVComponent_OnRep_IsBatteryLow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNVComponent.OnNVStateChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBNVComponent::OnNVStateChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNVComponent.OnNVStateChangedCallback");
		
		URBNVComponent_OnNVStateChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNVComponent.IsNVOn
	 * 		Flags  -> ()
	 */
	bool URBNVComponent::IsNVOn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNVComponent.IsNVOn");
		
		URBNVComponent_IsNVOn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNVComponent.IsBatteryLow
	 * 		Flags  -> ()
	 */
	bool URBNVComponent::IsBatteryLow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNVComponent.IsBatteryLow");
		
		URBNVComponent_IsBatteryLow_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBNVComponent.GetCurrentState
	 * 		Flags  -> ()
	 */
	ENVState URBNVComponent::GetCurrentState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBNVComponent.GetCurrentState");
		
		URBNVComponent_GetCurrentState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNVComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNVComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNVComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomAssociationComponent.BP_RefreshRoomAssociation
	 * 		Flags  -> ()
	 */
	void URBRoomAssociationComponent::BP_RefreshRoomAssociation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomAssociationComponent.BP_RefreshRoomAssociation");
		
		URBRoomAssociationComponent_BP_RefreshRoomAssociation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRoomAssociationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRoomAssociationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRoomAssociationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveActorComponent.BP_ShouldIconBeForcedHidden
	 * 		Flags  -> ()
	 */
	bool URBObjectiveActorComponent::BP_ShouldIconBeForcedHidden()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveActorComponent.BP_ShouldIconBeForcedHidden");
		
		URBObjectiveActorComponent_BP_ShouldIconBeForcedHidden_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBObjectiveActorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBObjectiveActorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBObjectiveActorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveCoordinatorGroup.OnConcurrentCoordinatorStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBaseObjectiveCoordinator*                 coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EObjectiveCoordinatorState                         State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBObjectiveCoordinatorGroup::OnConcurrentCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* coordinator, EObjectiveCoordinatorState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveCoordinatorGroup.OnConcurrentCoordinatorStateChanged");
		
		ARBObjectiveCoordinatorGroup_OnConcurrentCoordinatorStateChanged_Params params {};
		params.coordinator = coordinator;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBObjectiveCoordinatorGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBObjectiveCoordinatorGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBObjectiveCoordinatorGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveManager.OnStageStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBObjectiveManager::OnStageStarted(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveManager.OnStageStarted");
		
		URBObjectiveManager_OnStageStarted_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveManager.OnStageReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBObjectiveManager::OnStageReady(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveManager.OnStageReady");
		
		URBObjectiveManager_OnStageReady_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveManager.OnObjectiveCoordinatorStateChanged_Callback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBaseObjectiveCoordinator*                 coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EObjectiveCoordinatorState                         newState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBObjectiveManager::OnObjectiveCoordinatorStateChanged_Callback(class ARBBaseObjectiveCoordinator* coordinator, EObjectiveCoordinatorState newState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveManager.OnObjectiveCoordinatorStateChanged_Callback");
		
		URBObjectiveManager_OnObjectiveCoordinatorStateChanged_Callback_Params params {};
		params.coordinator = coordinator;
		params.newState = newState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveManager.GetCurrentQuestItemLimit
	 * 		Flags  -> ()
	 */
	int32_t URBObjectiveManager::GetCurrentQuestItemLimit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveManager.GetCurrentQuestItemLimit");
		
		URBObjectiveManager_GetCurrentQuestItemLimit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveManager.BP_PlayObjectiveScreenAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FNarrativeScreenAnimationData               animData                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayIntro                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBObjectiveManager::BP_PlayObjectiveScreenAnim(const struct FNarrativeScreenAnimationData& animData, bool bPlayIntro)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveManager.BP_PlayObjectiveScreenAnim");
		
		URBObjectiveManager_BP_PlayObjectiveScreenAnim_Params params {};
		params.animData = animData;
		params.bPlayIntro = bPlayIntro;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveManager.BP_HasStartedMainObjective
	 * 		Flags  -> ()
	 */
	bool URBObjectiveManager::BP_HasStartedMainObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveManager.BP_HasStartedMainObjective");
		
		URBObjectiveManager_BP_HasStartedMainObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveManager.BP_GetStartedObjectiveCoordinators
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class ARBBaseObjectiveCoordinator*>         outCoordinators                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void URBObjectiveManager::BP_GetStartedObjectiveCoordinators(TArray<class ARBBaseObjectiveCoordinator*>* outCoordinators)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveManager.BP_GetStartedObjectiveCoordinators");
		
		URBObjectiveManager_BP_GetStartedObjectiveCoordinators_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outCoordinators != nullptr)
			*outCoordinators = params.outCoordinators;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveManager.BP_GetIntroObjectiveIcon
	 * 		Flags  -> ()
	 */
	class UTexture2D* URBObjectiveManager::BP_GetIntroObjectiveIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveManager.BP_GetIntroObjectiveIcon");
		
		URBObjectiveManager_BP_GetIntroObjectiveIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveManager.BP_GetFormattedCurrentObjectiveString
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            maxCharPerLine                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBObjectiveManager::BP_GetFormattedCurrentObjectiveString(int32_t maxCharPerLine)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveManager.BP_GetFormattedCurrentObjectiveString");
		
		URBObjectiveManager_BP_GetFormattedCurrentObjectiveString_Params params {};
		params.maxCharPerLine = maxCharPerLine;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveManager.BP_GetAllObjectiveCoordinators
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class ARBBaseObjectiveCoordinator*>         outCoordinators                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void URBObjectiveManager::BP_GetAllObjectiveCoordinators(TArray<class ARBBaseObjectiveCoordinator*>* outCoordinators)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveManager.BP_GetAllObjectiveCoordinators");
		
		URBObjectiveManager_BP_GetAllObjectiveCoordinators_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outCoordinators != nullptr)
			*outCoordinators = params.outCoordinators;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveManager.BP_CompleteSingleObjective
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBObjectiveManager::BP_CompleteSingleObjective(class ARBPawn* Player, class AActor* objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveManager.BP_CompleteSingleObjective");
		
		URBObjectiveManager_BP_CompleteSingleObjective_Params params {};
		params.Player = Player;
		params.objective = objective;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBObjectiveManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBObjectiveManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBObjectiveManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBObjectiveProximityComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBObjectiveProximityComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBObjectiveProximityComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveRandomizable.GetObjectiveTypeIndex
	 * 		Flags  -> ()
	 */
	int32_t URBObjectiveRandomizable::GetObjectiveTypeIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveRandomizable.GetObjectiveTypeIndex");
		
		URBObjectiveRandomizable_GetObjectiveTypeIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBObjectiveRandomizable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBObjectiveRandomizable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBObjectiveRandomizable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveWidgetBase.SetObjectiveCoordinator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBaseObjectiveCoordinator*                 coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBObjectiveWidgetBase::SetObjectiveCoordinator(class ARBBaseObjectiveCoordinator* coordinator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveWidgetBase.SetObjectiveCoordinator");
		
		URBObjectiveWidgetBase_SetObjectiveCoordinator_Params params {};
		params.coordinator = coordinator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveWidgetBase.OnSingleObjectiveCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBaseObjectiveCoordinator*                 coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBObjectiveWidgetBase::OnSingleObjectiveCompleted(class ARBBaseObjectiveCoordinator* coordinator, class AActor* Player, class AActor* objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveWidgetBase.OnSingleObjectiveCompleted");
		
		URBObjectiveWidgetBase_OnSingleObjectiveCompleted_Params params {};
		params.coordinator = coordinator;
		params.Player = Player;
		params.objective = objective;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveWidgetBase.OnObjectiveCoordinatorStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBaseObjectiveCoordinator*                 coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EObjectiveCoordinatorState                         State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBObjectiveWidgetBase::OnObjectiveCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* coordinator, EObjectiveCoordinatorState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveWidgetBase.OnObjectiveCoordinatorStateChanged");
		
		URBObjectiveWidgetBase_OnObjectiveCoordinatorStateChanged_Params params {};
		params.coordinator = coordinator;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveWidgetBase.OnObjectiveCoordinatorStarted
	 * 		Flags  -> ()
	 */
	void URBObjectiveWidgetBase::OnObjectiveCoordinatorStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveWidgetBase.OnObjectiveCoordinatorStarted");
		
		URBObjectiveWidgetBase_OnObjectiveCoordinatorStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveWidgetBase.OnCompletionInProgressChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               isProgressionInProgress                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isCompletedByLocalPlayer                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBObjectiveWidgetBase::OnCompletionInProgressChanged(bool isProgressionInProgress, bool isCompletedByLocalPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveWidgetBase.OnCompletionInProgressChanged");
		
		URBObjectiveWidgetBase_OnCompletionInProgressChanged_Params params {};
		params.isProgressionInProgress = isProgressionInProgress;
		params.isCompletedByLocalPlayer = isCompletedByLocalPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveWidgetBase.Event_ProgressChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              progress                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isPositiveProgress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        objectiveText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBObjectiveWidgetBase::Event_ProgressChanged(float progress, bool isPositiveProgress, const class FText& objectiveText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveWidgetBase.Event_ProgressChanged");
		
		URBObjectiveWidgetBase_Event_ProgressChanged_Params params {};
		params.progress = progress;
		params.isPositiveProgress = isPositiveProgress;
		params.objectiveText = objectiveText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveWidgetBase.Event_IsMakingPositiveProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               isMakingPositiveProgress                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBObjectiveWidgetBase::Event_IsMakingPositiveProgress(bool isMakingPositiveProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveWidgetBase.Event_IsMakingPositiveProgress");
		
		URBObjectiveWidgetBase_Event_IsMakingPositiveProgress_Params params {};
		params.isMakingPositiveProgress = isMakingPositiveProgress;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBObjectiveWidgetBase.Event_Completed
	 * 		Flags  -> ()
	 */
	void URBObjectiveWidgetBase::Event_Completed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBObjectiveWidgetBase.Event_Completed");
		
		URBObjectiveWidgetBase_Event_Completed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBObjectiveWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBObjectiveWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBObjectiveWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBObstacleVariatorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBObstacleVariatorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBObstacleVariatorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableInterface.OnTriggerableDeactivated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBTriggerable*                              triggerable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBOperatableInterface::OnTriggerableDeactivated(class ARBTriggerable* triggerable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableInterface.OnTriggerableDeactivated");
		
		URBOperatableInterface_OnTriggerableDeactivated_Params params {};
		params.triggerable = triggerable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableInterface.OnTriggerableActivated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBTriggerable*                              triggerable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBOperatableInterface::OnTriggerableActivated(class ARBTriggerable* triggerable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableInterface.OnTriggerableActivated");
		
		URBOperatableInterface_OnTriggerableActivated_Params params {};
		params.triggerable = triggerable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableInterface.GetTriggerActionBehavior
	 * 		Flags  -> ()
	 */
	ETriggerableActionBehavior URBOperatableInterface::GetTriggerActionBehavior()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableInterface.GetTriggerActionBehavior");
		
		URBOperatableInterface_GetTriggerActionBehavior_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableInterface.GetProgressionRatio
	 * 		Flags  -> ()
	 */
	float URBOperatableInterface::GetProgressionRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableInterface.GetProgressionRatio");
		
		URBOperatableInterface_GetProgressionRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBOperatableInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBOperatableInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBOperatableInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableForObjectiveTrigger.GetLinkedTriggerable
	 * 		Flags  -> ()
	 */
	class ARBTriggerable* URBOperatableForObjectiveTrigger::GetLinkedTriggerable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableForObjectiveTrigger.GetLinkedTriggerable");
		
		URBOperatableForObjectiveTrigger_GetLinkedTriggerable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBOperatableForObjectiveTrigger.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBOperatableForObjectiveTrigger::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBOperatableForObjectiveTrigger");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableTriggerObjectiveCoordinator.OnRep_AllSelectedOperatables
	 * 		Flags  -> ()
	 */
	void ARBOperatableTriggerObjectiveCoordinator::OnRep_AllSelectedOperatables()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableTriggerObjectiveCoordinator.OnRep_AllSelectedOperatables");
		
		ARBOperatableTriggerObjectiveCoordinator_OnRep_AllSelectedOperatables_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableTriggerObjectiveCoordinator.OnPlayerCompletedOperatable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsOn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBOperatable*                               operatable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBOperatableTriggerObjectiveCoordinator::OnPlayerCompletedOperatable(bool IsOn, class ARBOperatable* operatable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableTriggerObjectiveCoordinator.OnPlayerCompletedOperatable");
		
		ARBOperatableTriggerObjectiveCoordinator_OnPlayerCompletedOperatable_Params params {};
		params.IsOn = IsOn;
		params.operatable = operatable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableTriggerObjectiveCoordinator.GetRemainingOperatablesForTriggerable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBTriggerable*                              triggerable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              outOperatables                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ARBOperatableTriggerObjectiveCoordinator::GetRemainingOperatablesForTriggerable(class ARBTriggerable* triggerable, TArray<class AActor*>* outOperatables)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableTriggerObjectiveCoordinator.GetRemainingOperatablesForTriggerable");
		
		ARBOperatableTriggerObjectiveCoordinator_GetRemainingOperatablesForTriggerable_Params params {};
		params.triggerable = triggerable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outOperatables != nullptr)
			*outOperatables = params.outOperatables;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOperatableTriggerObjectiveCoordinator.GetLinkedTriggerable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      operatable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBTriggerable* ARBOperatableTriggerObjectiveCoordinator::GetLinkedTriggerable(class AActor* operatable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOperatableTriggerObjectiveCoordinator.GetLinkedTriggerable");
		
		ARBOperatableTriggerObjectiveCoordinator_GetLinkedTriggerable_Params params {};
		params.operatable = operatable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBOperatableTriggerObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBOperatableTriggerObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBOperatableTriggerObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBOptionsData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBOptionsData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBOptionsData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOptionsMenu.CanViewCrossplaySetting
	 * 		Flags  -> ()
	 */
	bool URBOptionsMenu::CanViewCrossplaySetting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOptionsMenu.CanViewCrossplaySetting");
		
		URBOptionsMenu_CanViewCrossplaySetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOptionsMenu.CanEditCrossplaySetting
	 * 		Flags  -> ()
	 */
	bool URBOptionsMenu::CanEditCrossplaySetting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOptionsMenu.CanEditCrossplaySetting");
		
		URBOptionsMenu_CanEditCrossplaySetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBOptionsMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBOptionsMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBOptionsMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOutlineComponent.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabledValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBOutlineComponent::BP_SetEnabled(bool bEnabledValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOutlineComponent.BP_SetEnabled");
		
		URBOutlineComponent_BP_SetEnabled_Params params {};
		params.bEnabledValue = bEnabledValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOutlineComponent.BP_IsEnabled
	 * 		Flags  -> ()
	 */
	bool URBOutlineComponent::BP_IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOutlineComponent.BP_IsEnabled");
		
		URBOutlineComponent_BP_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBOutlineComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBOutlineComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBOutlineComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOverheadVoiceChatWidget.OnPlayerVoiceChatVolumeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProfileId                                  ProfileId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBOverheadVoiceChatWidget::OnPlayerVoiceChatVolumeChanged(const struct FProfileId& ProfileId, float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOverheadVoiceChatWidget.OnPlayerVoiceChatVolumeChanged");
		
		URBOverheadVoiceChatWidget_OnPlayerVoiceChatVolumeChanged_Params params {};
		params.ProfileId = ProfileId;
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOverheadVoiceChatWidget.OnMicrophoneVolumeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBOverheadVoiceChatWidget::OnMicrophoneVolumeChanged(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOverheadVoiceChatWidget.OnMicrophoneVolumeChanged");
		
		URBOverheadVoiceChatWidget_OnMicrophoneVolumeChanged_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOverheadVoiceChatWidget.IsVoiceChatConnected
	 * 		Flags  -> ()
	 */
	bool URBOverheadVoiceChatWidget::IsVoiceChatConnected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOverheadVoiceChatWidget.IsVoiceChatConnected");
		
		URBOverheadVoiceChatWidget_IsVoiceChatConnected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOverheadVoiceChatWidget.IsSpeaking
	 * 		Flags  -> ()
	 */
	bool URBOverheadVoiceChatWidget::IsSpeaking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOverheadVoiceChatWidget.IsSpeaking");
		
		URBOverheadVoiceChatWidget_IsSpeaking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOverheadVoiceChatWidget.IsMuted
	 * 		Flags  -> ()
	 */
	bool URBOverheadVoiceChatWidget::IsMuted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOverheadVoiceChatWidget.IsMuted");
		
		URBOverheadVoiceChatWidget_IsMuted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOverheadVoiceChatWidget.IsBlocked
	 * 		Flags  -> ()
	 */
	bool URBOverheadVoiceChatWidget::IsBlocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOverheadVoiceChatWidget.IsBlocked");
		
		URBOverheadVoiceChatWidget_IsBlocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOverheadVoiceChatWidget.Init
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FProfileId                                  ProfileId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBOverheadVoiceChatWidget::Init(const struct FProfileId& ProfileId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOverheadVoiceChatWidget.Init");
		
		URBOverheadVoiceChatWidget_Init_Params params {};
		params.ProfileId = ProfileId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOverheadVoiceChatWidget.HasVoiceChatPrivilege
	 * 		Flags  -> ()
	 */
	bool URBOverheadVoiceChatWidget::HasVoiceChatPrivilege()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOverheadVoiceChatWidget.HasVoiceChatPrivilege");
		
		URBOverheadVoiceChatWidget_HasVoiceChatPrivilege_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOverheadVoiceChatWidget.HasVoiceChatEnabled
	 * 		Flags  -> ()
	 */
	bool URBOverheadVoiceChatWidget::HasVoiceChatEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOverheadVoiceChatWidget.HasVoiceChatEnabled");
		
		URBOverheadVoiceChatWidget_HasVoiceChatEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBOverheadVoiceChatWidget.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBOverheadVoiceChatWidget::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBOverheadVoiceChatWidget.Event_Refresh");
		
		URBOverheadVoiceChatWidget_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBOverheadVoiceChatWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBOverheadVoiceChatWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBOverheadVoiceChatWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBOverseer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBOverseer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBOverseer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPartyInviteNotificationUserWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPartyInviteNotificationUserWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPartyInviteNotificationUserWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodeButtonComponent.OnRep_Pressed
	 * 		Flags  -> ()
	 */
	void URBPasscodeButtonComponent::OnRep_Pressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodeButtonComponent.OnRep_Pressed");
		
		URBPasscodeButtonComponent_OnRep_Pressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodeButtonComponent.OnRep_IsOn
	 * 		Flags  -> ()
	 */
	void URBPasscodeButtonComponent::OnRep_IsOn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodeButtonComponent.OnRep_IsOn");
		
		URBPasscodeButtonComponent_OnRep_IsOn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodeButtonComponent.BP_IsPressed
	 * 		Flags  -> ()
	 */
	bool URBPasscodeButtonComponent::BP_IsPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodeButtonComponent.BP_IsPressed");
		
		URBPasscodeButtonComponent_BP_IsPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPasscodeButtonComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPasscodeButtonComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPasscodeButtonComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodeNumberDecalActor.OnRep_DecalData
	 * 		Flags  -> ()
	 */
	void ARBPasscodeNumberDecalActor::OnRep_DecalData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodeNumberDecalActor.OnRep_DecalData");
		
		ARBPasscodeNumberDecalActor_OnRep_DecalData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodeNumberDecalActor.IsPasscodeDebugging
	 * 		Flags  -> ()
	 */
	bool ARBPasscodeNumberDecalActor::IsPasscodeDebugging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodeNumberDecalActor.IsPasscodeDebugging");
		
		ARBPasscodeNumberDecalActor_IsPasscodeDebugging_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodeNumberDecalActor.GetLinkedPuzzleRoom
	 * 		Flags  -> ()
	 */
	class URBPuzzleRoomComponent* ARBPasscodeNumberDecalActor::GetLinkedPuzzleRoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodeNumberDecalActor.GetLinkedPuzzleRoom");
		
		ARBPasscodeNumberDecalActor_GetLinkedPuzzleRoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodeNumberDecalActor.Event_OnSelected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bSelected                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPasscodeNumberDecalActor::Event_OnSelected(bool bSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodeNumberDecalActor.Event_OnSelected");
		
		ARBPasscodeNumberDecalActor_Event_OnSelected_Params params {};
		params.bSelected = bSelected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodeNumberDecalActor.Event_OnActiveChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPasscodeNumberDecalActor::Event_OnActiveChanged(bool bActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodeNumberDecalActor.Event_OnActiveChanged");
		
		ARBPasscodeNumberDecalActor_Event_OnActiveChanged_Params params {};
		params.bActive = bActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPasscodeNumberDecalActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPasscodeNumberDecalActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPasscodeNumberDecalActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodePadComponent.ValidatePad_Server
	 * 		Flags  -> ()
	 */
	void URBPasscodePadComponent::ValidatePad_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodePadComponent.ValidatePad_Server");
		
		URBPasscodePadComponent_ValidatePad_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodePadComponent.ReleaseAllButtons
	 * 		Flags  -> ()
	 */
	void URBPasscodePadComponent::ReleaseAllButtons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodePadComponent.ReleaseAllButtons");
		
		URBPasscodePadComponent_ReleaseAllButtons_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodePadComponent.OnRep_ButtonsPressed
	 * 		Flags  -> ()
	 */
	void URBPasscodePadComponent::OnRep_ButtonsPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodePadComponent.OnRep_ButtonsPressed");
		
		URBPasscodePadComponent_OnRep_ButtonsPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodePadComponent.Multicast_OnPasscodePadValidation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValid                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPasscodePadComponent::Multicast_OnPasscodePadValidation(bool bValid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodePadComponent.Multicast_OnPasscodePadValidation");
		
		URBPasscodePadComponent_Multicast_OnPasscodePadValidation_Params params {};
		params.bValid = bValid;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodePadComponent.IsSolved_Server
	 * 		Flags  -> ()
	 */
	bool URBPasscodePadComponent::IsSolved_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodePadComponent.IsSolved_Server");
		
		URBPasscodePadComponent_IsSolved_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPasscodePadComponent.BP_GetPuzzleRoomTimeLeft
	 * 		Flags  -> ()
	 */
	int32_t URBPasscodePadComponent::BP_GetPuzzleRoomTimeLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPasscodePadComponent.BP_GetPuzzleRoomTimeLeft");
		
		URBPasscodePadComponent_BP_GetPuzzleRoomTimeLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPasscodePadComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPasscodePadComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPasscodePadComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPathBlockingVolume.IsBlockingPath
	 * 		Flags  -> ()
	 */
	bool ARBPathBlockingVolume::IsBlockingPath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPathBlockingVolume.IsBlockingPath");
		
		ARBPathBlockingVolume_IsBlockingPath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPathBlockingVolume.EnablePathBlocking
	 * 		Flags  -> ()
	 */
	void ARBPathBlockingVolume::EnablePathBlocking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPathBlockingVolume.EnablePathBlocking");
		
		ARBPathBlockingVolume_EnablePathBlocking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPathBlockingVolume.DisablePathBlocking
	 * 		Flags  -> ()
	 */
	void ARBPathBlockingVolume::DisablePathBlocking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPathBlockingVolume.DisablePathBlocking");
		
		ARBPathBlockingVolume_DisablePathBlocking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPathBlockingVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPathBlockingVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPathBlockingVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_PawnToAvoid.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_PawnToAvoid::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_PawnToAvoid");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_ChaseOnly.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_ChaseOnly::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_ChaseOnly");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_Destroyable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_Destroyable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_Destroyable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_Undestroyable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_Undestroyable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_Undestroyable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_OpenedDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_OpenedDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_OpenedDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_UnlockedDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_UnlockedDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_UnlockedDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_LockedDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_LockedDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_LockedDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_OpenInvestigatedDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_OpenInvestigatedDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_OpenInvestigatedDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_UnlockedInvestigatedDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_UnlockedInvestigatedDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_UnlockedInvestigatedDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_LockedInvestigatedDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_LockedInvestigatedDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_LockedInvestigatedDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_Ledge.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_Ledge::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_Ledge");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_KnownTrap.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_KnownTrap::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_KnownTrap");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_CrouchUnder.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_CrouchUnder::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_CrouchUnder");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_MonsterCloset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_MonsterCloset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.NavArea_MonsterCloset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNavFilterBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNavFilterBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNavFilterBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNavFilter_Default.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNavFilter_Default::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNavFilter_Default");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNavFilter_InChase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNavFilter_InChase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNavFilter_InChase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNavFilter_UnawareInvestigation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNavFilter_UnawareInvestigation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNavFilter_UnawareInvestigation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNavFilter_AwareInvestigation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNavFilter_AwareInvestigation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNavFilter_AwareInvestigation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNavFilter_NoNavLink.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNavFilter_NoNavLink::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNavFilter_NoNavLink");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNavFilter_AvoidNavLinks.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNavFilter_AvoidNavLinks::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNavFilter_AvoidNavLinks");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNavFilter_IgnoreCosts.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNavFilter_IgnoreCosts::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNavFilter_IgnoreCosts");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNavFilter_NoObstacles.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNavFilter_NoObstacles::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNavFilter_NoObstacles");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNavFilter_MonsterCloset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNavFilter_MonsterCloset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNavFilter_MonsterCloset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBNavFilter_AttackClearance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBNavFilter_AttackClearance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBNavFilter_AttackClearance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRadialNavAreaComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRadialNavAreaComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRadialNavAreaComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPathFollowing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPathFollowing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPathFollowing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.UpdateStaticMeshComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UStaticMeshComponent*                        cmp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStaticMesh*                                 Mesh                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TMap<class FString, class UMaterialInstanceConstant*> materialOverrideMap                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBPawnCustomizationManager::UpdateStaticMeshComponent(class UStaticMeshComponent* cmp, class UStaticMesh* Mesh, TMap<class FString, class UMaterialInstanceConstant*> materialOverrideMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.UpdateStaticMeshComponent");
		
		URBPawnCustomizationManager_UpdateStaticMeshComponent_Params params {};
		params.cmp = cmp;
		params.Mesh = Mesh;
		params.materialOverrideMap = materialOverrideMap;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.UpdateSkeletalMeshComponentFromCustomizationOption
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      cmp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBPlayerCustomizationOption*                Option                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsFemale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPawnCustomizationManager::UpdateSkeletalMeshComponentFromCustomizationOption(class USkeletalMeshComponent* cmp, class URBPlayerCustomizationOption* Option, bool bIsFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.UpdateSkeletalMeshComponentFromCustomizationOption");
		
		URBPawnCustomizationManager_UpdateSkeletalMeshComponentFromCustomizationOption_Params params {};
		params.cmp = cmp;
		params.Option = Option;
		params.bIsFemale = bIsFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.UpdateSkeletalMeshComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      cmp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMesh*                               Mesh                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TMap<class FString, class UMaterialInstanceConstant*> materialOverrideMap                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bSetMasterPoseComponent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPawnCustomizationManager::UpdateSkeletalMeshComponent(class USkeletalMeshComponent* cmp, class USkeletalMesh* Mesh, TMap<class FString, class UMaterialInstanceConstant*> materialOverrideMap, bool bSetMasterPoseComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.UpdateSkeletalMeshComponent");
		
		URBPawnCustomizationManager_UpdateSkeletalMeshComponent_Params params {};
		params.cmp = cmp;
		params.Mesh = Mesh;
		params.materialOverrideMap = materialOverrideMap;
		params.bSetMasterPoseComponent = bSetMasterPoseComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.LoadPlayerCustomizationResourcesWithOutfitOverride
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      playerCustomizationOwner                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBCustomizationOutfit*                      Outfit                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBPawnCustomizationManager::LoadPlayerCustomizationResourcesWithOutfitOverride(class AActor* playerCustomizationOwner, class URBCustomizationOutfit* Outfit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.LoadPlayerCustomizationResourcesWithOutfitOverride");
		
		URBPawnCustomizationManager_LoadPlayerCustomizationResourcesWithOutfitOverride_Params params {};
		params.playerCustomizationOwner = playerCustomizationOwner;
		params.Outfit = Outfit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.LoadPlayerCustomizationResources
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      playerCustomizationOwner                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBPawnCustomizationManager::LoadPlayerCustomizationResources(class AActor* playerCustomizationOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.LoadPlayerCustomizationResources");
		
		URBPawnCustomizationManager_LoadPlayerCustomizationResources_Params params {};
		params.playerCustomizationOwner = playerCustomizationOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.LoadPawnCustomizationResources
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      playerCustomizationOwner                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FSoftObjectPath>                     ResourcesToLoad                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EPawnCustomizationRequestType                      requestType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBPawnCustomizationManager::LoadPawnCustomizationResources(class AActor* playerCustomizationOwner, TArray<struct FSoftObjectPath> ResourcesToLoad, EPawnCustomizationRequestType requestType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.LoadPawnCustomizationResources");
		
		URBPawnCustomizationManager_LoadPawnCustomizationResources_Params params {};
		params.playerCustomizationOwner = playerCustomizationOwner;
		params.ResourcesToLoad = ResourcesToLoad;
		params.requestType = requestType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.LoadNPCGruntResources
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      gruntOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGruntCustomizationMeshesConfig             customizationMeshesConfig                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FSelectedGruntCustomizationMeshesInfo       customizationMeshesInfo                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t URBPawnCustomizationManager::LoadNPCGruntResources(class AActor* gruntOwner, const struct FGruntCustomizationMeshesConfig& customizationMeshesConfig, const struct FSelectedGruntCustomizationMeshesInfo& customizationMeshesInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.LoadNPCGruntResources");
		
		URBPawnCustomizationManager_LoadNPCGruntResources_Params params {};
		params.gruntOwner = gruntOwner;
		params.customizationMeshesConfig = customizationMeshesConfig;
		params.customizationMeshesInfo = customizationMeshesInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.LoadCustomResources
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      requestOwner                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FSoftObjectPath>                     ResourcesToLoad                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	int32_t URBPawnCustomizationManager::LoadCustomResources(class AActor* requestOwner, TArray<struct FSoftObjectPath> ResourcesToLoad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.LoadCustomResources");
		
		URBPawnCustomizationManager_LoadCustomResources_Params params {};
		params.requestOwner = requestOwner;
		params.ResourcesToLoad = ResourcesToLoad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.IsRequestIDActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            requestID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBPawnCustomizationManager::IsRequestIDActive(int32_t requestID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.IsRequestIDActive");
		
		URBPawnCustomizationManager_IsRequestIDActive_Params params {};
		params.requestID = requestID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.IsRequestActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      customizationOwner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPawnCustomizationRequestType                      requestType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBPawnCustomizationManager::IsRequestActive(class AActor* customizationOwner, EPawnCustomizationRequestType requestType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.IsRequestActive");
		
		URBPawnCustomizationManager_IsRequestActive_Params params {};
		params.customizationOwner = customizationOwner;
		params.requestType = requestType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.CancelLoadCustomizationResources
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            requestID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPawnCustomizationManager::CancelLoadCustomizationResources(int32_t requestID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.CancelLoadCustomizationResources");
		
		URBPawnCustomizationManager_CancelLoadCustomizationResources_Params params {};
		params.requestID = requestID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.CancelAllLoadCustomizationResourcesOfType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      customizationOwner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPawnCustomizationRequestType                      requestType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPawnCustomizationManager::CancelAllLoadCustomizationResourcesOfType(class AActor* customizationOwner, EPawnCustomizationRequestType requestType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.CancelAllLoadCustomizationResourcesOfType");
		
		URBPawnCustomizationManager_CancelAllLoadCustomizationResourcesOfType_Params params {};
		params.customizationOwner = customizationOwner;
		params.requestType = requestType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.CancelAllLoadCustomizationResources
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      customizationOwner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPawnCustomizationManager::CancelAllLoadCustomizationResources(class AActor* customizationOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.CancelAllLoadCustomizationResources");
		
		URBPawnCustomizationManager_CancelAllLoadCustomizationResources_Params params {};
		params.customizationOwner = customizationOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.ApplySpecificPlayerCustomization
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      customizationOwner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBPlayerCustomizationInfo                  RBPlayerCustomizationInfo                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBPawnCustomizationManager::ApplySpecificPlayerCustomization(class AActor* customizationOwner, const struct FRBPlayerCustomizationInfo& RBPlayerCustomizationInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.ApplySpecificPlayerCustomization");
		
		URBPawnCustomizationManager_ApplySpecificPlayerCustomization_Params params {};
		params.customizationOwner = customizationOwner;
		params.RBPlayerCustomizationInfo = RBPlayerCustomizationInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.ApplyPlayerCustomizationWithOutfitOverride
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      customizationOwner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBCustomizationOutfit*                      Outfit                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPawnCustomizationManager::ApplyPlayerCustomizationWithOutfitOverride(class AActor* customizationOwner, class URBCustomizationOutfit* Outfit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.ApplyPlayerCustomizationWithOutfitOverride");
		
		URBPawnCustomizationManager_ApplyPlayerCustomizationWithOutfitOverride_Params params {};
		params.customizationOwner = customizationOwner;
		params.Outfit = Outfit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.ApplyPlayerCustomization
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      customizationOwner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPawnCustomizationManager::ApplyPlayerCustomization(class AActor* customizationOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.ApplyPlayerCustomization");
		
		URBPawnCustomizationManager_ApplyPlayerCustomization_Params params {};
		params.customizationOwner = customizationOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPawnCustomizationManager.AddExtraCustomizationMeshesForSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      baseSlotSkeletalCompoment                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class USkeletalMesh*>                       extraMeshes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EPlayerCustomizationSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class USkeletalMeshComponent*>              outNewComponents                                           (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBPawnCustomizationManager::AddExtraCustomizationMeshesForSlot(class USkeletalMeshComponent* baseSlotSkeletalCompoment, TArray<class USkeletalMesh*> extraMeshes, EPlayerCustomizationSlot Slot, TArray<class USkeletalMeshComponent*>* outNewComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPawnCustomizationManager.AddExtraCustomizationMeshesForSlot");
		
		URBPawnCustomizationManager_AddExtraCustomizationMeshesForSlot_Params params {};
		params.baseSlotSkeletalCompoment = baseSlotSkeletalCompoment;
		params.extraMeshes = extraMeshes;
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outNewComponents != nullptr)
			*outNewComponents = params.outNewComponents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPawnCustomizationManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPawnCustomizationManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPawnCustomizationManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPharmaSkill.OnRep_PawnInRadiusInfos
	 * 		Flags  -> ()
	 */
	void ARBPharmaSkill::OnRep_PawnInRadiusInfos()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPharmaSkill.OnRep_PawnInRadiusInfos");
		
		ARBPharmaSkill_OnRep_PawnInRadiusInfos_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPharmaSkill.Event_OnActiveQuietStop
	 * 		Flags  -> ()
	 */
	void ARBPharmaSkill::Event_OnActiveQuietStop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPharmaSkill.Event_OnActiveQuietStop");
		
		ARBPharmaSkill_Event_OnActiveQuietStop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPharmaSkill.Event_OnActiveQuietStart
	 * 		Flags  -> ()
	 */
	void ARBPharmaSkill::Event_OnActiveQuietStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPharmaSkill.Event_OnActiveQuietStart");
		
		ARBPharmaSkill_Event_OnActiveQuietStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPharmaSkill.Event_OnActiveOnPawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPharmaSkill::Event_OnActiveOnPawn(class ARBPawn* Pawn, bool bActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPharmaSkill.Event_OnActiveOnPawn");
		
		ARBPharmaSkill_Event_OnActiveOnPawn_Params params {};
		params.Pawn = Pawn;
		params.bActive = bActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPharmaSkill.Event_OnActiveLoudStop
	 * 		Flags  -> ()
	 */
	void ARBPharmaSkill::Event_OnActiveLoudStop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPharmaSkill.Event_OnActiveLoudStop");
		
		ARBPharmaSkill_Event_OnActiveLoudStop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPharmaSkill.Event_OnActiveLoudStart
	 * 		Flags  -> ()
	 */
	void ARBPharmaSkill::Event_OnActiveLoudStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPharmaSkill.Event_OnActiveLoudStart");
		
		ARBPharmaSkill_Event_OnActiveLoudStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPharmaSkill.BP_GetSkillRadius
	 * 		Flags  -> ()
	 */
	float ARBPharmaSkill::BP_GetSkillRadius()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPharmaSkill.BP_GetSkillRadius");
		
		ARBPharmaSkill_BP_GetSkillRadius_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPharmaSkill.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPharmaSkill::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPharmaSkill");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPhysicalMaterial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPhysicalMaterial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPhysicalMaterial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPhysicsVolume.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabledValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPhysicsVolume::BP_SetEnabled(bool bEnabledValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPhysicsVolume.BP_SetEnabled");
		
		ARBPhysicsVolume_BP_SetEnabled_Params params {};
		params.bEnabledValue = bEnabledValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPhysicsVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPhysicsVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPhysicsVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickupSearchObjectiveCoordinator.OnRep_PickupObjectives
	 * 		Flags  -> ()
	 */
	void ARBPickupSearchObjectiveCoordinator::OnRep_PickupObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickupSearchObjectiveCoordinator.OnRep_PickupObjectives");
		
		ARBPickupSearchObjectiveCoordinator_OnRep_PickupObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickupSearchObjectiveCoordinator.OnPlayerRevived_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   instigatorActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   subjectActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickupSearchObjectiveCoordinator::OnPlayerRevived_Server(class ARBPlayer* instigatorActor, class ARBPlayer* subjectActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickupSearchObjectiveCoordinator.OnPlayerRevived_Server");
		
		ARBPickupSearchObjectiveCoordinator_OnPlayerRevived_Server_Params params {};
		params.instigatorActor = instigatorActor;
		params.subjectActor = subjectActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickupSearchObjectiveCoordinator.OnPlayerPickedUpItem_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPickup*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickupSearchObjectiveCoordinator::OnPlayerPickedUpItem_Server(class ARBPlayer* Player, class ARBPickup* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickupSearchObjectiveCoordinator.OnPlayerPickedUpItem_Server");
		
		ARBPickupSearchObjectiveCoordinator_OnPlayerPickedUpItem_Server_Params params {};
		params.Player = Player;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickupSearchObjectiveCoordinator.OnPlayerDisconnect_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickupSearchObjectiveCoordinator::OnPlayerDisconnect_Server(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickupSearchObjectiveCoordinator.OnPlayerDisconnect_Server");
		
		ARBPickupSearchObjectiveCoordinator_OnPlayerDisconnect_Server_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickupSearchObjectiveCoordinator.OnPawnRespawned_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickupSearchObjectiveCoordinator::OnPawnRespawned_Server(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickupSearchObjectiveCoordinator.OnPawnRespawned_Server");
		
		ARBPickupSearchObjectiveCoordinator_OnPawnRespawned_Server_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPickupSearchObjectiveCoordinator.OnPawnKilled_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     instigatorActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Subject                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPickupSearchObjectiveCoordinator::OnPawnKilled_Server(class ARBPawn* instigatorActor, class ARBPawn* Subject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPickupSearchObjectiveCoordinator.OnPawnKilled_Server");
		
		ARBPickupSearchObjectiveCoordinator_OnPawnKilled_Server_Params params {};
		params.instigatorActor = instigatorActor;
		params.Subject = Subject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPickupSearchObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPickupSearchObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPickupSearchObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPingableObject.GetPlayerPingWorldLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   pingOwner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBPingableObject::GetPlayerPingWorldLocation(class ARBPlayer* pingOwner, const struct FHitResult& HitResult, struct FVector* OutLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPingableObject.GetPlayerPingWorldLocation");
		
		URBPingableObject_GetPlayerPingWorldLocation_Params params {};
		params.pingOwner = pingOwner;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPingableObject.GetPlayerPingData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   pingOwner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FPlayerPingData                             outData                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool URBPingableObject::GetPlayerPingData(class ARBPlayer* pingOwner, const struct FHitResult& HitResult, struct FPlayerPingData* outData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPingableObject.GetPlayerPingData");
		
		URBPingableObject_GetPlayerPingData_Params params {};
		params.pingOwner = pingOwner;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outData != nullptr)
			*outData = params.outData;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPingableObject.GetPingItemName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        outName                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool URBPingableObject::GetPingItemName(class FText* outName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPingableObject.GetPingItemName");
		
		URBPingableObject_GetPingItemName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outName != nullptr)
			*outName = params.outName;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPingableObject.GetPingEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   pingOwner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               outIsEnabled                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBPingableObject::GetPingEnabled(class ARBPlayer* pingOwner, const struct FHitResult& HitResult, bool* outIsEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPingableObject.GetPingEnabled");
		
		URBPingableObject_GetPingEnabled_Params params {};
		params.pingOwner = pingOwner;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outIsEnabled != nullptr)
			*outIsEnabled = params.outIsEnabled;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPingableObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPingableObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPingableObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPingComponent.IsEnabled
	 * 		Flags  -> ()
	 */
	bool URBPingComponent::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPingComponent.IsEnabled");
		
		URBPingComponent_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPingComponent.GetPlayerPingData
	 * 		Flags  -> ()
	 */
	struct FPlayerPingData URBPingComponent::GetPlayerPingData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPingComponent.GetPlayerPingData");
		
		URBPingComponent_GetPlayerPingData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPingComponent.GetPingWorldLocation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	struct FVector URBPingComponent::GetPingWorldLocation(const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPingComponent.GetPingWorldLocation");
		
		URBPingComponent_GetPingWorldLocation_Params params {};
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPingComponent.GetPingItemName
	 * 		Flags  -> ()
	 */
	class FText URBPingComponent::GetPingItemName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPingComponent.GetPingItemName");
		
		URBPingComponent_GetPingItemName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPipeModule.DestroyConnectors
	 * 		Flags  -> ()
	 */
	void ARBPipeModule::DestroyConnectors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPipeModule.DestroyConnectors");
		
		ARBPipeModule_DestroyConnectors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPipeModule.AddStaticMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTransform                                  Transforms                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UStaticMesh*                                 StaticMesh                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UStaticMeshComponent* ARBPipeModule::AddStaticMesh(const struct FTransform& Transforms, class UStaticMesh* StaticMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPipeModule.AddStaticMesh");
		
		ARBPipeModule_AddStaticMesh_Params params {};
		params.Transforms = Transforms;
		params.StaticMesh = StaticMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPipeModule.AddSplineMeshComponent
	 * 		Flags  -> ()
	 */
	class USplineMeshComponent* ARBPipeModule::AddSplineMeshComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPipeModule.AddSplineMeshComponent");
		
		ARBPipeModule_AddSplineMeshComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPipeModule.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPipeModule::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPipeModule");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.UnderwaterStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsUnderwater                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::UnderwaterStateChanged(bool bIsUnderwater)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.UnderwaterStateChanged");
		
		ARBPlayer_UnderwaterStateChanged_Params params {};
		params.bIsUnderwater = bIsUnderwater;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.TogglePlayerDepthTest
	 * 		Flags  -> ()
	 */
	void ARBPlayer::TogglePlayerDepthTest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.TogglePlayerDepthTest");
		
		ARBPlayer_TogglePlayerDepthTest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.StartCustomAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      customActionAnimBP                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::StartCustomAction(class UClass* customActionAnimBP)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.StartCustomAction");
		
		ARBPlayer_StartCustomAction_Params params {};
		params.customActionAnimBP = customActionAnimBP;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.ShowItemHeld
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   pickup                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::ShowItemHeld(class ARBPickup* pickup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.ShowItemHeld");
		
		ARBPlayer_ShowItemHeld_Params params {};
		params.pickup = pickup;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.SetLastConsumedBatteryType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemType                                          batteryType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::SetLastConsumedBatteryType(EItemType batteryType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.SetLastConsumedBatteryType");
		
		ARBPlayer_SetLastConsumedBatteryType_Params params {};
		params.batteryType = batteryType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_UpdateMeshOffsets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     translationOffset                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    RotationOffset                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_UpdateMeshOffsets(const struct FVector& translationOffset, const struct FRotator& RotationOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_UpdateMeshOffsets");
		
		ARBPlayer_Server_UpdateMeshOffsets_Params params {};
		params.translationOffset = translationOffset;
		params.RotationOffset = RotationOffset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_UpdateChessPanelMouseCursorPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector2D                                   newPosition                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_UpdateChessPanelMouseCursorPosition(const struct FVector2D& newPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_UpdateChessPanelMouseCursorPosition");
		
		ARBPlayer_Server_UpdateChessPanelMouseCursorPosition_Params params {};
		params.newPosition = newPosition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_TrySwitchToItemTutorial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            SpecialMoveIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESpecialMove                                       specialMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_TrySwitchToItemTutorial(int32_t SpecialMoveIndex, ESpecialMove specialMove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_TrySwitchToItemTutorial");
		
		ARBPlayer_Server_TrySwitchToItemTutorial_Params params {};
		params.SpecialMoveIndex = SpecialMoveIndex;
		params.specialMove = specialMove;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_TryStartTrading
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_TryStartTrading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_TryStartTrading");
		
		ARBPlayer_Server_TryStartTrading_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_TryDropItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_TryDropItem(class ARBPickup* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_TryDropItem");
		
		ARBPlayer_Server_TryDropItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_TalkWheel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETalkWheelAction                                   action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     currentEyeLocation                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     currentEyeForward                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_TalkWheel(ETalkWheelAction action, const struct FVector& currentEyeLocation, const struct FVector& currentEyeForward)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_TalkWheel");
		
		ARBPlayer_Server_TalkWheel_Params params {};
		params.action = action;
		params.currentEyeLocation = currentEyeLocation;
		params.currentEyeForward = currentEyeForward;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_StopTrading
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_StopTrading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_StopTrading");
		
		ARBPlayer_Server_StopTrading_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_StopInteractingWithPanelChild
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_StopInteractingWithPanelChild()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_StopInteractingWithPanelChild");
		
		ARBPlayer_Server_StopInteractingWithPanelChild_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_SetWantsNVActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_SetWantsNVActive(bool bActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_SetWantsNVActive");
		
		ARBPlayer_Server_SetWantsNVActive_Params params {};
		params.bActive = bActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_SetSwitchPanelPartDesiredStatusValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBSwitchPanelPart*                          panelPart                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_SetSwitchPanelPartDesiredStatusValue(class ARBSwitchPanelPart* panelPart, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_SetSwitchPanelPartDesiredStatusValue");
		
		ARBPlayer_Server_SetSwitchPanelPartDesiredStatusValue_Params params {};
		params.panelPart = panelPart;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_SetSaveEquippedItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_SetSaveEquippedItem(class ARBPickup* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_SetSaveEquippedItem");
		
		ARBPlayer_Server_SetSaveEquippedItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_SetPlayerInputAtCoord
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               inputDown                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FIntPoint                                   coord                                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBChessPieceComponent*                      piece                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_SetPlayerInputAtCoord(bool inputDown, const struct FIntPoint& coord, class URBChessPieceComponent* piece)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_SetPlayerInputAtCoord");
		
		ARBPlayer_Server_SetPlayerInputAtCoord_Params params {};
		params.inputDown = inputDown;
		params.coord = coord;
		params.piece = piece;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_SetObjectiveActorSeen
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBObjectiveActorComponent*                  objectiveActorComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_SetObjectiveActorSeen(class URBObjectiveActorComponent* objectiveActorComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_SetObjectiveActorSeen");
		
		ARBPlayer_Server_SetObjectiveActorSeen_Params params {};
		params.objectiveActorComponent = objectiveActorComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_SetInteractiblePanelChildValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractibleComponent*                    panelChild                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_SetInteractiblePanelChildValue(class URBInteractibleComponent* panelChild, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_SetInteractiblePanelChildValue");
		
		ARBPlayer_Server_SetInteractiblePanelChildValue_Params params {};
		params.panelChild = panelChild;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_SetGodMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_SetGodMode(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_SetGodMode");
		
		ARBPlayer_Server_SetGodMode_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_SetEquippedInventoryItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_SetEquippedInventoryItem(class ARBPickup* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_SetEquippedInventoryItem");
		
		ARBPlayer_Server_SetEquippedInventoryItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_ScheduleHelperCollisionEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBEvalCorridorHelperComponent*              corridorHelper                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              executionServerTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_ScheduleHelperCollisionEnabled(class URBEvalCorridorHelperComponent* corridorHelper, bool bEnable, float executionServerTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_ScheduleHelperCollisionEnabled");
		
		ARBPlayer_Server_ScheduleHelperCollisionEnabled_Params params {};
		params.corridorHelper = corridorHelper;
		params.bEnable = bEnable;
		params.executionServerTime = executionServerTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_RequestExitSASChair
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_RequestExitSASChair()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_RequestExitSASChair");
		
		ARBPlayer_Server_RequestExitSASChair_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_RemovePing
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerPingType                                    pingType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_RemovePing(EPlayerPingType pingType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_RemovePing");
		
		ARBPlayer_Server_RemovePing_Params params {};
		params.pingType = pingType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_RemoveAllPings
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_RemoveAllPings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_RemoveAllPings");
		
		ARBPlayer_Server_RemoveAllPings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_OnTortureInputPressed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBTorturePanelComponent*                    panelCmp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Timestamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            inputPressed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_OnTortureInputPressed(class URBTorturePanelComponent* panelCmp, float Timestamp, int32_t inputPressed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_OnTortureInputPressed");
		
		ARBPlayer_Server_OnTortureInputPressed_Params params {};
		params.panelCmp = panelCmp;
		params.Timestamp = Timestamp;
		params.inputPressed = inputPressed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_NotifyPanelUserReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_NotifyPanelUserReady(class URBInteractiblePanelComponent* panel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_NotifyPanelUserReady");
		
		ARBPlayer_Server_NotifyPanelUserReady_Params params {};
		params.panel = panel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_ExitCustomInteractable
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_ExitCustomInteractable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_ExitCustomInteractable");
		
		ARBPlayer_Server_ExitCustomInteractable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_DebugSimultaneousJumpForward
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_DebugSimultaneousJumpForward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_DebugSimultaneousJumpForward");
		
		ARBPlayer_Server_DebugSimultaneousJumpForward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_DebugSimultaneousInteraction
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_DebugSimultaneousInteraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_DebugSimultaneousInteraction");
		
		ARBPlayer_Server_DebugSimultaneousInteraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_DebugMovementAlwaysDesync
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_DebugMovementAlwaysDesync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_DebugMovementAlwaysDesync");
		
		ARBPlayer_Server_DebugMovementAlwaysDesync_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_DebugKillSelf
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_DebugKillSelf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_DebugKillSelf");
		
		ARBPlayer_Server_DebugKillSelf_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_DebugInteractionDesync
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_DebugInteractionDesync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_DebugInteractionDesync");
		
		ARBPlayer_Server_DebugInteractionDesync_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_DebugHitReaction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerHitReactionType                             hitReactionType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              relativeAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_DebugHitReaction(EPlayerHitReactionType hitReactionType, float relativeAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_DebugHitReaction");
		
		ARBPlayer_Server_DebugHitReaction_Params params {};
		params.hitReactionType = hitReactionType;
		params.relativeAngle = relativeAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_DebugDownSelf
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_DebugDownSelf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_DebugDownSelf");
		
		ARBPlayer_Server_DebugDownSelf_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_DebugChase
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_DebugChase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_DebugChase");
		
		ARBPlayer_Server_DebugChase_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_DeactivateActiveSkill
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_DeactivateActiveSkill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_DeactivateActiveSkill");
		
		ARBPlayer_Server_DeactivateActiveSkill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_CheatStunSelf
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_CheatStunSelf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_CheatStunSelf");
		
		ARBPlayer_Server_CheatStunSelf_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_CheatHurtSelf
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              damageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHitReaction                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            hurtType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_CheatHurtSelf(float damageAmount, bool bHitReaction, int32_t hurtType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_CheatHurtSelf");
		
		ARBPlayer_Server_CheatHurtSelf_Params params {};
		params.damageAmount = damageAmount;
		params.bHitReaction = bHitReaction;
		params.hurtType = hurtType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_Cheat_ToggleSilentForBots
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_Cheat_ToggleSilentForBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_Cheat_ToggleSilentForBots");
		
		ARBPlayer_Server_Cheat_ToggleSilentForBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_Cheat_ToggleInvisibleToBots
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_Cheat_ToggleInvisibleToBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_Cheat_ToggleInvisibleToBots");
		
		ARBPlayer_Server_Cheat_ToggleInvisibleToBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_Cheat_ToggleConditionalDebugActor
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_Cheat_ToggleConditionalDebugActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_Cheat_ToggleConditionalDebugActor");
		
		ARBPlayer_Server_Cheat_ToggleConditionalDebugActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_Cheat_DumpDebugInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_Cheat_DumpDebugInfo(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_Cheat_DumpDebugInfo");
		
		ARBPlayer_Server_Cheat_DumpDebugInfo_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_Cheat_DebugPuzzleRoom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPuzzleRoomComponent*                      puzzleRoom                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDebug                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_Cheat_DebugPuzzleRoom(class URBPuzzleRoomComponent* puzzleRoom, bool bDebug)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_Cheat_DebugPuzzleRoom");
		
		ARBPlayer_Server_Cheat_DebugPuzzleRoom_Params params {};
		params.puzzleRoom = puzzleRoom;
		params.bDebug = bDebug;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_Cheat_DebugCoopMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bExceptLocal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_Cheat_DebugCoopMove(bool bExceptLocal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_Cheat_DebugCoopMove");
		
		ARBPlayer_Server_Cheat_DebugCoopMove_Params params {};
		params.bExceptLocal = bExceptLocal;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_ChallengeArmWrestlingPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   challengedPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Server_ChallengeArmWrestlingPlayer(class ARBPlayer* challengedPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_ChallengeArmWrestlingPlayer");
		
		ARBPlayer_Server_ChallengeArmWrestlingPlayer_Params params {};
		params.challengedPlayer = challengedPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Server_ActivateActiveSkill
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Server_ActivateActiveSkill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Server_ActivateActiveSkill");
		
		ARBPlayer_Server_ActivateActiveSkill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.RBPlayerState
	 * 		Flags  -> ()
	 */
	class ARBPlayerState* ARBPlayer::RBPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.RBPlayerState");
		
		ARBPlayer_RBPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnWantsNVActiveChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnWantsNVActiveChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnWantsNVActiveChangedCallback");
		
		ARBPlayer_OnWantsNVActiveChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnTradeItemChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnTradeItemChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnTradeItemChangedCallback");
		
		ARBPlayer_OnTradeItemChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnShadowMeshCreated
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnShadowMeshCreated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnShadowMeshCreated");
		
		ARBPlayer_OnShadowMeshCreated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnSavedEquippedItemChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnSavedEquippedItemChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnSavedEquippedItemChangedCallback");
		
		ARBPlayer_OnSavedEquippedItemChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_WantsNVActive
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_WantsNVActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_WantsNVActive");
		
		ARBPlayer_OnRep_WantsNVActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_UINoiseMeterStrength
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_UINoiseMeterStrength()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_UINoiseMeterStrength");
		
		ARBPlayer_OnRep_UINoiseMeterStrength_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_TradeItem
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_TradeItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_TradeItem");
		
		ARBPlayer_OnRep_TradeItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_TemporaryHealth
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_TemporaryHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_TemporaryHealth");
		
		ARBPlayer_OnRep_TemporaryHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_TemporaryDamage
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_TemporaryDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_TemporaryDamage");
		
		ARBPlayer_OnRep_TemporaryDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_StruggleRatio_Helper
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              lastStruggleRatio_Helper                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnRep_StruggleRatio_Helper(float lastStruggleRatio_Helper)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_StruggleRatio_Helper");
		
		ARBPlayer_OnRep_StruggleRatio_Helper_Params params {};
		params.lastStruggleRatio_Helper = lastStruggleRatio_Helper;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_StruggleAction_Victim_Timestamp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              lastTimestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnRep_StruggleAction_Victim_Timestamp(float lastTimestamp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_StruggleAction_Victim_Timestamp");
		
		ARBPlayer_OnRep_StruggleAction_Victim_Timestamp_Params params {};
		params.lastTimestamp = lastTimestamp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_StruggleAction_Helper_Timestamp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              lastTimestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnRep_StruggleAction_Helper_Timestamp(float lastTimestamp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_StruggleAction_Helper_Timestamp");
		
		ARBPlayer_OnRep_StruggleAction_Helper_Timestamp_Params params {};
		params.lastTimestamp = lastTimestamp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_Stamina
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              oldStamina                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnRep_Stamina(float oldStamina)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_Stamina");
		
		ARBPlayer_OnRep_Stamina_Params params {};
		params.oldStamina = oldStamina;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_SlideDownVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBSlideDownVolume*                          slideDownVolume                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnRep_SlideDownVolume(class ARBSlideDownVolume* slideDownVolume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_SlideDownVolume");
		
		ARBPlayer_OnRep_SlideDownVolume_Params params {};
		params.slideDownVolume = slideDownVolume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_SavedEquippedItem
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_SavedEquippedItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_SavedEquippedItem");
		
		ARBPlayer_OnRep_SavedEquippedItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_PlayerSpecificUpgrades
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_PlayerSpecificUpgrades()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_PlayerSpecificUpgrades");
		
		ARBPlayer_OnRep_PlayerSpecificUpgrades_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_PlayerCameraComponent
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_PlayerCameraComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_PlayerCameraComponent");
		
		ARBPlayer_OnRep_PlayerCameraComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_NVLensBrokenFXValue
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_NVLensBrokenFXValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_NVLensBrokenFXValue");
		
		ARBPlayer_OnRep_NVLensBrokenFXValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_NVBattery
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_NVBattery()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_NVBattery");
		
		ARBPlayer_OnRep_NVBattery_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_ItemHeld
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_ItemHeld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_ItemHeld");
		
		ARBPlayer_OnRep_ItemHeld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_IsNVActive
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_IsNVActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_IsNVActive");
		
		ARBPlayer_OnRep_IsNVActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_IsAimingThrowable
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_IsAimingThrowable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_IsAimingThrowable");
		
		ARBPlayer_OnRep_IsAimingThrowable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_Inventory
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_Inventory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_Inventory");
		
		ARBPlayer_OnRep_Inventory_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_IgnorePlayerToPlayerCollisions
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_IgnorePlayerToPlayerCollisions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_IgnorePlayerToPlayerCollisions");
		
		ARBPlayer_OnRep_IgnorePlayerToPlayerCollisions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_HoldConsumeActionItem
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_HoldConsumeActionItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_HoldConsumeActionItem");
		
		ARBPlayer_OnRep_HoldConsumeActionItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_EquippedInventory
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_EquippedInventory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_EquippedInventory");
		
		ARBPlayer_OnRep_EquippedInventory_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_EffectivePsychosisMeter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnRep_EffectivePsychosisMeter(int32_t OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_EffectivePsychosisMeter");
		
		ARBPlayer_OnRep_EffectivePsychosisMeter_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_DamageBoostPawnTimestamps
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<float>                                      oldDamageBoostPawnTimestamps                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnRep_DamageBoostPawnTimestamps(TArray<float> oldDamageBoostPawnTimestamps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_DamageBoostPawnTimestamps");
		
		ARBPlayer_OnRep_DamageBoostPawnTimestamps_Params params {};
		params.oldDamageBoostPawnTimestamps = oldDamageBoostPawnTimestamps;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_CurrentPsychosisBracket
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            oldPsychosisBracket                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnRep_CurrentPsychosisBracket(int32_t oldPsychosisBracket)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_CurrentPsychosisBracket");
		
		ARBPlayer_OnRep_CurrentPsychosisBracket_Params params {};
		params.oldPsychosisBracket = oldPsychosisBracket;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_CurrentLargePickup
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_CurrentLargePickup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_CurrentLargePickup");
		
		ARBPlayer_OnRep_CurrentLargePickup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_CurrentEquippedItem
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_CurrentEquippedItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_CurrentEquippedItem");
		
		ARBPlayer_OnRep_CurrentEquippedItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_CoopTrapDart
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBTrapDart*                                 lastTrapDart                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnRep_CoopTrapDart(class ARBTrapDart* lastTrapDart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_CoopTrapDart");
		
		ARBPlayer_OnRep_CoopTrapDart_Params params {};
		params.lastTrapDart = lastTrapDart;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_ConsumeItemPreviousInteractable
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_ConsumeItemPreviousInteractable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_ConsumeItemPreviousInteractable");
		
		ARBPlayer_OnRep_ConsumeItemPreviousInteractable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_ChaseNPCs
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_ChaseNPCs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_ChaseNPCs");
		
		ARBPlayer_OnRep_ChaseNPCs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_AutoHealthRegenInProgress
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_AutoHealthRegenInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_AutoHealthRegenInProgress");
		
		ARBPlayer_OnRep_AutoHealthRegenInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_ActiveSkillActor
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_ActiveSkillActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_ActiveSkillActor");
		
		ARBPlayer_OnRep_ActiveSkillActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_ActivePuzzleRoom
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_ActivePuzzleRoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_ActivePuzzleRoom");
		
		ARBPlayer_OnRep_ActivePuzzleRoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnRep_ActiveEffectTrackingDataEntries
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnRep_ActiveEffectTrackingDataEntries()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnRep_ActiveEffectTrackingDataEntries");
		
		ARBPlayer_OnRep_ActiveEffectTrackingDataEntries_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnPlayerUpgradesChanged
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnPlayerUpgradesChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnPlayerUpgradesChanged");
		
		ARBPlayer_OnPlayerUpgradesChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBPlayer.OnPlayerCustomizationChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   RBPlayer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnPlayerCustomizationChanged__DelegateSignature(class ARBPlayer* RBPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBPlayer.OnPlayerCustomizationChanged__DelegateSignature");
		
		ARBPlayer_OnPlayerCustomizationChanged__DelegateSignature_Params params {};
		params.RBPlayer = RBPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnMaxStaminaChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnMaxStaminaChanged(float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnMaxStaminaChanged");
		
		ARBPlayer_OnMaxStaminaChanged_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnMaxNVBatteryChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnMaxNVBatteryChanged(float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnMaxNVBatteryChanged");
		
		ARBPlayer_OnMaxNVBatteryChanged_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnMaxHealthChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnMaxHealthChanged(float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnMaxHealthChanged");
		
		ARBPlayer_OnMaxHealthChanged_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnItemHeldChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnItemHeldChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnItemHeldChangedCallback");
		
		ARBPlayer_OnItemHeldChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnIsNVActiveChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnIsNVActiveChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnIsNVActiveChangedCallback");
		
		ARBPlayer_OnIsNVActiveChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnIsAimingThrowableChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnIsAimingThrowableChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnIsAimingThrowableChangedCallback");
		
		ARBPlayer_OnIsAimingThrowableChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnInventorySlotCountChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnInventorySlotCountChanged(float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnInventorySlotCountChanged");
		
		ARBPlayer_OnInventorySlotCountChanged_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnHoldConsumeActionItemChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnHoldConsumeActionItemChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnHoldConsumeActionItemChangedCallback");
		
		ARBPlayer_OnHoldConsumeActionItemChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnEffectiveNumberOfPlayersChanged
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnEffectiveNumberOfPlayersChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnEffectiveNumberOfPlayersChanged");
		
		ARBPlayer_OnEffectiveNumberOfPlayersChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnCurrentLargePickupChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnCurrentLargePickupChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnCurrentLargePickupChangedCallback");
		
		ARBPlayer_OnCurrentLargePickupChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnCurrentEquippedItemChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnCurrentEquippedItemChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnCurrentEquippedItemChangedCallback");
		
		ARBPlayer_OnCurrentEquippedItemChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnConsumeItemPreviousInteractableChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::OnConsumeItemPreviousInteractableChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnConsumeItemPreviousInteractableChangedCallback");
		
		ARBPlayer_OnConsumeItemPreviousInteractableChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.OnAffectedByPsychosisGas_BP
	 * 		Flags  -> ()
	 */
	void ARBPlayer::OnAffectedByPsychosisGas_BP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.OnAffectedByPsychosisGas_BP");
		
		ARBPlayer_OnAffectedByPsychosisGas_BP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Muticast_OnPsychosisSpookActivated
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Muticast_OnPsychosisSpookActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Muticast_OnPsychosisSpookActivated");
		
		ARBPlayer_Muticast_OnPsychosisSpookActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_TriggerTraversalBlendToLocomotionMode
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Multicast_TriggerTraversalBlendToLocomotionMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_TriggerTraversalBlendToLocomotionMode");
		
		ARBPlayer_Multicast_TriggerTraversalBlendToLocomotionMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_ThrowWeapon
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Multicast_ThrowWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_ThrowWeapon");
		
		ARBPlayer_Multicast_ThrowWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_TeleportPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              teleportPawnTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              teleportServerTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NewLoc                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    newRot                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsInstant                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAdjustLocForFeets                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterruptAction                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_TeleportPlayer(float teleportPawnTime, float teleportServerTime, const struct FVector& NewLoc, const struct FRotator& newRot, bool bIsInstant, bool bAdjustLocForFeets, bool bInterruptAction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_TeleportPlayer");
		
		ARBPlayer_Multicast_TeleportPlayer_Params params {};
		params.teleportPawnTime = teleportPawnTime;
		params.teleportServerTime = teleportServerTime;
		params.NewLoc = NewLoc;
		params.newRot = newRot;
		params.bIsInstant = bIsInstant;
		params.bAdjustLocForFeets = bAdjustLocForFeets;
		params.bInterruptAction = bInterruptAction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_TalkWheel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ETalkWheelAction                                   action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     currentEyeLocation                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     currentEyeForward                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_TalkWheel(ETalkWheelAction action, const struct FVector& currentEyeLocation, const struct FVector& currentEyeForward)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_TalkWheel");
		
		ARBPlayer_Multicast_TalkWheel_Params params {};
		params.action = action;
		params.currentEyeLocation = currentEyeLocation;
		params.currentEyeForward = currentEyeForward;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_StopHallucination
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHallucinationType                                 halluType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EHallucinationFadeOutType                          fadeOutType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_StopHallucination(EHallucinationType halluType, EHallucinationFadeOutType fadeOutType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_StopHallucination");
		
		ARBPlayer_Multicast_StopHallucination_Params params {};
		params.halluType = halluType;
		params.fadeOutType = fadeOutType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_StopCameraShake
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInstantly                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     shakeOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreOwnerCondition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_StopCameraShake(bool bInstantly, class UObject* shakeOwner, bool bIgnoreOwnerCondition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_StopCameraShake");
		
		ARBPlayer_Multicast_StopCameraShake_Params params {};
		params.bInstantly = bInstantly;
		params.shakeOwner = shakeOwner;
		params.bIgnoreOwnerCondition = bIgnoreOwnerCondition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_StopAdrenaline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              stopPawnTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_StopAdrenaline(float stopPawnTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_StopAdrenaline");
		
		ARBPlayer_Multicast_StopAdrenaline_Params params {};
		params.stopPawnTime = stopPawnTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_StartVolumetricFogLightmapFade
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFadeIn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_StartVolumetricFogLightmapFade(bool bFadeIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_StartVolumetricFogLightmapFade");
		
		ARBPlayer_Multicast_StartVolumetricFogLightmapFade_Params params {};
		params.bFadeIn = bFadeIn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_StartHallucination
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHallucinationData                          halluData                                                  (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_StartHallucination(const struct FHallucinationData& halluData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_StartHallucination");
		
		ARBPlayer_Multicast_StartHallucination_Params params {};
		params.halluData = halluData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_StartDoorOperation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBDoor*                                     door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_StartDoorOperation(class ARBDoor* door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_StartDoorOperation");
		
		ARBPlayer_Multicast_StartDoorOperation_Params params {};
		params.door = door;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_SpecialAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledSpecialAnimData                   SpecialAnimData                                            (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_SpecialAnimation(const struct FScheduledSpecialAnimData& SpecialAnimData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_SpecialAnimation");
		
		ARBPlayer_Multicast_SpecialAnimation_Params params {};
		params.SpecialAnimData = SpecialAnimData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_ShakeOffPushable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     pushedDir                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_ShakeOffPushable(const struct FVector& pushedDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_ShakeOffPushable");
		
		ARBPlayer_Multicast_ShakeOffPushable_Params params {};
		params.pushedDir = pushedDir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_SetTraversalData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FTraversalMoveData                          moveData                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_SetTraversalData(const struct FTraversalMoveData& moveData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_SetTraversalData");
		
		ARBPlayer_Multicast_SetTraversalData_Params params {};
		params.moveData = moveData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_SetSpecialMoveCameraLimits
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              minYaw                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              maxYaw                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              minPitch                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              maxPitch                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_SetSpecialMoveCameraLimits(float minYaw, float maxYaw, float minPitch, float maxPitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_SetSpecialMoveCameraLimits");
		
		ARBPlayer_Multicast_SetSpecialMoveCameraLimits_Params params {};
		params.minYaw = minYaw;
		params.maxYaw = maxYaw;
		params.minPitch = minPitch;
		params.maxPitch = maxPitch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_SetPainKillerEffectsDuration
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_SetPainKillerEffectsDuration(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_SetPainKillerEffectsDuration");
		
		ARBPlayer_Multicast_SetPainKillerEffectsDuration_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_SetGodMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_SetGodMode(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_SetGodMode");
		
		ARBPlayer_Multicast_SetGodMode_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_SetCoopMoveOfferingState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECoopMoveOfferState                                coopMoveOfferingState                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBLedgeMarker*                              LedgeMarker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   SpecificPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECoopMoveType                                      coopMoveOfferingType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBasicDirection                                    BasicDirection                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_SetCoopMoveOfferingState(ECoopMoveOfferState coopMoveOfferingState, class ARBLedgeMarker* LedgeMarker, class ARBPlayer* SpecificPlayer, ECoopMoveType coopMoveOfferingType, EBasicDirection BasicDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_SetCoopMoveOfferingState");
		
		ARBPlayer_Multicast_SetCoopMoveOfferingState_Params params {};
		params.coopMoveOfferingState = coopMoveOfferingState;
		params.LedgeMarker = LedgeMarker;
		params.SpecificPlayer = SpecificPlayer;
		params.coopMoveOfferingType = coopMoveOfferingType;
		params.BasicDirection = BasicDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_ScheduleStartCoopBash
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              PawnTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_ScheduleStartCoopBash(float PawnTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_ScheduleStartCoopBash");
		
		ARBPlayer_Multicast_ScheduleStartCoopBash_Params params {};
		params.PawnTime = PawnTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_ScheduleCoopMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCoopMoveData                               CoopMoveData                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FScheduledSpecialMoveData                   ScheduledSpecialMoveData                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_ScheduleCoopMove(const struct FCoopMoveData& CoopMoveData, const struct FScheduledSpecialMoveData& ScheduledSpecialMoveData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_ScheduleCoopMove");
		
		ARBPlayer_Multicast_ScheduleCoopMove_Params params {};
		params.CoopMoveData = CoopMoveData;
		params.ScheduledSpecialMoveData = ScheduledSpecialMoveData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_RemovePing
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerPingType                                    pingType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_RemovePing(EPlayerPingType pingType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_RemovePing");
		
		ARBPlayer_Multicast_RemovePing_Params params {};
		params.pingType = pingType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_RemoveAllPings
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Multicast_RemoveAllPings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_RemoveAllPings");
		
		ARBPlayer_Multicast_RemoveAllPings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_QuickTest
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     testLocation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_QuickTest(const struct FVector& testLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_QuickTest");
		
		ARBPlayer_Multicast_QuickTest_Params params {};
		params.testLocation = testLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_PutDownLargeObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLargePickup*                              largePickup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FQuat                                       Rotation                                                   (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bPredicted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_PutDownLargeObject(class ARBLargePickup* largePickup, const struct FVector& Location, const struct FQuat& Rotation, bool bPredicted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_PutDownLargeObject");
		
		ARBPlayer_Multicast_PutDownLargeObject_Params params {};
		params.largePickup = largePickup;
		params.Location = Location;
		params.Rotation = Rotation;
		params.bPredicted = bPredicted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_PlayPulledFromHidespot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPairedTwoPhaseAnimData                     animData                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ARBNPC*                                      Attacker                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBHidespotComponent*                        hidespot                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetPos                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetDir                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_PlayPulledFromHidespot(const struct FPairedTwoPhaseAnimData& animData, class ARBNPC* Attacker, class URBHidespotComponent* hidespot, const struct FVector& TargetPos, const struct FVector& TargetDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_PlayPulledFromHidespot");
		
		ARBPlayer_Multicast_PlayPulledFromHidespot_Params params {};
		params.animData = animData;
		params.Attacker = Attacker;
		params.hidespot = hidespot;
		params.TargetPos = TargetPos;
		params.TargetDir = TargetDir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_PlayGrabbed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPairedTwoPhaseAnimData                     animData                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class ARBNPC*                                      Attacker                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetPos                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetDir                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_PlayGrabbed(const struct FPairedTwoPhaseAnimData& animData, class ARBNPC* Attacker, const struct FVector& TargetPos, const struct FVector& TargetDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_PlayGrabbed");
		
		ARBPlayer_Multicast_PlayGrabbed_Params params {};
		params.animData = animData;
		params.Attacker = Attacker;
		params.TargetPos = TargetPos;
		params.TargetDir = TargetDir;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_PlayDamageDealtEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAttackStrike                               strike                                                     (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_PlayDamageDealtEffects(const struct FAttackStrike& strike)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_PlayDamageDealtEffects");
		
		ARBPlayer_Multicast_PlayDamageDealtEffects_Params params {};
		params.strike = strike;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_PickupLargeObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLargePickup*                              largePickup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Forward                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ELargeObjectPickupSubtype                          subtype                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_PickupLargeObject(class ARBLargePickup* largePickup, const struct FVector& Location, const struct FVector& Forward, ELargeObjectPickupSubtype subtype)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_PickupLargeObject");
		
		ARBPlayer_Multicast_PickupLargeObject_Params params {};
		params.largePickup = largePickup;
		params.Location = Location;
		params.Forward = Forward;
		params.subtype = subtype;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_PerformStandardFatality
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FStandardFatalityData                       fatalityData                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_PerformStandardFatality(const struct FStandardFatalityData& fatalityData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_PerformStandardFatality");
		
		ARBPlayer_Multicast_PerformStandardFatality_Params params {};
		params.fatalityData = fatalityData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_OnTrapRoomFailed
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Multicast_OnTrapRoomFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_OnTrapRoomFailed");
		
		ARBPlayer_Multicast_OnTrapRoomFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_OnKnockedDown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      knockDownInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_OnKnockedDown(class AActor* knockDownInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_OnKnockedDown");
		
		ARBPlayer_Multicast_OnKnockedDown_Params params {};
		params.knockDownInstigator = knockDownInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_OnContinuousPsychosisGained
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Multicast_OnContinuousPsychosisGained()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_OnContinuousPsychosisGained");
		
		ARBPlayer_Multicast_OnContinuousPsychosisGained_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_OnAffectedByGas
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Multicast_OnAffectedByGas()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_OnAffectedByGas");
		
		ARBPlayer_Multicast_OnAffectedByGas_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_InteractDynamicObstacle
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBDynamicObstacle*                          obstacle                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     charLocationRef                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     movementAcceleration                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_InteractDynamicObstacle(class ARBDynamicObstacle* obstacle, const struct FVector& charLocationRef, const struct FVector& movementAcceleration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_InteractDynamicObstacle");
		
		ARBPlayer_Multicast_InteractDynamicObstacle_Params params {};
		params.obstacle = obstacle;
		params.charLocationRef = charLocationRef;
		params.movementAcceleration = movementAcceleration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_HitReaction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlayerHitReactionParams                    hitReaction                                                (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bSchedule                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_HitReaction(const struct FPlayerHitReactionParams& hitReaction, bool bSchedule)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_HitReaction");
		
		ARBPlayer_Multicast_HitReaction_Params params {};
		params.hitReaction = hitReaction;
		params.bSchedule = bSchedule;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_GhostPawn
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bGhost                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     camLoc                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    camRot                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_GhostPawn(bool bGhost, const struct FVector& camLoc, const struct FRotator& camRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_GhostPawn");
		
		ARBPlayer_Multicast_GhostPawn_Params params {};
		params.bGhost = bGhost;
		params.camLoc = camLoc;
		params.camRot = camRot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_GetUpFromKnockedDown
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Multicast_GetUpFromKnockedDown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_GetUpFromKnockedDown");
		
		ARBPlayer_Multicast_GetUpFromKnockedDown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_GainCurrency
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECurrencyType                                      currencyType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_GainCurrency(ECurrencyType currencyType, int32_t amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_GainCurrency");
		
		ARBPlayer_Multicast_GainCurrency_Params params {};
		params.currencyType = currencyType;
		params.amount = amount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_FlagAsFakePlayer
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Multicast_FlagAsFakePlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_FlagAsFakePlayer");
		
		ARBPlayer_Multicast_FlagAsFakePlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_ExitGroundAndPound
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESpecialMove                                       playerSM                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDamageResultType                                  DamageResult                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               playerExitAnimSeq                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_ExitGroundAndPound(ESpecialMove playerSM, EDamageResultType DamageResult, class UAnimSequence* playerExitAnimSeq)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_ExitGroundAndPound");
		
		ARBPlayer_Multicast_ExitGroundAndPound_Params params {};
		params.playerSM = playerSM;
		params.DamageResult = DamageResult;
		params.playerExitAnimSeq = playerExitAnimSeq;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_EnterGroundAndPoundVictim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Attacker                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetPos                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ambushDir                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBlendSpaceBase*                             playerAnimBS                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_EnterGroundAndPoundVictim(class ARBPawn* Attacker, const struct FVector& TargetPos, const struct FVector& ambushDir, class UBlendSpaceBase* playerAnimBS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_EnterGroundAndPoundVictim");
		
		ARBPlayer_Multicast_EnterGroundAndPoundVictim_Params params {};
		params.Attacker = Attacker;
		params.TargetPos = TargetPos;
		params.ambushDir = ambushDir;
		params.playerAnimBS = playerAnimBS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_DrawDebugSphere
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FColor                                      Color                                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_DrawDebugSphere(const struct FVector& Location, float Radius, const struct FColor& Color, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_DrawDebugSphere");
		
		ARBPlayer_Multicast_DrawDebugSphere_Params params {};
		params.Location = Location;
		params.Radius = Radius;
		params.Color = Color;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_DrawDebugLine
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     locationA                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     locationB                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FColor                                      Color                                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_DrawDebugLine(const struct FVector& locationA, const struct FVector& locationB, const struct FColor& Color, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_DrawDebugLine");
		
		ARBPlayer_Multicast_DrawDebugLine_Params params {};
		params.locationA = locationA;
		params.locationB = locationB;
		params.Color = Color;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_DrawDebugBox
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Extent                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FQuat                                       Rotation                                                   (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FColor                                      Color                                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_DrawDebugBox(const struct FVector& Location, const struct FVector& Extent, const struct FQuat& Rotation, const struct FColor& Color, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_DrawDebugBox");
		
		ARBPlayer_Multicast_DrawDebugBox_Params params {};
		params.Location = Location;
		params.Extent = Extent;
		params.Rotation = Rotation;
		params.Color = Color;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_DoShove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlayerShoveData                            playerShove                                                (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_DoShove(const struct FPlayerShoveData& playerShove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_DoShove");
		
		ARBPlayer_Multicast_DoShove_Params params {};
		params.playerShove = playerShove;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_DoItemPickup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   pickupItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_DoItemPickup(class ARBPickup* pickupItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_DoItemPickup");
		
		ARBPlayer_Multicast_DoItemPickup_Params params {};
		params.pickupItem = pickupItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_DoHealthRegenEffect
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Multicast_DoHealthRegenEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_DoHealthRegenEffect");
		
		ARBPlayer_Multicast_DoHealthRegenEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_DisplayDeadbodyIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     deadbodyLocation                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_DisplayDeadbodyIcon(const struct FVector& deadbodyLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_DisplayDeadbodyIcon");
		
		ARBPlayer_Multicast_DisplayDeadbodyIcon_Params params {};
		params.deadbodyLocation = deadbodyLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_DebugSimultaneousInteraction
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Multicast_DebugSimultaneousInteraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_DebugSimultaneousInteraction");
		
		ARBPlayer_Multicast_DebugSimultaneousInteraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_DebugInventory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_DebugInventory(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_DebugInventory");
		
		ARBPlayer_Multicast_DebugInventory_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_ConsumeStaminaItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              startPawnTimestamp                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              noStaminaConsumptionDuration                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              staminaRestoreAmount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              movementSpeedMultiplier                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_ConsumeStaminaItem(float startPawnTimestamp, float noStaminaConsumptionDuration, float staminaRestoreAmount, float movementSpeedMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_ConsumeStaminaItem");
		
		ARBPlayer_Multicast_ConsumeStaminaItem_Params params {};
		params.startPawnTimestamp = startPawnTimestamp;
		params.noStaminaConsumptionDuration = noStaminaConsumptionDuration;
		params.staminaRestoreAmount = staminaRestoreAmount;
		params.movementSpeedMultiplier = movementSpeedMultiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_ConsumeInventoryItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   pickupItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_ConsumeInventoryItem(class ARBPickup* pickupItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_ConsumeInventoryItem");
		
		ARBPlayer_Multicast_ConsumeInventoryItem_Params params {};
		params.pickupItem = pickupItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_Command
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      MulticastCommand                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_Command(const class FString& MulticastCommand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_Command");
		
		ARBPlayer_Multicast_Command_Params params {};
		params.MulticastCommand = MulticastCommand;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_Cheat_ToggleSilentForBots
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_Cheat_ToggleSilentForBots(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_Cheat_ToggleSilentForBots");
		
		ARBPlayer_Multicast_Cheat_ToggleSilentForBots_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_Cheat_ToggleInvisibleToBots
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_Cheat_ToggleInvisibleToBots(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_Cheat_ToggleInvisibleToBots");
		
		ARBPlayer_Multicast_Cheat_ToggleInvisibleToBots_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_ChallengeArmWrestlingPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   challengedPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_ChallengeArmWrestlingPlayer(class ARBPlayer* challengedPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_ChallengeArmWrestlingPlayer");
		
		ARBPlayer_Multicast_ChallengeArmWrestlingPlayer_Params params {};
		params.challengedPlayer = challengedPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_CancelStateOnDamage
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Multicast_CancelStateOnDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_CancelStateOnDamage");
		
		ARBPlayer_Multicast_CancelStateOnDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_AddPingForDroppedItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   droppedItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     pingLocation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_AddPingForDroppedItem(class ARBPickup* droppedItem, const struct FVector& pingLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_AddPingForDroppedItem");
		
		ARBPlayer_Multicast_AddPingForDroppedItem_Params params {};
		params.droppedItem = droppedItem;
		params.pingLocation = pingLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Multicast_ActivateCameraShake
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCameraShakeData                            shakeData                                                  (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     sourceLocation                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     shakeOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Multicast_ActivateCameraShake(const struct FCameraShakeData& shakeData, const struct FVector& sourceLocation, class UObject* shakeOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Multicast_ActivateCameraShake");
		
		ARBPlayer_Multicast_ActivateCameraShake_Params params {};
		params.shakeData = shakeData;
		params.sourceLocation = sourceLocation;
		params.shakeOwner = shakeOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.LogPlayerEvent_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerEvent                                       EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            explicitValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::LogPlayerEvent_Server(EPlayerEvent EventType, int32_t explicitValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.LogPlayerEvent_Server");
		
		ARBPlayer_LogPlayerEvent_Server_Params params {};
		params.EventType = EventType;
		params.explicitValue = explicitValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.IsLocallySpectated
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::IsLocallySpectated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.IsLocallySpectated");
		
		ARBPlayer_IsLocallySpectated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.IsLocallyControlledOrSpectated
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::IsLocallyControlledOrSpectated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.IsLocallyControlledOrSpectated");
		
		ARBPlayer_IsLocallyControlledOrSpectated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.IsInSAS
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::IsInSAS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.IsInSAS");
		
		ARBPlayer_IsInSAS_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.IsInPsychosis
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::IsInPsychosis()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.IsInPsychosis");
		
		ARBPlayer_IsInPsychosis_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.IsFollower
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::IsFollower()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.IsFollower");
		
		ARBPlayer_IsFollower_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.IsFocusOnSwappingItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBPlayer::IsFocusOnSwappingItem(class ARBPickup* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.IsFocusOnSwappingItem");
		
		ARBPlayer_IsFocusOnSwappingItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.IsEyeLocationUnderwater
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::IsEyeLocationUnderwater()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.IsEyeLocationUnderwater");
		
		ARBPlayer_IsEyeLocationUnderwater_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.IsControllerInMenu
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::IsControllerInMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.IsControllerInMenu");
		
		ARBPlayer_IsControllerInMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.IsConsideredUsingSpectraActiveSkill
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::IsConsideredUsingSpectraActiveSkill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.IsConsideredUsingSpectraActiveSkill");
		
		ARBPlayer_IsConsideredUsingSpectraActiveSkill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.IsConsideredPeeking
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIgnoreNetworkFlag                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBPlayer::IsConsideredPeeking(bool bIgnoreNetworkFlag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.IsConsideredPeeking");
		
		ARBPlayer_IsConsideredPeeking_Params params {};
		params.bIgnoreNetworkFlag = bIgnoreNetworkFlag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.IsConsideredMakingKnockedDownBloodTrail
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::IsConsideredMakingKnockedDownBloodTrail()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.IsConsideredMakingKnockedDownBloodTrail");
		
		ARBPlayer_IsConsideredMakingKnockedDownBloodTrail_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.IsConsideredKnockedDown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bConsiderDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBPlayer::IsConsideredKnockedDown(bool bConsiderDelay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.IsConsideredKnockedDown");
		
		ARBPlayer_IsConsideredKnockedDown_Params params {};
		params.bConsiderDelay = bConsiderDelay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.IsAssociatedPlayerConnected
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::IsAssociatedPlayerConnected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.IsAssociatedPlayerConnected");
		
		ARBPlayer_IsAssociatedPlayerConnected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.HasHotPotato
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::HasHotPotato()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.HasHotPotato");
		
		ARBPlayer_HasHotPotato_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetUniqueId
	 * 		Flags  -> ()
	 */
	struct FUniqueNetIdRepl ARBPlayer::GetUniqueId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetUniqueId");
		
		ARBPlayer_GetUniqueId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetStaminaBoostItemModifier
	 * 		Flags  -> ()
	 */
	struct FRBGameplayAttributeModifier ARBPlayer::GetStaminaBoostItemModifier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetStaminaBoostItemModifier");
		
		ARBPlayer_GetStaminaBoostItemModifier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetMainShadowMesh
	 * 		Flags  -> ()
	 */
	class USkeletalMeshComponent* ARBPlayer::GetMainShadowMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetMainShadowMesh");
		
		ARBPlayer_GetMainShadowMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetKnockoutBleedoutTime
	 * 		Flags  -> ()
	 */
	float ARBPlayer::GetKnockoutBleedoutTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetKnockoutBleedoutTime");
		
		ARBPlayer_GetKnockoutBleedoutTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetItemHeld
	 * 		Flags  -> ()
	 */
	class ARBPickup* ARBPlayer::GetItemHeld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetItemHeld");
		
		ARBPlayer_GetItemHeld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetIsAimingThrowable
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::GetIsAimingThrowable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetIsAimingThrowable");
		
		ARBPlayer_GetIsAimingThrowable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetHoldConsumeActionItem
	 * 		Flags  -> ()
	 */
	class ARBPickup* ARBPlayer::GetHoldConsumeActionItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetHoldConsumeActionItem");
		
		ARBPlayer_GetHoldConsumeActionItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetGamePlayerName
	 * 		Flags  -> ()
	 */
	class FString ARBPlayer::GetGamePlayerName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetGamePlayerName");
		
		ARBPlayer_GetGamePlayerName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetCurrentEquippedOrHolsteredItemInventoryIndex
	 * 		Flags  -> ()
	 */
	int32_t ARBPlayer::GetCurrentEquippedOrHolsteredItemInventoryIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetCurrentEquippedOrHolsteredItemInventoryIndex");
		
		ARBPlayer_GetCurrentEquippedOrHolsteredItemInventoryIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetCurrentEquippedItemType
	 * 		Flags  -> ()
	 */
	EItemType ARBPlayer::GetCurrentEquippedItemType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetCurrentEquippedItemType");
		
		ARBPlayer_GetCurrentEquippedItemType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetCurrentEquippedItemInventoryIndex
	 * 		Flags  -> ()
	 */
	int32_t ARBPlayer::GetCurrentEquippedItemInventoryIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetCurrentEquippedItemInventoryIndex");
		
		ARBPlayer_GetCurrentEquippedItemInventoryIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetCurrentEquippedItemDefinition
	 * 		Flags  -> ()
	 */
	struct FItemDefinition ARBPlayer::GetCurrentEquippedItemDefinition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetCurrentEquippedItemDefinition");
		
		ARBPlayer_GetCurrentEquippedItemDefinition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetCurrentEquippedItem
	 * 		Flags  -> ()
	 */
	class ARBPickup* ARBPlayer::GetCurrentEquippedItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetCurrentEquippedItem");
		
		ARBPlayer_GetCurrentEquippedItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetCurrentActiveSkillType
	 * 		Flags  -> ()
	 */
	EActiveSkillType ARBPlayer::GetCurrentActiveSkillType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetCurrentActiveSkillType");
		
		ARBPlayer_GetCurrentActiveSkillType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetCoopMoveProgress
	 * 		Flags  -> ()
	 */
	float ARBPlayer::GetCoopMoveProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetCoopMoveProgress");
		
		ARBPlayer_GetCoopMoveProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetBatteryBoostItemModifier
	 * 		Flags  -> ()
	 */
	struct FRBGameplayAttributeModifier ARBPlayer::GetBatteryBoostItemModifier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetBatteryBoostItemModifier");
		
		ARBPlayer_GetBatteryBoostItemModifier_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.GetAllShadowMeshes
	 * 		Flags  -> ()
	 */
	TArray<class UPrimitiveComponent*> ARBPlayer::GetAllShadowMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.GetAllShadowMeshes");
		
		ARBPlayer_GetAllShadowMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Get3PAnimInstanceClass
	 * 		Flags  -> ()
	 */
	class UClass* ARBPlayer::Get3PAnimInstanceClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Get3PAnimInstanceClass");
		
		ARBPlayer_Get3PAnimInstanceClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.ForceNightVision
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNVState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisableInput                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::ForceNightVision(bool bNVState, bool bDisableInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.ForceNightVision");
		
		ARBPlayer_ForceNightVision_Params params {};
		params.bNVState = bNVState;
		params.bDisableInput = bDisableInput;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_StopSpectatingLocally
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Event_StopSpectatingLocally()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_StopSpectatingLocally");
		
		ARBPlayer_Event_StopSpectatingLocally_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_StartSpectatingLocally
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Event_StartSpectatingLocally()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_StartSpectatingLocally");
		
		ARBPlayer_Event_StartSpectatingLocally_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_PlayHitReactionEffects
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlayerHitReactionParams                    hitReaction                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     attackLoc                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              hitRelativeAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Event_PlayHitReactionEffects(const struct FPlayerHitReactionParams& hitReaction, const struct FVector& attackLoc, float hitRelativeAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_PlayHitReactionEffects");
		
		ARBPlayer_Event_PlayHitReactionEffects_Params params {};
		params.hitReaction = hitReaction;
		params.attackLoc = attackLoc;
		params.hitRelativeAngle = hitRelativeAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnWakeUp
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Event_OnWakeUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnWakeUp");
		
		ARBPlayer_Event_OnWakeUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnRemainingRespawnIncreased
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Event_OnRemainingRespawnIncreased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnRemainingRespawnIncreased");
		
		ARBPlayer_Event_OnRemainingRespawnIncreased_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnPlayerStateChanged
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Event_OnPlayerStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnPlayerStateChanged");
		
		ARBPlayer_Event_OnPlayerStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnPlayerPerspectiveChanged
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Event_OnPlayerPerspectiveChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnPlayerPerspectiveChanged");
		
		ARBPlayer_Event_OnPlayerPerspectiveChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnPlayerAnimInstanceChanged
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Event_OnPlayerAnimInstanceChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnPlayerAnimInstanceChanged");
		
		ARBPlayer_Event_OnPlayerAnimInstanceChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnNVAnimationNotify
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bWantsNvOn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ENightVisionAnimNotifyType                         Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Event_OnNVAnimationNotify(bool bWantsNvOn, ENightVisionAnimNotifyType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnNVAnimationNotify");
		
		ARBPlayer_Event_OnNVAnimationNotify_Params params {};
		params.bWantsNvOn = bWantsNvOn;
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnLocalLookAt
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Event_OnLocalLookAt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnLocalLookAt");
		
		ARBPlayer_Event_OnLocalLookAt_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnLastConsumedBatteryTypeChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemType                                          batteryType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Event_OnLastConsumedBatteryTypeChanged(EItemType batteryType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnLastConsumedBatteryTypeChanged");
		
		ARBPlayer_Event_OnLastConsumedBatteryTypeChanged_Params params {};
		params.batteryType = batteryType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnHealthRestored
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Event_OnHealthRestored()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnHealthRestored");
		
		ARBPlayer_Event_OnHealthRestored_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnExitActiveSkillLimiterZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBActiveSkillLimiterZone*                   zoneExited                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Event_OnExitActiveSkillLimiterZone(class ARBActiveSkillLimiterZone* zoneExited)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnExitActiveSkillLimiterZone");
		
		ARBPlayer_Event_OnExitActiveSkillLimiterZone_Params params {};
		params.zoneExited = zoneExited;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnEnterActiveSkillLimiterZone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBActiveSkillLimiterZone*                   zoneEntered                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Event_OnEnterActiveSkillLimiterZone(class ARBActiveSkillLimiterZone* zoneEntered)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnEnterActiveSkillLimiterZone");
		
		ARBPlayer_Event_OnEnterActiveSkillLimiterZone_Params params {};
		params.zoneEntered = zoneEntered;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnCustomizationChanged
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Event_OnCustomizationChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnCustomizationChanged");
		
		ARBPlayer_Event_OnCustomizationChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnContinuousPsychosisGained
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Event_OnContinuousPsychosisGained()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnContinuousPsychosisGained");
		
		ARBPlayer_Event_OnContinuousPsychosisGained_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnActiveSkillActorChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      activeSkillActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Event_OnActiveSkillActorChanged(class AActor* activeSkillActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnActiveSkillActorChanged");
		
		ARBPlayer_Event_OnActiveSkillActorChanged_Params params {};
		params.activeSkillActor = activeSkillActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnActiveEffectUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FActiveEffectTrackingData                   activeEffectTrackingDataEntry                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Event_OnActiveEffectUpdated(const struct FActiveEffectTrackingData& activeEffectTrackingDataEntry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnActiveEffectUpdated");
		
		ARBPlayer_Event_OnActiveEffectUpdated_Params params {};
		params.activeEffectTrackingDataEntry = activeEffectTrackingDataEntry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnActiveEffectsUpdated
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Event_OnActiveEffectsUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnActiveEffectsUpdated");
		
		ARBPlayer_Event_OnActiveEffectsUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnActiveEffectRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        EffectId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Event_OnActiveEffectRemoved(const class FName& EffectId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnActiveEffectRemoved");
		
		ARBPlayer_Event_OnActiveEffectRemoved_Params params {};
		params.EffectId = EffectId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_OnActiveEffectAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FActiveEffectTrackingData                   activeEffectTrackingDataEntry                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Event_OnActiveEffectAdded(const struct FActiveEffectTrackingData& activeEffectTrackingDataEntry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_OnActiveEffectAdded");
		
		ARBPlayer_Event_OnActiveEffectAdded_Params params {};
		params.activeEffectTrackingDataEntry = activeEffectTrackingDataEntry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Event_InitReplicated
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Event_InitReplicated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Event_InitReplicated");
		
		ARBPlayer_Event_InitReplicated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.EndCustomAction
	 * 		Flags  -> ()
	 */
	void ARBPlayer::EndCustomAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.EndCustomAction");
		
		ARBPlayer_EndCustomAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Debug_ForceSASChairInteraction
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Debug_ForceSASChairInteraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Debug_ForceSASChairInteraction");
		
		ARBPlayer_Debug_ForceSASChairInteraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Client_TalkWheelThrottled
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Client_TalkWheelThrottled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Client_TalkWheelThrottled");
		
		ARBPlayer_Client_TalkWheelThrottled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Client_ShowCustomInteractionMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EMessagePriority                                   Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Client_ShowCustomInteractionMessage(const class FText& Message, EMessagePriority Priority, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Client_ShowCustomInteractionMessage");
		
		ARBPlayer_Client_ShowCustomInteractionMessage_Params params {};
		params.Message = Message;
		params.Priority = Priority;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Client_RemoveObjectiveIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      inActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Client_RemoveObjectiveIcon(class AActor* inActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Client_RemoveObjectiveIcon");
		
		ARBPlayer_Client_RemoveObjectiveIcon_Params params {};
		params.inActor = inActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Client_PlayDisturbanceWarning
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Client_PlayDisturbanceWarning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Client_PlayDisturbanceWarning");
		
		ARBPlayer_Client_PlayDisturbanceWarning_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Client_OnRepossessed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              PawnTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Client_OnRepossessed(float PawnTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Client_OnRepossessed");
		
		ARBPlayer_Client_OnRepossessed_Params params {};
		params.PawnTime = PawnTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Client_HideCustomInteractionMessage
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Client_HideCustomInteractionMessage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Client_HideCustomInteractionMessage");
		
		ARBPlayer_Client_HideCustomInteractionMessage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Client_ForceNightVision
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNVState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisableInput                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::Client_ForceNightVision(bool bNVState, bool bDisableInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Client_ForceNightVision");
		
		ARBPlayer_Client_ForceNightVision_Params params {};
		params.bNVState = bNVState;
		params.bDisableInput = bDisableInput;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.Client_DebugSimultaneousJumpForward
	 * 		Flags  -> ()
	 */
	void ARBPlayer::Client_DebugSimultaneousJumpForward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.Client_DebugSimultaneousJumpForward");
		
		ARBPlayer_Client_DebugSimultaneousJumpForward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.ClearInventory_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIncludeActiveSkill                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::ClearInventory_Server(bool bIncludeActiveSkill)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.ClearInventory_Server");
		
		ARBPlayer_ClearInventory_Server_Params params {};
		params.bIncludeActiveSkill = bIncludeActiveSkill;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_TestHitReaction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerHitReactionType                             hitReactionType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitDirection                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_TestHitReaction(EPlayerHitReactionType hitReactionType, const struct FVector& HitDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_TestHitReaction");
		
		ARBPlayer_BP_TestHitReaction_Params params {};
		params.hitReactionType = hitReactionType;
		params.HitDirection = HitDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_StopHallucination
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFadeOut                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_StopHallucination(bool bFadeOut)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_StopHallucination");
		
		ARBPlayer_BP_StopHallucination_Params params {};
		params.bFadeOut = bFadeOut;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_StopDizziness
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFadeOut                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_StopDizziness(bool bFadeOut)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_StopDizziness");
		
		ARBPlayer_BP_StopDizziness_Params params {};
		params.bFadeOut = bFadeOut;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_StopCameraShake
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInstantly                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     shakeOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreOwnerCondition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_StopCameraShake(bool bInstantly, class UObject* shakeOwner, bool bIgnoreOwnerCondition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_StopCameraShake");
		
		ARBPlayer_BP_StopCameraShake_Params params {};
		params.bInstantly = bInstantly;
		params.shakeOwner = shakeOwner;
		params.bIgnoreOwnerCondition = bIgnoreOwnerCondition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_StartHallucination
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EHallucinationType                                 halluType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBHallucinationConfig*                      Config                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_StartHallucination(EHallucinationType halluType, class URBHallucinationConfig* Config)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_StartHallucination");
		
		ARBPlayer_BP_StartHallucination_Params params {};
		params.halluType = halluType;
		params.Config = Config;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_StartDizziness
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBDizzinessConfig*                          configAsset                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_StartDizziness(class URBDizzinessConfig* configAsset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_StartDizziness");
		
		ARBPlayer_BP_StartDizziness_Params params {};
		params.configAsset = configAsset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_ShouldShowStamina
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::BP_ShouldShowStamina()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_ShouldShowStamina");
		
		ARBPlayer_BP_ShouldShowStamina_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_SetSpecialMoveCameraLimits
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              minYaw                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              maxYaw                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              minPitch                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              maxPitch                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_SetSpecialMoveCameraLimits(float minYaw, float maxYaw, float minPitch, float maxPitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_SetSpecialMoveCameraLimits");
		
		ARBPlayer_BP_SetSpecialMoveCameraLimits_Params params {};
		params.minYaw = minYaw;
		params.maxYaw = maxYaw;
		params.minPitch = minPitch;
		params.maxPitch = maxPitch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_SetGodMode
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bGod                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_SetGodMode(bool bGod)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_SetGodMode");
		
		ARBPlayer_BP_SetGodMode_Params params {};
		params.bGod = bGod;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_OnTrapRoomFailed
	 * 		Flags  -> ()
	 */
	void ARBPlayer::BP_OnTrapRoomFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_OnTrapRoomFailed");
		
		ARBPlayer_BP_OnTrapRoomFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_IsUsingGamepad
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::BP_IsUsingGamepad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_IsUsingGamepad");
		
		ARBPlayer_BP_IsUsingGamepad_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_IsNVOn
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::BP_IsNVOn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_IsNVOn");
		
		ARBPlayer_BP_IsNVOn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_IsNVBatteryRecharging
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::BP_IsNVBatteryRecharging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_IsNVBatteryRecharging");
		
		ARBPlayer_BP_IsNVBatteryRecharging_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_IsFlaggedAsFakePlayer
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::BP_IsFlaggedAsFakePlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_IsFlaggedAsFakePlayer");
		
		ARBPlayer_BP_IsFlaggedAsFakePlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_IsExhausted
	 * 		Flags  -> ()
	 */
	bool ARBPlayer::BP_IsExhausted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_IsExhausted");
		
		ARBPlayer_BP_IsExhausted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_InstaKill
	 * 		Flags  -> ()
	 */
	void ARBPlayer::BP_InstaKill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_InstaKill");
		
		ARBPlayer_BP_InstaKill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_InstaDown
	 * 		Flags  -> ()
	 */
	void ARBPlayer::BP_InstaDown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_InstaDown");
		
		ARBPlayer_BP_InstaDown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_HasInventoryItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBPlayer::BP_HasInventoryItem(class UClass* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_HasInventoryItem");
		
		ARBPlayer_BP_HasInventoryItem_Params params {};
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_GetPickupInFocus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               outIsSwap                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBPickup* ARBPlayer::BP_GetPickupInFocus(bool* outIsSwap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_GetPickupInFocus");
		
		ARBPlayer_BP_GetPickupInFocus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outIsSwap != nullptr)
			*outIsSwap = params.outIsSwap;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_GetNumberOfItemForCategory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ARBPlayer::BP_GetNumberOfItemForCategory(EItemCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_GetNumberOfItemForCategory");
		
		ARBPlayer_BP_GetNumberOfItemForCategory_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_GetNoStaminaConsumptionDuration
	 * 		Flags  -> ()
	 */
	float ARBPlayer::BP_GetNoStaminaConsumptionDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_GetNoStaminaConsumptionDuration");
		
		ARBPlayer_BP_GetNoStaminaConsumptionDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_GetMaxNumberOfItemForCategory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ARBPlayer::BP_GetMaxNumberOfItemForCategory(EItemCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_GetMaxNumberOfItemForCategory");
		
		ARBPlayer_BP_GetMaxNumberOfItemForCategory_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_GetLastConsumedBatteryType
	 * 		Flags  -> ()
	 */
	EItemType ARBPlayer::BP_GetLastConsumedBatteryType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_GetLastConsumedBatteryType");
		
		ARBPlayer_BP_GetLastConsumedBatteryType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_GetItemsForCategory
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class ARBPickup*> ARBPlayer::BP_GetItemsForCategory(EItemCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_GetItemsForCategory");
		
		ARBPlayer_BP_GetItemsForCategory_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_GetItemIndexForSwap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPickup*                                   Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ARBPlayer::BP_GetItemIndexForSwap(EItemCategory Category, class ARBPickup* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_GetItemIndexForSwap");
		
		ARBPlayer_BP_GetItemIndexForSwap_Params params {};
		params.Category = Category;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_GetItemFromIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            itemIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBPickup* ARBPlayer::BP_GetItemFromIndex(int32_t itemIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_GetItemFromIndex");
		
		ARBPlayer_BP_GetItemFromIndex_Params params {};
		params.itemIndex = itemIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_GetInventoryIndexFromItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ARBPlayer::BP_GetInventoryIndexFromItem(class ARBPickup* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_GetInventoryIndexFromItem");
		
		ARBPlayer_BP_GetInventoryIndexFromItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_GetHealthF
	 * 		Flags  -> ()
	 */
	float ARBPlayer::BP_GetHealthF()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_GetHealthF");
		
		ARBPlayer_BP_GetHealthF_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_GetCurrentStamina
	 * 		Flags  -> ()
	 */
	float ARBPlayer::BP_GetCurrentStamina()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_GetCurrentStamina");
		
		ARBPlayer_BP_GetCurrentStamina_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_ForceWakeUpSequence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerStart*                              PlayerStart                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_ForceWakeUpSequence(class ARBPlayerStart* PlayerStart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_ForceWakeUpSequence");
		
		ARBPlayer_BP_ForceWakeUpSequence_Params params {};
		params.PlayerStart = PlayerStart;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_ForceTradeOnFakePlayer
	 * 		Flags  -> ()
	 */
	void ARBPlayer::BP_ForceTradeOnFakePlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_ForceTradeOnFakePlayer");
		
		ARBPlayer_BP_ForceTradeOnFakePlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_ForceSpecialAnimation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bCancelInteraction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      targetLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimSequence*                               Animation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCollisionEnabled                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              blendInTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_ForceSpecialAnimation(bool bCancelInteraction, class AActor* targetLocation, class UAnimSequence* Animation, bool bCollisionEnabled, float blendInTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_ForceSpecialAnimation");
		
		ARBPlayer_BP_ForceSpecialAnimation_Params params {};
		params.bCancelInteraction = bCancelInteraction;
		params.targetLocation = targetLocation;
		params.Animation = Animation;
		params.bCollisionEnabled = bCollisionEnabled;
		params.blendInTime = blendInTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_ForcePickupItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPickup*                                   pickup                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_ForcePickupItem(class ARBPickup* pickup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_ForcePickupItem");
		
		ARBPlayer_BP_ForcePickupItem_Params params {};
		params.pickup = pickup;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_ForceInteractionOnFakePlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              interval                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_ForceInteractionOnFakePlayer(float interval)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_ForceInteractionOnFakePlayer");
		
		ARBPlayer_BP_ForceInteractionOnFakePlayer_Params params {};
		params.interval = interval;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_ForceHitReaction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bCancelInteraction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayerHitReactionType                             hitReactionType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitDirection                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_ForceHitReaction(bool bCancelInteraction, EPlayerHitReactionType hitReactionType, const struct FVector& HitDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_ForceHitReaction");
		
		ARBPlayer_BP_ForceHitReaction_Params params {};
		params.bCancelInteraction = bCancelInteraction;
		params.hitReactionType = hitReactionType;
		params.HitDirection = HitDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_ForceDropHeldObjectives
	 * 		Flags  -> ()
	 */
	void ARBPlayer::BP_ForceDropHeldObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_ForceDropHeldObjectives");
		
		ARBPlayer_BP_ForceDropHeldObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_ForceCrouchOnFakePlayer
	 * 		Flags  -> ()
	 */
	void ARBPlayer::BP_ForceCrouchOnFakePlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_ForceCrouchOnFakePlayer");
		
		ARBPlayer_BP_ForceCrouchOnFakePlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_FlagAsFakePlayer
	 * 		Flags  -> ()
	 */
	void ARBPlayer::BP_FlagAsFakePlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_FlagAsFakePlayer");
		
		ARBPlayer_BP_FlagAsFakePlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_FindFirstInventoryItemIndexFromClass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      ItemClass                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAllowChildClasses                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ARBPlayer::BP_FindFirstInventoryItemIndexFromClass(class UClass* ItemClass, bool bAllowChildClasses)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_FindFirstInventoryItemIndexFromClass");
		
		ARBPlayer_BP_FindFirstInventoryItemIndexFromClass_Params params {};
		params.ItemClass = ItemClass;
		params.bAllowChildClasses = bAllowChildClasses;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_FindFirstInventoryItemIndex
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemCategory                                      Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ARBPlayer::BP_FindFirstInventoryItemIndex(EItemCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_FindFirstInventoryItemIndex");
		
		ARBPlayer_BP_FindFirstInventoryItemIndex_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_Debug_AdjustPlayerPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      refActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              offsetFwd                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              offsetSide                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              offsetHeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_Debug_AdjustPlayerPosition(class AActor* refActor, float offsetFwd, float offsetSide, float offsetHeight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_Debug_AdjustPlayerPosition");
		
		ARBPlayer_BP_Debug_AdjustPlayerPosition_Params params {};
		params.refActor = refActor;
		params.offsetFwd = offsetFwd;
		params.offsetSide = offsetSide;
		params.offsetHeight = offsetHeight;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_DamagePlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EDamageType                                        dmgType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      SrcActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DmgAmount                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanKill                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanKnockdown                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_DamagePlayer(EDamageType dmgType, class AActor* SrcActor, float DmgAmount, bool bCanKill, bool bCanKnockdown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_DamagePlayer");
		
		ARBPlayer_BP_DamagePlayer_Params params {};
		params.dmgType = dmgType;
		params.SrcActor = SrcActor;
		params.DmgAmount = DmgAmount;
		params.bCanKill = bCanKill;
		params.bCanKnockdown = bCanKnockdown;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_ClearProgressivePsychosis
	 * 		Flags  -> ()
	 */
	void ARBPlayer::BP_ClearProgressivePsychosis()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_ClearProgressivePsychosis");
		
		ARBPlayer_BP_ClearProgressivePsychosis_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_AddScoringPoints
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            nbPoints                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_AddScoringPoints(int32_t nbPoints)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_AddScoringPoints");
		
		ARBPlayer_BP_AddScoringPoints_Params params {};
		params.nbPoints = nbPoints;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_AddProgressivePsychosis
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              psychosisAmount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGas                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBypassPlayerReductions                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_AddProgressivePsychosis(float psychosisAmount, bool bGas, bool bBypassPlayerReductions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_AddProgressivePsychosis");
		
		ARBPlayer_BP_AddProgressivePsychosis_Params params {};
		params.psychosisAmount = psychosisAmount;
		params.bGas = bGas;
		params.bBypassPlayerReductions = bBypassPlayerReductions;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayer.BP_ActivateCameraShake
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FCameraShakeData                            shakeData                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     sourceLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     shakeOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayer::BP_ActivateCameraShake(const struct FCameraShakeData& shakeData, const struct FVector& sourceLocation, class UObject* shakeOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayer.BP_ActivateCameraShake");
		
		ARBPlayer_BP_ActivateCameraShake_Params params {};
		params.shakeData = shakeData;
		params.sourceLocation = sourceLocation;
		params.shakeOwner = shakeOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCamera.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCamera::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCamera");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCameraShakeConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCameraShakeConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCameraShakeConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCameraLocationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCameraLocationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCameraLocationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerVolume.OnUntriggeredEventBypass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPlayerTriggerComponent*                   Trigger                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerTriggerVolume::OnUntriggeredEventBypass(class URBPlayerTriggerComponent* Trigger)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerVolume.OnUntriggeredEventBypass");
		
		ARBPlayerTriggerVolume_OnUntriggeredEventBypass_Params params {};
		params.Trigger = Trigger;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerVolume.OnTriggeredEventBypass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPlayerTriggerComponent*                   Trigger                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerTriggerVolume::OnTriggeredEventBypass(class URBPlayerTriggerComponent* Trigger)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerVolume.OnTriggeredEventBypass");
		
		ARBPlayerTriggerVolume_OnTriggeredEventBypass_Params params {};
		params.Trigger = Trigger;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerVolume.OnPlayerExitedEventBypass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerTriggerVolume::OnPlayerExitedEventBypass(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerVolume.OnPlayerExitedEventBypass");
		
		ARBPlayerTriggerVolume_OnPlayerExitedEventBypass_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerVolume.OnPlayerEnteredEventBypass
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerTriggerVolume::OnPlayerEnteredEventBypass(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerVolume.OnPlayerEnteredEventBypass");
		
		ARBPlayerTriggerVolume_OnPlayerEnteredEventBypass_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerVolume.IsEnabled
	 * 		Flags  -> ()
	 */
	bool ARBPlayerTriggerVolume::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerVolume.IsEnabled");
		
		ARBPlayerTriggerVolume_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerVolume.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               Enabled                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerTriggerVolume::BP_SetEnabled(bool Enabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerVolume.BP_SetEnabled");
		
		ARBPlayerTriggerVolume_BP_SetEnabled_Params params {};
		params.Enabled = Enabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPlayerTriggerVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPlayerTriggerVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerTriggerVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.RefreshCustomization
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRBPlayerCellCustomizationEntry>     playerCellCustomization                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerCell::RefreshCustomization(TArray<struct FRBPlayerCellCustomizationEntry> playerCellCustomization)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.RefreshCustomization");
		
		ARBPlayerCell_RefreshCustomization_Params params {};
		params.playerCellCustomization = playerCellCustomization;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.PreviewCustomization
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECustomizationMenuCategory                         Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBPlayerCellItemDefinition*                 ItemDefinition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerCell::PreviewCustomization(ECustomizationMenuCategory Slot, class URBPlayerCellItemDefinition* ItemDefinition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.PreviewCustomization");
		
		ARBPlayerCell_PreviewCustomization_Params params {};
		params.Slot = Slot;
		params.ItemDefinition = ItemDefinition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.OnPlayerEnteredReflectionCaptureTrigger
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerCell::OnPlayerEnteredReflectionCaptureTrigger(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.OnPlayerEnteredReflectionCaptureTrigger");
		
		ARBPlayerCell_OnPlayerEnteredReflectionCaptureTrigger_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.OnPlayerCellCustomizationUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FRBPlayerCellCustomizationEntry>     playerCellCustomization                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerCell::OnPlayerCellCustomizationUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, TArray<struct FRBPlayerCellCustomizationEntry> playerCellCustomization)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.OnPlayerCellCustomizationUpdated");
		
		ARBPlayerCell_OnPlayerCellCustomizationUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.playerCellCustomization = playerCellCustomization;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.OnAssignedPlayerStateUpdated
	 * 		Flags  -> ()
	 */
	void ARBPlayerCell::OnAssignedPlayerStateUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.OnAssignedPlayerStateUpdated");
		
		ARBPlayerCell_OnAssignedPlayerStateUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.OnAllowedPawnsUpdated
	 * 		Flags  -> ()
	 */
	void ARBPlayerCell::OnAllowedPawnsUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.OnAllowedPawnsUpdated");
		
		ARBPlayerCell_OnAllowedPawnsUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.Multicast_MarkReflectionCaptureDirty
	 * 		Flags  -> ()
	 */
	void ARBPlayerCell::Multicast_MarkReflectionCaptureDirty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.Multicast_MarkReflectionCaptureDirty");
		
		ARBPlayerCell_Multicast_MarkReflectionCaptureDirty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.GetLinkedPlayerStarts
	 * 		Flags  -> ()
	 */
	TArray<class AActor*> ARBPlayerCell::GetLinkedPlayerStarts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.GetLinkedPlayerStarts");
		
		ARBPlayerCell_GetLinkedPlayerStarts_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.GetLinkedInteractibles
	 * 		Flags  -> ()
	 */
	TArray<class ARBInteractible*> ARBPlayerCell::GetLinkedInteractibles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.GetLinkedInteractibles");
		
		ARBPlayerCell_GetLinkedInteractibles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.GetLinkedDoors
	 * 		Flags  -> ()
	 */
	TArray<class ARBDoor*> ARBPlayerCell::GetLinkedDoors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.GetLinkedDoors");
		
		ARBPlayerCell_GetLinkedDoors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.GetLinkedCustomizationInterfaces
	 * 		Flags  -> ()
	 */
	TArray<class ARBCustomizationInterface*> ARBPlayerCell::GetLinkedCustomizationInterfaces()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.GetLinkedCustomizationInterfaces");
		
		ARBPlayerCell_GetLinkedCustomizationInterfaces_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.GetLinkedCollectibleDisplays
	 * 		Flags  -> ()
	 */
	TArray<class ARBCollectibleDisplay*> ARBPlayerCell::GetLinkedCollectibleDisplays()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.GetLinkedCollectibleDisplays");
		
		ARBPlayerCell_GetLinkedCollectibleDisplays_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.GetLinkedCellItems
	 * 		Flags  -> ()
	 */
	TArray<class ARBPlayerCellItem*> ARBPlayerCell::GetLinkedCellItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.GetLinkedCellItems");
		
		ARBPlayerCell_GetLinkedCellItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.GetLinkedBlockingVolumes
	 * 		Flags  -> ()
	 */
	TArray<class ARBBlockingVolume*> ARBPlayerCell::GetLinkedBlockingVolumes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.GetLinkedBlockingVolumes");
		
		ARBPlayerCell_GetLinkedBlockingVolumes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.GetCellMenuCharacter
	 * 		Flags  -> ()
	 */
	class AActor* ARBPlayerCell::GetCellMenuCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.GetCellMenuCharacter");
		
		ARBPlayerCell_GetCellMenuCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.GetCellCustomizationCamera
	 * 		Flags  -> ()
	 */
	class AActor* ARBPlayerCell::GetCellCustomizationCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.GetCellCustomizationCamera");
		
		ARBPlayerCell_GetCellCustomizationCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCell.GetAssignedPlayer
	 * 		Flags  -> ()
	 */
	class ARBLobbyPlayerController* ARBPlayerCell::GetAssignedPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCell.GetAssignedPlayer");
		
		ARBPlayerCell_GetAssignedPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPlayerCell.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPlayerCell::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCell");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomizationOption.IsUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              PlayerState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBCustomizationOption::IsUnlocked(class ARBPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomizationOption.IsUnlocked");
		
		URBCustomizationOption_IsUnlocked_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomizationOption.IsPartOfDLCContentPack
	 * 		Flags  -> ()
	 */
	bool URBCustomizationOption::IsPartOfDLCContentPack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomizationOption.IsPartOfDLCContentPack");
		
		URBCustomizationOption_IsPartOfDLCContentPack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomizationOption.IsDevOption
	 * 		Flags  -> ()
	 */
	bool URBCustomizationOption::IsDevOption()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomizationOption.IsDevOption");
		
		URBCustomizationOption_IsDevOption_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomizationOption.IsAcquired
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              PlayerState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBCustomizationOption::IsAcquired(class ARBPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomizationOption.IsAcquired");
		
		URBCustomizationOption_IsAcquired_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomizationOption.BP_GetCost
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TMap<ECurrencyType, int32_t> URBCustomizationOption::BP_GetCost(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomizationOption.BP_GetCost");
		
		URBCustomizationOption_BP_GetCost_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCustomizationOption.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCustomizationOption::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCustomizationOption");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCellItemDefinition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCellItemDefinition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCellItemDefinition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCellCustomizationConfig.RefreshItems
	 * 		Flags  -> ()
	 */
	void URBPlayerCellCustomizationConfig::RefreshItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCellCustomizationConfig.RefreshItems");
		
		URBPlayerCellCustomizationConfig_RefreshItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCellCustomizationConfig.GetPlayerCellItemDefinition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBPlayerCellItemDefinition* URBPlayerCellCustomizationConfig::GetPlayerCellItemDefinition(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCellCustomizationConfig.GetPlayerCellItemDefinition");
		
		URBPlayerCellCustomizationConfig_GetPlayerCellItemDefinition_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCellCustomizationConfig.GetDefaultPlayerCellItemForSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECustomizationMenuCategory                         Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBPlayerCellItemDefinition* URBPlayerCellCustomizationConfig::GetDefaultPlayerCellItemForSlot(ECustomizationMenuCategory Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCellCustomizationConfig.GetDefaultPlayerCellItemForSlot");
		
		URBPlayerCellCustomizationConfig_GetDefaultPlayerCellItemForSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCellCustomizationConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCellCustomizationConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCellCustomizationConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCellItem.Event_UnassignedFromPlayer
	 * 		Flags  -> ()
	 */
	void ARBPlayerCellItem::Event_UnassignedFromPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCellItem.Event_UnassignedFromPlayer");
		
		ARBPlayerCellItem_Event_UnassignedFromPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCellItem.Event_ClearItem
	 * 		Flags  -> ()
	 */
	void ARBPlayerCellItem::Event_ClearItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCellItem.Event_ClearItem");
		
		ARBPlayerCellItem_Event_ClearItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCellItem.Event_AssignToPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerCellItem::Event_AssignToPlayer(class ARBLobbyPlayerState* RBLobbyPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCellItem.Event_AssignToPlayer");
		
		ARBPlayerCellItem_Event_AssignToPlayer_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCellItem.Event_AssignItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPlayerCellItemDefinition*                 ItemDefinition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerCellItem::Event_AssignItem(class URBPlayerCellItemDefinition* ItemDefinition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCellItem.Event_AssignItem");
		
		ARBPlayerCellItem_Event_AssignItem_Params params {};
		params.ItemDefinition = ItemDefinition;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPlayerCellItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPlayerCellItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCellItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCondition_AllOfSubConditions.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCondition_AllOfSubConditions::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCondition_AllOfSubConditions");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCondition_AnyOfSubConditions.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCondition_AnyOfSubConditions::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCondition_AnyOfSubConditions");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCondition_Blueprint.Event_EvaluateCondition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBPlayerCondition_Blueprint::Event_EvaluateCondition(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCondition_Blueprint.Event_EvaluateCondition");
		
		URBPlayerCondition_Blueprint_Event_EvaluateCondition_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCondition_Blueprint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCondition_Blueprint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCondition_Blueprint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCondition_IsHidden.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCondition_IsHidden::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCondition_IsHidden");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCondition_IsBeingChased.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCondition_IsBeingChased::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCondition_IsBeingChased");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCondition_RecentlySeen.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCondition_RecentlySeen::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCondition_RecentlySeen");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCondition_Rushing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCondition_Rushing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCondition_Rushing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCondition_Proximity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCondition_Proximity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCondition_Proximity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationOption.GetStaticMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsFemale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerCustomizationOption::GetStaticMesh(bool bIsFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationOption.GetStaticMesh");
		
		URBPlayerCustomizationOption_GetStaticMesh_Params params {};
		params.bIsFemale = bIsFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationOption.GetSkeletalMesh
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsFemale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerCustomizationOption::GetSkeletalMesh(bool bIsFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationOption.GetSkeletalMesh");
		
		URBPlayerCustomizationOption_GetSkeletalMesh_Params params {};
		params.bIsFemale = bIsFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationOption.GetMaterialOverrides
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsFemale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FRBPlayerCustomizationMaterialOverride> URBPlayerCustomizationOption::GetMaterialOverrides(bool bIsFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationOption.GetMaterialOverrides");
		
		URBPlayerCustomizationOption_GetMaterialOverrides_Params params {};
		params.bIsFemale = bIsFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationOption.GetExtraSkeletalMeshes
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsFemale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerCustomizationOption::GetExtraSkeletalMeshes(bool bIsFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationOption.GetExtraSkeletalMeshes");
		
		URBPlayerCustomizationOption_GetExtraSkeletalMeshes_Params params {};
		params.bIsFemale = bIsFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationOption.BP_GetMaterialOverrideInstancesMap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsFemale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TMap<class FString, class UMaterialInstanceConstant*> URBPlayerCustomizationOption::BP_GetMaterialOverrideInstancesMap(bool bIsFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationOption.BP_GetMaterialOverrideInstancesMap");
		
		URBPlayerCustomizationOption_BP_GetMaterialOverrideInstancesMap_Params params {};
		params.bIsFemale = bIsFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationOption.BP_GetAllResourcesToLoad
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsFemale                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FSoftObjectPath> URBPlayerCustomizationOption::BP_GetAllResourcesToLoad(bool IsFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationOption.BP_GetAllResourcesToLoad");
		
		URBPlayerCustomizationOption_BP_GetAllResourcesToLoad_Params params {};
		params.IsFemale = IsFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCustomizationOption.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCustomizationOption::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCustomizationOption");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVoiceCustomizationOption.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVoiceCustomizationOption::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVoiceCustomizationOption");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerIconCustomizationOption.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerIconCustomizationOption::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerIconCustomizationOption");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomizationOutfit.IsSlotPartOfOutfit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerCustomizationSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBCustomizationOutfit::IsSlotPartOfOutfit(EPlayerCustomizationSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomizationOutfit.IsSlotPartOfOutfit");
		
		URBCustomizationOutfit_IsSlotPartOfOutfit_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomizationOutfit.GetUnlockLevel
	 * 		Flags  -> ()
	 */
	int32_t URBCustomizationOutfit::GetUnlockLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomizationOutfit.GetUnlockLevel");
		
		URBCustomizationOutfit_GetUnlockLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomizationOutfit.GetOutfitCustomizationOption
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerCustomizationSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBPlayerCustomizationOption* URBCustomizationOutfit::GetOutfitCustomizationOption(EPlayerCustomizationSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomizationOutfit.GetOutfitCustomizationOption");
		
		URBCustomizationOutfit_GetOutfitCustomizationOption_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomizationOutfit.GetNonAcquiredOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class URBPlayerCustomizationOption*>        outOptions                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void URBCustomizationOutfit::GetNonAcquiredOptions(class ARBPlayerState* RBPlayerState, TArray<class URBPlayerCustomizationOption*>* outOptions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomizationOutfit.GetNonAcquiredOptions");
		
		URBCustomizationOutfit_GetNonAcquiredOptions_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outOptions != nullptr)
			*outOptions = params.outOptions;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomizationOutfit.Editor_RefreshHiddenSlots
	 * 		Flags  -> ()
	 */
	void URBCustomizationOutfit::Editor_RefreshHiddenSlots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomizationOutfit.Editor_RefreshHiddenSlots");
		
		URBCustomizationOutfit_Editor_RefreshHiddenSlots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomizationOutfit.CanEquipSinglePieces
	 * 		Flags  -> ()
	 */
	bool URBCustomizationOutfit::CanEquipSinglePieces()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomizationOutfit.CanEquipSinglePieces");
		
		URBCustomizationOutfit_CanEquipSinglePieces_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBCustomizationOutfit.BP_GetAllResourcesToLoad
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsFemale                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FSoftObjectPath> URBCustomizationOutfit::BP_GetAllResourcesToLoad(bool IsFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBCustomizationOutfit.BP_GetAllResourcesToLoad");
		
		URBCustomizationOutfit_BP_GetAllResourcesToLoad_Params params {};
		params.IsFemale = IsFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBCustomizationOutfit.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBCustomizationOutfit::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBCustomizationOutfit");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.GetVoiceOption
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBVoiceCustomizationOption* URBPlayerCustomizationConfig::GetVoiceOption(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.GetVoiceOption");
		
		URBPlayerCustomizationConfig_GetVoiceOption_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.GetRandomDeadBodyCustomizationInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRandomSex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsFemale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBPlayerCustomizationInfo URBPlayerCustomizationConfig::GetRandomDeadBodyCustomizationInfo(int32_t RandomSeed, bool bRandomSex, bool bIsFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.GetRandomDeadBodyCustomizationInfo");
		
		URBPlayerCustomizationConfig_GetRandomDeadBodyCustomizationInfo_Params params {};
		params.RandomSeed = RandomSeed;
		params.bRandomSex = bRandomSex;
		params.bIsFemale = bIsFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.GetRandomCustomizationInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayerCustomizationRarity                         maxRarity                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRandomSex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsFemale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBPlayerCustomizationInfo URBPlayerCustomizationConfig::GetRandomCustomizationInfo(int32_t RandomSeed, EPlayerCustomizationRarity maxRarity, bool bRandomSex, bool bIsFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.GetRandomCustomizationInfo");
		
		URBPlayerCustomizationConfig_GetRandomCustomizationInfo_Params params {};
		params.RandomSeed = RandomSeed;
		params.maxRarity = maxRarity;
		params.bRandomSex = bRandomSex;
		params.bIsFemale = bIsFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.GetRandomAcquiredPlayerIconCustomizationOption
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBPlayerIconCustomizationOption* URBPlayerCustomizationConfig::GetRandomAcquiredPlayerIconCustomizationOption(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.GetRandomAcquiredPlayerIconCustomizationOption");
		
		URBPlayerCustomizationConfig_GetRandomAcquiredPlayerIconCustomizationOption_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.GetRandomAcquiredCustomizationOption
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayerCustomizationSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsFemale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAlwaysAcquiredOnly                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBPlayerCustomizationOption* URBPlayerCustomizationConfig::GetRandomAcquiredCustomizationOption(class ARBPlayerState* RBPlayerState, EPlayerCustomizationSlot Slot, bool bIsFemale, bool bAlwaysAcquiredOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.GetRandomAcquiredCustomizationOption");
		
		URBPlayerCustomizationConfig_GetRandomAcquiredCustomizationOption_Params params {};
		params.RBPlayerState = RBPlayerState;
		params.Slot = Slot;
		params.bIsFemale = bIsFemale;
		params.bAlwaysAcquiredOnly = bAlwaysAcquiredOnly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.GetRandomAcquiredCustomizationInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAlwaysAcquiredOnly                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBPlayerCustomizationInfo URBPlayerCustomizationConfig::GetRandomAcquiredCustomizationInfo(class ARBPlayerState* RBPlayerState, bool bAlwaysAcquiredOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.GetRandomAcquiredCustomizationInfo");
		
		URBPlayerCustomizationConfig_GetRandomAcquiredCustomizationInfo_Params params {};
		params.RBPlayerState = RBPlayerState;
		params.bAlwaysAcquiredOnly = bAlwaysAcquiredOnly;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.GetPlayerIconOption
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBPlayerIconCustomizationOption* URBPlayerCustomizationConfig::GetPlayerIconOption(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.GetPlayerIconOption");
		
		URBPlayerCustomizationConfig_GetPlayerIconOption_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.GetPlayerCustomizationOption
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBPlayerCustomizationOption* URBPlayerCustomizationConfig::GetPlayerCustomizationOption(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.GetPlayerCustomizationOption");
		
		URBPlayerCustomizationConfig_GetPlayerCustomizationOption_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.GetHairColorOption
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBHairColorOption URBPlayerCustomizationConfig::GetHairColorOption(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.GetHairColorOption");
		
		URBPlayerCustomizationConfig_GetHairColorOption_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.GetDefaultPlayerCustomizationInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsFemale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBPlayerCustomizationInfo URBPlayerCustomizationConfig::GetDefaultPlayerCustomizationInfo(bool bIsFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.GetDefaultPlayerCustomizationInfo");
		
		URBPlayerCustomizationConfig_GetDefaultPlayerCustomizationInfo_Params params {};
		params.bIsFemale = bIsFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.GetDefaultCustomizationOption
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerCustomizationSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsFemale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBPlayerCustomizationOption* URBPlayerCustomizationConfig::GetDefaultCustomizationOption(EPlayerCustomizationSlot Slot, bool bIsFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.GetDefaultCustomizationOption");
		
		URBPlayerCustomizationConfig_GetDefaultCustomizationOption_Params params {};
		params.Slot = Slot;
		params.bIsFemale = bIsFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.GetCustomizationOutfit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBCustomizationOutfit* URBPlayerCustomizationConfig::GetCustomizationOutfit(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.GetCustomizationOutfit");
		
		URBPlayerCustomizationConfig_GetCustomizationOutfit_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.GetAllCustomizationOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerCustomizationSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayerCustomizationSexQueryType                   sexQueryType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeLegendaries                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class URBPlayerCustomizationOption*> URBPlayerCustomizationConfig::GetAllCustomizationOptions(EPlayerCustomizationSlot Slot, EPlayerCustomizationSexQueryType sexQueryType, bool bIncludeLegendaries)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.GetAllCustomizationOptions");
		
		URBPlayerCustomizationConfig_GetAllCustomizationOptions_Params params {};
		params.Slot = Slot;
		params.sexQueryType = sexQueryType;
		params.bIncludeLegendaries = bIncludeLegendaries;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.Editor_RebuildAutoGeneratedData
	 * 		Flags  -> ()
	 */
	void URBPlayerCustomizationConfig::Editor_RebuildAutoGeneratedData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.Editor_RebuildAutoGeneratedData");
		
		URBPlayerCustomizationConfig_Editor_RebuildAutoGeneratedData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.Editor_DumpUnusedInventoryItems
	 * 		Flags  -> ()
	 */
	void URBPlayerCustomizationConfig::Editor_DumpUnusedInventoryItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.Editor_DumpUnusedInventoryItems");
		
		URBPlayerCustomizationConfig_Editor_DumpUnusedInventoryItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.Editor_DumpUnmappedItemProgressionData
	 * 		Flags  -> ()
	 */
	void URBPlayerCustomizationConfig::Editor_DumpUnmappedItemProgressionData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.Editor_DumpUnmappedItemProgressionData");
		
		URBPlayerCustomizationConfig_Editor_DumpUnmappedItemProgressionData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.Editor_DumpMismatchedItemProgressionData
	 * 		Flags  -> ()
	 */
	void URBPlayerCustomizationConfig::Editor_DumpMismatchedItemProgressionData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.Editor_DumpMismatchedItemProgressionData");
		
		URBPlayerCustomizationConfig_Editor_DumpMismatchedItemProgressionData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationConfig.Editor_BuildOnlineIds
	 * 		Flags  -> ()
	 */
	void URBPlayerCustomizationConfig::Editor_BuildOnlineIds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationConfig.Editor_BuildOnlineIds");
		
		URBPlayerCustomizationConfig_Editor_BuildOnlineIds_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCustomizationConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCustomizationConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCustomizationConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationOwner.OnExtraCustomizationMeshesAddedForSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class USkeletalMeshComponent*>              addedExtraMeshes                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		EPlayerCustomizationSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerCustomizationOwner::OnExtraCustomizationMeshesAddedForSlot(TArray<class USkeletalMeshComponent*> addedExtraMeshes, EPlayerCustomizationSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationOwner.OnExtraCustomizationMeshesAddedForSlot");
		
		URBPlayerCustomizationOwner_OnExtraCustomizationMeshesAddedForSlot_Params params {};
		params.addedExtraMeshes = addedExtraMeshes;
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationOwner.GetWatchComponent
	 * 		Flags  -> ()
	 */
	class UStaticMeshComponent* URBPlayerCustomizationOwner::GetWatchComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationOwner.GetWatchComponent");
		
		URBPlayerCustomizationOwner_GetWatchComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationOwner.GetSkeletalMeshComponentForSlot
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerCustomizationSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USkeletalMeshComponent* URBPlayerCustomizationOwner::GetSkeletalMeshComponentForSlot(EPlayerCustomizationSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationOwner.GetSkeletalMeshComponentForSlot");
		
		URBPlayerCustomizationOwner_GetSkeletalMeshComponentForSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationOwner.GetPlayerCustomizationInfo
	 * 		Flags  -> ()
	 */
	struct FRBPlayerCustomizationInfo URBPlayerCustomizationOwner::GetPlayerCustomizationInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationOwner.GetPlayerCustomizationInfo");
		
		URBPlayerCustomizationOwner_GetPlayerCustomizationInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerCustomizationOwner.GetMainParentSkeletalMesh
	 * 		Flags  -> ()
	 */
	class USkeletalMeshComponent* URBPlayerCustomizationOwner::GetMainParentSkeletalMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerCustomizationOwner.GetMainParentSkeletalMesh");
		
		URBPlayerCustomizationOwner_GetMainParentSkeletalMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerCustomizationOwner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerCustomizationOwner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerCustomizationOwner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCustomizationFoleyTorsoMaterial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCustomizationFoleyTorsoMaterial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.CustomizationFoleyTorsoMaterial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCustomizationFoleyLegsMaterial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCustomizationFoleyLegsMaterial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.CustomizationFoleyLegsMaterial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCustomizationFoleyFullBodyMaterial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCustomizationFoleyFullBodyMaterial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.CustomizationFoleyFullBodyMaterial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCustomizationFoleyFootMaterial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCustomizationFoleyFootMaterial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.CustomizationFoleyFootMaterial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerDetectionComponent.OnRep_CurrentState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerComponentDetectionState                     oldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerDetectionComponent::OnRep_CurrentState(EPlayerComponentDetectionState oldState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerDetectionComponent.OnRep_CurrentState");
		
		URBPlayerDetectionComponent_OnRep_CurrentState_Params params {};
		params.oldState = oldState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerDetectionComponent.GetCurrentDetectionDistance
	 * 		Flags  -> ()
	 */
	float URBPlayerDetectionComponent::GetCurrentDetectionDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerDetectionComponent.GetCurrentDetectionDistance");
		
		URBPlayerDetectionComponent_GetCurrentDetectionDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerDetectionComponent.GetCurrentDetectionAngle
	 * 		Flags  -> ()
	 */
	float URBPlayerDetectionComponent::GetCurrentDetectionAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerDetectionComponent.GetCurrentDetectionAngle");
		
		URBPlayerDetectionComponent_GetCurrentDetectionAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerDetectionComponent.Event_OnDetectionStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerComponentDetectionState                     oldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayerComponentDetectionState                     newState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerDetectionComponent::Event_OnDetectionStateChanged(EPlayerComponentDetectionState oldState, EPlayerComponentDetectionState newState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerDetectionComponent.Event_OnDetectionStateChanged");
		
		URBPlayerDetectionComponent_Event_OnDetectionStateChanged_Params params {};
		params.oldState = oldState;
		params.newState = newState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerDetectionComponent.BP_SetCurrentState_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerComponentDetectionState                     newState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerDetectionComponent::BP_SetCurrentState_Server(EPlayerComponentDetectionState newState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerDetectionComponent.BP_SetCurrentState_Server");
		
		URBPlayerDetectionComponent_BP_SetCurrentState_Server_Params params {};
		params.newState = newState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerDetectionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerDetectionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerDetectionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerGameSessionManager.OnPartyMemberPlayerSlotsReservationProcessed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FProfileId>                          members                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bAccepted                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerGameSessionManager::OnPartyMemberPlayerSlotsReservationProcessed(TArray<struct FProfileId> members, bool bAccepted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerGameSessionManager.OnPartyMemberPlayerSlotsReservationProcessed");
		
		URBPlayerGameSessionManager_OnPartyMemberPlayerSlotsReservationProcessed_Params params {};
		params.members = members;
		params.bAccepted = bAccepted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerGameSessionManager.IsBusy
	 * 		Flags  -> ()
	 */
	bool URBPlayerGameSessionManager::IsBusy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerGameSessionManager.IsBusy");
		
		URBPlayerGameSessionManager_IsBusy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerGameSessionManager.GetTransitionType
	 * 		Flags  -> ()
	 */
	EPlayerGameSessionTransitionType URBPlayerGameSessionManager::GetTransitionType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerGameSessionManager.GetTransitionType");
		
		URBPlayerGameSessionManager_GetTransitionType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerGameSessionManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerGameSessionManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerGameSessionManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerGameSessionTransitionWidget.OnOutroCompleted
	 * 		Flags  -> ()
	 */
	void URBPlayerGameSessionTransitionWidget::OnOutroCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerGameSessionTransitionWidget.OnOutroCompleted");
		
		URBPlayerGameSessionTransitionWidget_OnOutroCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerGameSessionTransitionWidget.Event_Show
	 * 		Flags  -> ()
	 */
	void URBPlayerGameSessionTransitionWidget::Event_Show()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerGameSessionTransitionWidget.Event_Show");
		
		URBPlayerGameSessionTransitionWidget_Event_Show_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerGameSessionTransitionWidget.Event_Hide
	 * 		Flags  -> ()
	 */
	void URBPlayerGameSessionTransitionWidget::Event_Hide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerGameSessionTransitionWidget.Event_Hide");
		
		URBPlayerGameSessionTransitionWidget_Event_Hide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerGameSessionTransitionWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerGameSessionTransitionWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerGameSessionTransitionWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerInvestigationZoneComponent.Multicast_OnInvestigationDone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   investigator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerInvestigationZoneComponent::Multicast_OnInvestigationDone(class ARBPlayer* investigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerInvestigationZoneComponent.Multicast_OnInvestigationDone");
		
		URBPlayerInvestigationZoneComponent_Multicast_OnInvestigationDone_Params params {};
		params.investigator = investigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerInvestigationZoneComponent.BP_AddSlave_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPlayerInvestigationZoneComponent*         newSlave                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerInvestigationZoneComponent::BP_AddSlave_Server(class URBPlayerInvestigationZoneComponent* newSlave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerInvestigationZoneComponent.BP_AddSlave_Server");
		
		URBPlayerInvestigationZoneComponent_BP_AddSlave_Server_Params params {};
		params.newSlave = newSlave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerInvestigationZoneComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerInvestigationZoneComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerInvestigationZoneComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutConfig.GetActiveSkillCommonParamsById
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FActiveSkillCommonParams URBPlayerLoadoutConfig::GetActiveSkillCommonParamsById(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutConfig.GetActiveSkillCommonParamsById");
		
		URBPlayerLoadoutConfig_GetActiveSkillCommonParamsById_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutConfig.GetActiveSkillCommonParams
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActiveSkillType                                   Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FActiveSkillCommonParams URBPlayerLoadoutConfig::GetActiveSkillCommonParams(EActiveSkillType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutConfig.GetActiveSkillCommonParams");
		
		URBPlayerLoadoutConfig_GetActiveSkillCommonParams_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerLoadoutConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerLoadoutConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerLoadoutConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutManager.UpdatePlayerLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBController*                               RBController                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBPlayerLoadout                            loadout                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerLoadoutManager::UpdatePlayerLoadout(class ARBController* RBController, const struct FRBPlayerLoadout& loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutManager.UpdatePlayerLoadout");
		
		ARBPlayerLoadoutManager_UpdatePlayerLoadout_Params params {};
		params.RBController = RBController;
		params.loadout = loadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutManager.OnPlayerProgressionReceived
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerLoadoutManager::OnPlayerProgressionReceived(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutManager.OnPlayerProgressionReceived");
		
		ARBPlayerLoadoutManager_OnPlayerProgressionReceived_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutManager.IsValidLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBPlayerLoadout                            loadout                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool ARBPlayerLoadoutManager::IsValidLoadout(class ARBPlayerState* RBPlayerState, const struct FRBPlayerLoadout& loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutManager.IsValidLoadout");
		
		ARBPlayerLoadoutManager_IsValidLoadout_Params params {};
		params.RBPlayerState = RBPlayerState;
		params.loadout = loadout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPlayerLoadoutManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPlayerLoadoutManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerLoadoutManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutUIBlueprintLibrary.TogglePerkInMenuLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        itemIdToEquip                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBPlayerLoadoutUIBlueprintLibrary::TogglePerkInMenuLoadout(const class FName& itemIdToEquip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutUIBlueprintLibrary.TogglePerkInMenuLoadout");
		
		URBPlayerLoadoutUIBlueprintLibrary_TogglePerkInMenuLoadout_Params params {};
		params.itemIdToEquip = itemIdToEquip;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutUIBlueprintLibrary.ToggleActiveSkillInMenuloadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActiveSkillType                                   ActiveSkillType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBPlayerLoadoutUIBlueprintLibrary::ToggleActiveSkillInMenuloadout(EActiveSkillType ActiveSkillType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutUIBlueprintLibrary.ToggleActiveSkillInMenuloadout");
		
		URBPlayerLoadoutUIBlueprintLibrary_ToggleActiveSkillInMenuloadout_Params params {};
		params.ActiveSkillType = ActiveSkillType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutUIBlueprintLibrary.InitMenuLoadout
	 * 		Flags  -> ()
	 */
	void URBPlayerLoadoutUIBlueprintLibrary::InitMenuLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutUIBlueprintLibrary.InitMenuLoadout");
		
		URBPlayerLoadoutUIBlueprintLibrary_InitMenuLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutUIBlueprintLibrary.HasAcquiredRig
	 * 		Flags  -> ()
	 */
	bool URBPlayerLoadoutUIBlueprintLibrary::HasAcquiredRig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutUIBlueprintLibrary.HasAcquiredRig");
		
		URBPlayerLoadoutUIBlueprintLibrary_HasAcquiredRig_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutUIBlueprintLibrary.GetUpgradeItemInfoForPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ItemId                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayerState*                              RBPlayerState                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FMenuUpgradeItemInfo URBPlayerLoadoutUIBlueprintLibrary::GetUpgradeItemInfoForPlayer(const class FName& ItemId, class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutUIBlueprintLibrary.GetUpgradeItemInfoForPlayer");
		
		URBPlayerLoadoutUIBlueprintLibrary_GetUpgradeItemInfoForPlayer_Params params {};
		params.ItemId = ItemId;
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutUIBlueprintLibrary.GetUpgradeItemInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ItemId                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FMenuUpgradeItemInfo URBPlayerLoadoutUIBlueprintLibrary::GetUpgradeItemInfo(const class FName& ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutUIBlueprintLibrary.GetUpgradeItemInfo");
		
		URBPlayerLoadoutUIBlueprintLibrary_GetUpgradeItemInfo_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutUIBlueprintLibrary.GetMenuLoadout
	 * 		Flags  -> ()
	 */
	struct FRBPlayerLoadout URBPlayerLoadoutUIBlueprintLibrary::GetMenuLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutUIBlueprintLibrary.GetMenuLoadout");
		
		URBPlayerLoadoutUIBlueprintLibrary_GetMenuLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutUIBlueprintLibrary.GetActiveSkillUpgradeItemInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActiveSkillType                                   ActiveSkillType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FMenuUpgradeItemInfo URBPlayerLoadoutUIBlueprintLibrary::GetActiveSkillUpgradeItemInfo(EActiveSkillType ActiveSkillType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutUIBlueprintLibrary.GetActiveSkillUpgradeItemInfo");
		
		URBPlayerLoadoutUIBlueprintLibrary_GetActiveSkillUpgradeItemInfo_Params params {};
		params.ActiveSkillType = ActiveSkillType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerLoadoutUIBlueprintLibrary.CanEquipPerkInMenuLoadout
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        itemIdToEquip                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBPlayerLoadoutUIBlueprintLibrary::CanEquipPerkInMenuLoadout(const class FName& itemIdToEquip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerLoadoutUIBlueprintLibrary.CanEquipPerkInMenuLoadout");
		
		URBPlayerLoadoutUIBlueprintLibrary_CanEquipPerkInMenuLoadout_Params params {};
		params.itemIdToEquip = itemIdToEquip;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerLoadoutUIBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerLoadoutUIBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerLoadoutUIBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetUnlockInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ItemId                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FItemUnlockInfo URBPlayerProgressionData::GetUnlockInfo(class ARBPlayerState* RBPlayerState, const class FName& ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetUnlockInfo");
		
		URBPlayerProgressionData_GetUnlockInfo_Params params {};
		params.RBPlayerState = RBPlayerState;
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetRewardUIDataFromRewards
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBRewardData                               RewardData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FRewardUIData> URBPlayerProgressionData::GetRewardUIDataFromRewards(class ARBPlayerState* RBPlayerState, const struct FRBRewardData& RewardData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetRewardUIDataFromRewards");
		
		URBPlayerProgressionData_GetRewardUIDataFromRewards_Params params {};
		params.RBPlayerState = RBPlayerState;
		params.RewardData = RewardData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetRewardUIDataFromLevelData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPlayerProgressionLevelData                 levelData                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FRewardUIData> URBPlayerProgressionData::GetRewardUIDataFromLevelData(class ARBPlayerState* RBPlayerState, const struct FPlayerProgressionLevelData& levelData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetRewardUIDataFromLevelData");
		
		URBPlayerProgressionData_GetRewardUIDataFromLevelData_Params params {};
		params.RBPlayerState = RBPlayerState;
		params.levelData = levelData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetRewardUIDataFromGeneratedRewards
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBGeneratedRewardData                      RewardData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FRewardUIData> URBPlayerProgressionData::GetRewardUIDataFromGeneratedRewards(class ARBPlayerState* RBPlayerState, const struct FRBGeneratedRewardData& RewardData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetRewardUIDataFromGeneratedRewards");
		
		URBPlayerProgressionData_GetRewardUIDataFromGeneratedRewards_Params params {};
		params.RBPlayerState = RBPlayerState;
		params.RewardData = RewardData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetRewardsForPlayerLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Level                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBRewardData URBPlayerProgressionData::GetRewardsForPlayerLevel(int32_t Level)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetRewardsForPlayerLevel");
		
		URBPlayerProgressionData_GetRewardsForPlayerLevel_Params params {};
		params.Level = Level;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetRewardPool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        RewardPoolId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBRandomRewardPool URBPlayerProgressionData::GetRewardPool(const class FName& RewardPoolId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetRewardPool");
		
		URBPlayerProgressionData_GetRewardPool_Params params {};
		params.RewardPoolId = RewardPoolId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetRewardData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        RewardDataId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBRewardData URBPlayerProgressionData::GetRewardData(const class FName& RewardDataId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetRewardData");
		
		URBPlayerProgressionData_GetRewardData_Params params {};
		params.RewardDataId = RewardDataId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetPlayerUpgradeEffectSetting
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        EffectId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        settingId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DefaultValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBPlayerProgressionData::GetPlayerUpgradeEffectSetting(const class FName& EffectId, const class FName& settingId, float DefaultValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetPlayerUpgradeEffectSetting");
		
		URBPlayerProgressionData_GetPlayerUpgradeEffectSetting_Params params {};
		params.EffectId = EffectId;
		params.settingId = settingId;
		params.DefaultValue = DefaultValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetPlayerUpgradeEffectData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        EffectId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBPlayerUpgradeEffectData URBPlayerProgressionData::GetPlayerUpgradeEffectData(const class FName& EffectId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetPlayerUpgradeEffectData");
		
		URBPlayerProgressionData_GetPlayerUpgradeEffectData_Params params {};
		params.EffectId = EffectId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetPlayerLevelRequiredXP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Level                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBPlayerProgressionData::GetPlayerLevelRequiredXP(int32_t Level)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetPlayerLevelRequiredXP");
		
		URBPlayerProgressionData_GetPlayerLevelRequiredXP_Params params {};
		params.Level = Level;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetPerkSlotRequiredLevel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            perkSlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBPlayerProgressionData::GetPerkSlotRequiredLevel(int32_t perkSlotIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetPerkSlotRequiredLevel");
		
		URBPlayerProgressionData_GetPerkSlotRequiredLevel_Params params {};
		params.perkSlotIndex = perkSlotIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetMaxPlayerLevel
	 * 		Flags  -> ()
	 */
	int32_t URBPlayerProgressionData::GetMaxPlayerLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetMaxPlayerLevel");
		
		URBPlayerProgressionData_GetMaxPlayerLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetLevelingData
	 * 		Flags  -> ()
	 */
	struct FPlayerProgressionLevelingData URBPlayerProgressionData::GetLevelingData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetLevelingData");
		
		URBPlayerProgressionData_GetLevelingData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetItemProgressionData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ItemId                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bValidateFeatureSwitch                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBItemProgressionData URBPlayerProgressionData::GetItemProgressionData(const class FName& ItemId, bool bValidateFeatureSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetItemProgressionData");
		
		URBPlayerProgressionData_GetItemProgressionData_Params params {};
		params.ItemId = ItemId;
		params.bValidateFeatureSwitch = bValidateFeatureSwitch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetBadges
	 * 		Flags  -> ()
	 */
	TArray<struct FRBPlayerBadgeRow> URBPlayerProgressionData::GetBadges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetBadges");
		
		URBPlayerProgressionData_GetBadges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetBadge
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        BadgeId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBPlayerBadgeRow URBPlayerProgressionData::GetBadge(const class FName& BadgeId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetBadge");
		
		URBPlayerProgressionData_GetBadge_Params params {};
		params.BadgeId = BadgeId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.GetActiveSkillSettings
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EActiveSkillType                                   ActiveSkillType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBActiveSkillSettings URBPlayerProgressionData::GetActiveSkillSettings(EActiveSkillType ActiveSkillType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.GetActiveSkillSettings");
		
		URBPlayerProgressionData_GetActiveSkillSettings_Params params {};
		params.ActiveSkillType = ActiveSkillType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.FilterItemProgressionDataIds
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemProgressionCategory                           Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EActiveSkillType                                   AssociatedActiveSkillType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EProfileUpgradeCategory                            ProfileUpgradeCategory                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Rank                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterAvailable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class FName> URBPlayerProgressionData::FilterItemProgressionDataIds(EItemProgressionCategory Category, EActiveSkillType AssociatedActiveSkillType, EProfileUpgradeCategory ProfileUpgradeCategory, int32_t Rank, bool bFilterAvailable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.FilterItemProgressionDataIds");
		
		URBPlayerProgressionData_FilterItemProgressionDataIds_Params params {};
		params.Category = Category;
		params.AssociatedActiveSkillType = AssociatedActiveSkillType;
		params.ProfileUpgradeCategory = ProfileUpgradeCategory;
		params.Rank = Rank;
		params.bFilterAvailable = bFilterAvailable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionData.FilterItemProgressionData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemProgressionCategory                           Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EActiveSkillType                                   AssociatedActiveSkillType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EProfileUpgradeCategory                            ProfileUpgradeCategory                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Rank                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterAvailable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FRBItemProgressionData> URBPlayerProgressionData::FilterItemProgressionData(EItemProgressionCategory Category, EActiveSkillType AssociatedActiveSkillType, EProfileUpgradeCategory ProfileUpgradeCategory, int32_t Rank, bool bFilterAvailable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionData.FilterItemProgressionData");
		
		URBPlayerProgressionData_FilterItemProgressionData_Params params {};
		params.Category = Category;
		params.AssociatedActiveSkillType = AssociatedActiveSkillType;
		params.ProfileUpgradeCategory = ProfileUpgradeCategory;
		params.Rank = Rank;
		params.bFilterAvailable = bFilterAvailable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerProgressionData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerProgressionData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerProgressionData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerProgressionManager.CanReleaseCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBController*                               RBController                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBPlayerProgressionManager::CanReleaseCharacter(class ARBController* RBController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerProgressionManager.CanReleaseCharacter");
		
		ARBPlayerProgressionManager_CanReleaseCharacter_Params params {};
		params.RBController = RBController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPlayerProgressionManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPlayerProgressionManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerProgressionManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerRespawner.OnRespawnTransitionFinished
	 * 		Flags  -> ()
	 */
	void ARBPlayerRespawner::OnRespawnTransitionFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerRespawner.OnRespawnTransitionFinished");
		
		ARBPlayerRespawner_OnRespawnTransitionFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerRespawner.OnRep_OnStateChanged
	 * 		Flags  -> ()
	 */
	void ARBPlayerRespawner::OnRep_OnStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerRespawner.OnRep_OnStateChanged");
		
		ARBPlayerRespawner_OnRep_OnStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerRespawner.IsInUse
	 * 		Flags  -> ()
	 */
	bool ARBPlayerRespawner::IsInUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerRespawner.IsInUse");
		
		ARBPlayerRespawner_IsInUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerRespawner.Event_OnStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERespawnerState                                    newState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerRespawner::Event_OnStateChanged(ERespawnerState newState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerRespawner.Event_OnStateChanged");
		
		ARBPlayerRespawner_Event_OnStateChanged_Params params {};
		params.newState = newState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerRespawner.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerRespawner::BP_SetEnabled(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerRespawner.BP_SetEnabled");
		
		ARBPlayerRespawner_BP_SetEnabled_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerRespawner.BP_OnDoorOpened
	 * 		Flags  -> ()
	 */
	void ARBPlayerRespawner::BP_OnDoorOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerRespawner.BP_OnDoorOpened");
		
		ARBPlayerRespawner_BP_OnDoorOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerRespawner.BP_OnDoorClosed
	 * 		Flags  -> ()
	 */
	void ARBPlayerRespawner::BP_OnDoorClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerRespawner.BP_OnDoorClosed");
		
		ARBPlayerRespawner_BP_OnDoorClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPlayerRespawner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPlayerRespawner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerRespawner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerSeparatorVolume.OnRep_PlayerInside
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   oldPlayerInside                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerSeparatorVolume::OnRep_PlayerInside(class ARBPlayer* oldPlayerInside)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerSeparatorVolume.OnRep_PlayerInside");
		
		ARBPlayerSeparatorVolume_OnRep_PlayerInside_Params params {};
		params.oldPlayerInside = oldPlayerInside;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerSeparatorVolume.OnEndActorOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerSeparatorVolume::OnEndActorOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerSeparatorVolume.OnEndActorOverlap");
		
		ARBPlayerSeparatorVolume_OnEndActorOverlap_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerSeparatorVolume.OnBeginActorOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPlayerSeparatorVolume::OnBeginActorOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerSeparatorVolume.OnBeginActorOverlap");
		
		ARBPlayerSeparatorVolume_OnBeginActorOverlap_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPlayerSeparatorVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPlayerSeparatorVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerSeparatorVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerSkelMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerSkelMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerSkelMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerSoundDetectionComponent.OnRep_CurrentState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerSoundDetectionState                         oldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerSoundDetectionComponent::OnRep_CurrentState(EPlayerSoundDetectionState oldState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerSoundDetectionComponent.OnRep_CurrentState");
		
		URBPlayerSoundDetectionComponent_OnRep_CurrentState_Params params {};
		params.oldState = oldState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerSoundDetectionComponent.OnRep_CurrentDetectionMeter
	 * 		Flags  -> ()
	 */
	void URBPlayerSoundDetectionComponent::OnRep_CurrentDetectionMeter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerSoundDetectionComponent.OnRep_CurrentDetectionMeter");
		
		URBPlayerSoundDetectionComponent_OnRep_CurrentDetectionMeter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerSoundDetectionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerSoundDetectionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerSoundDetectionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerSpawnPoint.ShouldActivateNV
	 * 		Flags  -> ()
	 */
	bool URBPlayerSpawnPoint::ShouldActivateNV()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerSpawnPoint.ShouldActivateNV");
		
		URBPlayerSpawnPoint_ShouldActivateNV_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerSpawnPoint.GetSpawnPointTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     OutPosition                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    OutRotation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBPlayerSpawnPoint::GetSpawnPointTransform(struct FVector* OutPosition, struct FRotator* OutRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerSpawnPoint.GetSpawnPointTransform");
		
		URBPlayerSpawnPoint_GetSpawnPointTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPosition != nullptr)
			*OutPosition = params.OutPosition;
		if (OutRotation != nullptr)
			*OutRotation = params.OutRotation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerSpawnPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerSpawnPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerSpawnPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPlayerStart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPlayerStart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerStart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPlayerStartDynamic.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPlayerStartDynamic::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerStartDynamic");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerStatsConfig.GetPlayerStatConfigById
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBPlayerStatConfig URBPlayerStatsConfig::GetPlayerStatConfigById(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerStatsConfig.GetPlayerStatConfigById");
		
		URBPlayerStatsConfig_GetPlayerStatConfigById_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerStatsConfig.GetPlayerStatConfig
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerStat                                        PlayerStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBPlayerStatConfig URBPlayerStatsConfig::GetPlayerStatConfig(EPlayerStat PlayerStat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerStatsConfig.GetPlayerStatConfig");
		
		URBPlayerStatsConfig_GetPlayerStatConfig_Params params {};
		params.PlayerStat = PlayerStat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerStatsConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerStatsConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerStatsConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerStatsTabWidget.OnPlayerStatsDataAvailable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRBStatContext>                      stats                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FRBUIReleasedCharacterDetails>       releasedCharacterDetailsList                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBPlayerStatsTabWidget::OnPlayerStatsDataAvailable(TArray<struct FRBStatContext> stats, TArray<struct FRBUIReleasedCharacterDetails> releasedCharacterDetailsList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerStatsTabWidget.OnPlayerStatsDataAvailable");
		
		URBPlayerStatsTabWidget_OnPlayerStatsDataAvailable_Params params {};
		params.stats = stats;
		params.releasedCharacterDetailsList = releasedCharacterDetailsList;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerStatsTabWidget.IsDataPending
	 * 		Flags  -> ()
	 */
	bool URBPlayerStatsTabWidget::IsDataPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerStatsTabWidget.IsDataPending");
		
		URBPlayerStatsTabWidget_IsDataPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerStatsTabWidget.GetStats
	 * 		Flags  -> ()
	 */
	TArray<struct FRBStatContext> URBPlayerStatsTabWidget::GetStats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerStatsTabWidget.GetStats");
		
		URBPlayerStatsTabWidget_GetStats_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerStatsTabWidget.GetReleasedCharacterDetailsList
	 * 		Flags  -> ()
	 */
	TArray<struct FRBUIReleasedCharacterDetails> URBPlayerStatsTabWidget::GetReleasedCharacterDetailsList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerStatsTabWidget.GetReleasedCharacterDetailsList");
		
		URBPlayerStatsTabWidget_GetReleasedCharacterDetailsList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerStatsTabWidget.GetGlobalStatValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerStat                                        PlayerStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBPlayerStatsTabWidget::GetGlobalStatValue(EPlayerStat PlayerStat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerStatsTabWidget.GetGlobalStatValue");
		
		URBPlayerStatsTabWidget_GetGlobalStatValue_Params params {};
		params.PlayerStat = PlayerStat;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerStatsTabWidget.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBPlayerStatsTabWidget::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerStatsTabWidget.Event_Refresh");
		
		URBPlayerStatsTabWidget_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerStatsTabWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerStatsTabWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerStatsTabWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerTriggerCondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerTriggerCondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.PlayerTriggerCondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAllPlayerPlayerTriggerCondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAllPlayerPlayerTriggerCondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.AllPlayerPlayerTriggerCondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHalfOfAllPlayerPlayerTriggerCondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHalfOfAllPlayerPlayerTriggerCondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.HalfOfAllPlayerPlayerTriggerCondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpecificNumberOfPlayerPlayerTriggerCondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpecificNumberOfPlayerPlayerTriggerCondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.SpecificNumberOfPlayerPlayerTriggerCondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerComponent.OnPlayerRevived
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   instigatorActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   subjectActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerTriggerComponent::OnPlayerRevived(class ARBPlayer* instigatorActor, class ARBPlayer* subjectActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerComponent.OnPlayerRevived");
		
		URBPlayerTriggerComponent_OnPlayerRevived_Params params {};
		params.instigatorActor = instigatorActor;
		params.subjectActor = subjectActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerComponent.OnPawnRespawned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerTriggerComponent::OnPawnRespawned(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerComponent.OnPawnRespawned");
		
		URBPlayerTriggerComponent_OnPawnRespawned_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerComponent.OnPawnKilled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     instigatorActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     subjectActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerTriggerComponent::OnPawnKilled(class ARBPawn* instigatorActor, class ARBPawn* subjectActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerComponent.OnPawnKilled");
		
		URBPlayerTriggerComponent_OnPawnKilled_Params params {};
		params.instigatorActor = instigatorActor;
		params.subjectActor = subjectActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerComponent.OnComponentEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerTriggerComponent::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerComponent.OnComponentEndOverlap");
		
		URBPlayerTriggerComponent_OnComponentEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerComponent.OnComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBPlayerTriggerComponent::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerComponent.OnComponentBeginOverlap");
		
		URBPlayerTriggerComponent_OnComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerComponent.OnActorOverlapped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerTriggerComponent::OnActorOverlapped(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerComponent.OnActorOverlapped");
		
		URBPlayerTriggerComponent_OnActorOverlapped_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerComponent.OnActorLeft
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPlayerTriggerComponent::OnActorLeft(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerComponent.OnActorLeft");
		
		URBPlayerTriggerComponent_OnActorLeft_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPlayerTriggerComponent.IsEnabled
	 * 		Flags  -> ()
	 */
	bool URBPlayerTriggerComponent::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPlayerTriggerComponent.IsEnabled");
		
		URBPlayerTriggerComponent_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPlayerTriggerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPlayerTriggerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPlayerTriggerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPolicyDocumentMenuWidget.Event_Setup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Content                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPolicyDocumentMenuWidget::Event_Setup(const class FString& Content)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPolicyDocumentMenuWidget.Event_Setup");
		
		URBPolicyDocumentMenuWidget_Event_Setup_Params params {};
		params.Content = Content;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPolicyDocumentMenuWidget.Accept
	 * 		Flags  -> ()
	 */
	void URBPolicyDocumentMenuWidget::Accept()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPolicyDocumentMenuWidget.Accept");
		
		URBPolicyDocumentMenuWidget_Accept_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPolicyDocumentMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPolicyDocumentMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPolicyDocumentMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPopUpAnchorWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPopUpAnchorWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPopUpAnchorWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpConfirmCancelWidget.Event_InitializePopup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        TitleText                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        MainText                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        ConfirmText                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        CancelText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBPopUpConfirmCancelWidget::Event_InitializePopup(const class FText& TitleText, const class FText& MainText, const class FText& ConfirmText, const class FText& CancelText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpConfirmCancelWidget.Event_InitializePopup");
		
		URBPopUpConfirmCancelWidget_Event_InitializePopup_Params params {};
		params.TitleText = TitleText;
		params.MainText = MainText;
		params.ConfirmText = ConfirmText;
		params.CancelText = CancelText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpConfirmCancelWidget.BP_Confirm
	 * 		Flags  -> ()
	 */
	void URBPopUpConfirmCancelWidget::BP_Confirm()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpConfirmCancelWidget.BP_Confirm");
		
		URBPopUpConfirmCancelWidget_BP_Confirm_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpConfirmCancelWidget.BP_Cancel
	 * 		Flags  -> ()
	 */
	void URBPopUpConfirmCancelWidget::BP_Cancel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpConfirmCancelWidget.BP_Cancel");
		
		URBPopUpConfirmCancelWidget_BP_Cancel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPopUpConfirmCancelWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPopUpConfirmCancelWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPopUpConfirmCancelWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpWaitWidget.Event_InitializePopup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        TitleText                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        MainText                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBPopUpWaitWidget::Event_InitializePopup(const class FText& TitleText, const class FText& MainText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpWaitWidget.Event_InitializePopup");
		
		URBPopUpWaitWidget_Event_InitializePopup_Params params {};
		params.TitleText = TitleText;
		params.MainText = MainText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpWaitWidget.BP_EndWait
	 * 		Flags  -> ()
	 */
	void URBPopUpWaitWidget::BP_EndWait()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpWaitWidget.BP_EndWait");
		
		URBPopUpWaitWidget_BP_EndWait_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPopUpWaitWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPopUpWaitWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPopUpWaitWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpInputTextWidget.Event_InitializePopup
	 * 		Flags  -> ()
	 */
	void URBPopUpInputTextWidget::Event_InitializePopup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpInputTextWidget.Event_InitializePopup");
		
		URBPopUpInputTextWidget_Event_InitializePopup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpInputTextWidget.BP_OnTextEntered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPopUpInputTextWidget::BP_OnTextEntered(const class FString& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpInputTextWidget.BP_OnTextEntered");
		
		URBPopUpInputTextWidget_BP_OnTextEntered_Params params {};
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPopUpInputTextWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPopUpInputTextWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPopUpInputTextWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpBlueprintLibrary.CreatePopUpWait
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      WidgetType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        TitleText                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		class FText                                        MainText                                                   (Parm, NativeAccessSpecifierPublic)
	 */
	class URBPopUpWaitWidget* URBPopUpBlueprintLibrary::CreatePopUpWait(class UObject* WorldContextObject, class UClass* WidgetType, const class FText& TitleText, const class FText& MainText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpBlueprintLibrary.CreatePopUpWait");
		
		URBPopUpBlueprintLibrary_CreatePopUpWait_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.WidgetType = WidgetType;
		params.TitleText = TitleText;
		params.MainText = MainText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpBlueprintLibrary.CreatePopUpInputText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      WidgetType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBPopUpInputTextWidget* URBPopUpBlueprintLibrary::CreatePopUpInputText(class UObject* WorldContextObject, class UClass* WidgetType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpBlueprintLibrary.CreatePopUpInputText");
		
		URBPopUpBlueprintLibrary_CreatePopUpInputText_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.WidgetType = WidgetType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpBlueprintLibrary.CreatePopUpConfirmCancel
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      WidgetType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        TitleText                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		class FText                                        MainText                                                   (Parm, NativeAccessSpecifierPublic)
	 * 		class FText                                        ConfirmText                                                (Parm, NativeAccessSpecifierPublic)
	 * 		class FText                                        CancelText                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	class URBPopUpConfirmCancelWidget* URBPopUpBlueprintLibrary::CreatePopUpConfirmCancel(class UObject* WorldContextObject, class UClass* WidgetType, const class FText& TitleText, const class FText& MainText, const class FText& ConfirmText, const class FText& CancelText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpBlueprintLibrary.CreatePopUpConfirmCancel");
		
		URBPopUpBlueprintLibrary_CreatePopUpConfirmCancel_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.WidgetType = WidgetType;
		params.TitleText = TitleText;
		params.MainText = MainText;
		params.ConfirmText = ConfirmText;
		params.CancelText = CancelText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPopUpBlueprintLibrary.CreatePopUpConfirm
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      WidgetType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        TitleText                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		class FText                                        MainText                                                   (Parm, NativeAccessSpecifierPublic)
	 * 		class FText                                        ConfirmText                                                (Parm, NativeAccessSpecifierPublic)
	 */
	class URBPopUpConfirmWidget* URBPopUpBlueprintLibrary::CreatePopUpConfirm(class UObject* WorldContextObject, class UClass* WidgetType, const class FText& TitleText, const class FText& MainText, const class FText& ConfirmText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPopUpBlueprintLibrary.CreatePopUpConfirm");
		
		URBPopUpBlueprintLibrary_CreatePopUpConfirm_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.WidgetType = WidgetType;
		params.TitleText = TitleText;
		params.MainText = MainText;
		params.ConfirmText = ConfirmText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPopUpBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPopUpBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPopUpBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPosedDeadBody.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPosedDeadBody::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPosedDeadBody");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPositionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPositionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPositionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPositionMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPositionMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPositionMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPostProcessSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPostProcessSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPostProcessSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPostProcessUpdateManager.OnExitNightVision
	 * 		Flags  -> ()
	 */
	void ARBPostProcessUpdateManager::OnExitNightVision()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPostProcessUpdateManager.OnExitNightVision");
		
		ARBPostProcessUpdateManager_OnExitNightVision_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPostProcessUpdateManager.OnEnterNightVision
	 * 		Flags  -> ()
	 */
	void ARBPostProcessUpdateManager::OnEnterNightVision()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPostProcessUpdateManager.OnEnterNightVision");
		
		ARBPostProcessUpdateManager_OnEnterNightVision_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPostProcessUpdateManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPostProcessUpdateManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPostProcessUpdateManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.OnUnlockingButtonStateChanged_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBCoopOperatableComponent*                  Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPressurePanelComponent::OnUnlockingButtonStateChanged_Server(class URBCoopOperatableComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.OnUnlockingButtonStateChanged_Server");
		
		URBPressurePanelComponent_OnUnlockingButtonStateChanged_Server_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.OnRep_ValveType
	 * 		Flags  -> ()
	 */
	void URBPressurePanelComponent::OnRep_ValveType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.OnRep_ValveType");
		
		URBPressurePanelComponent_OnRep_ValveType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.OnRep_Locked
	 * 		Flags  -> ()
	 */
	void URBPressurePanelComponent::OnRep_Locked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.OnRep_Locked");
		
		URBPressurePanelComponent_OnRep_Locked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.OnRep_LastInputHeldStartedPawnTime
	 * 		Flags  -> ()
	 */
	void URBPressurePanelComponent::OnRep_LastInputHeldStartedPawnTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.OnRep_LastInputHeldStartedPawnTime");
		
		URBPressurePanelComponent_OnRep_LastInputHeldStartedPawnTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.OnRep_InputRatioTarget
	 * 		Flags  -> ()
	 */
	void URBPressurePanelComponent::OnRep_InputRatioTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.OnRep_InputRatioTarget");
		
		URBPressurePanelComponent_OnRep_InputRatioTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.OnRep_InputRatioInZone
	 * 		Flags  -> ()
	 */
	void URBPressurePanelComponent::OnRep_InputRatioInZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.OnRep_InputRatioInZone");
		
		URBPressurePanelComponent_OnRep_InputRatioInZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.OnRep_InputHeld
	 * 		Flags  -> ()
	 */
	void URBPressurePanelComponent::OnRep_InputHeld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.OnRep_InputHeld");
		
		URBPressurePanelComponent_OnRep_InputHeld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.OnRep_CurrentMeter
	 * 		Flags  -> ()
	 */
	void URBPressurePanelComponent::OnRep_CurrentMeter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.OnRep_CurrentMeter");
		
		URBPressurePanelComponent_OnRep_CurrentMeter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.OnRep_CurrentInputRatio
	 * 		Flags  -> ()
	 */
	void URBPressurePanelComponent::OnRep_CurrentInputRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.OnRep_CurrentInputRatio");
		
		URBPressurePanelComponent_OnRep_CurrentInputRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.Multicast_OnPanelSucceeded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPressurePanelComponent::Multicast_OnPanelSucceeded(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.Multicast_OnPanelSucceeded");
		
		URBPressurePanelComponent_Multicast_OnPanelSucceeded_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.LastInputHeldStartedPawnTimeChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPressurePanelComponent::LastInputHeldStartedPawnTimeChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.LastInputHeldStartedPawnTimeChangedCallback");
		
		URBPressurePanelComponent_LastInputHeldStartedPawnTimeChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.IsCompleted
	 * 		Flags  -> ()
	 */
	bool URBPressurePanelComponent::IsCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.IsCompleted");
		
		URBPressurePanelComponent_IsCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.InputRatioInZoneChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPressurePanelComponent::InputRatioInZoneChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.InputRatioInZoneChangedCallback");
		
		URBPressurePanelComponent_InputRatioInZoneChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.InputHeldChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPressurePanelComponent::InputHeldChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.InputHeldChangedCallback");
		
		URBPressurePanelComponent_InputHeldChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.GetUnlockedTimeLeftRatio
	 * 		Flags  -> ()
	 */
	float URBPressurePanelComponent::GetUnlockedTimeLeftRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.GetUnlockedTimeLeftRatio");
		
		URBPressurePanelComponent_GetUnlockedTimeLeftRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.GetCurrentMeterRatio
	 * 		Flags  -> ()
	 */
	float URBPressurePanelComponent::GetCurrentMeterRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.GetCurrentMeterRatio");
		
		URBPressurePanelComponent_GetCurrentMeterRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPressurePanelComponent.CurrentInputRatioChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPressurePanelComponent::CurrentInputRatioChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPressurePanelComponent.CurrentInputRatioChangedCallback");
		
		URBPressurePanelComponent_CurrentInputRatioChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPressurePanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPressurePanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPressurePanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBProfilingLocation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBProfilingLocation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBProfilingLocation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPropOptimizerComponent.SetTickEnabledOnProps
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPropOptimizerComponent::SetTickEnabledOnProps(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPropOptimizerComponent.SetTickEnabledOnProps");
		
		URBPropOptimizerComponent_SetTickEnabledOnProps_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPropOptimizerComponent.SetOptimEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPropOptimizerComponent::SetOptimEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPropOptimizerComponent.SetOptimEnabled");
		
		URBPropOptimizerComponent_SetOptimEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPropOptimizerComponent.SetForceUpdateAnims
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bForced                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPropOptimizerComponent::SetForceUpdateAnims(bool bForced)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPropOptimizerComponent.SetForceUpdateAnims");
		
		URBPropOptimizerComponent_SetForceUpdateAnims_Params params {};
		params.bForced = bForced;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPropOptimizerComponent.SetCustomControlledMeshes
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class UPrimitiveComponent*>                 controlledMeshes                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBPropOptimizerComponent::SetCustomControlledMeshes(TArray<class UPrimitiveComponent*> controlledMeshes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPropOptimizerComponent.SetCustomControlledMeshes");
		
		URBPropOptimizerComponent_SetCustomControlledMeshes_Params params {};
		params.controlledMeshes = controlledMeshes;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPropOptimizerComponent.RecomputeControlledComponents
	 * 		Flags  -> ()
	 */
	void URBPropOptimizerComponent::RecomputeControlledComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPropOptimizerComponent.RecomputeControlledComponents");
		
		URBPropOptimizerComponent_RecomputeControlledComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPropOptimizerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPropOptimizerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPropOptimizerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectableComponent.OnRep_ProgressLevel
	 * 		Flags  -> ()
	 */
	void URBProximityDetectableComponent::OnRep_ProgressLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectableComponent.OnRep_ProgressLevel");
		
		URBProximityDetectableComponent_OnRep_ProgressLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectableComponent.OnRep_ProgressCompleted
	 * 		Flags  -> ()
	 */
	void URBProximityDetectableComponent::OnRep_ProgressCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectableComponent.OnRep_ProgressCompleted");
		
		URBProximityDetectableComponent_OnRep_ProgressCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectableComponent.OnRep_ProgressActive
	 * 		Flags  -> ()
	 */
	void URBProximityDetectableComponent::OnRep_ProgressActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectableComponent.OnRep_ProgressActive");
		
		URBProximityDetectableComponent_OnRep_ProgressActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectableComponent.OnRep_IsProgressLocked
	 * 		Flags  -> ()
	 */
	void URBProximityDetectableComponent::OnRep_IsProgressLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectableComponent.OnRep_IsProgressLocked");
		
		URBProximityDetectableComponent_OnRep_IsProgressLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectableComponent.OnRep_Detectors
	 * 		Flags  -> ()
	 */
	void URBProximityDetectableComponent::OnRep_Detectors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectableComponent.OnRep_Detectors");
		
		URBProximityDetectableComponent_OnRep_Detectors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectableComponent.OnRep_Active
	 * 		Flags  -> ()
	 */
	void URBProximityDetectableComponent::OnRep_Active()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectableComponent.OnRep_Active");
		
		URBProximityDetectableComponent_OnRep_Active_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectableComponent.OnRefreshLight
	 * 		Flags  -> ()
	 */
	void URBProximityDetectableComponent::OnRefreshLight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectableComponent.OnRefreshLight");
		
		URBProximityDetectableComponent_OnRefreshLight_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectableComponent.OnProgressLockedChanged
	 * 		Flags  -> ()
	 */
	void URBProximityDetectableComponent::OnProgressLockedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectableComponent.OnProgressLockedChanged");
		
		URBProximityDetectableComponent_OnProgressLockedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectableComponent.IsProgressLocked
	 * 		Flags  -> ()
	 */
	bool URBProximityDetectableComponent::IsProgressLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectableComponent.IsProgressLocked");
		
		URBProximityDetectableComponent_IsProgressLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectableComponent.GetProgressRatio
	 * 		Flags  -> ()
	 */
	float URBProximityDetectableComponent::GetProgressRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectableComponent.GetProgressRatio");
		
		URBProximityDetectableComponent_GetProgressRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectableComponent.BP_ShouldTick
	 * 		Flags  -> ()
	 */
	bool URBProximityDetectableComponent::BP_ShouldTick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectableComponent.BP_ShouldTick");
		
		URBProximityDetectableComponent_BP_ShouldTick_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectableComponent.BP_SetIsProgressLocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBProximityDetectableComponent::BP_SetIsProgressLocked(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectableComponent.BP_SetIsProgressLocked");
		
		URBProximityDetectableComponent_BP_SetIsProgressLocked_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectableComponent.BP_SetActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewActive                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBProximityDetectableComponent::BP_SetActive(bool bNewActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectableComponent.BP_SetActive");
		
		URBProximityDetectableComponent_BP_SetActive_Params params {};
		params.bNewActive = bNewActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBProximityDetectableComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBProximityDetectableComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBProximityDetectableComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectionObjectiveCoordinator.SetShowProximityTriggerIconsVisible_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBProximityDetectionObjectiveCoordinator::SetShowProximityTriggerIconsVisible_Server(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectionObjectiveCoordinator.SetShowProximityTriggerIconsVisible_Server");
		
		ARBProximityDetectionObjectiveCoordinator_SetShowProximityTriggerIconsVisible_Server_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectionObjectiveCoordinator.SetShowProximityDetectorIconsVisible_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBProximityDetectionObjectiveCoordinator::SetShowProximityDetectorIconsVisible_Server(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectionObjectiveCoordinator.SetShowProximityDetectorIconsVisible_Server");
		
		ARBProximityDetectionObjectiveCoordinator_SetShowProximityDetectorIconsVisible_Server_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectionObjectiveCoordinator.OnRep_ShowProximityTriggerIcons
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectionObjectiveCoordinator::OnRep_ShowProximityTriggerIcons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectionObjectiveCoordinator.OnRep_ShowProximityTriggerIcons");
		
		ARBProximityDetectionObjectiveCoordinator_OnRep_ShowProximityTriggerIcons_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectionObjectiveCoordinator.OnRep_ShowProximityDetectorIcons
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectionObjectiveCoordinator::OnRep_ShowProximityDetectorIcons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectionObjectiveCoordinator.OnRep_ShowProximityDetectorIcons");
		
		ARBProximityDetectionObjectiveCoordinator_OnRep_ShowProximityDetectorIcons_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectionObjectiveCoordinator.OnProximityProgressCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBProximityDetectableComponent*             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBProximityDetectionObjectiveCoordinator::OnProximityProgressCompleted(class URBProximityDetectableComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectionObjectiveCoordinator.OnProximityProgressCompleted");
		
		ARBProximityDetectionObjectiveCoordinator_OnProximityProgressCompleted_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBProximityDetectionObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBProximityDetectionObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBProximityDetectionObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.OnRep_ProximityZLevelState
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::OnRep_ProximityZLevelState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.OnRep_ProximityZLevelState");
		
		ARBProximityDetectorItem_OnRep_ProximityZLevelState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.OnRep_ProximityLevel
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::OnRep_ProximityLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.OnRep_ProximityLevel");
		
		ARBProximityDetectorItem_OnRep_ProximityLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.OnRep_ProximityComponentDetected
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::OnRep_ProximityComponentDetected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.OnRep_ProximityComponentDetected");
		
		ARBProximityDetectorItem_OnRep_ProximityComponentDetected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.OnRep_DetectorState
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::OnRep_DetectorState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.OnRep_DetectorState");
		
		ARBProximityDetectorItem_OnRep_DetectorState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.OnRep_ButtonHeld
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::OnRep_ButtonHeld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.OnRep_ButtonHeld");
		
		ARBProximityDetectorItem_OnRep_ButtonHeld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.OnProximityComponentDetectedChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBProximityDetectorItem::OnProximityComponentDetectedChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.OnProximityComponentDetectedChangedCallback");
		
		ARBProximityDetectorItem_OnProximityComponentDetectedChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.OnDetectorStateChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBProximityDetectorItem::OnDetectorStateChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.OnDetectorStateChangedCallback");
		
		ARBProximityDetectorItem_OnDetectorStateChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.OnButtonHeldChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBProximityDetectorItem::OnButtonHeldChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.OnButtonHeldChangedCallback");
		
		ARBProximityDetectorItem_OnButtonHeldChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.Multicast_OnCompletedLevel
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::Multicast_OnCompletedLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.Multicast_OnCompletedLevel");
		
		ARBProximityDetectorItem_Multicast_OnCompletedLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.IsHoldingButton
	 * 		Flags  -> ()
	 */
	bool ARBProximityDetectorItem::IsHoldingButton()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.IsHoldingButton");
		
		ARBProximityDetectorItem_IsHoldingButton_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.GetProximityZLevelState
	 * 		Flags  -> ()
	 */
	EProximityDetectorZLevelState ARBProximityDetectorItem::GetProximityZLevelState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.GetProximityZLevelState");
		
		ARBProximityDetectorItem_GetProximityZLevelState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.GetProximityLevel
	 * 		Flags  -> ()
	 */
	int32_t ARBProximityDetectorItem::GetProximityLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.GetProximityLevel");
		
		ARBProximityDetectorItem_GetProximityLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.GetProximityComponentDetected
	 * 		Flags  -> ()
	 */
	class URBProximityDetectableComponent* ARBProximityDetectorItem::GetProximityComponentDetected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.GetProximityComponentDetected");
		
		ARBProximityDetectorItem_GetProximityComponentDetected_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.GetDeviceType
	 * 		Flags  -> ()
	 */
	EProximityDetectorDeviceType ARBProximityDetectorItem::GetDeviceType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.GetDeviceType");
		
		ARBProximityDetectorItem_GetDeviceType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.BP_OnUnequipped
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::BP_OnUnequipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.BP_OnUnequipped");
		
		ARBProximityDetectorItem_BP_OnUnequipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.BP_OnProximityStateChanged
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::BP_OnProximityStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.BP_OnProximityStateChanged");
		
		ARBProximityDetectorItem_BP_OnProximityStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.BP_OnProximityLevelChanged
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::BP_OnProximityLevelChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.BP_OnProximityLevelChanged");
		
		ARBProximityDetectorItem_BP_OnProximityLevelChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.BP_OnProgressChanged
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::BP_OnProgressChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.BP_OnProgressChanged");
		
		ARBProximityDetectorItem_BP_OnProgressChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.BP_OnHoldStateChanged
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::BP_OnHoldStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.BP_OnHoldStateChanged");
		
		ARBProximityDetectorItem_BP_OnHoldStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.BP_OnEquipped
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::BP_OnEquipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.BP_OnEquipped");
		
		ARBProximityDetectorItem_BP_OnEquipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.BP_OnDeviceStateChanged
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::BP_OnDeviceStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.BP_OnDeviceStateChanged");
		
		ARBProximityDetectorItem_BP_OnDeviceStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.BP_OnCompletedLevel
	 * 		Flags  -> ()
	 */
	void ARBProximityDetectorItem::BP_OnCompletedLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.BP_OnCompletedLevel");
		
		ARBProximityDetectorItem_BP_OnCompletedLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.BP_IsHolding
	 * 		Flags  -> ()
	 */
	bool ARBProximityDetectorItem::BP_IsHolding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.BP_IsHolding");
		
		ARBProximityDetectorItem_BP_IsHolding_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBProximityDetectorItem.BP_GetProgress
	 * 		Flags  -> ()
	 */
	float ARBProximityDetectorItem::BP_GetProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBProximityDetectorItem.BP_GetProgress");
		
		ARBProximityDetectorItem_BP_GetProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBProximityDetectorItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBProximityDetectorItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBProximityDetectorItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPsychosisMine.OnRep_State
	 * 		Flags  -> ()
	 */
	void ARBPsychosisMine::OnRep_State()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPsychosisMine.OnRep_State");
		
		ARBPsychosisMine_OnRep_State_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPsychosisMine.Multicast_OnDeploy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     deployer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Transform                                                  (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBPsychosisMine::Multicast_OnDeploy(class ARBPawn* deployer, const struct FTransform& Transform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPsychosisMine.Multicast_OnDeploy");
		
		ARBPsychosisMine_Multicast_OnDeploy_Params params {};
		params.deployer = deployer;
		params.Transform = Transform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPsychosisMine.InitPlacedInLevel_Server
	 * 		Flags  -> ()
	 */
	void ARBPsychosisMine::InitPlacedInLevel_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPsychosisMine.InitPlacedInLevel_Server");
		
		ARBPsychosisMine_InitPlacedInLevel_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPsychosisMine.Event_OnExpiredUnactivated
	 * 		Flags  -> ()
	 */
	void ARBPsychosisMine::Event_OnExpiredUnactivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPsychosisMine.Event_OnExpiredUnactivated");
		
		ARBPsychosisMine_Event_OnExpiredUnactivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPsychosisMine.Event_OnDeployed
	 * 		Flags  -> ()
	 */
	void ARBPsychosisMine::Event_OnDeployed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPsychosisMine.Event_OnDeployed");
		
		ARBPsychosisMine_Event_OnDeployed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPsychosisMine.Event_OnBreak
	 * 		Flags  -> ()
	 */
	void ARBPsychosisMine::Event_OnBreak()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPsychosisMine.Event_OnBreak");
		
		ARBPsychosisMine_Event_OnBreak_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPsychosisMine.Event_OnActivate
	 * 		Flags  -> ()
	 */
	void ARBPsychosisMine::Event_OnActivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPsychosisMine.Event_OnActivate");
		
		ARBPsychosisMine_Event_OnActivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPsychosisMine.Event_EffectFinished
	 * 		Flags  -> ()
	 */
	void ARBPsychosisMine::Event_EffectFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPsychosisMine.Event_EffectFinished");
		
		ARBPsychosisMine_Event_EffectFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPsychosisMine.DeinitPlacedInLevel_Server
	 * 		Flags  -> ()
	 */
	void ARBPsychosisMine::DeinitPlacedInLevel_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPsychosisMine.DeinitPlacedInLevel_Server");
		
		ARBPsychosisMine_DeinitPlacedInLevel_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPsychosisMine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPsychosisMine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPsychosisMine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPsychosisObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPsychosisObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPsychosisObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPushableComponent.OnRep_PawnPushing
	 * 		Flags  -> ()
	 */
	void URBPushableComponent::OnRep_PawnPushing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPushableComponent.OnRep_PawnPushing");
		
		URBPushableComponent_OnRep_PawnPushing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPushableComponent.OnPawnPushingChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPushableComponent::OnPawnPushingChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPushableComponent.OnPawnPushingChangedCallback");
		
		URBPushableComponent_OnPawnPushingChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPushableComponent.GetPawnPushing
	 * 		Flags  -> ()
	 */
	class ARBPawn* URBPushableComponent::GetPawnPushing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPushableComponent.GetPawnPushing");
		
		URBPushableComponent_GetPawnPushing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPushableComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPushableComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPushableComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPushCartGoalManager.OnRep_LinkedObjectiveCoordinator
	 * 		Flags  -> ()
	 */
	void ARBPushCartGoalManager::OnRep_LinkedObjectiveCoordinator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPushCartGoalManager.OnRep_LinkedObjectiveCoordinator");
		
		ARBPushCartGoalManager_OnRep_LinkedObjectiveCoordinator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPushCartGoalManager.OnRep_CartGoalReached
	 * 		Flags  -> ()
	 */
	void ARBPushCartGoalManager::OnRep_CartGoalReached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPushCartGoalManager.OnRep_CartGoalReached");
		
		ARBPushCartGoalManager_OnRep_CartGoalReached_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPushCartGoalManager.OnRep_Active
	 * 		Flags  -> ()
	 */
	void ARBPushCartGoalManager::OnRep_Active()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPushCartGoalManager.OnRep_Active");
		
		ARBPushCartGoalManager_OnRep_Active_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPushCartGoalManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPushCartGoalManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPushCartGoalManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPushCartObjectiveCoordinator.OnTargetTriggerBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBPushCartObjectiveCoordinator::OnTargetTriggerBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPushCartObjectiveCoordinator.OnTargetTriggerBeginOverlap");
		
		ARBPushCartObjectiveCoordinator_OnTargetTriggerBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPushCartObjectiveCoordinator.OnRep_PushCartInfos
	 * 		Flags  -> ()
	 */
	void ARBPushCartObjectiveCoordinator::OnRep_PushCartInfos()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPushCartObjectiveCoordinator.OnRep_PushCartInfos");
		
		ARBPushCartObjectiveCoordinator_OnRep_PushCartInfos_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPushCartObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPushCartObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPushCartObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPushCartRailStopper.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPushCartRailStopper::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPushCartRailStopper");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPushCartRailBlocker.OnLinkedTriggered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsOn                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBTriggerable*                              triggerable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPushCartRailBlocker::OnLinkedTriggered(bool bIsOn, class ARBTriggerable* triggerable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPushCartRailBlocker.OnLinkedTriggered");
		
		ARBPushCartRailBlocker_OnLinkedTriggered_Params params {};
		params.bIsOn = bIsOn;
		params.triggerable = triggerable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPushCartRailBlocker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPushCartRailBlocker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPushCartRailBlocker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPushCartSpawnerTrigger.GetGoalTrigger
	 * 		Flags  -> ()
	 */
	class UPrimitiveComponent* URBPushCartSpawnerTrigger::GetGoalTrigger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPushCartSpawnerTrigger.GetGoalTrigger");
		
		URBPushCartSpawnerTrigger_GetGoalTrigger_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPushCartSpawnerTrigger.GetGoalIconActor
	 * 		Flags  -> ()
	 */
	class AActor* URBPushCartSpawnerTrigger::GetGoalIconActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPushCartSpawnerTrigger.GetGoalIconActor");
		
		URBPushCartSpawnerTrigger_GetGoalIconActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPushCartSpawnerTrigger.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPushCartSpawnerTrigger::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPushCartSpawnerTrigger");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPushCartSpawner.OnRep_ScheduledForSpawn
	 * 		Flags  -> ()
	 */
	void ARBPushCartSpawner::OnRep_ScheduledForSpawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPushCartSpawner.OnRep_ScheduledForSpawn");
		
		ARBPushCartSpawner_OnRep_ScheduledForSpawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPushCartSpawner.OnRep_Pushable
	 * 		Flags  -> ()
	 */
	void ARBPushCartSpawner::OnRep_Pushable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPushCartSpawner.OnRep_Pushable");
		
		ARBPushCartSpawner_OnRep_Pushable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPushCartSpawner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPushCartSpawner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPushCartSpawner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomComponent.TryActivatePuzzleRoom_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBInteractibleComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPuzzleRoomComponent::TryActivatePuzzleRoom_Server(class ARBPawn* interactor, class URBInteractibleComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomComponent.TryActivatePuzzleRoom_Server");
		
		URBPuzzleRoomComponent_TryActivatePuzzleRoom_Server_Params params {};
		params.interactor = interactor;
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomComponent.OnWorldPopulateFinished_Implementation
	 * 		Flags  -> ()
	 */
	void URBPuzzleRoomComponent::OnWorldPopulateFinished_Implementation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomComponent.OnWorldPopulateFinished_Implementation");
		
		URBPuzzleRoomComponent_OnWorldPopulateFinished_Implementation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomComponent.OnRep_Scheduled
	 * 		Flags  -> ()
	 */
	void URBPuzzleRoomComponent::OnRep_Scheduled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomComponent.OnRep_Scheduled");
		
		URBPuzzleRoomComponent_OnRep_Scheduled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomComponent.OnRep_CountdownElapsed
	 * 		Flags  -> ()
	 */
	void URBPuzzleRoomComponent::OnRep_CountdownElapsed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomComponent.OnRep_CountdownElapsed");
		
		URBPuzzleRoomComponent_OnRep_CountdownElapsed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomComponent.OnRep_Active
	 * 		Flags  -> ()
	 */
	void URBPuzzleRoomComponent::OnRep_Active()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomComponent.OnRep_Active");
		
		URBPuzzleRoomComponent_OnRep_Active_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomComponent.OnPawnEnterRoom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBPuzzleRoomComponent::OnPawnEnterRoom(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomComponent.OnPawnEnterRoom");
		
		URBPuzzleRoomComponent_OnPawnEnterRoom_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomComponent.GetNumberOfDigitsToUnlock
	 * 		Flags  -> ()
	 */
	int32_t URBPuzzleRoomComponent::GetNumberOfDigitsToUnlock()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomComponent.GetNumberOfDigitsToUnlock");
		
		URBPuzzleRoomComponent_GetNumberOfDigitsToUnlock_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomComponent.GetLinkedTimerButton
	 * 		Flags  -> ()
	 */
	class URBSimpleInteractionComponent* URBPuzzleRoomComponent::GetLinkedTimerButton()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomComponent.GetLinkedTimerButton");
		
		URBPuzzleRoomComponent_GetLinkedTimerButton_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomComponent.GetAllLinkedPasscodePads
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class URBPasscodePadComponent*>             outPads                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBPuzzleRoomComponent::GetAllLinkedPasscodePads(TArray<class URBPasscodePadComponent*>* outPads)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomComponent.GetAllLinkedPasscodePads");
		
		URBPuzzleRoomComponent_GetAllLinkedPasscodePads_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outPads != nullptr)
			*outPads = params.outPads;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomComponent.GetAllLinkedPasscodeDecals
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class ARBPasscodeNumberDecalActor*>         OutActors                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void URBPuzzleRoomComponent::GetAllLinkedPasscodeDecals(TArray<class ARBPasscodeNumberDecalActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomComponent.GetAllLinkedPasscodeDecals");
		
		URBPuzzleRoomComponent_GetAllLinkedPasscodeDecals_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomComponent.GetAllLinkedLights
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class ARBLight*>                            outLights                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void URBPuzzleRoomComponent::GetAllLinkedLights(TArray<class ARBLight*>* outLights)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomComponent.GetAllLinkedLights");
		
		URBPuzzleRoomComponent_GetAllLinkedLights_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outLights != nullptr)
			*outLights = params.outLights;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomComponent.GetAllLinkedBlacklights
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class ARBBlacklight*>                       outBlacklights                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void URBPuzzleRoomComponent::GetAllLinkedBlacklights(TArray<class ARBBlacklight*>* outBlacklights)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomComponent.GetAllLinkedBlacklights");
		
		URBPuzzleRoomComponent_GetAllLinkedBlacklights_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outBlacklights != nullptr)
			*outBlacklights = params.outBlacklights;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBPuzzleRoomComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBPuzzleRoomComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPuzzleRoomComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnRep_AvailableLargePickups
	 * 		Flags  -> ()
	 */
	void ARBPuzzleRoomLargeInteractObjectiveCoordinator::OnRep_AvailableLargePickups()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnRep_AvailableLargePickups");
		
		ARBPuzzleRoomLargeInteractObjectiveCoordinator_OnRep_AvailableLargePickups_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnPickupHolderChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBLargePickup*                              largePickup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPuzzleRoomLargeInteractObjectiveCoordinator::OnPickupHolderChanged(class ARBPawn* Player, class ARBLargePickup* largePickup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnPickupHolderChanged");
		
		ARBPuzzleRoomLargeInteractObjectiveCoordinator_OnPickupHolderChanged_Params params {};
		params.Player = Player;
		params.largePickup = largePickup;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnLargePickupUsedOnObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBLargePickup*                              largePickup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBLargeObjectInteractionPanelComponent*     interactible                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPuzzleRoomLargeInteractObjectiveCoordinator::OnLargePickupUsedOnObject(class ARBPawn* interactor, class ARBLargePickup* largePickup, class URBLargeObjectInteractionPanelComponent* interactible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnLargePickupUsedOnObject");
		
		ARBPuzzleRoomLargeInteractObjectiveCoordinator_OnLargePickupUsedOnObject_Params params {};
		params.interactor = interactor;
		params.largePickup = largePickup;
		params.interactible = interactible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnLargeObjectInteractionDoAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBLargeObjectInteractionPanelComponent*     largeObjectPanel                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBLargePickup*                              largePickup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPuzzleRoomLargeInteractObjectiveCoordinator::OnLargeObjectInteractionDoAction(class URBLargeObjectInteractionPanelComponent* largeObjectPanel, class ARBLargePickup* largePickup, class ARBPawn* interactor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnLargeObjectInteractionDoAction");
		
		ARBPuzzleRoomLargeInteractObjectiveCoordinator_OnLargeObjectInteractionDoAction_Params params {};
		params.largeObjectPanel = largeObjectPanel;
		params.largePickup = largePickup;
		params.interactor = interactor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnInteractibleAddedToWorld
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBInteractible*                             interactible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBPuzzleRoomLargeInteractObjectiveCoordinator::OnInteractibleAddedToWorld(class ARBInteractible* interactible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator.OnInteractibleAddedToWorld");
		
		ARBPuzzleRoomLargeInteractObjectiveCoordinator_OnInteractibleAddedToWorld_Params params {};
		params.interactible = interactible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBPuzzleRoomLargeInteractObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBPuzzleRoomLargeInteractObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBPuzzleRoomLargeInteractObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBQuestGiverConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBQuestGiverConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBQuestGiverConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBQuitMenu.ExitToMainMenu
	 * 		Flags  -> ()
	 */
	void URBQuitMenu::ExitToMainMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBQuitMenu.ExitToMainMenu");
		
		URBQuitMenu_ExitToMainMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBQuitMenu.ExitGame
	 * 		Flags  -> ()
	 */
	void URBQuitMenu::ExitGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBQuitMenu.ExitGame");
		
		URBQuitMenu_ExitGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBQuitMenu.Event_Exiting
	 * 		Flags  -> ()
	 */
	void URBQuitMenu::Event_Exiting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBQuitMenu.Event_Exiting");
		
		URBQuitMenu_Event_Exiting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBQuitMenu.Cancel
	 * 		Flags  -> ()
	 */
	void URBQuitMenu::Cancel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBQuitMenu.Cancel");
		
		URBQuitMenu_Cancel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBQuitMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBQuitMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBQuitMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRadioDistraction.Multicast_Break
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     breakingPawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBRadioDistraction::Multicast_Break(class ARBPawn* breakingPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRadioDistraction.Multicast_Break");
		
		ARBRadioDistraction_Multicast_Break_Params params {};
		params.breakingPawn = breakingPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRadioDistraction.Event_Break
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     breakingPawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBRadioDistraction::Event_Break(class ARBPawn* breakingPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRadioDistraction.Event_Break");
		
		ARBRadioDistraction_Event_Break_Params params {};
		params.breakingPawn = breakingPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRadioDistraction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRadioDistraction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRadioDistraction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRailForPushableComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRailForPushableComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRailForPushableComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRandomAmbientSound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRandomAmbientSound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRandomAmbientSound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRandomAmbientSoundComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRandomAmbientSoundComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRandomAmbientSoundComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRandomAudioFXManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRandomAudioFXManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRandomAudioFXManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomGroup.SelectLinkedActors
	 * 		Flags  -> ()
	 */
	void ARBRandomGroup::SelectLinkedActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomGroup.SelectLinkedActors");
		
		ARBRandomGroup_SelectLinkedActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomGroup.CenterOnLinkedActors
	 * 		Flags  -> ()
	 */
	void ARBRandomGroup::CenterOnLinkedActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomGroup.CenterOnLinkedActors");
		
		ARBRandomGroup_CenterOnLinkedActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomGroup.AddSelectedActors
	 * 		Flags  -> ()
	 */
	void ARBRandomGroup::AddSelectedActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomGroup.AddSelectedActors");
		
		ARBRandomGroup_AddSelectedActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRandomGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRandomGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRandomGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizable.ShouldBeIgnoredForLots
	 * 		Flags  -> ()
	 */
	bool URBRandomizable::ShouldBeIgnoredForLots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizable.ShouldBeIgnoredForLots");
		
		URBRandomizable_ShouldBeIgnoredForLots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizable.SetState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bStateA                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRandomizable::SetState(bool bStateA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizable.SetState");
		
		URBRandomizable_SetState_Params params {};
		params.bStateA = bStateA;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizable.SetShouldBeIgnoredForLots
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRandomizable::SetShouldBeIgnoredForLots(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizable.SetShouldBeIgnoredForLots");
		
		URBRandomizable_SetShouldBeIgnoredForLots_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizable.PrepareState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bStateA                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      randomOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRandomizable::PrepareState(bool bStateA, class AActor* randomOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizable.PrepareState");
		
		URBRandomizable_PrepareState_Params params {};
		params.bStateA = bStateA;
		params.randomOwner = randomOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizable.IsStateA
	 * 		Flags  -> ()
	 */
	bool URBRandomizable::IsStateA()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizable.IsStateA");
		
		URBRandomizable_IsStateA_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizable.GetStateName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      stateA                                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      stateB                                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBRandomizable::GetStateName(class FString* stateA, class FString* stateB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizable.GetStateName");
		
		URBRandomizable_GetStateName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (stateA != nullptr)
			*stateA = params.stateA;
		if (stateB != nullptr)
			*stateB = params.stateB;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRandomizable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRandomizable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRandomizable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableDeferredDecal.OnRep_Enabled
	 * 		Flags  -> ()
	 */
	void ARBRandomizableDeferredDecal::OnRep_Enabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableDeferredDecal.OnRep_Enabled");
		
		ARBRandomizableDeferredDecal_OnRep_Enabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRandomizableDeferredDecal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRandomizableDeferredDecal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRandomizableDeferredDecal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableHelperComponent.SnapToState
	 * 		Flags  -> ()
	 */
	void URBRandomizableHelperComponent::SnapToState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableHelperComponent.SnapToState");
		
		URBRandomizableHelperComponent_SnapToState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableHelperComponent.SelectSharedActors
	 * 		Flags  -> ()
	 */
	void URBRandomizableHelperComponent::SelectSharedActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableHelperComponent.SelectSharedActors");
		
		URBRandomizableHelperComponent_SelectSharedActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableHelperComponent.SelectLinkedActors
	 * 		Flags  -> ()
	 */
	void URBRandomizableHelperComponent::SelectLinkedActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableHelperComponent.SelectLinkedActors");
		
		URBRandomizableHelperComponent_SelectLinkedActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableHelperComponent.OnRep_RandomState
	 * 		Flags  -> ()
	 */
	void URBRandomizableHelperComponent::OnRep_RandomState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableHelperComponent.OnRep_RandomState");
		
		URBRandomizableHelperComponent_OnRep_RandomState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableHelperComponent.IsolateSharedActorsToMatchState
	 * 		Flags  -> ()
	 */
	void URBRandomizableHelperComponent::IsolateSharedActorsToMatchState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableHelperComponent.IsolateSharedActorsToMatchState");
		
		URBRandomizableHelperComponent_IsolateSharedActorsToMatchState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableHelperComponent.Editor_TransferSharedActorToMatchActor
	 * 		Flags  -> ()
	 */
	void URBRandomizableHelperComponent::Editor_TransferSharedActorToMatchActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableHelperComponent.Editor_TransferSharedActorToMatchActor");
		
		URBRandomizableHelperComponent_Editor_TransferSharedActorToMatchActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableHelperComponent.BP_ShouldBeIgnoredForLots
	 * 		Flags  -> ()
	 */
	bool URBRandomizableHelperComponent::BP_ShouldBeIgnoredForLots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableHelperComponent.BP_ShouldBeIgnoredForLots");
		
		URBRandomizableHelperComponent_BP_ShouldBeIgnoredForLots_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableHelperComponent.BP_SetShouldBeIgnoredForLots
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRandomizableHelperComponent::BP_SetShouldBeIgnoredForLots(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableHelperComponent.BP_SetShouldBeIgnoredForLots");
		
		URBRandomizableHelperComponent_BP_SetShouldBeIgnoredForLots_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableHelperComponent.BP_SetRandomState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERandomState                                       newRandomState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRandomizableHelperComponent::BP_SetRandomState(ERandomState newRandomState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableHelperComponent.BP_SetRandomState");
		
		URBRandomizableHelperComponent_BP_SetRandomState_Params params {};
		params.newRandomState = newRandomState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableHelperComponent.BP_SetIsStateA
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsStateA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRandomizableHelperComponent::BP_SetIsStateA(bool bIsStateA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableHelperComponent.BP_SetIsStateA");
		
		URBRandomizableHelperComponent_BP_SetIsStateA_Params params {};
		params.bIsStateA = bIsStateA;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableHelperComponent.BP_PrepareIsStateA
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsStateA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRandomizableHelperComponent::BP_PrepareIsStateA(bool bIsStateA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableHelperComponent.BP_PrepareIsStateA");
		
		URBRandomizableHelperComponent_BP_PrepareIsStateA_Params params {};
		params.bIsStateA = bIsStateA;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableHelperComponent.BP_IsStateSet
	 * 		Flags  -> ()
	 */
	bool URBRandomizableHelperComponent::BP_IsStateSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableHelperComponent.BP_IsStateSet");
		
		URBRandomizableHelperComponent_BP_IsStateSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableHelperComponent.BP_IsStateA
	 * 		Flags  -> ()
	 */
	bool URBRandomizableHelperComponent::BP_IsStateA()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableHelperComponent.BP_IsStateA");
		
		URBRandomizableHelperComponent_BP_IsStateA_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRandomizableHelperComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRandomizableHelperComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRandomizableHelperComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRandomizableMeshActor.OnRep_Visible
	 * 		Flags  -> ()
	 */
	void ARBRandomizableMeshActor::OnRep_Visible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRandomizableMeshActor.OnRep_Visible");
		
		ARBRandomizableMeshActor_OnRep_Visible_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRandomizableMeshActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRandomizableMeshActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRandomizableMeshActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRandomPathMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRandomPathMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRandomPathMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRatingsManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRatingsManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRatingsManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRechargeStationPanelComponent.OnRep_IsRecharging
	 * 		Flags  -> ()
	 */
	void URBRechargeStationPanelComponent::OnRep_IsRecharging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRechargeStationPanelComponent.OnRep_IsRecharging");
		
		URBRechargeStationPanelComponent_OnRep_IsRecharging_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRechargeStationPanelComponent.OnRep_IsInCooldown
	 * 		Flags  -> ()
	 */
	void URBRechargeStationPanelComponent::OnRep_IsInCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRechargeStationPanelComponent.OnRep_IsInCooldown");
		
		URBRechargeStationPanelComponent_OnRep_IsInCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRechargeStationPanelComponent.OnRep_CurrentEnergy
	 * 		Flags  -> ()
	 */
	void URBRechargeStationPanelComponent::OnRep_CurrentEnergy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRechargeStationPanelComponent.OnRep_CurrentEnergy");
		
		URBRechargeStationPanelComponent_OnRep_CurrentEnergy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRechargeStationPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRechargeStationPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRechargeStationPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRegroupObjectiveInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRegroupObjectiveInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRegroupObjectiveInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRegroupObjectiveActor.OnTotalNumberOfPlayersChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            numberOfPlayers                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRegroupObjectiveActor::OnTotalNumberOfPlayersChanged(int32_t numberOfPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRegroupObjectiveActor.OnTotalNumberOfPlayersChanged");
		
		URBRegroupObjectiveActor_OnTotalNumberOfPlayersChanged_Params params {};
		params.numberOfPlayers = numberOfPlayers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRegroupObjectiveActor.OnRegroupObjectiveStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERegroupObjectiveState                             newState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRegroupObjectiveActor::OnRegroupObjectiveStateChanged(ERegroupObjectiveState newState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRegroupObjectiveActor.OnRegroupObjectiveStateChanged");
		
		URBRegroupObjectiveActor_OnRegroupObjectiveStateChanged_Params params {};
		params.newState = newState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRegroupObjectiveActor.OnRegroupActionFailed
	 * 		Flags  -> ()
	 */
	void URBRegroupObjectiveActor::OnRegroupActionFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRegroupObjectiveActor.OnRegroupActionFailed");
		
		URBRegroupObjectiveActor_OnRegroupActionFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRegroupObjectiveActor.OnObjectiveStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBRegroupObjectiveCoordinator*              coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRegroupObjectiveActor::OnObjectiveStarted(class ARBRegroupObjectiveCoordinator* coordinator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRegroupObjectiveActor.OnObjectiveStarted");
		
		URBRegroupObjectiveActor_OnObjectiveStarted_Params params {};
		params.coordinator = coordinator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRegroupObjectiveActor.OnObjectiveEnded
	 * 		Flags  -> ()
	 */
	void URBRegroupObjectiveActor::OnObjectiveEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRegroupObjectiveActor.OnObjectiveEnded");
		
		URBRegroupObjectiveActor_OnObjectiveEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRegroupObjectiveActor.OnNumberOfPlayerInZoneChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            numberOfPlayers                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRegroupObjectiveActor::OnNumberOfPlayerInZoneChanged(int32_t numberOfPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRegroupObjectiveActor.OnNumberOfPlayerInZoneChanged");
		
		URBRegroupObjectiveActor_OnNumberOfPlayerInZoneChanged_Params params {};
		params.numberOfPlayers = numberOfPlayers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRegroupObjectiveActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRegroupObjectiveActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRegroupObjectiveActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRegroupObjectiveCoordinator.OnRep_TotalNumberOfPlayers
	 * 		Flags  -> ()
	 */
	void ARBRegroupObjectiveCoordinator::OnRep_TotalNumberOfPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRegroupObjectiveCoordinator.OnRep_TotalNumberOfPlayers");
		
		ARBRegroupObjectiveCoordinator_OnRep_TotalNumberOfPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRegroupObjectiveCoordinator.OnRep_RegroupState
	 * 		Flags  -> ()
	 */
	void ARBRegroupObjectiveCoordinator::OnRep_RegroupState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRegroupObjectiveCoordinator.OnRep_RegroupState");
		
		ARBRegroupObjectiveCoordinator_OnRep_RegroupState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRegroupObjectiveCoordinator.OnRep_NumberOfPlayerInZone
	 * 		Flags  -> ()
	 */
	void ARBRegroupObjectiveCoordinator::OnRep_NumberOfPlayerInZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRegroupObjectiveCoordinator.OnRep_NumberOfPlayerInZone");
		
		ARBRegroupObjectiveCoordinator_OnRep_NumberOfPlayerInZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRegroupObjectiveCoordinator.OnPlayerSimpleDoAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBInteractibleComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBRegroupObjectiveCoordinator::OnPlayerSimpleDoAction(class ARBPawn* Player, class URBInteractibleComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRegroupObjectiveCoordinator.OnPlayerSimpleDoAction");
		
		ARBRegroupObjectiveCoordinator_OnPlayerSimpleDoAction_Params params {};
		params.Player = Player;
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRegroupObjectiveCoordinator.OnPlayerDoAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBInteractible*                             interactible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBRegroupObjectiveCoordinator::OnPlayerDoAction(class ARBPawn* Player, class ARBInteractible* interactible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRegroupObjectiveCoordinator.OnPlayerDoAction");
		
		ARBRegroupObjectiveCoordinator_OnPlayerDoAction_Params params {};
		params.Player = Player;
		params.interactible = interactible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRegroupObjectiveCoordinator.OnOperatingFinished
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBOperatableComponent*                      Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBRegroupObjectiveCoordinator::OnOperatingFinished(class URBOperatableComponent* Component, class ARBPawn* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRegroupObjectiveCoordinator.OnOperatingFinished");
		
		ARBRegroupObjectiveCoordinator_OnOperatingFinished_Params params {};
		params.Component = Component;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRegroupObjectiveCoordinator.BP_SetWaitingForBP
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBRegroupObjectiveCoordinator::BP_SetWaitingForBP(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRegroupObjectiveCoordinator.BP_SetWaitingForBP");
		
		ARBRegroupObjectiveCoordinator_BP_SetWaitingForBP_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRegroupObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRegroupObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRegroupObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReleaseMenu.ReleaseCharacter
	 * 		Flags  -> ()
	 */
	void URBReleaseMenu::ReleaseCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReleaseMenu.ReleaseCharacter");
		
		URBReleaseMenu_ReleaseCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReleaseMenu.OnReleaseButtonUp
	 * 		Flags  -> ()
	 */
	void URBReleaseMenu::OnReleaseButtonUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReleaseMenu.OnReleaseButtonUp");
		
		URBReleaseMenu_OnReleaseButtonUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReleaseMenu.OnReleaseButtonDown
	 * 		Flags  -> ()
	 */
	void URBReleaseMenu::OnReleaseButtonDown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReleaseMenu.OnReleaseButtonDown");
		
		URBReleaseMenu_OnReleaseButtonDown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReleaseMenu.OnPlayerReleaseStateUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlayerReleaseState                         PlayerReleaseState                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBReleaseMenu::OnPlayerReleaseStateUpdated(const struct FPlayerReleaseState& PlayerReleaseState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReleaseMenu.OnPlayerReleaseStateUpdated");
		
		URBReleaseMenu_OnPlayerReleaseStateUpdated_Params params {};
		params.PlayerReleaseState = PlayerReleaseState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReleaseMenu.Event_CharacterReleased
	 * 		Flags  -> ()
	 */
	void URBReleaseMenu::Event_CharacterReleased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReleaseMenu.Event_CharacterReleased");
		
		URBReleaseMenu_Event_CharacterReleased_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBReleaseMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBReleaseMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBReleaseMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRemoteDebuggingComponent.Server_SetDebuggingState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRemoteDebuggingState                       debuggingState                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBRemoteDebuggingComponent::Server_SetDebuggingState(const struct FRemoteDebuggingState& debuggingState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRemoteDebuggingComponent.Server_SetDebuggingState");
		
		URBRemoteDebuggingComponent_Server_SetDebuggingState_Params params {};
		params.debuggingState = debuggingState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRemoteDebuggingComponent.Client_UpdateServerStreamingInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FLevelStreamingInfo                         debugInfo                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBRemoteDebuggingComponent::Client_UpdateServerStreamingInfo(const struct FLevelStreamingInfo& debugInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRemoteDebuggingComponent.Client_UpdateServerStreamingInfo");
		
		URBRemoteDebuggingComponent_Client_UpdateServerStreamingInfo_Params params {};
		params.debugInfo = debugInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRemoteDebuggingComponent.Client_UpdateScoringDebugInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScoringDebugInfo                           debugInfo                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBRemoteDebuggingComponent::Client_UpdateScoringDebugInfo(const struct FScoringDebugInfo& debugInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRemoteDebuggingComponent.Client_UpdateScoringDebugInfo");
		
		URBRemoteDebuggingComponent_Client_UpdateScoringDebugInfo_Params params {};
		params.debugInfo = debugInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRemoteDebuggingComponent.Client_UpdatePlayerDebugInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FPlayerDebugInfo                            debugInfo                                                  (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBRemoteDebuggingComponent::Client_UpdatePlayerDebugInfo(const struct FPlayerDebugInfo& debugInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRemoteDebuggingComponent.Client_UpdatePlayerDebugInfo");
		
		URBRemoteDebuggingComponent_Client_UpdatePlayerDebugInfo_Params params {};
		params.debugInfo = debugInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRemoteDebuggingComponent.Client_UpdateOverseerInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FOverseerInfo                               OverseerInfo                                               (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBRemoteDebuggingComponent::Client_UpdateOverseerInfo(const struct FOverseerInfo& OverseerInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRemoteDebuggingComponent.Client_UpdateOverseerInfo");
		
		URBRemoteDebuggingComponent_Client_UpdateOverseerInfo_Params params {};
		params.OverseerInfo = OverseerInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRemoteDebuggingComponent.Client_UpdateNPCRandomizationInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRandomNPCSpawningDebugInfo                 npcRandomizationInfo                                       (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBRemoteDebuggingComponent::Client_UpdateNPCRandomizationInfo(const struct FRandomNPCSpawningDebugInfo& npcRandomizationInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRemoteDebuggingComponent.Client_UpdateNPCRandomizationInfo");
		
		URBRemoteDebuggingComponent_Client_UpdateNPCRandomizationInfo_Params params {};
		params.npcRandomizationInfo = npcRandomizationInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRemoteDebuggingComponent.Client_UpdateMusicDebugInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FMusicDebugInfo                             debugInfo                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBRemoteDebuggingComponent::Client_UpdateMusicDebugInfo(const struct FMusicDebugInfo& debugInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRemoteDebuggingComponent.Client_UpdateMusicDebugInfo");
		
		URBRemoteDebuggingComponent_Client_UpdateMusicDebugInfo_Params params {};
		params.debugInfo = debugInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRemoteDebuggingComponent.Client_UpdateGameplayRandomizationDebugInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FGameplayRandomizationDebugInfo             debugInfo                                                  (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBRemoteDebuggingComponent::Client_UpdateGameplayRandomizationDebugInfo(const struct FGameplayRandomizationDebugInfo& debugInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRemoteDebuggingComponent.Client_UpdateGameplayRandomizationDebugInfo");
		
		URBRemoteDebuggingComponent_Client_UpdateGameplayRandomizationDebugInfo_Params params {};
		params.debugInfo = debugInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRemoteDebuggingComponent.Client_UpdateBotDebugInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FBotDebugInfo                               debugInfo                                                  (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void URBRemoteDebuggingComponent::Client_UpdateBotDebugInfo(const struct FBotDebugInfo& debugInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRemoteDebuggingComponent.Client_UpdateBotDebugInfo");
		
		URBRemoteDebuggingComponent_Client_UpdateBotDebugInfo_Params params {};
		params.debugInfo = debugInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRemoteDebuggingComponent.Client_SetRecentAnalyticsEvents
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FString>                              RecentEvents                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBRemoteDebuggingComponent::Client_SetRecentAnalyticsEvents(TArray<class FString> RecentEvents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRemoteDebuggingComponent.Client_SetRecentAnalyticsEvents");
		
		URBRemoteDebuggingComponent_Client_SetRecentAnalyticsEvents_Params params {};
		params.RecentEvents = RecentEvents;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRemoteDebuggingComponent.Client_SetAIConfigInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAIConfigData                               addedOverrides                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class URBPartialAIConfig*>                  AdditionalConfigs                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBRemoteDebuggingComponent::Client_SetAIConfigInfo(const struct FAIConfigData& addedOverrides, TArray<class URBPartialAIConfig*> AdditionalConfigs)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRemoteDebuggingComponent.Client_SetAIConfigInfo");
		
		URBRemoteDebuggingComponent_Client_SetAIConfigInfo_Params params {};
		params.addedOverrides = addedOverrides;
		params.AdditionalConfigs = AdditionalConfigs;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRemoteDebuggingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRemoteDebuggingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRemoteDebuggingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRenderingStressTestAgent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRenderingStressTestAgent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRenderingStressTestAgent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReplayTutorialMenu.IsOperationPending
	 * 		Flags  -> ()
	 */
	bool URBReplayTutorialMenu::IsOperationPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReplayTutorialMenu.IsOperationPending");
		
		URBReplayTutorialMenu_IsOperationPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReplayTutorialMenu.FindTutorialServer
	 * 		Flags  -> ()
	 */
	void URBReplayTutorialMenu::FindTutorialServer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReplayTutorialMenu.FindTutorialServer");
		
		URBReplayTutorialMenu_FindTutorialServer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReplayTutorialMenu.Event_Exiting
	 * 		Flags  -> ()
	 */
	void URBReplayTutorialMenu::Event_Exiting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReplayTutorialMenu.Event_Exiting");
		
		URBReplayTutorialMenu_Event_Exiting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReplayTutorialMenu.Cancel
	 * 		Flags  -> ()
	 */
	void URBReplayTutorialMenu::Cancel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReplayTutorialMenu.Cancel");
		
		URBReplayTutorialMenu_Cancel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBReplayTutorialMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBReplayTutorialMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBReplayTutorialMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReportPlayerMenu.Send
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerReportReason                                Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      reasonText                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBReportPlayerMenu::Send(EPlayerReportReason Reason, const class FString& reasonText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReportPlayerMenu.Send");
		
		URBReportPlayerMenu_Send_Params params {};
		params.Reason = Reason;
		params.reasonText = reasonText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReportPlayerMenu.GetPlayerReportReasonText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerReportReason                                Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText URBReportPlayerMenu::GetPlayerReportReasonText(EPlayerReportReason Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReportPlayerMenu.GetPlayerReportReasonText");
		
		URBReportPlayerMenu_GetPlayerReportReasonText_Params params {};
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReportPlayerMenu.GetPlayerPlatform
	 * 		Flags  -> ()
	 */
	EProfilePlatform URBReportPlayerMenu::GetPlayerPlatform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReportPlayerMenu.GetPlayerPlatform");
		
		URBReportPlayerMenu_GetPlayerPlatform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReportPlayerMenu.GetPlayerDisplayName
	 * 		Flags  -> ()
	 */
	class FString URBReportPlayerMenu::GetPlayerDisplayName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReportPlayerMenu.GetPlayerDisplayName");
		
		URBReportPlayerMenu_GetPlayerDisplayName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReportPlayerMenu.FilterDetailsText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Text                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class FText URBReportPlayerMenu::FilterDetailsText(const class FText& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReportPlayerMenu.FilterDetailsText");
		
		URBReportPlayerMenu_FilterDetailsText_Params params {};
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBReportPlayerMenu.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBReportPlayerMenu::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBReportPlayerMenu.Event_Refresh");
		
		URBReportPlayerMenu_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBReportPlayerMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBReportPlayerMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBReportPlayerMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRepulsionComponent.SetOriginalSizeToCurrentSize
	 * 		Flags  -> ()
	 */
	void URBRepulsionComponent::SetOriginalSizeToCurrentSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRepulsionComponent.SetOriginalSizeToCurrentSize");
		
		URBRepulsionComponent_SetOriginalSizeToCurrentSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRepulsionComponent.OnRep_ScheduledTime
	 * 		Flags  -> ()
	 */
	void URBRepulsionComponent::OnRep_ScheduledTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRepulsionComponent.OnRep_ScheduledTime");
		
		URBRepulsionComponent_OnRep_ScheduledTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRepulsionComponent.OnRep_ScheduledState
	 * 		Flags  -> ()
	 */
	void URBRepulsionComponent::OnRep_ScheduledState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRepulsionComponent.OnRep_ScheduledState");
		
		URBRepulsionComponent_OnRep_ScheduledState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRepulsionComponent.OnRep_RepulsionRules
	 * 		Flags  -> ()
	 */
	void URBRepulsionComponent::OnRep_RepulsionRules()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRepulsionComponent.OnRep_RepulsionRules");
		
		URBRepulsionComponent_OnRep_RepulsionRules_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRepulsionComponent.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRepulsionComponent::BP_SetEnabled(bool bNewValue, float delay, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRepulsionComponent.BP_SetEnabled");
		
		URBRepulsionComponent_BP_SetEnabled_Params params {};
		params.bNewValue = bNewValue;
		params.delay = delay;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRepulsionComponent.AddPawnException
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRepulsionComponent::AddPawnException(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRepulsionComponent.AddPawnException");
		
		URBRepulsionComponent_AddPawnException_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRepulsionComponent.ActivateScheduledState
	 * 		Flags  -> ()
	 */
	void URBRepulsionComponent::ActivateScheduledState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRepulsionComponent.ActivateScheduledState");
		
		URBRepulsionComponent_ActivateScheduledState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRepulsionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRepulsionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRepulsionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRespawnLimiterZone.SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBRespawnLimiterZone::SetEnabled(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRespawnLimiterZone.SetEnabled");
		
		ARBRespawnLimiterZone_SetEnabled_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRespawnLimiterZone.IsEnabled
	 * 		Flags  -> ()
	 */
	bool ARBRespawnLimiterZone::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRespawnLimiterZone.IsEnabled");
		
		ARBRespawnLimiterZone_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRespawnLimiterZone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRespawnLimiterZone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRespawnLimiterZone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBReviveObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBReviveObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBReviveObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRewardRoomComponent.OnRep_Scheduled
	 * 		Flags  -> ()
	 */
	void URBRewardRoomComponent::OnRep_Scheduled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRewardRoomComponent.OnRep_Scheduled");
		
		URBRewardRoomComponent_OnRep_Scheduled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRewardRoomComponent.OnRep_LinkedRewardDoor
	 * 		Flags  -> ()
	 */
	void URBRewardRoomComponent::OnRep_LinkedRewardDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRewardRoomComponent.OnRep_LinkedRewardDoor");
		
		URBRewardRoomComponent_OnRep_LinkedRewardDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRewardRoomComponent.OnLinkedDoorUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRewardRoomComponent::OnLinkedDoorUnlocked(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRewardRoomComponent.OnLinkedDoorUnlocked");
		
		URBRewardRoomComponent_OnLinkedDoorUnlocked_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRewardRoomComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRewardRoomComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRewardRoomComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRichTextBlockInputWidgetDecorator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRichTextBlockInputWidgetDecorator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRichTextBlockInputWidgetDecorator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.OnActorExitRoom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBRoom::OnActorExitRoom(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.OnActorExitRoom");
		
		ARBRoom_OnActorExitRoom_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.OnActorEnterRoom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBRoom::OnActorEnterRoom(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.OnActorEnterRoom");
		
		ARBRoom_OnActorEnterRoom_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.IsSlaveRoom
	 * 		Flags  -> ()
	 */
	bool ARBRoom::IsSlaveRoom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.IsSlaveRoom");
		
		ARBRoom_IsSlaveRoom_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.GetLinkedMissionRoomGroup
	 * 		Flags  -> ()
	 */
	class ARBRoomGroup* ARBRoom::GetLinkedMissionRoomGroup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.GetLinkedMissionRoomGroup");
		
		ARBRoom_GetLinkedMissionRoomGroup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.GetAllOverlappingActors
	 * 		Flags  -> ()
	 */
	void ARBRoom::GetAllOverlappingActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.GetAllOverlappingActors");
		
		ARBRoom_GetAllOverlappingActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.Editor_SetAsRoomLinkMaster
	 * 		Flags  -> ()
	 */
	void ARBRoom::Editor_SetAsRoomLinkMaster()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.Editor_SetAsRoomLinkMaster");
		
		ARBRoom_Editor_SetAsRoomLinkMaster_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.Editor_SelectCurrentRoomGroups
	 * 		Flags  -> ()
	 */
	void ARBRoom::Editor_SelectCurrentRoomGroups()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.Editor_SelectCurrentRoomGroups");
		
		ARBRoom_Editor_SelectCurrentRoomGroups_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.Editor_SelectAllLinkedRooms
	 * 		Flags  -> ()
	 */
	void ARBRoom::Editor_SelectAllLinkedRooms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.Editor_SelectAllLinkedRooms");
		
		ARBRoom_Editor_SelectAllLinkedRooms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.Editor_SelectAllConnectors
	 * 		Flags  -> ()
	 */
	void ARBRoom::Editor_SelectAllConnectors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.Editor_SelectAllConnectors");
		
		ARBRoom_Editor_SelectAllConnectors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.Editor_PreviewPrizeAvailable
	 * 		Flags  -> ()
	 */
	void ARBRoom::Editor_PreviewPrizeAvailable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.Editor_PreviewPrizeAvailable");
		
		ARBRoom_Editor_PreviewPrizeAvailable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.Editor_PreviewDeactivated
	 * 		Flags  -> ()
	 */
	void ARBRoom::Editor_PreviewDeactivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.Editor_PreviewDeactivated");
		
		ARBRoom_Editor_PreviewDeactivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.Editor_PreviewCompleted
	 * 		Flags  -> ()
	 */
	void ARBRoom::Editor_PreviewCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.Editor_PreviewCompleted");
		
		ARBRoom_Editor_PreviewCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.Editor_PreviewActivated
	 * 		Flags  -> ()
	 */
	void ARBRoom::Editor_PreviewActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.Editor_PreviewActivated");
		
		ARBRoom_Editor_PreviewActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.Editor_LinkAllSelectedRooms
	 * 		Flags  -> ()
	 */
	void ARBRoom::Editor_LinkAllSelectedRooms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.Editor_LinkAllSelectedRooms");
		
		ARBRoom_Editor_LinkAllSelectedRooms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.Editor_ClearRoomLink
	 * 		Flags  -> ()
	 */
	void ARBRoom::Editor_ClearRoomLink()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.Editor_ClearRoomLink");
		
		ARBRoom_Editor_ClearRoomLink_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.Editor_ClearFromRoomGroups
	 * 		Flags  -> ()
	 */
	void ARBRoom::Editor_ClearFromRoomGroups()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.Editor_ClearFromRoomGroups");
		
		ARBRoom_Editor_ClearFromRoomGroups_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.BP_GetPossibleObjectivesInside
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              outObjectiveActors                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ARBRoom::BP_GetPossibleObjectivesInside(TArray<class AActor*>* outObjectiveActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.BP_GetPossibleObjectivesInside");
		
		ARBRoom_BP_GetPossibleObjectivesInside_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outObjectiveActors != nullptr)
			*outObjectiveActors = params.outObjectiveActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoom.BP_GetActiveObjectivesInside
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              outObjectiveActors                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ARBRoom::BP_GetActiveObjectivesInside(TArray<class AActor*>* outObjectiveActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoom.BP_GetActiveObjectivesInside");
		
		ARBRoom_BP_GetActiveObjectivesInside_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outObjectiveActors != nullptr)
			*outObjectiveActors = params.outObjectiveActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRoom.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRoom::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRoom");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomConnectorComponent.SetConnectionState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERoomConnectionState                               newState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBRoomConnectorComponent::SetConnectionState(ERoomConnectionState newState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomConnectorComponent.SetConnectionState");
		
		URBRoomConnectorComponent_SetConnectionState_Params params {};
		params.newState = newState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomConnectorComponent.GetRoomInFront
	 * 		Flags  -> ()
	 */
	class ARBRoom* URBRoomConnectorComponent::GetRoomInFront()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomConnectorComponent.GetRoomInFront");
		
		URBRoomConnectorComponent_GetRoomInFront_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomConnectorComponent.GetRoomInBack
	 * 		Flags  -> ()
	 */
	class ARBRoom* URBRoomConnectorComponent::GetRoomInBack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomConnectorComponent.GetRoomInBack");
		
		URBRoomConnectorComponent_GetRoomInBack_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRoomConnectorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRoomConnectorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRoomConnectorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomGroup.OnRep_IsMissionRoomGroup
	 * 		Flags  -> ()
	 */
	void ARBRoomGroup::OnRep_IsMissionRoomGroup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomGroup.OnRep_IsMissionRoomGroup");
		
		ARBRoomGroup_OnRep_IsMissionRoomGroup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomGroup.Editor_UnlinkAllSelectedRooms
	 * 		Flags  -> ()
	 */
	void ARBRoomGroup::Editor_UnlinkAllSelectedRooms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomGroup.Editor_UnlinkAllSelectedRooms");
		
		ARBRoomGroup_Editor_UnlinkAllSelectedRooms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomGroup.Editor_SelectedAllLinkedRooms
	 * 		Flags  -> ()
	 */
	void ARBRoomGroup::Editor_SelectedAllLinkedRooms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomGroup.Editor_SelectedAllLinkedRooms");
		
		ARBRoomGroup_Editor_SelectedAllLinkedRooms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomGroup.Editor_LinkAllSelectedRooms
	 * 		Flags  -> ()
	 */
	void ARBRoomGroup::Editor_LinkAllSelectedRooms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomGroup.Editor_LinkAllSelectedRooms");
		
		ARBRoomGroup_Editor_LinkAllSelectedRooms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomGroup.Editor_ClearInvalidRooms
	 * 		Flags  -> ()
	 */
	void ARBRoomGroup::Editor_ClearInvalidRooms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomGroup.Editor_ClearInvalidRooms");
		
		ARBRoomGroup_Editor_ClearInvalidRooms_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomGroup.BP_SetSectionClosedOff
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bClosedOff                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSnapToState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBRoomGroup::BP_SetSectionClosedOff(bool bClosedOff, bool bSnapToState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomGroup.BP_SetSectionClosedOff");
		
		ARBRoomGroup_BP_SetSectionClosedOff_Params params {};
		params.bClosedOff = bClosedOff;
		params.bSnapToState = bSnapToState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomGroup.BP_GetVolumeList
	 * 		Flags  -> ()
	 */
	TArray<class AVolume*> ARBRoomGroup::BP_GetVolumeList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomGroup.BP_GetVolumeList");
		
		ARBRoomGroup_BP_GetVolumeList_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomGroup.BP_GetPossibleObjectivesInside
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              outObjectiveActors                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ARBRoomGroup::BP_GetPossibleObjectivesInside(TArray<class AActor*>* outObjectiveActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomGroup.BP_GetPossibleObjectivesInside");
		
		ARBRoomGroup_BP_GetPossibleObjectivesInside_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outObjectiveActors != nullptr)
			*outObjectiveActors = params.outObjectiveActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomGroup.BP_GetActiveObjectivesInside
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class AActor*>                              outObjectiveActors                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void ARBRoomGroup::BP_GetActiveObjectivesInside(TArray<class AActor*>* outObjectiveActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomGroup.BP_GetActiveObjectivesInside");
		
		ARBRoomGroup_BP_GetActiveObjectivesInside_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outObjectiveActors != nullptr)
			*outObjectiveActors = params.outObjectiveActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRoomGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRoomGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRoomGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBRoomPostProcessComponent.OnWorldPopulateFinished_Implementation
	 * 		Flags  -> ()
	 */
	void URBRoomPostProcessComponent::OnWorldPopulateFinished_Implementation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBRoomPostProcessComponent.OnWorldPopulateFinished_Implementation");
		
		URBRoomPostProcessComponent_OnWorldPopulateFinished_Implementation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBRoomPostProcessComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBRoomPostProcessComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRoomPostProcessComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBRubbishScatterer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBRubbishScatterer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBRubbishScatterer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSAS.OnStageReady
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBSAS::OnStageReady(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSAS.OnStageReady");
		
		ARBSAS_OnStageReady_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSAS.OnStageEnded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               isRestarting                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSAS::OnStageEnded(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, bool isRestarting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSAS.OnStageEnded");
		
		ARBSAS_OnStageEnded_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		params.isRestarting = isRestarting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSAS.OnRep_CurrentState
	 * 		Flags  -> ()
	 */
	void ARBSAS::OnRep_CurrentState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSAS.OnRep_CurrentState");
		
		ARBSAS_OnRep_CurrentState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSAS.OnPlayerExitedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSAS::OnPlayerExitedEvent(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSAS.OnPlayerExitedEvent");
		
		ARBSAS_OnPlayerExitedEvent_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSAS.OnPlayerEnteredEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSAS::OnPlayerEnteredEvent(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSAS.OnPlayerEnteredEvent");
		
		ARBSAS_OnPlayerEnteredEvent_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSAS.OnPawnRespawned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSAS::OnPawnRespawned(class ARBPawn* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSAS.OnPawnRespawned");
		
		ARBSAS_OnPawnRespawned_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSAS.OnGamePhaseUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGamePhase                                         gamePhase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSAS::OnGamePhaseUpdated(EGamePhase gamePhase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSAS.OnGamePhaseUpdated");
		
		ARBSAS_OnGamePhaseUpdated_Params params {};
		params.gamePhase = gamePhase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSAS.Event_OnCleanSAS
	 * 		Flags  -> ()
	 */
	void ARBSAS::Event_OnCleanSAS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSAS.Event_OnCleanSAS");
		
		ARBSAS_Event_OnCleanSAS_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSAS.BP_OnStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESASState                                          State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSAS::BP_OnStateChanged(ESASState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSAS.BP_OnStateChanged");
		
		ARBSAS_BP_OnStateChanged_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSAS.BP_Cheat_ForceSASState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESASState                                          State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSAS::BP_Cheat_ForceSASState(ESASState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSAS.BP_Cheat_ForceSASState");
		
		ARBSAS_BP_Cheat_ForceSASState_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSAS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSAS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSAS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSASChairInteractionRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSASChairInteractionRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSASChairInteractionRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.ShouldFaceTV
	 * 		Flags  -> ()
	 */
	bool URBSASChairPanelComponent::ShouldFaceTV()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.ShouldFaceTV");
		
		URBSASChairPanelComponent_ShouldFaceTV_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.OnRep_ShouldFaceTV
	 * 		Flags  -> ()
	 */
	void URBSASChairPanelComponent::OnRep_ShouldFaceTV()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.OnRep_ShouldFaceTV");
		
		URBSASChairPanelComponent_OnRep_ShouldFaceTV_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.OnRep_CanSitInChair
	 * 		Flags  -> ()
	 */
	void URBSASChairPanelComponent::OnRep_CanSitInChair()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.OnRep_CanSitInChair");
		
		URBSASChairPanelComponent_OnRep_CanSitInChair_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.OnRep_CanLeaveChair
	 * 		Flags  -> ()
	 */
	void URBSASChairPanelComponent::OnRep_CanLeaveChair()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.OnRep_CanLeaveChair");
		
		URBSASChairPanelComponent_OnRep_CanLeaveChair_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.OnGamePhaseUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGamePhase                                         gamePhase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSASChairPanelComponent::OnGamePhaseUpdated(EGamePhase gamePhase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.OnGamePhaseUpdated");
		
		URBSASChairPanelComponent_OnGamePhaseUpdated_Params params {};
		params.gamePhase = gamePhase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.OnForceExitCallback
	 * 		Flags  -> ()
	 */
	void URBSASChairPanelComponent::OnForceExitCallback()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.OnForceExitCallback");
		
		URBSASChairPanelComponent_OnForceExitCallback_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.OnCanSitInChairChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSASChairPanelComponent::OnCanSitInChairChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.OnCanSitInChairChangedCallback");
		
		URBSASChairPanelComponent_OnCanSitInChairChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.OnCanLeaveChairChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSASChairPanelComponent::OnCanLeaveChairChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.OnCanLeaveChairChangedCallback");
		
		URBSASChairPanelComponent_OnCanLeaveChairChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.GetCanSitInChair
	 * 		Flags  -> ()
	 */
	bool URBSASChairPanelComponent::GetCanSitInChair()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.GetCanSitInChair");
		
		URBSASChairPanelComponent_GetCanSitInChair_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.GetCanLeaveChair
	 * 		Flags  -> ()
	 */
	bool URBSASChairPanelComponent::GetCanLeaveChair()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.GetCanLeaveChair");
		
		URBSASChairPanelComponent_GetCanLeaveChair_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.Debug_ForceAllowedToSit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSASChairPanelComponent::Debug_ForceAllowedToSit(float delay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.Debug_ForceAllowedToSit");
		
		URBSASChairPanelComponent_Debug_ForceAllowedToSit_Params params {};
		params.delay = delay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.BP_StartExitSequence
	 * 		Flags  -> ()
	 */
	void URBSASChairPanelComponent::BP_StartExitSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.BP_StartExitSequence");
		
		URBSASChairPanelComponent_BP_StartExitSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.BP_SetShouldFaceTV
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSASChairPanelComponent::BP_SetShouldFaceTV(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.BP_SetShouldFaceTV");
		
		URBSASChairPanelComponent_BP_SetShouldFaceTV_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASChairPanelComponent.BP_SetIsInDrugSequence
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSASChairPanelComponent::BP_SetIsInDrugSequence(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASChairPanelComponent.BP_SetIsInDrugSequence");
		
		URBSASChairPanelComponent_BP_SetIsInDrugSequence_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSASChairPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSASChairPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSASChairPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTransitionZone.OnRep_IsActive
	 * 		Flags  -> ()
	 */
	void ARBSASTransitionZone::OnRep_IsActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTransitionZone.OnRep_IsActive");
		
		ARBSASTransitionZone_OnRep_IsActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTransitionZone.OnRep_CurrentTransitionDirection
	 * 		Flags  -> ()
	 */
	void ARBSASTransitionZone::OnRep_CurrentTransitionDirection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTransitionZone.OnRep_CurrentTransitionDirection");
		
		ARBSASTransitionZone_OnRep_CurrentTransitionDirection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTransitionZone.IsSASDoor
	 * 		Flags  -> ()
	 */
	bool ARBSASTransitionZone::IsSASDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTransitionZone.IsSASDoor");
		
		ARBSASTransitionZone_IsSASDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTransitionZone.Event_OnCurrentDirectionChanged
	 * 		Flags  -> ()
	 */
	void ARBSASTransitionZone::Event_OnCurrentDirectionChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTransitionZone.Event_OnCurrentDirectionChanged");
		
		ARBSASTransitionZone_Event_OnCurrentDirectionChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTransitionZone.BP_SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSASTransitionZone::BP_SetEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTransitionZone.BP_SetEnabled");
		
		ARBSASTransitionZone_BP_SetEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTransitionZone.BP_SetActivated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bActivated                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSASTransitionZone::BP_SetActivated(bool bActivated)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTransitionZone.BP_SetActivated");
		
		ARBSASTransitionZone_BP_SetActivated_Params params {};
		params.bActivated = bActivated;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTransitionZone.BP_OnDeactivate
	 * 		Flags  -> ()
	 */
	void ARBSASTransitionZone::BP_OnDeactivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTransitionZone.BP_OnDeactivate");
		
		ARBSASTransitionZone_BP_OnDeactivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTransitionZone.BP_OnActivate
	 * 		Flags  -> ()
	 */
	void ARBSASTransitionZone::BP_OnActivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTransitionZone.BP_OnActivate");
		
		ARBSASTransitionZone_BP_OnActivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTransitionZone.BP_ExecuteTranstion
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSASTransitionZone::BP_ExecuteTranstion(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTransitionZone.BP_ExecuteTranstion");
		
		ARBSASTransitionZone_BP_ExecuteTranstion_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSASTransitionZone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSASTransitionZone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSASTransitionZone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASPlayerStartTransitionZone.BP_ExecuteTransitionOnPlayersInside
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AVolume*                                     Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBSASPlayerStartTransitionZone::BP_ExecuteTransitionOnPlayersInside(class AVolume* Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASPlayerStartTransitionZone.BP_ExecuteTransitionOnPlayersInside");
		
		ARBSASPlayerStartTransitionZone_BP_ExecuteTransitionOnPlayersInside_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSASPlayerStartTransitionZone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSASPlayerStartTransitionZone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSASPlayerStartTransitionZone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.OnRep_TubeFacingForward
	 * 		Flags  -> ()
	 */
	void ARBSASTube::OnRep_TubeFacingForward()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.OnRep_TubeFacingForward");
		
		ARBSASTube_OnRep_TubeFacingForward_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.OnRep_PlayersInside
	 * 		Flags  -> ()
	 */
	void ARBSASTube::OnRep_PlayersInside()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.OnRep_PlayersInside");
		
		ARBSASTube_OnRep_PlayersInside_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.OnRep_IsOpened
	 * 		Flags  -> ()
	 */
	void ARBSASTube::OnRep_IsOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.OnRep_IsOpened");
		
		ARBSASTube_OnRep_IsOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.OnRep_DoorState
	 * 		Flags  -> ()
	 */
	void ARBSASTube::OnRep_DoorState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.OnRep_DoorState");
		
		ARBSASTube_OnRep_DoorState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.OnComponentCapsuleEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSASTube::OnComponentCapsuleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.OnComponentCapsuleEndOverlap");
		
		ARBSASTube_OnComponentCapsuleEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.OnComponentCapsuleBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBSASTube::OnComponentCapsuleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.OnComponentCapsuleBeginOverlap");
		
		ARBSASTube_OnComponentCapsuleBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.OnComponentBoxBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBSASTube::OnComponentBoxBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.OnComponentBoxBeginOverlap");
		
		ARBSASTube_OnComponentBoxBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.GetDoorState
	 * 		Flags  -> ()
	 */
	EAutoDoorState ARBSASTube::GetDoorState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.GetDoorState");
		
		ARBSASTube_GetDoorState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.Event_OnTubeFacingForwardChanged
	 * 		Flags  -> ()
	 */
	void ARBSASTube::Event_OnTubeFacingForwardChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.Event_OnTubeFacingForwardChanged");
		
		ARBSASTube_Event_OnTubeFacingForwardChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.Event_OnDoorStateChanged
	 * 		Flags  -> ()
	 */
	void ARBSASTube::Event_OnDoorStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.Event_OnDoorStateChanged");
		
		ARBSASTube_Event_OnDoorStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.BP_OnPreBeginPlay
	 * 		Flags  -> ()
	 */
	void ARBSASTube::BP_OnPreBeginPlay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.BP_OnPreBeginPlay");
		
		ARBSASTube_BP_OnPreBeginPlay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.BP_OnPlayersInsideChanged
	 * 		Flags  -> ()
	 */
	void ARBSASTube::BP_OnPlayersInsideChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.BP_OnPlayersInsideChanged");
		
		ARBSASTube_BP_OnPlayersInsideChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.BP_OnOpen
	 * 		Flags  -> ()
	 */
	void ARBSASTube::BP_OnOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.BP_OnOpen");
		
		ARBSASTube_BP_OnOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.BP_OnDoorAnimationFinished
	 * 		Flags  -> ()
	 */
	void ARBSASTube::BP_OnDoorAnimationFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.BP_OnDoorAnimationFinished");
		
		ARBSASTube_BP_OnDoorAnimationFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.BP_OnClose
	 * 		Flags  -> ()
	 */
	void ARBSASTube::BP_OnClose()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.BP_OnClose");
		
		ARBSASTube_BP_OnClose_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTube.BP_ForceAutoDoorState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EAutoDoorState                                     inDoorState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSASTube::BP_ForceAutoDoorState(EAutoDoorState inDoorState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTube.BP_ForceAutoDoorState");
		
		ARBSASTube_BP_ForceAutoDoorState_Params params {};
		params.inDoorState = inDoorState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSASTube.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSASTube::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSASTube");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTubesDoor.OnRep_Tubes
	 * 		Flags  -> ()
	 */
	void ARBSASTubesDoor::OnRep_Tubes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTubesDoor.OnRep_Tubes");
		
		ARBSASTubesDoor_OnRep_Tubes_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTubesDoor.Event_OnTubesChanged
	 * 		Flags  -> ()
	 */
	void ARBSASTubesDoor::Event_OnTubesChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTubesDoor.Event_OnTubesChanged");
		
		ARBSASTubesDoor_Event_OnTubesChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSASTubesDoor.BP_ForceAlwaysOpen
	 * 		Flags  -> ()
	 */
	void ARBSASTubesDoor::BP_ForceAlwaysOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSASTubesDoor.BP_ForceAlwaysOpen");
		
		ARBSASTubesDoor_BP_ForceAlwaysOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSASTubesDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSASTubesDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSASTubesDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSaveGameManager.AsyncWriteProfileDone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SlotName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            UserIndex                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSaveGameManager::AsyncWriteProfileDone(const class FString& SlotName, int32_t UserIndex, bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSaveGameManager.AsyncWriteProfileDone");
		
		URBSaveGameManager_AsyncWriteProfileDone_Params params {};
		params.SlotName = SlotName;
		params.UserIndex = UserIndex;
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSaveGameManager.AsyncWriteGameUserPreferencesDone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SlotName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            UserIndex                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSaveGameManager::AsyncWriteGameUserPreferencesDone(const class FString& SlotName, int32_t UserIndex, bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSaveGameManager.AsyncWriteGameUserPreferencesDone");
		
		URBSaveGameManager_AsyncWriteGameUserPreferencesDone_Params params {};
		params.SlotName = SlotName;
		params.UserIndex = UserIndex;
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSaveGameManager.AsyncLoadProfileDone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SlotName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            UserIndex                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USaveGame*                                   SaveGame                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSaveGameManager::AsyncLoadProfileDone(const class FString& SlotName, int32_t UserIndex, class USaveGame* SaveGame)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSaveGameManager.AsyncLoadProfileDone");
		
		URBSaveGameManager_AsyncLoadProfileDone_Params params {};
		params.SlotName = SlotName;
		params.UserIndex = UserIndex;
		params.SaveGame = SaveGame;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSaveGameManager.AsyncLoadGameUserPreferencesDone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      SlotName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            UserIndex                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USaveGame*                                   SaveGame                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSaveGameManager::AsyncLoadGameUserPreferencesDone(const class FString& SlotName, int32_t UserIndex, class USaveGame* SaveGame)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSaveGameManager.AsyncLoadGameUserPreferencesDone");
		
		URBSaveGameManager_AsyncLoadGameUserPreferencesDone_Params params {};
		params.SlotName = SlotName;
		params.UserIndex = UserIndex;
		params.SaveGame = SaveGame;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSaveGameManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSaveGameManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSaveGameManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSawPanelComponent.OnSlavePanelPawnInteractingChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSawPanelComponent::OnSlavePanelPawnInteractingChanged(class URBInteractiblePanelComponent* panel, class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSawPanelComponent.OnSlavePanelPawnInteractingChanged");
		
		URBSawPanelComponent_OnSlavePanelPawnInteractingChanged_Params params {};
		params.panel = panel;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSawPanelComponent.IsMaster
	 * 		Flags  -> ()
	 */
	bool URBSawPanelComponent::IsMaster()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSawPanelComponent.IsMaster");
		
		URBSawPanelComponent_IsMaster_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSawPanelComponent.BP_IsSawConsideredMoving
	 * 		Flags  -> ()
	 */
	bool URBSawPanelComponent::BP_IsSawConsideredMoving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSawPanelComponent.BP_IsSawConsideredMoving");
		
		URBSawPanelComponent_BP_IsSawConsideredMoving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSawPanelComponent.BP_GetSawPushDelta
	 * 		Flags  -> ()
	 */
	float URBSawPanelComponent::BP_GetSawPushDelta()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSawPanelComponent.BP_GetSawPushDelta");
		
		URBSawPanelComponent_BP_GetSawPushDelta_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSawPanelComponent.BP_GetSawOffsetRatioForSide
	 * 		Flags  -> ()
	 */
	float URBSawPanelComponent::BP_GetSawOffsetRatioForSide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSawPanelComponent.BP_GetSawOffsetRatioForSide");
		
		URBSawPanelComponent_BP_GetSawOffsetRatioForSide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSawPanelComponent.BP_GetSawMovingSpeed
	 * 		Flags  -> ()
	 */
	float URBSawPanelComponent::BP_GetSawMovingSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSawPanelComponent.BP_GetSawMovingSpeed");
		
		URBSawPanelComponent_BP_GetSawMovingSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSawPanelComponent.BP_GetSawCurrentOffset
	 * 		Flags  -> ()
	 */
	float URBSawPanelComponent::BP_GetSawCurrentOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSawPanelComponent.BP_GetSawCurrentOffset");
		
		URBSawPanelComponent_BP_GetSawCurrentOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSawPanelComponent.BP_GetSawAccumulatedDistance
	 * 		Flags  -> ()
	 */
	float URBSawPanelComponent::BP_GetSawAccumulatedDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSawPanelComponent.BP_GetSawAccumulatedDistance");
		
		URBSawPanelComponent_BP_GetSawAccumulatedDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSawPanelComponent.BP_GetPawnPushingIntentRatio
	 * 		Flags  -> ()
	 */
	float URBSawPanelComponent::BP_GetPawnPushingIntentRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSawPanelComponent.BP_GetPawnPushingIntentRatio");
		
		URBSawPanelComponent_BP_GetPawnPushingIntentRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSawPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSawPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSawPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBScheduledBotSpawnCommand.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBScheduledBotSpawnCommand::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBScheduledBotSpawnCommand");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBScheduledBotSpawnAtMonsterClosetCommand.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBScheduledBotSpawnAtMonsterClosetCommand::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBScheduledBotSpawnAtMonsterClosetCommand");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBScheduledSpawnerSpawnAICommand.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBScheduledSpawnerSpawnAICommand::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBScheduledSpawnerSpawnAICommand");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledUObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledUObject                           ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::SetValue_ScheduledUObject(struct FScheduledUObject* ScheduledProperty, class UObject* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledUObject");
		
		URBScheduledBlueprintLibrary_SetValue_ScheduledUObject_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledTransform                         ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Value                                                      (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::SetValue_ScheduledTransform(struct FScheduledTransform* ScheduledProperty, const struct FTransform& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledTransform");
		
		URBScheduledBlueprintLibrary_SetValue_ScheduledTransform_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledInt8
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt8                              ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::SetValue_ScheduledInt8(struct FScheduledInt8* ScheduledProperty, unsigned char Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledInt8");
		
		URBScheduledBlueprintLibrary_SetValue_ScheduledInt8_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledInt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt                               ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::SetValue_ScheduledInt(struct FScheduledInt* ScheduledProperty, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledInt");
		
		URBScheduledBlueprintLibrary_SetValue_ScheduledInt_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledFloat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledFloat                             ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::SetValue_ScheduledFloat(struct FScheduledFloat* ScheduledProperty, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledFloat");
		
		URBScheduledBlueprintLibrary_SetValue_ScheduledFloat_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledBool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledBool                              ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::SetValue_ScheduledBool(struct FScheduledBool* ScheduledProperty, bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.SetValue_ScheduledBool");
		
		URBScheduledBlueprintLibrary_SetValue_ScheduledBool_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledUObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledUObject                           ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::SetInitialValue_ScheduledUObject(struct FScheduledUObject* ScheduledProperty, class UObject* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledUObject");
		
		URBScheduledBlueprintLibrary_SetInitialValue_ScheduledUObject_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledTransform                         ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Value                                                      (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::SetInitialValue_ScheduledTransform(struct FScheduledTransform* ScheduledProperty, const struct FTransform& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledTransform");
		
		URBScheduledBlueprintLibrary_SetInitialValue_ScheduledTransform_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledInt8
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt8                              ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::SetInitialValue_ScheduledInt8(struct FScheduledInt8* ScheduledProperty, unsigned char Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledInt8");
		
		URBScheduledBlueprintLibrary_SetInitialValue_ScheduledInt8_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledInt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt                               ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::SetInitialValue_ScheduledInt(struct FScheduledInt* ScheduledProperty, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledInt");
		
		URBScheduledBlueprintLibrary_SetInitialValue_ScheduledInt_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledFloat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledFloat                             ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::SetInitialValue_ScheduledFloat(struct FScheduledFloat* ScheduledProperty, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledFloat");
		
		URBScheduledBlueprintLibrary_SetInitialValue_ScheduledFloat_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledBool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledBool                              ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::SetInitialValue_ScheduledBool(struct FScheduledBool* ScheduledProperty, bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.SetInitialValue_ScheduledBool");
		
		URBScheduledBlueprintLibrary_SetInitialValue_ScheduledBool_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledUObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledUObject                           ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::ScheduleValue_ScheduledUObject(struct FScheduledUObject* ScheduledProperty, class UObject* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledUObject");
		
		URBScheduledBlueprintLibrary_ScheduleValue_ScheduledUObject_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledTransform                         ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Value                                                      (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::ScheduleValue_ScheduledTransform(struct FScheduledTransform* ScheduledProperty, const struct FTransform& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledTransform");
		
		URBScheduledBlueprintLibrary_ScheduleValue_ScheduledTransform_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledInt8
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt8                              ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::ScheduleValue_ScheduledInt8(struct FScheduledInt8* ScheduledProperty, unsigned char Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledInt8");
		
		URBScheduledBlueprintLibrary_ScheduleValue_ScheduledInt8_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledInt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt                               ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::ScheduleValue_ScheduledInt(struct FScheduledInt* ScheduledProperty, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledInt");
		
		URBScheduledBlueprintLibrary_ScheduleValue_ScheduledInt_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledFloat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledFloat                             ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::ScheduleValue_ScheduledFloat(struct FScheduledFloat* ScheduledProperty, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledFloat");
		
		URBScheduledBlueprintLibrary_ScheduleValue_ScheduledFloat_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledBool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledBool                              ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::ScheduleValue_ScheduledBool(struct FScheduledBool* ScheduledProperty, bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.ScheduleValue_ScheduledBool");
		
		URBScheduledBlueprintLibrary_ScheduleValue_ScheduledBool_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledUObject_Component
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledUObject                           ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UActorComponent*                             Owner                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              InDelegate                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::Initialize_ScheduledUObject_Component(struct FScheduledUObject* ScheduledProperty, class UActorComponent* Owner, const class FScriptDelegate& InDelegate, const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledUObject_Component");
		
		URBScheduledBlueprintLibrary_Initialize_ScheduledUObject_Component_Params params {};
		params.Owner = Owner;
		params.InDelegate = InDelegate;
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledUObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledUObject                           ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              InDelegate                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::Initialize_ScheduledUObject(struct FScheduledUObject* ScheduledProperty, class AActor* Owner, const class FScriptDelegate& InDelegate, const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledUObject");
		
		URBScheduledBlueprintLibrary_Initialize_ScheduledUObject_Params params {};
		params.Owner = Owner;
		params.InDelegate = InDelegate;
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledTransform_Component
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledTransform                         ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UActorComponent*                             Owner                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              InDelegate                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::Initialize_ScheduledTransform_Component(struct FScheduledTransform* ScheduledProperty, class UActorComponent* Owner, const class FScriptDelegate& InDelegate, const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledTransform_Component");
		
		URBScheduledBlueprintLibrary_Initialize_ScheduledTransform_Component_Params params {};
		params.Owner = Owner;
		params.InDelegate = InDelegate;
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledTransform                         ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              InDelegate                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::Initialize_ScheduledTransform(struct FScheduledTransform* ScheduledProperty, class AActor* Owner, const class FScriptDelegate& InDelegate, const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledTransform");
		
		URBScheduledBlueprintLibrary_Initialize_ScheduledTransform_Params params {};
		params.Owner = Owner;
		params.InDelegate = InDelegate;
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledInt_Component
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt                               ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UActorComponent*                             Owner                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              InDelegate                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::Initialize_ScheduledInt_Component(struct FScheduledInt* ScheduledProperty, class UActorComponent* Owner, const class FScriptDelegate& InDelegate, const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledInt_Component");
		
		URBScheduledBlueprintLibrary_Initialize_ScheduledInt_Component_Params params {};
		params.Owner = Owner;
		params.InDelegate = InDelegate;
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledInt8_Component
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt8                              ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UActorComponent*                             Owner                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              InDelegate                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::Initialize_ScheduledInt8_Component(struct FScheduledInt8* ScheduledProperty, class UActorComponent* Owner, const class FScriptDelegate& InDelegate, const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledInt8_Component");
		
		URBScheduledBlueprintLibrary_Initialize_ScheduledInt8_Component_Params params {};
		params.Owner = Owner;
		params.InDelegate = InDelegate;
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledInt8
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt8                              ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              InDelegate                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::Initialize_ScheduledInt8(struct FScheduledInt8* ScheduledProperty, class AActor* Owner, const class FScriptDelegate& InDelegate, const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledInt8");
		
		URBScheduledBlueprintLibrary_Initialize_ScheduledInt8_Params params {};
		params.Owner = Owner;
		params.InDelegate = InDelegate;
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledInt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt                               ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              InDelegate                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::Initialize_ScheduledInt(struct FScheduledInt* ScheduledProperty, class AActor* Owner, const class FScriptDelegate& InDelegate, const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledInt");
		
		URBScheduledBlueprintLibrary_Initialize_ScheduledInt_Params params {};
		params.Owner = Owner;
		params.InDelegate = InDelegate;
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledFloat_Component
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledFloat                             ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UActorComponent*                             Owner                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              InDelegate                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::Initialize_ScheduledFloat_Component(struct FScheduledFloat* ScheduledProperty, class UActorComponent* Owner, const class FScriptDelegate& InDelegate, const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledFloat_Component");
		
		URBScheduledBlueprintLibrary_Initialize_ScheduledFloat_Component_Params params {};
		params.Owner = Owner;
		params.InDelegate = InDelegate;
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledFloat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledFloat                             ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              InDelegate                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::Initialize_ScheduledFloat(struct FScheduledFloat* ScheduledProperty, class AActor* Owner, const class FScriptDelegate& InDelegate, const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledFloat");
		
		URBScheduledBlueprintLibrary_Initialize_ScheduledFloat_Params params {};
		params.Owner = Owner;
		params.InDelegate = InDelegate;
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledBool_Component
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledBool                              ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UActorComponent*                             Owner                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              InDelegate                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::Initialize_ScheduledBool_Component(struct FScheduledBool* ScheduledProperty, class UActorComponent* Owner, const class FScriptDelegate& InDelegate, const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledBool_Component");
		
		URBScheduledBlueprintLibrary_Initialize_ScheduledBool_Component_Params params {};
		params.Owner = Owner;
		params.InDelegate = InDelegate;
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledBool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledBool                              ScheduledProperty                                          (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              InDelegate                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBScheduledBlueprintLibrary::Initialize_ScheduledBool(struct FScheduledBool* ScheduledProperty, class AActor* Owner, const class FScriptDelegate& InDelegate, const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.Initialize_ScheduledBool");
		
		URBScheduledBlueprintLibrary_Initialize_ScheduledBool_Params params {};
		params.Owner = Owner;
		params.InDelegate = InDelegate;
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScheduledProperty != nullptr)
			*ScheduledProperty = params.ScheduledProperty;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledUObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledUObject                           ScheduledProperty                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class UObject* URBScheduledBlueprintLibrary::GetInitialValue_ScheduledUObject(const struct FScheduledUObject& ScheduledProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledUObject");
		
		URBScheduledBlueprintLibrary_GetInitialValue_ScheduledUObject_Params params {};
		params.ScheduledProperty = ScheduledProperty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledTransform                         ScheduledProperty                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	struct FTransform URBScheduledBlueprintLibrary::GetInitialValue_ScheduledTransform(const struct FScheduledTransform& ScheduledProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledTransform");
		
		URBScheduledBlueprintLibrary_GetInitialValue_ScheduledTransform_Params params {};
		params.ScheduledProperty = ScheduledProperty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledInt8
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt8                              ScheduledProperty                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	unsigned char URBScheduledBlueprintLibrary::GetInitialValue_ScheduledInt8(const struct FScheduledInt8& ScheduledProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledInt8");
		
		URBScheduledBlueprintLibrary_GetInitialValue_ScheduledInt8_Params params {};
		params.ScheduledProperty = ScheduledProperty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledInt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt                               ScheduledProperty                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	int32_t URBScheduledBlueprintLibrary::GetInitialValue_ScheduledInt(const struct FScheduledInt& ScheduledProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledInt");
		
		URBScheduledBlueprintLibrary_GetInitialValue_ScheduledInt_Params params {};
		params.ScheduledProperty = ScheduledProperty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledFloat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledFloat                             ScheduledProperty                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	float URBScheduledBlueprintLibrary::GetInitialValue_ScheduledFloat(const struct FScheduledFloat& ScheduledProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledFloat");
		
		URBScheduledBlueprintLibrary_GetInitialValue_ScheduledFloat_Params params {};
		params.ScheduledProperty = ScheduledProperty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledBool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledBool                              ScheduledProperty                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool URBScheduledBlueprintLibrary::GetInitialValue_ScheduledBool(const struct FScheduledBool& ScheduledProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.GetInitialValue_ScheduledBool");
		
		URBScheduledBlueprintLibrary_GetInitialValue_ScheduledBool_Params params {};
		params.ScheduledProperty = ScheduledProperty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledUObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledUObject                           ScheduledProperty                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class UObject* URBScheduledBlueprintLibrary::GetCurrentValue_ScheduledUObject(const struct FScheduledUObject& ScheduledProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledUObject");
		
		URBScheduledBlueprintLibrary_GetCurrentValue_ScheduledUObject_Params params {};
		params.ScheduledProperty = ScheduledProperty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledTransform                         ScheduledProperty                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	struct FTransform URBScheduledBlueprintLibrary::GetCurrentValue_ScheduledTransform(const struct FScheduledTransform& ScheduledProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledTransform");
		
		URBScheduledBlueprintLibrary_GetCurrentValue_ScheduledTransform_Params params {};
		params.ScheduledProperty = ScheduledProperty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledInt8
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt8                              ScheduledProperty                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	unsigned char URBScheduledBlueprintLibrary::GetCurrentValue_ScheduledInt8(const struct FScheduledInt8& ScheduledProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledInt8");
		
		URBScheduledBlueprintLibrary_GetCurrentValue_ScheduledInt8_Params params {};
		params.ScheduledProperty = ScheduledProperty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledInt
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledInt                               ScheduledProperty                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	int32_t URBScheduledBlueprintLibrary::GetCurrentValue_ScheduledInt(const struct FScheduledInt& ScheduledProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledInt");
		
		URBScheduledBlueprintLibrary_GetCurrentValue_ScheduledInt_Params params {};
		params.ScheduledProperty = ScheduledProperty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledFloat
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledFloat                             ScheduledProperty                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	float URBScheduledBlueprintLibrary::GetCurrentValue_ScheduledFloat(const struct FScheduledFloat& ScheduledProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledFloat");
		
		URBScheduledBlueprintLibrary_GetCurrentValue_ScheduledFloat_Params params {};
		params.ScheduledProperty = ScheduledProperty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledBool
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FScheduledBool                              ScheduledProperty                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool URBScheduledBlueprintLibrary::GetCurrentValue_ScheduledBool(const struct FScheduledBool& ScheduledProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScheduledBlueprintLibrary.GetCurrentValue_ScheduledBool");
		
		URBScheduledBlueprintLibrary_GetCurrentValue_ScheduledBool_Params params {};
		params.ScheduledProperty = ScheduledProperty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBScheduledBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBScheduledBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBScheduledBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScoringConfig.GetTextValue
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRecordedScoringEvent                       scoringEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class FText URBScoringConfig::GetTextValue(const struct FRecordedScoringEvent& scoringEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScoringConfig.GetTextValue");
		
		URBScoringConfig_GetTextValue_Params params {};
		params.scoringEvent = scoringEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScoringConfig.GetScoringRule
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        RuleId                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRBScoringRuleRow URBScoringConfig::GetScoringRule(const class FName& RuleId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScoringConfig.GetScoringRule");
		
		URBScoringConfig_GetScoringRule_Params params {};
		params.RuleId = RuleId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScoringConfig.FilterScoringEvents
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRecordedScoringEvent>               scoringEvents                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxEvents                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FRecordedScoringEvent> URBScoringConfig::FilterScoringEvents(TArray<struct FRecordedScoringEvent> scoringEvents, int32_t maxEvents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScoringConfig.FilterScoringEvents");
		
		URBScoringConfig_FilterScoringEvents_Params params {};
		params.scoringEvents = scoringEvents;
		params.maxEvents = maxEvents;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBScoringConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBScoringConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBScoringConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScriptedAnimStation.TryPlayFacialAnim
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      lineId                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBScriptedAnimStation::TryPlayFacialAnim(const class FString& lineId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScriptedAnimStation.TryPlayFacialAnim");
		
		ARBScriptedAnimStation_TryPlayFacialAnim_Params params {};
		params.lineId = lineId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScriptedAnimStation.SetForceClientMeshUpdate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBScriptedAnimStation::SetForceClientMeshUpdate(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScriptedAnimStation.SetForceClientMeshUpdate");
		
		ARBScriptedAnimStation_SetForceClientMeshUpdate_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScriptedAnimStation.OnRep_StationHidden
	 * 		Flags  -> ()
	 */
	void ARBScriptedAnimStation::OnRep_StationHidden()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScriptedAnimStation.OnRep_StationHidden");
		
		ARBScriptedAnimStation_OnRep_StationHidden_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScriptedAnimStation.OnRep_ShouldBePlaying
	 * 		Flags  -> ()
	 */
	void ARBScriptedAnimStation::OnRep_ShouldBePlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScriptedAnimStation.OnRep_ShouldBePlaying");
		
		ARBScriptedAnimStation_OnRep_ShouldBePlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScriptedAnimStation.GetFacePoseAsset
	 * 		Flags  -> ()
	 */
	class UPoseAsset* ARBScriptedAnimStation::GetFacePoseAsset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScriptedAnimStation.GetFacePoseAsset");
		
		ARBScriptedAnimStation_GetFacePoseAsset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScriptedAnimStation.GetFaceFXSkeletalMeshComponent
	 * 		Flags  -> ()
	 */
	class USkeletalMeshComponent* ARBScriptedAnimStation::GetFaceFXSkeletalMeshComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScriptedAnimStation.GetFaceFXSkeletalMeshComponent");
		
		ARBScriptedAnimStation_GetFaceFXSkeletalMeshComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScriptedAnimStation.Event_StoppedScriptedAnim
	 * 		Flags  -> ()
	 */
	void ARBScriptedAnimStation::Event_StoppedScriptedAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScriptedAnimStation.Event_StoppedScriptedAnim");
		
		ARBScriptedAnimStation_Event_StoppedScriptedAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScriptedAnimStation.Event_StartedScriptedAnim
	 * 		Flags  -> ()
	 */
	void ARBScriptedAnimStation::Event_StartedScriptedAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScriptedAnimStation.Event_StartedScriptedAnim");
		
		ARBScriptedAnimStation_Event_StartedScriptedAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScriptedAnimStation.BP_WillSkeletalMeshTick
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBScriptedAnimStation::BP_WillSkeletalMeshTick(class USkeletalMeshComponent* Mesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScriptedAnimStation.BP_WillSkeletalMeshTick");
		
		ARBScriptedAnimStation_BP_WillSkeletalMeshTick_Params params {};
		params.Mesh = Mesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScriptedAnimStation.BP_StopScriptedSequence
	 * 		Flags  -> ()
	 */
	void ARBScriptedAnimStation::BP_StopScriptedSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScriptedAnimStation.BP_StopScriptedSequence");
		
		ARBScriptedAnimStation_BP_StopScriptedSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScriptedAnimStation.BP_StartScriptedSequence
	 * 		Flags  -> ()
	 */
	void ARBScriptedAnimStation::BP_StartScriptedSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScriptedAnimStation.BP_StartScriptedSequence");
		
		ARBScriptedAnimStation_BP_StartScriptedSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBScriptedAnimStation.BP_SetStationHidden
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBScriptedAnimStation::BP_SetStationHidden(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBScriptedAnimStation.BP_SetStationHidden");
		
		ARBScriptedAnimStation_BP_SetStationHidden_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBScriptedAnimStation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBScriptedAnimStation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBScriptedAnimStation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSettings_Anim.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSettings_Anim::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSettings_Anim");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSettings_Audio.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSettings_Audio::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSettings_Audio");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSettings_DevDecals.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSettings_DevDecals::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSettings_DevDecals");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSettings_DevTools.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSettings_DevTools::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSettings_DevTools");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSettings_DevUser.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSettings_DevUser::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSettings_DevUser");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSettings_FeatureSwitch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSettings_FeatureSwitch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSettings_FeatureSwitch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSettings_Gameplay.GetIngameItemConfig
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EItemType                                          ItemType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FIngameItemConfig URBSettings_Gameplay::GetIngameItemConfig(EItemType ItemType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSettings_Gameplay.GetIngameItemConfig");
		
		URBSettings_Gameplay_GetIngameItemConfig_Params params {};
		params.ItemType = ItemType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSettings_Gameplay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSettings_Gameplay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSettings_Gameplay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSettings_GlobalConfigs.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSettings_GlobalConfigs::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSettings_GlobalConfigs");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSettings_Rendering.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSettings_Rendering::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSettings_Rendering");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSettings_Texts.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSettings_Texts::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSettings_Texts");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSimpleInteractionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSimpleInteractionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSimpleInteractionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleObjectiveActor.OnRep_IsInWorld
	 * 		Flags  -> ()
	 */
	void ARBSimpleObjectiveActor::OnRep_IsInWorld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleObjectiveActor.OnRep_IsInWorld");
		
		ARBSimpleObjectiveActor_OnRep_IsInWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSimpleObjectiveActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSimpleObjectiveActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSimpleObjectiveActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleObjectiveCoordinator.OnUsedOnObject
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBLargePickup*                              largePickup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBLargeObjectInteractionPanelComponent*     panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSimpleObjectiveCoordinator::OnUsedOnObject(class ARBPawn* interactor, class ARBLargePickup* largePickup, class URBLargeObjectInteractionPanelComponent* panel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleObjectiveCoordinator.OnUsedOnObject");
		
		ARBSimpleObjectiveCoordinator_OnUsedOnObject_Params params {};
		params.interactor = interactor;
		params.largePickup = largePickup;
		params.panel = panel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleObjectiveCoordinator.OnTriggeredVolumeEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBPlayerTriggerComponent*                   Trigger                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSimpleObjectiveCoordinator::OnTriggeredVolumeEvent(class URBPlayerTriggerComponent* Trigger)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleObjectiveCoordinator.OnTriggeredVolumeEvent");
		
		ARBSimpleObjectiveCoordinator_OnTriggeredVolumeEvent_Params params {};
		params.Trigger = Trigger;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleObjectiveCoordinator.OnTriggered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsOn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBTriggerable*                              triggerable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSimpleObjectiveCoordinator::OnTriggered(bool IsOn, class ARBTriggerable* triggerable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleObjectiveCoordinator.OnTriggered");
		
		ARBSimpleObjectiveCoordinator_OnTriggered_Params params {};
		params.IsOn = IsOn;
		params.triggerable = triggerable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleObjectiveCoordinator.OnTargetTriggerBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBSimpleObjectiveCoordinator::OnTargetTriggerBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleObjectiveCoordinator.OnTargetTriggerBeginOverlap");
		
		ARBSimpleObjectiveCoordinator_OnTargetTriggerBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleObjectiveCoordinator.OnPlayerSimpleDoAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBInteractibleComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSimpleObjectiveCoordinator::OnPlayerSimpleDoAction(class ARBPawn* Player, class URBInteractibleComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleObjectiveCoordinator.OnPlayerSimpleDoAction");
		
		ARBSimpleObjectiveCoordinator_OnPlayerSimpleDoAction_Params params {};
		params.Player = Player;
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleObjectiveCoordinator.OnPlayerDoAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBInteractible*                             interactible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSimpleObjectiveCoordinator::OnPlayerDoAction(class ARBPawn* Player, class ARBInteractible* interactible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleObjectiveCoordinator.OnPlayerDoAction");
		
		ARBSimpleObjectiveCoordinator_OnPlayerDoAction_Params params {};
		params.Player = Player;
		params.interactible = interactible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleObjectiveCoordinator.OnPlayerCompletedOperatable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsOn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBOperatable*                               operatable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSimpleObjectiveCoordinator::OnPlayerCompletedOperatable(bool IsOn, class ARBOperatable* operatable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleObjectiveCoordinator.OnPlayerCompletedOperatable");
		
		ARBSimpleObjectiveCoordinator_OnPlayerCompletedOperatable_Params params {};
		params.IsOn = IsOn;
		params.operatable = operatable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleObjectiveCoordinator.Multicast_ShowSimpleObjectiveTutorial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBSimpleInteractionComponent*               simpleComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSimpleObjectiveCoordinator::Multicast_ShowSimpleObjectiveTutorial(class ARBPawn* Player, class URBSimpleInteractionComponent* simpleComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleObjectiveCoordinator.Multicast_ShowSimpleObjectiveTutorial");
		
		ARBSimpleObjectiveCoordinator_Multicast_ShowSimpleObjectiveTutorial_Params params {};
		params.Player = Player;
		params.simpleComponent = simpleComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSimpleObjectiveCoordinator.Multicast_OnSimpleDoActionCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBInteractibleComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSimpleObjectiveCoordinator::Multicast_OnSimpleDoActionCompleted(class ARBPawn* Player, class URBInteractibleComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSimpleObjectiveCoordinator.Multicast_OnSimpleDoActionCompleted");
		
		ARBSimpleObjectiveCoordinator_Multicast_OnSimpleDoActionCompleted_Params params {};
		params.Player = Player;
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSimpleObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSimpleObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSimpleObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSinglePlayerHelperComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSinglePlayerHelperComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSinglePlayerHelperComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlideDownVolume.OnPlayerEntered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSlideDownVolume::OnPlayerEntered(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlideDownVolume.OnPlayerEntered");
		
		ARBSlideDownVolume_OnPlayerEntered_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlideDownVolume.OnBrushComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBSlideDownVolume::OnBrushComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlideDownVolume.OnBrushComponentBeginOverlap");
		
		ARBSlideDownVolume_OnBrushComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSlideDownVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSlideDownVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSlideDownVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlidingLock.OnRep_Islocked
	 * 		Flags  -> ()
	 */
	void ARBSlidingLock::OnRep_Islocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlidingLock.OnRep_Islocked");
		
		ARBSlidingLock_OnRep_Islocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlidingLock.IsLockedChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSlidingLock::IsLockedChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlidingLock.IsLockedChangedCallback");
		
		ARBSlidingLock_IsLockedChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlidingLock.BP_SetLocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bLocked                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSlidingLock::BP_SetLocked(bool bLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlidingLock.BP_SetLocked");
		
		ARBSlidingLock_BP_SetLocked_Params params {};
		params.bLocked = bLocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlidingLock.BP_PostDoorInitialization
	 * 		Flags  -> ()
	 */
	void ARBSlidingLock::BP_PostDoorInitialization()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlidingLock.BP_PostDoorInitialization");
		
		ARBSlidingLock_BP_PostDoorInitialization_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlidingLock.BP_OverrideEditorCompTranform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        compName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLocked                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Transform                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FTransform ARBSlidingLock::BP_OverrideEditorCompTranform(const class FName& compName, bool bLocked, const struct FTransform& Transform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlidingLock.BP_OverrideEditorCompTranform");
		
		ARBSlidingLock_BP_OverrideEditorCompTranform_Params params {};
		params.compName = compName;
		params.bLocked = bLocked;
		params.Transform = Transform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlidingLock.BP_OnUnlock
	 * 		Flags  -> ()
	 */
	void ARBSlidingLock::BP_OnUnlock()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlidingLock.BP_OnUnlock");
		
		ARBSlidingLock_BP_OnUnlock_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlidingLock.BP_OnLock
	 * 		Flags  -> ()
	 */
	void ARBSlidingLock::BP_OnLock()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlidingLock.BP_OnLock");
		
		ARBSlidingLock_BP_OnLock_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlidingLock.BP_OnDoorOwnerChanged
	 * 		Flags  -> ()
	 */
	void ARBSlidingLock::BP_OnDoorOwnerChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlidingLock.BP_OnDoorOwnerChanged");
		
		ARBSlidingLock_BP_OnDoorOwnerChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlidingLock.BP_OnDoorDestroyed
	 * 		Flags  -> ()
	 */
	void ARBSlidingLock::BP_OnDoorDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlidingLock.BP_OnDoorDestroyed");
		
		ARBSlidingLock_BP_OnDoorDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlidingLock.BP_IsLocked
	 * 		Flags  -> ()
	 */
	bool ARBSlidingLock::BP_IsLocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlidingLock.BP_IsLocked");
		
		ARBSlidingLock_BP_IsLocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlidingLock.BP_IsInFront
	 * 		Flags  -> ()
	 */
	bool ARBSlidingLock::BP_IsInFront()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlidingLock.BP_IsInFront");
		
		ARBSlidingLock_BP_IsInFront_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSlidingLock.BP_ApplyAnimatedTransform
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              curveValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     interactorPawn                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSlidingLock::BP_ApplyAnimatedTransform(float curveValue, class ARBPawn* interactorPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSlidingLock.BP_ApplyAnimatedTransform");
		
		ARBSlidingLock_BP_ApplyAnimatedTransform_Params params {};
		params.curveValue = curveValue;
		params.interactorPawn = interactorPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSlidingLock.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSlidingLock::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSlidingLock");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.ShowCharacter
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntry::ShowCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.ShowCharacter");
		
		URBSocialMenuEntry_ShowCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.ShouldDisplayPresence
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::ShouldDisplayPresence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.ShouldDisplayPresence");
		
		URBSocialMenuEntry_ShouldDisplayPresence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.SetVoiceChatVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntry::SetVoiceChatVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.SetVoiceChatVolume");
		
		URBSocialMenuEntry_SetVoiceChatVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.SetVoiceChatOutputVolume
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntry::SetVoiceChatOutputVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.SetVoiceChatOutputVolume");
		
		URBSocialMenuEntry_SetVoiceChatOutputVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.Setup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuManager*                        Parent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRBSocialMenuEntryDetails                   entryDetails                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntry::Setup(class URBSocialMenuManager* Parent, const struct FRBSocialMenuEntryDetails& entryDetails)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.Setup");
		
		URBSocialMenuEntry_Setup_Params params {};
		params.Parent = Parent;
		params.entryDetails = entryDetails;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.RequiresInvite
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::RequiresInvite()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.RequiresInvite");
		
		URBSocialMenuEntry_RequiresInvite_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.RequestOpenContextualMenu
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntry::RequestOpenContextualMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.RequestOpenContextualMenu");
		
		URBSocialMenuEntry_RequestOpenContextualMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.RequestAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERBSocialMenuEntryAction                           action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntry::RequestAction(ERBSocialMenuEntryAction action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.RequestAction");
		
		URBSocialMenuEntry_RequestAction_Params params {};
		params.action = action;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.OnSocialMenuPartyInviteWidgetVisibilityUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntry::OnSocialMenuPartyInviteWidgetVisibilityUpdated(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.OnSocialMenuPartyInviteWidgetVisibilityUpdated");
		
		URBSocialMenuEntry_OnSocialMenuPartyInviteWidgetVisibilityUpdated_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.OnSocialMenuEntryActionStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuEntry*                          Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERBSocialMenuEntryAction                           action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntry::OnSocialMenuEntryActionStarted(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.OnSocialMenuEntryActionStarted");
		
		URBSocialMenuEntry_OnSocialMenuEntryActionStarted_Params params {};
		params.Entry = Entry;
		params.action = action;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.OnSocialMenuEntryActionCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuEntry*                          Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERBSocialMenuEntryAction                           action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntry::OnSocialMenuEntryActionCompleted(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.OnSocialMenuEntryActionCompleted");
		
		URBSocialMenuEntry_OnSocialMenuEntryActionCompleted_Params params {};
		params.Entry = Entry;
		params.action = action;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.OnPlayerStateMatchStateUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMatchState                                 MatchState                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntry::OnPlayerStateMatchStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchState& MatchState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.OnPlayerStateMatchStateUpdated");
		
		URBSocialMenuEntry_OnPlayerStateMatchStateUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.MatchState = MatchState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.OnPlayerPartyStateUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntry::OnPlayerPartyStateUpdated(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.OnPlayerPartyStateUpdated");
		
		URBSocialMenuEntry_OnPlayerPartyStateUpdated_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.OnPlayerLevelChanged
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntry::OnPlayerLevelChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.OnPlayerLevelChanged");
		
		URBSocialMenuEntry_OnPlayerLevelChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.OnPlayerLeaving
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerLeaveTarget                                 Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntry::OnPlayerLeaving(EPlayerLeaveTarget Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.OnPlayerLeaving");
		
		URBSocialMenuEntry_OnPlayerLeaving_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.OnPlayerCustomizationUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBPlayerCustomizationInfo                  customizationInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntry::OnPlayerCustomizationUpdated(const struct FRBPlayerCustomizationInfo& customizationInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.OnPlayerCustomizationUpdated");
		
		URBSocialMenuEntry_OnPlayerCustomizationUpdated_Params params {};
		params.customizationInfo = customizationInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.OnCurrentLoadoutChanged
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntry::OnCurrentLoadoutChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.OnCurrentLoadoutChanged");
		
		URBSocialMenuEntry_OnCurrentLoadoutChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.IsVoiceChatEnabled
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::IsVoiceChatEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.IsVoiceChatEnabled");
		
		URBSocialMenuEntry_IsVoiceChatEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.IsPartyOwner
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::IsPartyOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.IsPartyOwner");
		
		URBSocialMenuEntry_IsPartyOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.IsPartyInviteWidgetShown
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::IsPartyInviteWidgetShown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.IsPartyInviteWidgetShown");
		
		URBSocialMenuEntry_IsPartyInviteWidgetShown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.IsOperationPending
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::IsOperationPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.IsOperationPending");
		
		URBSocialMenuEntry_IsOperationPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.IsOnline
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::IsOnline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.IsOnline");
		
		URBSocialMenuEntry_IsOnline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.IsJoinable
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::IsJoinable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.IsJoinable");
		
		URBSocialMenuEntry_IsJoinable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.IsInYourParty
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::IsInYourParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.IsInYourParty");
		
		URBSocialMenuEntry_IsInYourParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.IsInYourGame
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::IsInYourGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.IsInYourGame");
		
		URBSocialMenuEntry_IsInYourGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.IsInGame
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::IsInGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.IsInGame");
		
		URBSocialMenuEntry_IsInGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.IsCompatibleBuild
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::IsCompatibleBuild()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.IsCompatibleBuild");
		
		URBSocialMenuEntry_IsCompatibleBuild_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.IsBlocked
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::IsBlocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.IsBlocked");
		
		URBSocialMenuEntry_IsBlocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.HideCharacter
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntry::HideCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.HideCharacter");
		
		URBSocialMenuEntry_HideCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.HasPlayerLevel
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::HasPlayerLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.HasPlayerLevel");
		
		URBSocialMenuEntry_HasPlayerLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.HasFlag
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERBSocialMenuEntryFlag                             Flag                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBSocialMenuEntry::HasFlag(ERBSocialMenuEntryFlag Flag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.HasFlag");
		
		URBSocialMenuEntry_HasFlag_Params params {};
		params.Flag = Flag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetVoiceChatVolume
	 * 		Flags  -> ()
	 */
	float URBSocialMenuEntry::GetVoiceChatVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetVoiceChatVolume");
		
		URBSocialMenuEntry_GetVoiceChatVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetVoiceChatOutputVolume
	 * 		Flags  -> ()
	 */
	float URBSocialMenuEntry::GetVoiceChatOutputVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetVoiceChatOutputVolume");
		
		URBSocialMenuEntry_GetVoiceChatOutputVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetSocialMenuEntryListType
	 * 		Flags  -> ()
	 */
	ERBSocialMenuEntryListType URBSocialMenuEntry::GetSocialMenuEntryListType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetSocialMenuEntryListType");
		
		URBSocialMenuEntry_GetSocialMenuEntryListType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetSessionMemberCount
	 * 		Flags  -> ()
	 */
	int32_t URBSocialMenuEntry::GetSessionMemberCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetSessionMemberCount");
		
		URBSocialMenuEntry_GetSessionMemberCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetSessionMaxMemberCount
	 * 		Flags  -> ()
	 */
	int32_t URBSocialMenuEntry::GetSessionMaxMemberCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetSessionMaxMemberCount");
		
		URBSocialMenuEntry_GetSessionMaxMemberCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetSelectedActiveSkill
	 * 		Flags  -> ()
	 */
	EActiveSkillType URBSocialMenuEntry::GetSelectedActiveSkill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetSelectedActiveSkill");
		
		URBSocialMenuEntry_GetSelectedActiveSkill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetReleaseCount
	 * 		Flags  -> ()
	 */
	int32_t URBSocialMenuEntry::GetReleaseCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetReleaseCount");
		
		URBSocialMenuEntry_GetReleaseCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetProfileId
	 * 		Flags  -> ()
	 */
	struct FProfileId URBSocialMenuEntry::GetProfileId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetProfileId");
		
		URBSocialMenuEntry_GetProfileId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetPresenceText
	 * 		Flags  -> ()
	 */
	class FText URBSocialMenuEntry::GetPresenceText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetPresenceText");
		
		URBSocialMenuEntry_GetPresenceText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetPlayerLevel
	 * 		Flags  -> ()
	 */
	int32_t URBSocialMenuEntry::GetPlayerLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetPlayerLevel");
		
		URBSocialMenuEntry_GetPlayerLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetPlayerIcon
	 * 		Flags  -> ()
	 */
	class UTexture2D* URBSocialMenuEntry::GetPlayerIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetPlayerIcon");
		
		URBSocialMenuEntry_GetPlayerIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetPlatform
	 * 		Flags  -> ()
	 */
	EProfilePlatform URBSocialMenuEntry::GetPlatform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetPlatform");
		
		URBSocialMenuEntry_GetPlatform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetName
	 * 		Flags  -> ()
	 */
	class FString URBSocialMenuEntry::GetName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetName");
		
		URBSocialMenuEntry_GetName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetFlags
	 * 		Flags  -> ()
	 */
	int32_t URBSocialMenuEntry::GetFlags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetFlags");
		
		URBSocialMenuEntry_GetFlags_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.GetAvailableActions
	 * 		Flags  -> ()
	 */
	TArray<ERBSocialMenuEntryAction> URBSocialMenuEntry::GetAvailableActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.GetAvailableActions");
		
		URBSocialMenuEntry_GetAvailableActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntry::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.Event_Refresh");
		
		URBSocialMenuEntry_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.Event_OpenContextualMenu
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntry::Event_OpenContextualMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.Event_OpenContextualMenu");
		
		URBSocialMenuEntry_Event_OpenContextualMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.Event_CloseContextualMenu
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntry::Event_CloseContextualMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.Event_CloseContextualMenu");
		
		URBSocialMenuEntry_Event_CloseContextualMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.Event_ActionRequested
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntry::Event_ActionRequested()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.Event_ActionRequested");
		
		URBSocialMenuEntry_Event_ActionRequested_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.CanUpdateVoiceChatVolume
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::CanUpdateVoiceChatVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.CanUpdateVoiceChatVolume");
		
		URBSocialMenuEntry_CanUpdateVoiceChatVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.CanSendPartyInvite
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::CanSendPartyInvite()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.CanSendPartyInvite");
		
		URBSocialMenuEntry_CanSendPartyInvite_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.CanOpenContextualMenu
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntry::CanOpenContextualMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.CanOpenContextualMenu");
		
		URBSocialMenuEntry_CanOpenContextualMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntry.BP_GetRBPlayerState
	 * 		Flags  -> ()
	 */
	class ARBPlayerState* URBSocialMenuEntry::BP_GetRBPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntry.BP_GetRBPlayerState");
		
		URBSocialMenuEntry_BP_GetRBPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSocialMenuEntry.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSocialMenuEntry::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSocialMenuEntry");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryContextualMenu.Setup
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuEntry*                          AssociatedEntry                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntryContextualMenu::Setup(class URBSocialMenuEntry* AssociatedEntry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryContextualMenu.Setup");
		
		URBSocialMenuEntryContextualMenu_Setup_Params params {};
		params.AssociatedEntry = AssociatedEntry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryContextualMenu.RequestAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERBSocialMenuEntryAction                           action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntryContextualMenu::RequestAction(ERBSocialMenuEntryAction action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryContextualMenu.RequestAction");
		
		URBSocialMenuEntryContextualMenu_RequestAction_Params params {};
		params.action = action;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryContextualMenu.GetAvailableActions
	 * 		Flags  -> ()
	 */
	TArray<ERBSocialMenuEntryAction> URBSocialMenuEntryContextualMenu::GetAvailableActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryContextualMenu.GetAvailableActions");
		
		URBSocialMenuEntryContextualMenu_GetAvailableActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryContextualMenu.GetAssociatedEntry
	 * 		Flags  -> ()
	 */
	class URBSocialMenuEntry* URBSocialMenuEntryContextualMenu::GetAssociatedEntry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryContextualMenu.GetAssociatedEntry");
		
		URBSocialMenuEntryContextualMenu_GetAssociatedEntry_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryContextualMenu.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntryContextualMenu::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryContextualMenu.Event_Refresh");
		
		URBSocialMenuEntryContextualMenu_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSocialMenuEntryContextualMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSocialMenuEntryContextualMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSocialMenuEntryContextualMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.SetFilter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERBSocialMenuEntryFilter                           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntryListWidget::SetFilter(ERBSocialMenuEntryFilter Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.SetFilter");
		
		URBSocialMenuEntryListWidget_SetFilter_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.PreviousPage
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntryListWidget::PreviousPage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.PreviousPage");
		
		URBSocialMenuEntryListWidget_PreviousPage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.OnPlayerLeftGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntryListWidget::OnPlayerLeftGame(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.OnPlayerLeftGame");
		
		URBSocialMenuEntryListWidget_OnPlayerLeftGame_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.OnPlayerJoinedGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntryListWidget::OnPlayerJoinedGame(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.OnPlayerJoinedGame");
		
		URBSocialMenuEntryListWidget_OnPlayerJoinedGame_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.OnFilterChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERBSocialMenuEntryFilter                           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntryListWidget::OnFilterChanged(ERBSocialMenuEntryFilter Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.OnFilterChanged");
		
		URBSocialMenuEntryListWidget_OnFilterChanged_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.OnEntryActionRequested
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuEntry*                          Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERBSocialMenuEntryAction                           action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntryListWidget::OnEntryActionRequested(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.OnEntryActionRequested");
		
		URBSocialMenuEntryListWidget_OnEntryActionRequested_Params params {};
		params.Entry = Entry;
		params.action = action;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.NextPage
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntryListWidget::NextPage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.NextPage");
		
		URBSocialMenuEntryListWidget_NextPage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.IsOperationPending
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntryListWidget::IsOperationPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.IsOperationPending");
		
		URBSocialMenuEntryListWidget_IsOperationPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.IsEmpty
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntryListWidget::IsEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.IsEmpty");
		
		URBSocialMenuEntryListWidget_IsEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.IsDataPending
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuEntryListWidget::IsDataPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.IsDataPending");
		
		URBSocialMenuEntryListWidget_IsDataPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.GetFilter
	 * 		Flags  -> ()
	 */
	ERBSocialMenuEntryFilter URBSocialMenuEntryListWidget::GetFilter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.GetFilter");
		
		URBSocialMenuEntryListWidget_GetFilter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.Event_UpdateEntry
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBUserWidget*                               Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            column                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            row                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntryListWidget::Event_UpdateEntry(class URBUserWidget* Entry, int32_t column, int32_t row)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.Event_UpdateEntry");
		
		URBSocialMenuEntryListWidget_Event_UpdateEntry_Params params {};
		params.Entry = Entry;
		params.column = column;
		params.row = row;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.Event_RemoveEntry
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBUserWidget*                               Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntryListWidget::Event_RemoveEntry(class URBUserWidget* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.Event_RemoveEntry");
		
		URBSocialMenuEntryListWidget_Event_RemoveEntry_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.Event_OnEmptyStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsEmpty                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntryListWidget::Event_OnEmptyStateChanged(bool bIsEmpty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.Event_OnEmptyStateChanged");
		
		URBSocialMenuEntryListWidget_Event_OnEmptyStateChanged_Params params {};
		params.bIsEmpty = bIsEmpty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.Event_OnDataPending
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsDataPending                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntryListWidget::Event_OnDataPending(bool bIsDataPending)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.Event_OnDataPending");
		
		URBSocialMenuEntryListWidget_Event_OnDataPending_Params params {};
		params.bIsDataPending = bIsDataPending;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.Event_EntriesUpdated
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntryListWidget::Event_EntriesUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.Event_EntriesUpdated");
		
		URBSocialMenuEntryListWidget_Event_EntriesUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.Event_Clear
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntryListWidget::Event_Clear()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.Event_Clear");
		
		URBSocialMenuEntryListWidget_Event_Clear_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.Deactivate
	 * 		Flags  -> ()
	 */
	void URBSocialMenuEntryListWidget::Deactivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.Deactivate");
		
		URBSocialMenuEntryListWidget_Deactivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuEntryListWidget.Activate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuManager*                        Parent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuEntryListWidget::Activate(class URBSocialMenuManager* Parent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuEntryListWidget.Activate");
		
		URBSocialMenuEntryListWidget_Activate_Params params {};
		params.Parent = Parent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSocialMenuEntryListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSocialMenuEntryListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSocialMenuEntryListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuManager.ShowFilter
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuManager::ShowFilter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuManager.ShowFilter");
		
		URBSocialMenuManager_ShowFilter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuManager.ShouldEnableFindFriendMenuOption
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuManager::ShouldEnableFindFriendMenuOption()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuManager.ShouldEnableFindFriendMenuOption");
		
		URBSocialMenuManager_ShouldEnableFindFriendMenuOption_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuManager.SetFilter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERBSocialMenuEntryFilter                           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuManager::SetFilter(ERBSocialMenuEntryFilter Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuManager.SetFilter");
		
		URBSocialMenuManager_SetFilter_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuManager.OpenPartyInviteWidget
	 * 		Flags  -> ()
	 */
	void URBSocialMenuManager::OpenPartyInviteWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuManager.OpenPartyInviteWidget");
		
		URBSocialMenuManager_OpenPartyInviteWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> DelegateFunction OPP.RBSocialMenuManager.OnFilterChanged__DelegateSignature
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERBSocialMenuEntryFilter                           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuManager::OnFilterChanged__DelegateSignature(ERBSocialMenuEntryFilter Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction OPP.RBSocialMenuManager.OnFilterChanged__DelegateSignature");
		
		URBSocialMenuManager_OnFilterChanged__DelegateSignature_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuManager.IsPartyInviteWidgetShown
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuManager::IsPartyInviteWidgetShown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuManager.IsPartyInviteWidgetShown");
		
		URBSocialMenuManager_IsPartyInviteWidgetShown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuManager.IsCrossplayEnabled
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuManager::IsCrossplayEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuManager.IsCrossplayEnabled");
		
		URBSocialMenuManager_IsCrossplayEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuManager.HasPendingFriendRequest
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuManager::HasPendingFriendRequest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuManager.HasPendingFriendRequest");
		
		URBSocialMenuManager_HasPendingFriendRequest_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuManager.HasContextualMenuOpen
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuManager::HasContextualMenuOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuManager.HasContextualMenuOpen");
		
		URBSocialMenuManager_HasContextualMenuOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuManager.GetFilter
	 * 		Flags  -> ()
	 */
	ERBSocialMenuEntryFilter URBSocialMenuManager::GetFilter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuManager.GetFilter");
		
		URBSocialMenuManager_GetFilter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuManager.ClosePartyInviteWidget
	 * 		Flags  -> ()
	 */
	void URBSocialMenuManager::ClosePartyInviteWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuManager.ClosePartyInviteWidget");
		
		URBSocialMenuManager_ClosePartyInviteWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuManager.CloseContextualMenu
	 * 		Flags  -> ()
	 */
	void URBSocialMenuManager::CloseContextualMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuManager.CloseContextualMenu");
		
		URBSocialMenuManager_CloseContextualMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSocialMenuManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSocialMenuManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSocialMenuManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.ShouldShowPartyOptions
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuPartyWidget::ShouldShowPartyOptions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.ShouldShowPartyOptions");
		
		URBSocialMenuPartyWidget_ShouldShowPartyOptions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.ShouldDisplayCrossplaySetting
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuPartyWidget::ShouldDisplayCrossplaySetting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.ShouldDisplayCrossplaySetting");
		
		URBSocialMenuPartyWidget_ShouldDisplayCrossplaySetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.SetPartyPrivacy
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPartyPrivacy                                      privacy                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::SetPartyPrivacy(EPartyPrivacy privacy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.SetPartyPrivacy");
		
		URBSocialMenuPartyWidget_SetPartyPrivacy_Params params {};
		params.privacy = privacy;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.SetPartyInviteFilter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            PartyInviteFilter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::SetPartyInviteFilter(int32_t PartyInviteFilter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.SetPartyInviteFilter");
		
		URBSocialMenuPartyWidget_SetPartyInviteFilter_Params params {};
		params.PartyInviteFilter = PartyInviteFilter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.SetAllowPartyMemberInvites
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bAllowPartyMemberInvites                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::SetAllowPartyMemberInvites(bool bAllowPartyMemberInvites)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.SetAllowPartyMemberInvites");
		
		URBSocialMenuPartyWidget_SetAllowPartyMemberInvites_Params params {};
		params.bAllowPartyMemberInvites = bAllowPartyMemberInvites;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.OnSocialMenuEntryCustomizationUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuEntry*                          Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::OnSocialMenuEntryCustomizationUpdated(class URBSocialMenuEntry* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.OnSocialMenuEntryCustomizationUpdated");
		
		URBSocialMenuPartyWidget_OnSocialMenuEntryCustomizationUpdated_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.OnSocialMenuEntryActionStarted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuEntry*                          Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERBSocialMenuEntryAction                           action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::OnSocialMenuEntryActionStarted(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.OnSocialMenuEntryActionStarted");
		
		URBSocialMenuPartyWidget_OnSocialMenuEntryActionStarted_Params params {};
		params.Entry = Entry;
		params.action = action;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.OnSocialMenuEntryActionCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuEntry*                          Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERBSocialMenuEntryAction                           action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::OnSocialMenuEntryActionCompleted(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.OnSocialMenuEntryActionCompleted");
		
		URBSocialMenuPartyWidget_OnSocialMenuEntryActionCompleted_Params params {};
		params.Entry = Entry;
		params.action = action;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.OnPlayerLeftGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::OnPlayerLeftGame(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.OnPlayerLeftGame");
		
		URBSocialMenuPartyWidget_OnPlayerLeftGame_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.OnPlayerLeaving
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerLeaveTarget                                 Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::OnPlayerLeaving(EPlayerLeaveTarget Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.OnPlayerLeaving");
		
		URBSocialMenuPartyWidget_OnPlayerLeaving_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.OnPlayerJoinedGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::OnPlayerJoinedGame(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.OnPlayerJoinedGame");
		
		URBSocialMenuPartyWidget_OnPlayerJoinedGame_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.OnEntryActionRequested
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuEntry*                          Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERBSocialMenuEntryAction                           action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::OnEntryActionRequested(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.OnEntryActionRequested");
		
		URBSocialMenuPartyWidget_OnEntryActionRequested_Params params {};
		params.Entry = Entry;
		params.action = action;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.LeaveParty
	 * 		Flags  -> ()
	 */
	void URBSocialMenuPartyWidget::LeaveParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.LeaveParty");
		
		URBSocialMenuPartyWidget_LeaveParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.IsPartyOwner
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuPartyWidget::IsPartyOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.IsPartyOwner");
		
		URBSocialMenuPartyWidget_IsPartyOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.IsOperationPending
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuPartyWidget::IsOperationPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.IsOperationPending");
		
		URBSocialMenuPartyWidget_IsOperationPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.IsEmpty
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuPartyWidget::IsEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.IsEmpty");
		
		URBSocialMenuPartyWidget_IsEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.IsDataPending
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuPartyWidget::IsDataPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.IsDataPending");
		
		URBSocialMenuPartyWidget_IsDataPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.IsCrossplayEnabled
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuPartyWidget::IsCrossplayEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.IsCrossplayEnabled");
		
		URBSocialMenuPartyWidget_IsCrossplayEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.GetPartyPrivacy
	 * 		Flags  -> ()
	 */
	EPartyPrivacy URBSocialMenuPartyWidget::GetPartyPrivacy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.GetPartyPrivacy");
		
		URBSocialMenuPartyWidget_GetPartyPrivacy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.GetPartyInviteFilter
	 * 		Flags  -> ()
	 */
	int32_t URBSocialMenuPartyWidget::GetPartyInviteFilter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.GetPartyInviteFilter");
		
		URBSocialMenuPartyWidget_GetPartyInviteFilter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.Event_UpdateEntry
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBUserWidget*                               Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            column                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            row                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::Event_UpdateEntry(class URBUserWidget* Entry, int32_t column, int32_t row)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.Event_UpdateEntry");
		
		URBSocialMenuPartyWidget_Event_UpdateEntry_Params params {};
		params.Entry = Entry;
		params.column = column;
		params.row = row;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.Event_RemoveEntry
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBUserWidget*                               Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::Event_RemoveEntry(class URBUserWidget* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.Event_RemoveEntry");
		
		URBSocialMenuPartyWidget_Event_RemoveEntry_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.Event_RefreshPartyOptions
	 * 		Flags  -> ()
	 */
	void URBSocialMenuPartyWidget::Event_RefreshPartyOptions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.Event_RefreshPartyOptions");
		
		URBSocialMenuPartyWidget_Event_RefreshPartyOptions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.Event_OnDataPending
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bIsDataPending                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::Event_OnDataPending(bool bIsDataPending)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.Event_OnDataPending");
		
		URBSocialMenuPartyWidget_Event_OnDataPending_Params params {};
		params.bIsDataPending = bIsDataPending;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.Event_EntriesUpdated
	 * 		Flags  -> ()
	 */
	void URBSocialMenuPartyWidget::Event_EntriesUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.Event_EntriesUpdated");
		
		URBSocialMenuPartyWidget_Event_EntriesUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.Event_Clear
	 * 		Flags  -> ()
	 */
	void URBSocialMenuPartyWidget::Event_Clear()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.Event_Clear");
		
		URBSocialMenuPartyWidget_Event_Clear_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.Deactivate
	 * 		Flags  -> ()
	 */
	void URBSocialMenuPartyWidget::Deactivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.Deactivate");
		
		URBSocialMenuPartyWidget_Deactivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.CanLeaveParty
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuPartyWidget::CanLeaveParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.CanLeaveParty");
		
		URBSocialMenuPartyWidget_CanLeaveParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.AllowPartyMemberInvites
	 * 		Flags  -> ()
	 */
	bool URBSocialMenuPartyWidget::AllowPartyMemberInvites()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.AllowPartyMemberInvites");
		
		URBSocialMenuPartyWidget_AllowPartyMemberInvites_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuPartyWidget.Activate
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuManager*                        Parent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSocialMenuPartyWidget::Activate(class URBSocialMenuManager* Parent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuPartyWidget.Activate");
		
		URBSocialMenuPartyWidget_Activate_Params params {};
		params.Parent = Parent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSocialMenuPartyWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSocialMenuPartyWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSocialMenuPartyWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuSceneActor.IsFailureScene
	 * 		Flags  -> ()
	 */
	bool ARBSocialMenuSceneActor::IsFailureScene()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuSceneActor.IsFailureScene");
		
		ARBSocialMenuSceneActor_IsFailureScene_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuSceneActor.GetType
	 * 		Flags  -> ()
	 */
	ESocialMenuSceneActorType ARBSocialMenuSceneActor::GetType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuSceneActor.GetType");
		
		ARBSocialMenuSceneActor_GetType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuSceneActor.GetMenuCharacter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ESocialMenuSceneActorSlot                          Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBMenuCharacter* ARBSocialMenuSceneActor::GetMenuCharacter(ESocialMenuSceneActorSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuSceneActor.GetMenuCharacter");
		
		ARBSocialMenuSceneActor_GetMenuCharacter_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuSceneActor.Event_UpdateNumDisplayedSlots
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            Num                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSocialMenuSceneActor::Event_UpdateNumDisplayedSlots(int32_t Num)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuSceneActor.Event_UpdateNumDisplayedSlots");
		
		ARBSocialMenuSceneActor_Event_UpdateNumDisplayedSlots_Params params {};
		params.Num = Num;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuSceneActor.Event_Deactivate
	 * 		Flags  -> ()
	 */
	void ARBSocialMenuSceneActor::Event_Deactivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuSceneActor.Event_Deactivate");
		
		ARBSocialMenuSceneActor_Event_Deactivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSocialMenuSceneActor.Event_Activate
	 * 		Flags  -> ()
	 */
	void ARBSocialMenuSceneActor::Event_Activate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSocialMenuSceneActor.Event_Activate");
		
		ARBSocialMenuSceneActor_Event_Activate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSocialMenuSceneActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSocialMenuSceneActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSocialMenuSceneActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundConnectorActor.Editor_RefreshConnection
	 * 		Flags  -> ()
	 */
	void ARBSoundConnectorActor::Editor_RefreshConnection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundConnectorActor.Editor_RefreshConnection");
		
		ARBSoundConnectorActor_Editor_RefreshConnection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSoundConnectorActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSoundConnectorActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSoundConnectorActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundConnectorComponent.SetOpen_Internal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bOpenValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSoundConnectorComponent::SetOpen_Internal(bool bOpenValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundConnectorComponent.SetOpen_Internal");
		
		URBSoundConnectorComponent_SetOpen_Internal_Params params {};
		params.bOpenValue = bOpenValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundConnectorComponent.SetEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabledValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSoundConnectorComponent::SetEnabled(bool bEnabledValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundConnectorComponent.SetEnabled");
		
		URBSoundConnectorComponent_SetEnabled_Params params {};
		params.bEnabledValue = bEnabledValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundConnectorComponent.OnRep_IsOpened
	 * 		Flags  -> ()
	 */
	void URBSoundConnectorComponent::OnRep_IsOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundConnectorComponent.OnRep_IsOpened");
		
		URBSoundConnectorComponent_OnRep_IsOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundConnectorComponent.OnRep_Enabled
	 * 		Flags  -> ()
	 */
	void URBSoundConnectorComponent::OnRep_Enabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundConnectorComponent.OnRep_Enabled");
		
		URBSoundConnectorComponent_OnRep_Enabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundConnectorComponent.IsOpenedChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSoundConnectorComponent::IsOpenedChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundConnectorComponent.IsOpenedChangedCallback");
		
		URBSoundConnectorComponent_IsOpenedChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundConnectorComponent.Editor_RefreshConnection
	 * 		Flags  -> ()
	 */
	void URBSoundConnectorComponent::Editor_RefreshConnection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundConnectorComponent.Editor_RefreshConnection");
		
		URBSoundConnectorComponent_Editor_RefreshConnection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundConnectorComponent.BP_OpenConnector
	 * 		Flags  -> ()
	 */
	void URBSoundConnectorComponent::BP_OpenConnector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundConnectorComponent.BP_OpenConnector");
		
		URBSoundConnectorComponent_BP_OpenConnector_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundConnectorComponent.BP_CloseConnector
	 * 		Flags  -> ()
	 */
	void URBSoundConnectorComponent::BP_CloseConnector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundConnectorComponent.BP_CloseConnector");
		
		URBSoundConnectorComponent_BP_CloseConnector_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSoundConnectorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSoundConnectorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSoundConnectorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSoundDetector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSoundDetector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSoundDetector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSoundReferences.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSoundReferences::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSoundReferences");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundTrap.OnCapsuleBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComp                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBSoundTrap::OnCapsuleBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundTrap.OnCapsuleBeginOverlap");
		
		ARBSoundTrap_OnCapsuleBeginOverlap_Params params {};
		params.OverlappedComp = OverlappedComp;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundTrap.Multicast_OnTrapTriggered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSoundTrap::Multicast_OnTrapTriggered(class ARBPawn* Source)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundTrap.Multicast_OnTrapTriggered");
		
		ARBSoundTrap_Multicast_OnTrapTriggered_Params params {};
		params.Source = Source;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundTrap.BP_OnHitByThrowable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     HitLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBThrowableWeapon*                          throwableWeapon                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSoundTrap::BP_OnHitByThrowable(const struct FVector& HitLocation, class ARBThrowableWeapon* throwableWeapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundTrap.BP_OnHitByThrowable");
		
		ARBSoundTrap_BP_OnHitByThrowable_Params params {};
		params.HitLocation = HitLocation;
		params.throwableWeapon = throwableWeapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundTrap.BP_GetCollisionCapsule
	 * 		Flags  -> ()
	 */
	class UCapsuleComponent* ARBSoundTrap::BP_GetCollisionCapsule()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundTrap.BP_GetCollisionCapsule");
		
		ARBSoundTrap_BP_GetCollisionCapsule_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSoundTrap.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSoundTrap::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSoundTrap");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundVolume.RemoveDynamicEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSoundTriggerEvent                          SoundTriggerEvent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBSoundVolume::RemoveDynamicEvent(const struct FSoundTriggerEvent& SoundTriggerEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundVolume.RemoveDynamicEvent");
		
		ARBSoundVolume_RemoveDynamicEvent_Params params {};
		params.SoundTriggerEvent = SoundTriggerEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundVolume.Editor_RefreshConnection
	 * 		Flags  -> ()
	 */
	void ARBSoundVolume::Editor_RefreshConnection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundVolume.Editor_RefreshConnection");
		
		ARBSoundVolume_Editor_RefreshConnection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSoundVolume.AddDynamicEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FSoundTriggerEvent                          SoundTriggerEvent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBSoundVolume::AddDynamicEvent(const struct FSoundTriggerEvent& SoundTriggerEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSoundVolume.AddDynamicEvent");
		
		ARBSoundVolume_AddDynamicEvent_Params params {};
		params.SoundTriggerEvent = SoundTriggerEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSoundVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSoundVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSoundVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBAreaExitPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBAreaExitPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBAreaExitPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSpatialReasoning.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSpatialReasoning::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSpatialReasoning");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSpectatorMenu.TogglePreviousSpectator
	 * 		Flags  -> ()
	 */
	void URBSpectatorMenu::TogglePreviousSpectator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSpectatorMenu.TogglePreviousSpectator");
		
		URBSpectatorMenu_TogglePreviousSpectator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSpectatorMenu.ToggleNextSpectator
	 * 		Flags  -> ()
	 */
	void URBSpectatorMenu::ToggleNextSpectator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSpectatorMenu.ToggleNextSpectator");
		
		URBSpectatorMenu_ToggleNextSpectator_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSpectatorMenu.Event_OnSpectatorChanged
	 * 		Flags  -> ()
	 */
	void URBSpectatorMenu::Event_OnSpectatorChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSpectatorMenu.Event_OnSpectatorChanged");
		
		URBSpectatorMenu_Event_OnSpectatorChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSpectatorMenu.CanCycleSpectators
	 * 		Flags  -> ()
	 */
	bool URBSpectatorMenu::CanCycleSpectators()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSpectatorMenu.CanCycleSpectators");
		
		URBSpectatorMenu_CanCycleSpectators_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSpectatorMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSpectatorMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSpectatorMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSpectatorPawn.Event_OnSetupFinished
	 * 		Flags  -> ()
	 */
	void ARBSpectatorPawn::Event_OnSetupFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSpectatorPawn.Event_OnSetupFinished");
		
		ARBSpectatorPawn_Event_OnSetupFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSpectatorPawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSpectatorPawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSpectatorPawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSpectraSkill.Event_OnVisionFullEffectStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bFullEffect                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSpectraSkill::Event_OnVisionFullEffectStateChanged(bool bFullEffect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSpectraSkill.Event_OnVisionFullEffectStateChanged");
		
		ARBSpectraSkill_Event_OnVisionFullEffectStateChanged_Params params {};
		params.bFullEffect = bFullEffect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSpectraSkill.Event_OnVisionActorRemoved
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      visionActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSpectraSkill::Event_OnVisionActorRemoved(class AActor* visionActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSpectraSkill.Event_OnVisionActorRemoved");
		
		ARBSpectraSkill_Event_OnVisionActorRemoved_Params params {};
		params.visionActor = visionActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSpectraSkill.Event_OnVisionActorAdded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      visionActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSpectraSkill::Event_OnVisionActorAdded(class AActor* visionActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSpectraSkill.Event_OnVisionActorAdded");
		
		ARBSpectraSkill_Event_OnVisionActorAdded_Params params {};
		params.visionActor = visionActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSpectraSkill.Event_OnVisionActiveChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               IsActive                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFullEffect                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSpectraSkill::Event_OnVisionActiveChanged(bool IsActive, bool bFullEffect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSpectraSkill.Event_OnVisionActiveChanged");
		
		ARBSpectraSkill_Event_OnVisionActiveChanged_Params params {};
		params.IsActive = IsActive;
		params.bFullEffect = bFullEffect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSpectraSkill.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSpectraSkill::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSpectraSkill");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBOverrideDialSkill.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBOverrideDialSkill::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBOverrideDialSkill");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingStation.OnSplineFollowingActorReachedStation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBSplineFollowingActor*                     splineFollowingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSplineFollowingStation::OnSplineFollowingActorReachedStation(class ARBSplineFollowingActor* splineFollowingActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingStation.OnSplineFollowingActorReachedStation");
		
		ARBSplineFollowingStation_OnSplineFollowingActorReachedStation_Params params {};
		params.splineFollowingActor = splineFollowingActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingStation.OnComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBSplineFollowingStation::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingStation.OnComponentBeginOverlap");
		
		ARBSplineFollowingStation_OnComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingStation.OnActorEnterProximity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSplineFollowingStation::OnActorEnterProximity(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingStation.OnActorEnterProximity");
		
		ARBSplineFollowingStation_OnActorEnterProximity_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingStation.Multicast_OnSplineFollowingActorReachedStation
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBSplineFollowingActor*                     splineFollowingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSplineFollowingStation::Multicast_OnSplineFollowingActorReachedStation(class ARBSplineFollowingActor* splineFollowingActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingStation.Multicast_OnSplineFollowingActorReachedStation");
		
		ARBSplineFollowingStation_Multicast_OnSplineFollowingActorReachedStation_Params params {};
		params.splineFollowingActor = splineFollowingActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingStation.Event_OnSplineFollowingActorAnimationDone
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBSplineFollowingActor*                     splineFollowingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSplineFollowingStation::Event_OnSplineFollowingActorAnimationDone(class ARBSplineFollowingActor* splineFollowingActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingStation.Event_OnSplineFollowingActorAnimationDone");
		
		ARBSplineFollowingStation_Event_OnSplineFollowingActorAnimationDone_Params params {};
		params.splineFollowingActor = splineFollowingActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineFollowingStation.BP_SetStationEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSplineFollowingStation::BP_SetStationEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineFollowingStation.BP_SetStationEnabled");
		
		ARBSplineFollowingStation_BP_SetStationEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSplineFollowingStation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSplineFollowingStation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSplineFollowingStation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineHelperComponent.OnLargePickupHoldingPlayerChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBLargePickup*                              largePickup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSplineHelperComponent::OnLargePickupHoldingPlayerChanged(class ARBPawn* Pawn, class ARBLargePickup* largePickup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineHelperComponent.OnLargePickupHoldingPlayerChanged");
		
		URBSplineHelperComponent_OnLargePickupHoldingPlayerChanged_Params params {};
		params.Pawn = Pawn;
		params.largePickup = largePickup;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSplineHelperComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSplineHelperComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSplineHelperComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineMeshActor.OnRep_Enabled
	 * 		Flags  -> ()
	 */
	void ARBSplineMeshActor::OnRep_Enabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineMeshActor.OnRep_Enabled");
		
		ARBSplineMeshActor_OnRep_Enabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineMeshActor.BP_UnlinkPreviousSpline
	 * 		Flags  -> ()
	 */
	void ARBSplineMeshActor::BP_UnlinkPreviousSpline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineMeshActor.BP_UnlinkPreviousSpline");
		
		ARBSplineMeshActor_BP_UnlinkPreviousSpline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineMeshActor.BP_UnlinkNextSpline
	 * 		Flags  -> ()
	 */
	void ARBSplineMeshActor::BP_UnlinkNextSpline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineMeshActor.BP_UnlinkNextSpline");
		
		ARBSplineMeshActor_BP_UnlinkNextSpline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineMeshActor.BP_SetPreviousSpline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBSplineMeshActor*                          previousSplineMesh                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bToLastNode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSplineMeshActor::BP_SetPreviousSpline(class ARBSplineMeshActor* previousSplineMesh, bool bToLastNode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineMeshActor.BP_SetPreviousSpline");
		
		ARBSplineMeshActor_BP_SetPreviousSpline_Params params {};
		params.previousSplineMesh = previousSplineMesh;
		params.bToLastNode = bToLastNode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineMeshActor.BP_SetNextSpline
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBSplineMeshActor*                          nextSplineMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bToFirstNode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSplineMeshActor::BP_SetNextSpline(class ARBSplineMeshActor* nextSplineMesh, bool bToFirstNode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineMeshActor.BP_SetNextSpline");
		
		ARBSplineMeshActor_BP_SetNextSpline_Params params {};
		params.nextSplineMesh = nextSplineMesh;
		params.bToFirstNode = bToFirstNode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSplineMeshActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSplineMeshActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSplineMeshActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplineMeshLinkChooserComponent.OnRandomizationDone
	 * 		Flags  -> ()
	 */
	void URBSplineMeshLinkChooserComponent::OnRandomizationDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplineMeshLinkChooserComponent.OnRandomizationDone");
		
		URBSplineMeshLinkChooserComponent_OnRandomizationDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSplineMeshLinkChooserComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSplineMeshLinkChooserComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSplineMeshLinkChooserComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplinePushable.OnRep_AutoMove
	 * 		Flags  -> ()
	 */
	void ARBSplinePushable::OnRep_AutoMove()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplinePushable.OnRep_AutoMove");
		
		ARBSplinePushable_OnRep_AutoMove_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplinePushable.IsRollbacking
	 * 		Flags  -> ()
	 */
	bool ARBSplinePushable::IsRollbacking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplinePushable.IsRollbacking");
		
		ARBSplinePushable_IsRollbacking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplinePushable.Event_OnAutoMoveStateChanged
	 * 		Flags  -> ()
	 */
	void ARBSplinePushable::Event_OnAutoMoveStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplinePushable.Event_OnAutoMoveStateChanged");
		
		ARBSplinePushable_Event_OnAutoMoveStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplinePushable.BP_PostRotated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRotator                                    frontRotation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    rearRotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ARBSplinePushable::BP_PostRotated(const struct FRotator& frontRotation, const struct FRotator& rearRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplinePushable.BP_PostRotated");
		
		ARBSplinePushable_BP_PostRotated_Params params {};
		params.frontRotation = frontRotation;
		params.rearRotation = rearRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplinePushable.BP_DetachFromSpline
	 * 		Flags  -> ()
	 */
	void ARBSplinePushable::BP_DetachFromSpline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplinePushable.BP_DetachFromSpline");
		
		ARBSplinePushable_BP_DetachFromSpline_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSplinePushable.AutoMove
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSplinePushable::AutoMove(float Distance, float Speed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSplinePushable.AutoMove");
		
		ARBSplinePushable_AutoMove_Params params {};
		params.Distance = Distance;
		params.Speed = Speed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSplinePushable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSplinePushable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSplinePushable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStairsMarker.IsLocationValidInZ
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ZBuffer                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBStairsMarker::IsLocationValidInZ(const struct FVector& Location, float ZBuffer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStairsMarker.IsLocationValidInZ");
		
		ARBStairsMarker_IsLocationValidInZ_Params params {};
		params.Location = Location;
		params.ZBuffer = ZBuffer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStairsMarker.IsLocationOnStairs
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBStairsMarker::IsLocationOnStairs(const struct FVector& Location, float Radius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStairsMarker.IsLocationOnStairs");
		
		ARBStairsMarker_IsLocationOnStairs_Params params {};
		params.Location = Location;
		params.Radius = Radius;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStairsMarker.GetStairsKnockdownSlideVelocity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector ARBStairsMarker::GetStairsKnockdownSlideVelocity(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStairsMarker.GetStairsKnockdownSlideVelocity");
		
		ARBStairsMarker_GetStairsKnockdownSlideVelocity_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStairsMarker.GetStairsDownDirection
	 * 		Flags  -> ()
	 */
	struct FVector ARBStairsMarker::GetStairsDownDirection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStairsMarker.GetStairsDownDirection");
		
		ARBStairsMarker_GetStairsDownDirection_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStairsMarker.GetApproximateStairsDistanceSqr2D
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ARBStairsMarker::GetApproximateStairsDistanceSqr2D(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStairsMarker.GetApproximateStairsDistanceSqr2D");
		
		ARBStairsMarker_GetApproximateStairsDistanceSqr2D_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStairsMarker.CastLocationOnStairs
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector ARBStairsMarker::CastLocationOnStairs(const struct FVector& Location, float Radius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStairsMarker.CastLocationOnStairs");
		
		ARBStairsMarker_CastLocationOnStairs_Params params {};
		params.Location = Location;
		params.Radius = Radius;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBStairsMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBStairsMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBStairsMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.SetShowProximityTriggerIconsVisible_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBStalkerObjectiveCoordinator::SetShowProximityTriggerIconsVisible_Server(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.SetShowProximityTriggerIconsVisible_Server");
		
		ARBStalkerObjectiveCoordinator_SetShowProximityTriggerIconsVisible_Server_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.SetShowProximityDetectorIconsVisible_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBStalkerObjectiveCoordinator::SetShowProximityDetectorIconsVisible_Server(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.SetShowProximityDetectorIconsVisible_Server");
		
		ARBStalkerObjectiveCoordinator_SetShowProximityDetectorIconsVisible_Server_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.OnTargetDie
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBStalkerObjectiveCoordinator::OnTargetDie(class ARBNPC* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.OnTargetDie");
		
		ARBStalkerObjectiveCoordinator_OnTargetDie_Params params {};
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.OnStopSpectatorMode
	 * 		Flags  -> ()
	 */
	void ARBStalkerObjectiveCoordinator::OnStopSpectatorMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.OnStopSpectatorMode");
		
		ARBStalkerObjectiveCoordinator_OnStopSpectatorMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.OnStartSpectatingPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBStalkerObjectiveCoordinator::OnStartSpectatingPlayer(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.OnStartSpectatingPlayer");
		
		ARBStalkerObjectiveCoordinator_OnStartSpectatingPlayer_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.OnRep_ShowProximityTriggerIcons
	 * 		Flags  -> ()
	 */
	void ARBStalkerObjectiveCoordinator::OnRep_ShowProximityTriggerIcons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.OnRep_ShowProximityTriggerIcons");
		
		ARBStalkerObjectiveCoordinator_OnRep_ShowProximityTriggerIcons_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.OnRep_ShowProximityDetectorIcons
	 * 		Flags  -> ()
	 */
	void ARBStalkerObjectiveCoordinator::OnRep_ShowProximityDetectorIcons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.OnRep_ShowProximityDetectorIcons");
		
		ARBStalkerObjectiveCoordinator_OnRep_ShowProximityDetectorIcons_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.OnRep_CurrentTargetInfos
	 * 		Flags  -> ()
	 */
	void ARBStalkerObjectiveCoordinator::OnRep_CurrentTargetInfos()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.OnRep_CurrentTargetInfos");
		
		ARBStalkerObjectiveCoordinator_OnRep_CurrentTargetInfos_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.OnProximityProgressCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBProximityDetectableComponent*             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBStalkerObjectiveCoordinator::OnProximityProgressCompleted(class URBProximityDetectableComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.OnProximityProgressCompleted");
		
		ARBStalkerObjectiveCoordinator_OnProximityProgressCompleted_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.OnBotSpawned
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBAISpawner*                                spawner                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBStalkerObjectiveCoordinator::OnBotSpawned(class ARBAISpawner* spawner, class ARBBot* bot, class ARBNPC* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.OnBotSpawned");
		
		ARBStalkerObjectiveCoordinator_OnBotSpawned_Params params {};
		params.spawner = spawner;
		params.bot = bot;
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.Multicast_OnNextRoundStarted
	 * 		Flags  -> ()
	 */
	void ARBStalkerObjectiveCoordinator::Multicast_OnNextRoundStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.Multicast_OnNextRoundStarted");
		
		ARBStalkerObjectiveCoordinator_Multicast_OnNextRoundStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.IsNPCStalked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBStalkerObjectiveCoordinator::IsNPCStalked(class ARBNPC* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.IsNPCStalked");
		
		ARBStalkerObjectiveCoordinator_IsNPCStalked_Params params {};
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.IsNPCLocallyStalked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBStalkerObjectiveCoordinator::IsNPCLocallyStalked(class ARBNPC* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.IsNPCLocallyStalked");
		
		ARBStalkerObjectiveCoordinator_IsNPCLocallyStalked_Params params {};
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.IsLocalPlayerStalking
	 * 		Flags  -> ()
	 */
	bool ARBStalkerObjectiveCoordinator::IsLocalPlayerStalking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.IsLocalPlayerStalking");
		
		ARBStalkerObjectiveCoordinator_IsLocalPlayerStalking_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.Event_OnNPCStalkedEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBStalkerObjectiveCoordinator::Event_OnNPCStalkedEnd(class ARBNPC* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.Event_OnNPCStalkedEnd");
		
		ARBStalkerObjectiveCoordinator_Event_OnNPCStalkedEnd_Params params {};
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.Event_OnNPCStalkedBegin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBStalkerObjectiveCoordinator::Event_OnNPCStalkedBegin(class ARBNPC* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.Event_OnNPCStalkedBegin");
		
		ARBStalkerObjectiveCoordinator_Event_OnNPCStalkedBegin_Params params {};
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.Event_OnLocallyStalkingNPCEnd
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBStalkerObjectiveCoordinator::Event_OnLocallyStalkingNPCEnd(class ARBNPC* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.Event_OnLocallyStalkingNPCEnd");
		
		ARBStalkerObjectiveCoordinator_Event_OnLocallyStalkingNPCEnd_Params params {};
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStalkerObjectiveCoordinator.Event_OnLocallyStalkingNPCBegin
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBNPC*                                      NPC                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBStalkerObjectiveCoordinator::Event_OnLocallyStalkingNPCBegin(class ARBNPC* NPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStalkerObjectiveCoordinator.Event_OnLocallyStalkingNPCBegin");
		
		ARBStalkerObjectiveCoordinator_Event_OnLocallyStalkingNPCBegin_Params params {};
		params.NPC = NPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBStalkerObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBStalkerObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBStalkerObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStatsManager.OnGamePhaseUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGamePhase                                         gamePhase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBStatsManager::OnGamePhaseUpdated(EGamePhase gamePhase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStatsManager.OnGamePhaseUpdated");
		
		URBStatsManager_OnGamePhaseUpdated_Params params {};
		params.gamePhase = gamePhase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStatsManager.GetTrialStatContext
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBStatsManager::GetTrialStatContext(const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStatsManager.GetTrialStatContext");
		
		URBStatsManager_GetTrialStatContext_Params params {};
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStatsManager.GetGlobalStatContext
	 * 		Flags  -> ()
	 */
	class FString URBStatsManager::GetGlobalStatContext()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStatsManager.GetGlobalStatContext");
		
		URBStatsManager_GetGlobalStatContext_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStatsManager.GetCurrentTrialStatContext
	 * 		Flags  -> ()
	 */
	class FString URBStatsManager::GetCurrentTrialStatContext()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStatsManager.GetCurrentTrialStatContext");
		
		URBStatsManager_GetCurrentTrialStatContext_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStatsManager.GetCurrentCharacterStatContext
	 * 		Flags  -> ()
	 */
	class FString URBStatsManager::GetCurrentCharacterStatContext()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStatsManager.GetCurrentCharacterStatContext");
		
		URBStatsManager_GetCurrentCharacterStatContext_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStatsManager.GetCharacterStatContext
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBStatsManager::GetCharacterStatContext(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStatsManager.GetCharacterStatContext");
		
		URBStatsManager_GetCharacterStatContext_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBStatsManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBStatsManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBStatsManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStreaming.UnloadLevels
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FName>                                LevelNames                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBStreaming::UnloadLevels(TArray<class FName> LevelNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStreaming.UnloadLevels");
		
		ARBStreaming_UnloadLevels_Params params {};
		params.LevelNames = LevelNames;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStreaming.StartMapTransition
	 * 		Flags  -> ()
	 */
	void ARBStreaming::StartMapTransition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStreaming.StartMapTransition");
		
		ARBStreaming_StartMapTransition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStreaming.PrepareMapChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FName>                                LevelNames                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                ForcedLevelNames                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBStreaming::PrepareMapChange(TArray<class FName> LevelNames, TArray<class FName> ForcedLevelNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStreaming.PrepareMapChange");
		
		ARBStreaming_PrepareMapChange_Params params {};
		params.LevelNames = LevelNames;
		params.ForcedLevelNames = ForcedLevelNames;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStreaming.OnTargetStreamingStateUpdated
	 * 		Flags  -> ()
	 */
	void ARBStreaming::OnTargetStreamingStateUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStreaming.OnTargetStreamingStateUpdated");
		
		ARBStreaming_OnTargetStreamingStateUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStreaming.OnLevelsToExcludeChanged
	 * 		Flags  -> ()
	 */
	void ARBStreaming::OnLevelsToExcludeChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStreaming.OnLevelsToExcludeChanged");
		
		ARBStreaming_OnLevelsToExcludeChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStreaming.IsTargetStateReachedAndStreamingStable
	 * 		Flags  -> ()
	 */
	bool ARBStreaming::IsTargetStateReachedAndStreamingStable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStreaming.IsTargetStateReachedAndStreamingStable");
		
		ARBStreaming_IsTargetStateReachedAndStreamingStable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStreaming.CancelPendingMapChange
	 * 		Flags  -> ()
	 */
	void ARBStreaming::CancelPendingMapChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStreaming.CancelPendingMapChange");
		
		ARBStreaming_CancelPendingMapChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBStreaming.AddLocalForcedLoadedLevels
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class FName>                                LevelNames                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBStreaming::AddLocalForcedLoadedLevels(TArray<class FName> LevelNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBStreaming.AddLocalForcedLoadedLevels");
		
		ARBStreaming_AddLocalForcedLoadedLevels_Params params {};
		params.LevelNames = LevelNames;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBStreaming.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBStreaming::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBStreaming");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSubRandomManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSubRandomManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSubRandomManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchFlipSwitchComponent.OnRep_CurrentFlipSwitchState
	 * 		Flags  -> ()
	 */
	void URBSwitchMatchFlipSwitchComponent::OnRep_CurrentFlipSwitchState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchFlipSwitchComponent.OnRep_CurrentFlipSwitchState");
		
		URBSwitchMatchFlipSwitchComponent_OnRep_CurrentFlipSwitchState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchFlipSwitchComponent.OnLocallyFocusStateChange
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSwitchMatchFlipSwitchComponent::OnLocallyFocusStateChange(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchFlipSwitchComponent.OnLocallyFocusStateChange");
		
		URBSwitchMatchFlipSwitchComponent_OnLocallyFocusStateChange_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchFlipSwitchComponent.OnFlipSwitchStageChanged
	 * 		Flags  -> ()
	 */
	void URBSwitchMatchFlipSwitchComponent::OnFlipSwitchStageChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchFlipSwitchComponent.OnFlipSwitchStageChanged");
		
		URBSwitchMatchFlipSwitchComponent_OnFlipSwitchStageChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchFlipSwitchComponent.OnCurrentFlipSwitchStateCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSwitchMatchFlipSwitchComponent::OnCurrentFlipSwitchStateCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchFlipSwitchComponent.OnCurrentFlipSwitchStateCallback");
		
		URBSwitchMatchFlipSwitchComponent_OnCurrentFlipSwitchStateCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchFlipSwitchComponent.IsLocallyFocused
	 * 		Flags  -> ()
	 */
	bool URBSwitchMatchFlipSwitchComponent::IsLocallyFocused()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchFlipSwitchComponent.IsLocallyFocused");
		
		URBSwitchMatchFlipSwitchComponent_IsLocallyFocused_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchFlipSwitchComponent.GetFlipSwitchState
	 * 		Flags  -> ()
	 */
	EFlipSwitchState URBSwitchMatchFlipSwitchComponent::GetFlipSwitchState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchFlipSwitchComponent.GetFlipSwitchState");
		
		URBSwitchMatchFlipSwitchComponent_GetFlipSwitchState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSwitchMatchFlipSwitchComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSwitchMatchFlipSwitchComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSwitchMatchFlipSwitchComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchPanelComponent.OnRep_ResetUntilServerTimestamp
	 * 		Flags  -> ()
	 */
	void URBSwitchMatchPanelComponent::OnRep_ResetUntilServerTimestamp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchPanelComponent.OnRep_ResetUntilServerTimestamp");
		
		URBSwitchMatchPanelComponent_OnRep_ResetUntilServerTimestamp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchPanelComponent.OnRep_IsCompleted
	 * 		Flags  -> ()
	 */
	void URBSwitchMatchPanelComponent::OnRep_IsCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchPanelComponent.OnRep_IsCompleted");
		
		URBSwitchMatchPanelComponent_OnRep_IsCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchPanelComponent.OnRep_CurrentPuzzle
	 * 		Flags  -> ()
	 */
	void URBSwitchMatchPanelComponent::OnRep_CurrentPuzzle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchPanelComponent.OnRep_CurrentPuzzle");
		
		URBSwitchMatchPanelComponent_OnRep_CurrentPuzzle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchPanelComponent.OnRep_CurrentNumberOfInteraction
	 * 		Flags  -> ()
	 */
	void URBSwitchMatchPanelComponent::OnRep_CurrentNumberOfInteraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchPanelComponent.OnRep_CurrentNumberOfInteraction");
		
		URBSwitchMatchPanelComponent_OnRep_CurrentNumberOfInteraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchPanelComponent.OnCurrentNumberOfInteractionCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBSwitchMatchPanelComponent::OnCurrentNumberOfInteractionCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchPanelComponent.OnCurrentNumberOfInteractionCallback");
		
		URBSwitchMatchPanelComponent_OnCurrentNumberOfInteractionCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchPanelComponent.OnCompletedGameplayCallback
	 * 		Flags  -> ()
	 */
	void URBSwitchMatchPanelComponent::OnCompletedGameplayCallback()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchPanelComponent.OnCompletedGameplayCallback");
		
		URBSwitchMatchPanelComponent_OnCompletedGameplayCallback_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchPanelComponent.InitializePanel_Server
	 * 		Flags  -> ()
	 */
	void URBSwitchMatchPanelComponent::InitializePanel_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchPanelComponent.InitializePanel_Server");
		
		URBSwitchMatchPanelComponent_InitializePanel_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchPanelComponent.Event_OnPanelSuccessStateChanged
	 * 		Flags  -> ()
	 */
	void URBSwitchMatchPanelComponent::Event_OnPanelSuccessStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchPanelComponent.Event_OnPanelSuccessStateChanged");
		
		URBSwitchMatchPanelComponent_Event_OnPanelSuccessStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchPanelComponent.Event_OnNumbersOfInteractionChanged
	 * 		Flags  -> ()
	 */
	void URBSwitchMatchPanelComponent::Event_OnNumbersOfInteractionChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchPanelComponent.Event_OnNumbersOfInteractionChanged");
		
		URBSwitchMatchPanelComponent_Event_OnNumbersOfInteractionChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchPanelComponent.Event_OnCurrentPuzzleReset
	 * 		Flags  -> ()
	 */
	void URBSwitchMatchPanelComponent::Event_OnCurrentPuzzleReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchPanelComponent.Event_OnCurrentPuzzleReset");
		
		URBSwitchMatchPanelComponent_Event_OnCurrentPuzzleReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchMatchPanelComponent.Event_OnCurrentPuzzleChanged
	 * 		Flags  -> ()
	 */
	void URBSwitchMatchPanelComponent::Event_OnCurrentPuzzleChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchMatchPanelComponent.Event_OnCurrentPuzzleChanged");
		
		URBSwitchMatchPanelComponent_Event_OnCurrentPuzzleChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBSwitchMatchPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBSwitchMatchPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSwitchMatchPanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.OnRep_DesiredSwitchStatusNetwork_Callback
	 * 		Flags  -> ()
	 */
	void ARBSwitchPanelPart::OnRep_DesiredSwitchStatusNetwork_Callback()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.OnRep_DesiredSwitchStatusNetwork_Callback");
		
		ARBSwitchPanelPart_OnRep_DesiredSwitchStatusNetwork_Callback_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.OnRep_DesiredSwitchStatusNetwork
	 * 		Flags  -> ()
	 */
	void ARBSwitchPanelPart::OnRep_DesiredSwitchStatusNetwork()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.OnRep_DesiredSwitchStatusNetwork");
		
		ARBSwitchPanelPart_OnRep_DesiredSwitchStatusNetwork_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.OnRep_ActiveSwitchValue
	 * 		Flags  -> ()
	 */
	void ARBSwitchPanelPart::OnRep_ActiveSwitchValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.OnRep_ActiveSwitchValue");
		
		ARBSwitchPanelPart_OnRep_ActiveSwitchValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.Multicast_ResetValues
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              desiredSwitchStatusValue                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSwitchPanelPart::Multicast_ResetValues(float desiredSwitchStatusValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.Multicast_ResetValues");
		
		ARBSwitchPanelPart_Multicast_ResetValues_Params params {};
		params.desiredSwitchStatusValue = desiredSwitchStatusValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.BP_SetSwitchStatus
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSwitchPanelPart::BP_SetSwitchStatus(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.BP_SetSwitchStatus");
		
		ARBSwitchPanelPart_BP_SetSwitchStatus_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.BP_ResetValues
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bKeepCurrentValues                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSwitchPanelPart::BP_ResetValues(bool bKeepCurrentValues)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.BP_ResetValues");
		
		ARBSwitchPanelPart_BP_ResetValues_Params params {};
		params.bKeepCurrentValues = bKeepCurrentValues;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.BP_OnSwitchStatusChanged
	 * 		Flags  -> ()
	 */
	void ARBSwitchPanelPart::BP_OnSwitchStatusChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.BP_OnSwitchStatusChanged");
		
		ARBSwitchPanelPart_BP_OnSwitchStatusChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.BP_OnStopInteract
	 * 		Flags  -> ()
	 */
	void ARBSwitchPanelPart::BP_OnStopInteract()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.BP_OnStopInteract");
		
		ARBSwitchPanelPart_BP_OnStopInteract_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.BP_OnStartInteract
	 * 		Flags  -> ()
	 */
	void ARBSwitchPanelPart::BP_OnStartInteract()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.BP_OnStartInteract");
		
		ARBSwitchPanelPart_BP_OnStartInteract_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.BP_OnAddInputVertical
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsGamepad                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              deltaValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSwitchPanelPart::BP_OnAddInputVertical(float Val, bool bIsGamepad, float deltaValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.BP_OnAddInputVertical");
		
		ARBSwitchPanelPart_BP_OnAddInputVertical_Params params {};
		params.Val = Val;
		params.bIsGamepad = bIsGamepad;
		params.deltaValue = deltaValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.BP_OnAddInputHorizontal
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsGamepad                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              deltaValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBSwitchPanelPart::BP_OnAddInputHorizontal(float Val, bool bIsGamepad, float deltaValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.BP_OnAddInputHorizontal");
		
		ARBSwitchPanelPart_BP_OnAddInputHorizontal_Params params {};
		params.Val = Val;
		params.bIsGamepad = bIsGamepad;
		params.deltaValue = deltaValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.BP_IsPanelEnabled
	 * 		Flags  -> ()
	 */
	bool ARBSwitchPanelPart::BP_IsPanelEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.BP_IsPanelEnabled");
		
		ARBSwitchPanelPart_BP_IsPanelEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.BP_IsCloseToActive
	 * 		Flags  -> ()
	 */
	bool ARBSwitchPanelPart::BP_IsCloseToActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.BP_IsCloseToActive");
		
		ARBSwitchPanelPart_BP_IsCloseToActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBSwitchPanelPart.BP_IsActive
	 * 		Flags  -> ()
	 */
	bool ARBSwitchPanelPart::BP_IsActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBSwitchPanelPart.BP_IsActive");
		
		ARBSwitchPanelPart_BP_IsActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBSwitchPanelPart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBSwitchPanelPart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBSwitchPanelPart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTalkWheel.Event_RefreshSlices
	 * 		Flags  -> ()
	 */
	void URBTalkWheel::Event_RefreshSlices()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTalkWheel.Event_RefreshSlices");
		
		URBTalkWheel_Event_RefreshSlices_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTalkWheel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTalkWheel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTalkWheel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.OnRep_State
	 * 		Flags  -> ()
	 */
	void ARBTask::OnRep_State()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.OnRep_State");
		
		ARBTask_OnRep_State_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.OnRep_Progress
	 * 		Flags  -> ()
	 */
	void ARBTask::OnRep_Progress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.OnRep_Progress");
		
		ARBTask_OnRep_Progress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.OnRep_PendingProgress
	 * 		Flags  -> ()
	 */
	void ARBTask::OnRep_PendingProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.OnRep_PendingProgress");
		
		ARBTask_OnRep_PendingProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.OnGamePhaseUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGamePhase                                         gamePhase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTask::OnGamePhaseUpdated(EGamePhase gamePhase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.OnGamePhaseUpdated");
		
		ARBTask_OnGamePhaseUpdated_Params params {};
		params.gamePhase = gamePhase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.IsExpiringSoon
	 * 		Flags  -> ()
	 */
	bool ARBTask::IsExpiringSoon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.IsExpiringSoon");
		
		ARBTask_IsExpiringSoon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.GetTaskUniqueId
	 * 		Flags  -> ()
	 */
	int64_t ARBTask::GetTaskUniqueId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.GetTaskUniqueId");
		
		ARBTask_GetTaskUniqueId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.GetTaskState
	 * 		Flags  -> ()
	 */
	ETaskState ARBTask::GetTaskState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.GetTaskState");
		
		ARBTask_GetTaskState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.GetTaskData
	 * 		Flags  -> ()
	 */
	class URBTaskData* ARBTask::GetTaskData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.GetTaskData");
		
		ARBTask_GetTaskData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.GetSecondsUntilExpiration
	 * 		Flags  -> ()
	 */
	int64_t ARBTask::GetSecondsUntilExpiration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.GetSecondsUntilExpiration");
		
		ARBTask_GetSecondsUntilExpiration_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.GetProgressText
	 * 		Flags  -> ()
	 */
	class FText ARBTask::GetProgressText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.GetProgressText");
		
		ARBTask_GetProgressText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.GetProgressRatio
	 * 		Flags  -> ()
	 */
	float ARBTask::GetProgressRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.GetProgressRatio");
		
		ARBTask_GetProgressRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.GetProgressionCounterMaxValue
	 * 		Flags  -> ()
	 */
	int32_t ARBTask::GetProgressionCounterMaxValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.GetProgressionCounterMaxValue");
		
		ARBTask_GetProgressionCounterMaxValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.GetProgressionCounterCurrentValue
	 * 		Flags  -> ()
	 */
	int32_t ARBTask::GetProgressionCounterCurrentValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.GetProgressionCounterCurrentValue");
		
		ARBTask_GetProgressionCounterCurrentValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.GetObjectiveText
	 * 		Flags  -> ()
	 */
	class FText ARBTask::GetObjectiveText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.GetObjectiveText");
		
		ARBTask_GetObjectiveText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask.GetExpirationTimeText
	 * 		Flags  -> ()
	 */
	class FText ARBTask::GetExpirationTimeText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask.GetExpirationTimeText");
		
		ARBTask_GetExpirationTimeText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTask.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTask::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTask");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTask_PlayerCondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTask_PlayerCondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTask_PlayerCondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask_PlayerEvent.OnPlayerEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerEvent                                       EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTask_PlayerEvent::OnPlayerEvent(EPlayerEvent EventType, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask_PlayerEvent.OnPlayerEvent");
		
		ARBTask_PlayerEvent_OnPlayerEvent_Params params {};
		params.EventType = EventType;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTask_PlayerEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTask_PlayerEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTask_PlayerEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTask_PlayerStat.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTask_PlayerStat::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTask_PlayerStat");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask_StageCompletion.OnStageEnded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBStageID                                  StageID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRBMissionID                                MissionID                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bisReset                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTask_StageCompletion::OnStageEnded(const struct FRBStageID& StageID, const struct FRBMissionID& MissionID, bool bisReset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask_StageCompletion.OnStageEnded");
		
		ARBTask_StageCompletion_OnStageEnded_Params params {};
		params.StageID = StageID;
		params.MissionID = MissionID;
		params.bisReset = bisReset;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTask_StageCompletion.OnPlayerEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerEvent                                       EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTask_StageCompletion::OnPlayerEvent(EPlayerEvent EventType, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTask_StageCompletion.OnPlayerEvent");
		
		ARBTask_StageCompletion_OnPlayerEvent_Params params {};
		params.EventType = EventType;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTask_StageCompletion.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTask_StageCompletion::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTask_StageCompletion");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTaskData.HasDifficultyRequirements
	 * 		Flags  -> ()
	 */
	bool URBTaskData::HasDifficultyRequirements()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTaskData.HasDifficultyRequirements");
		
		URBTaskData_HasDifficultyRequirements_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTaskData.GetProgressionCounterMaxValue
	 * 		Flags  -> ()
	 */
	int32_t URBTaskData::GetProgressionCounterMaxValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTaskData.GetProgressionCounterMaxValue");
		
		URBTaskData_GetProgressionCounterMaxValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTaskData.FormatTitle
	 * 		Flags  -> ()
	 */
	class FText URBTaskData::FormatTitle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTaskData.FormatTitle");
		
		URBTaskData_FormatTitle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTaskData.FormatObjective
	 * 		Flags  -> ()
	 */
	class FText URBTaskData::FormatObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTaskData.FormatObjective");
		
		URBTaskData_FormatObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTaskData.FormatDescription
	 * 		Flags  -> ()
	 */
	class FText URBTaskData::FormatDescription()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTaskData.FormatDescription");
		
		URBTaskData_FormatDescription_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTaskData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTaskData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTaskData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTaskData_PlayerCondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTaskData_PlayerCondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTaskData_PlayerCondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTaskData_PlayerEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTaskData_PlayerEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTaskData_PlayerEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTaskData_PlayerStat.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTaskData_PlayerStat::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTaskData_PlayerStat");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTaskData_StageCompletion.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTaskData_StageCompletion::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTaskData_StageCompletion");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTaskManager.OnPlayerProgressionReceived
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTaskManager::OnPlayerProgressionReceived(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTaskManager.OnPlayerProgressionReceived");
		
		ARBTaskManager_OnPlayerProgressionReceived_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTaskManager.GetPlayerTasks
	 * 		Flags  -> ()
	 */
	struct FPlayerTasks ARBTaskManager::GetPlayerTasks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTaskManager.GetPlayerTasks");
		
		ARBTaskManager_GetPlayerTasks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTaskManager.GetAvailableTasks
	 * 		Flags  -> ()
	 */
	TArray<struct FAvailableTask> ARBTaskManager::GetAvailableTasks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTaskManager.GetAvailableTasks");
		
		ARBTaskManager_GetAvailableTasks_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTaskManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTaskManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTaskManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTasksConfig.FindTaskData
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        taskId                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class URBTaskData* URBTasksConfig::FindTaskData(const class FName& taskId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTasksConfig.FindTaskData");
		
		URBTasksConfig_FindTaskData_Params params {};
		params.taskId = taskId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTasksConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTasksConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTasksConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTextChatManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTextChatManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTextChatManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTextChatWidget.OnTextChatManagerRegistered
	 * 		Flags  -> ()
	 */
	void URBTextChatWidget::OnTextChatManagerRegistered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTextChatWidget.OnTextChatManagerRegistered");
		
		URBTextChatWidget_OnTextChatManagerRegistered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTextChatWidget.Event_ShowMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBTextChatMessage                          Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBTextChatWidget::Event_ShowMessage(const struct FRBTextChatMessage& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTextChatWidget.Event_ShowMessage");
		
		URBTextChatWidget_Event_ShowMessage_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTextChatWidget.Event_HideMessage
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            MessageId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTextChatWidget::Event_HideMessage(int32_t MessageId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTextChatWidget.Event_HideMessage");
		
		URBTextChatWidget_Event_HideMessage_Params params {};
		params.MessageId = MessageId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTextChatWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTextChatWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTextChatWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBThrowableWeapon.Multicast_ThrownHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     HitLocation                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitNormal                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     reflectedDir                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPhysicalMaterial*                           impactMaterial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      hitActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               forceBreak                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBThrowableWeapon::Multicast_ThrownHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& reflectedDir, class UPhysicalMaterial* impactMaterial, class AActor* hitActor, bool forceBreak)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBThrowableWeapon.Multicast_ThrownHit");
		
		ARBThrowableWeapon_Multicast_ThrownHit_Params params {};
		params.HitLocation = HitLocation;
		params.HitNormal = HitNormal;
		params.reflectedDir = reflectedDir;
		params.impactMaterial = impactMaterial;
		params.hitActor = hitActor;
		params.forceBreak = forceBreak;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBThrowableWeapon.Multicast_Throw
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     throwOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     throwStartLocation                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     throwOnCurveLocationaimAssistTargetComp                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBAimAssistComponent*                       aimAssistTargetComp                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBThrowableWeapon::Multicast_Throw(class ARBPawn* throwOwner, const struct FVector& throwStartLocation, const struct FVector& throwOnCurveLocationaimAssistTargetComp, class URBAimAssistComponent* aimAssistTargetComp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBThrowableWeapon.Multicast_Throw");
		
		ARBThrowableWeapon_Multicast_Throw_Params params {};
		params.throwOwner = throwOwner;
		params.throwStartLocation = throwStartLocation;
		params.throwOnCurveLocationaimAssistTargetComp = throwOnCurveLocationaimAssistTargetComp;
		params.aimAssistTargetComp = aimAssistTargetComp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBThrowableWeapon.BP_OnThrownHit
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     HitNormal                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     hitReflectionNormal                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPhysicalMaterial*                           impactMaterial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      hitActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBThrowableWeapon::BP_OnThrownHit(const struct FVector& HitNormal, const struct FVector& hitReflectionNormal, class UPhysicalMaterial* impactMaterial, class AActor* hitActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBThrowableWeapon.BP_OnThrownHit");
		
		ARBThrowableWeapon_BP_OnThrownHit_Params params {};
		params.HitNormal = HitNormal;
		params.hitReflectionNormal = hitReflectionNormal;
		params.impactMaterial = impactMaterial;
		params.hitActor = hitActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBThrowableWeapon.BP_OnHitDestroy
	 * 		Flags  -> ()
	 */
	void ARBThrowableWeapon::BP_OnHitDestroy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBThrowableWeapon.BP_OnHitDestroy");
		
		ARBThrowableWeapon_BP_OnHitDestroy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBThrowableWeapon.BP_OnGroundAndPoundCounter
	 * 		Flags  -> ()
	 */
	void ARBThrowableWeapon::BP_OnGroundAndPoundCounter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBThrowableWeapon.BP_OnGroundAndPoundCounter");
		
		ARBThrowableWeapon_BP_OnGroundAndPoundCounter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBThrowableWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBThrowableWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBThrowableWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBThrowableSkillItem.OnRep_State
	 * 		Flags  -> ()
	 */
	void ARBThrowableSkillItem::OnRep_State()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBThrowableSkillItem.OnRep_State");
		
		ARBThrowableSkillItem_OnRep_State_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBThrowableSkillItem.GetImpactRadius
	 * 		Flags  -> ()
	 */
	float ARBThrowableSkillItem::GetImpactRadius()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBThrowableSkillItem.GetImpactRadius");
		
		ARBThrowableSkillItem_GetImpactRadius_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBThrowableSkillItem.Event_OnDeployed
	 * 		Flags  -> ()
	 */
	void ARBThrowableSkillItem::Event_OnDeployed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBThrowableSkillItem.Event_OnDeployed");
		
		ARBThrowableSkillItem_Event_OnDeployed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBThrowableSkillItem.Event_OnActivate
	 * 		Flags  -> ()
	 */
	void ARBThrowableSkillItem::Event_OnActivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBThrowableSkillItem.Event_OnActivate");
		
		ARBThrowableSkillItem_Event_OnActivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBThrowableSkillItem.DelayedDestroy
	 * 		Flags  -> ()
	 */
	void ARBThrowableSkillItem::DelayedDestroy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBThrowableSkillItem.DelayedDestroy");
		
		ARBThrowableSkillItem_DelayedDestroy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBThrowableSkillItem.BP_MakePermanentlyDestroyed
	 * 		Flags  -> ()
	 */
	void ARBThrowableSkillItem::BP_MakePermanentlyDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBThrowableSkillItem.BP_MakePermanentlyDestroyed");
		
		ARBThrowableSkillItem_BP_MakePermanentlyDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBThrowableSkillItem.BP_EndActivationSequence
	 * 		Flags  -> ()
	 */
	void ARBThrowableSkillItem::BP_EndActivationSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBThrowableSkillItem.BP_EndActivationSequence");
		
		ARBThrowableSkillItem_BP_EndActivationSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBThrowableSkillItem.BP_BeginActivationSequence
	 * 		Flags  -> ()
	 */
	void ARBThrowableSkillItem::BP_BeginActivationSequence()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBThrowableSkillItem.BP_BeginActivationSequence");
		
		ARBThrowableSkillItem_BP_BeginActivationSequence_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBThrowableSkillItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBThrowableSkillItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBThrowableSkillItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBToasterDetector.BP_SetExternalAlertedStateActions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FAlertedStateActions                        inAlertedStateActions                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ARBToasterDetector::BP_SetExternalAlertedStateActions(const struct FAlertedStateActions& inAlertedStateActions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBToasterDetector.BP_SetExternalAlertedStateActions");
		
		ARBToasterDetector_BP_SetExternalAlertedStateActions_Params params {};
		params.inAlertedStateActions = inAlertedStateActions;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBToasterDetector.BP_GetAllLinkedTriggerables
	 * 		Flags  -> ()
	 */
	TArray<class ARBTriggerable*> ARBToasterDetector::BP_GetAllLinkedTriggerables()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBToasterDetector.BP_GetAllLinkedTriggerables");
		
		ARBToasterDetector_BP_GetAllLinkedTriggerables_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBToasterDetector.BP_ClearExternalAlertedStateActions
	 * 		Flags  -> ()
	 */
	void ARBToasterDetector::BP_ClearExternalAlertedStateActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBToasterDetector.BP_ClearExternalAlertedStateActions");
		
		ARBToasterDetector_BP_ClearExternalAlertedStateActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBToasterDetector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBToasterDetector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBToasterDetector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBToggleable.PostToggled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bToggleEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBToggleable::PostToggled(bool bToggleEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBToggleable.PostToggled");
		
		URBToggleable_PostToggled_Params params {};
		params.bToggleEnabled = bToggleEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBToggleable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBToggleable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBToggleable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureObjectiveCoordinator.OnTortureRoomCurrentMeterChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBTortureRoom*                              tortureRoom                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTortureObjectiveCoordinator::OnTortureRoomCurrentMeterChanged(class ARBTortureRoom* tortureRoom)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureObjectiveCoordinator.OnTortureRoomCurrentMeterChanged");
		
		ARBTortureObjectiveCoordinator_OnTortureRoomCurrentMeterChanged_Params params {};
		params.tortureRoom = tortureRoom;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureObjectiveCoordinator.OnTortureRoomCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBTortureRoom*                              tortureRoom                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTortureObjectiveCoordinator::OnTortureRoomCompleted(class ARBTortureRoom* tortureRoom)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureObjectiveCoordinator.OnTortureRoomCompleted");
		
		ARBTortureObjectiveCoordinator_OnTortureRoomCompleted_Params params {};
		params.tortureRoom = tortureRoom;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureObjectiveCoordinator.OnRep_TortureRoom
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBTortureRoom*                              oldTortureRoom                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTortureObjectiveCoordinator::OnRep_TortureRoom(class ARBTortureRoom* oldTortureRoom)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureObjectiveCoordinator.OnRep_TortureRoom");
		
		ARBTortureObjectiveCoordinator_OnRep_TortureRoom_Params params {};
		params.oldTortureRoom = oldTortureRoom;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureObjectiveCoordinator.OnPanelPawnInteractingChangedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     pawnInteracting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTortureObjectiveCoordinator::OnPanelPawnInteractingChangedEvent(class URBInteractiblePanelComponent* panel, class ARBPawn* pawnInteracting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureObjectiveCoordinator.OnPanelPawnInteractingChangedEvent");
		
		ARBTortureObjectiveCoordinator_OnPanelPawnInteractingChangedEvent_Params params {};
		params.panel = panel;
		params.pawnInteracting = pawnInteracting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureObjectiveCoordinator.OnPanelActiveChangedEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     pawnInteracting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTortureObjectiveCoordinator::OnPanelActiveChangedEvent(class URBInteractiblePanelComponent* panel, class ARBPawn* pawnInteracting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureObjectiveCoordinator.OnPanelActiveChangedEvent");
		
		ARBTortureObjectiveCoordinator_OnPanelActiveChangedEvent_Params params {};
		params.panel = panel;
		params.pawnInteracting = pawnInteracting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTortureObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTortureObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTortureObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTorturePanelComponent.Multicast_OnTrySucceeded
	 * 		Flags  -> ()
	 */
	void URBTorturePanelComponent::Multicast_OnTrySucceeded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTorturePanelComponent.Multicast_OnTrySucceeded");
		
		URBTorturePanelComponent_Multicast_OnTrySucceeded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTorturePanelComponent.Multicast_OnTryFailed
	 * 		Flags  -> ()
	 */
	void URBTorturePanelComponent::Multicast_OnTryFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTorturePanelComponent.Multicast_OnTryFailed");
		
		URBTorturePanelComponent_Multicast_OnTryFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTorturePanelComponent.Multicast_OnPanelSucceeded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               tortureCompleted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTorturePanelComponent::Multicast_OnPanelSucceeded(class ARBPawn* Pawn, bool tortureCompleted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTorturePanelComponent.Multicast_OnPanelSucceeded");
		
		URBTorturePanelComponent_Multicast_OnPanelSucceeded_Params params {};
		params.Pawn = Pawn;
		params.tortureCompleted = tortureCompleted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTorturePanelComponent.IsTortureRoomCompleted
	 * 		Flags  -> ()
	 */
	bool URBTorturePanelComponent::IsTortureRoomCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTorturePanelComponent.IsTortureRoomCompleted");
		
		URBTorturePanelComponent_IsTortureRoomCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTorturePanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTorturePanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTorturePanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureRoom.OnRep_TortureEnabled
	 * 		Flags  -> ()
	 */
	void ARBTortureRoom::OnRep_TortureEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureRoom.OnRep_TortureEnabled");
		
		ARBTortureRoom_OnRep_TortureEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureRoom.OnRep_TortureCompleted
	 * 		Flags  -> ()
	 */
	void ARBTortureRoom::OnRep_TortureCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureRoom.OnRep_TortureCompleted");
		
		ARBTortureRoom_OnRep_TortureCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureRoom.OnRep_CurrentMeter
	 * 		Flags  -> ()
	 */
	void ARBTortureRoom::OnRep_CurrentMeter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureRoom.OnRep_CurrentMeter");
		
		ARBTortureRoom_OnRep_CurrentMeter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureRoom.Event_OnTortureEnabledChanged
	 * 		Flags  -> ()
	 */
	void ARBTortureRoom::Event_OnTortureEnabledChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureRoom.Event_OnTortureEnabledChanged");
		
		ARBTortureRoom_Event_OnTortureEnabledChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureRoom.Event_OnTortureCompletedChanged
	 * 		Flags  -> ()
	 */
	void ARBTortureRoom::Event_OnTortureCompletedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureRoom.Event_OnTortureCompletedChanged");
		
		ARBTortureRoom_Event_OnTortureCompletedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureRoom.Event_OnPlayerInputSuccess
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBTorturePanelComponent*                    tortureComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTortureRoom::Event_OnPlayerInputSuccess(class URBTorturePanelComponent* tortureComponent, class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureRoom.Event_OnPlayerInputSuccess");
		
		ARBTortureRoom_Event_OnPlayerInputSuccess_Params params {};
		params.tortureComponent = tortureComponent;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureRoom.Event_OnPlayerInputFailed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBTorturePanelComponent*                    tortureComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTortureRoom::Event_OnPlayerInputFailed(class URBTorturePanelComponent* tortureComponent, class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureRoom.Event_OnPlayerInputFailed");
		
		ARBTortureRoom_Event_OnPlayerInputFailed_Params params {};
		params.tortureComponent = tortureComponent;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureRoom.Event_OnPlayerDisconnected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBTorturePanelComponent*                    tortureComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTortureRoom::Event_OnPlayerDisconnected(class URBTorturePanelComponent* tortureComponent, class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureRoom.Event_OnPlayerDisconnected");
		
		ARBTortureRoom_Event_OnPlayerDisconnected_Params params {};
		params.tortureComponent = tortureComponent;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureRoom.Event_OnPlayerConnected
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBTorturePanelComponent*                    tortureComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTortureRoom::Event_OnPlayerConnected(class URBTorturePanelComponent* tortureComponent, class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureRoom.Event_OnPlayerConnected");
		
		ARBTortureRoom_Event_OnPlayerConnected_Params params {};
		params.tortureComponent = tortureComponent;
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTortureRoom.Event_OnCurrentMeterChanged
	 * 		Flags  -> ()
	 */
	void ARBTortureRoom::Event_OnCurrentMeterChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTortureRoom.Event_OnCurrentMeterChanged");
		
		ARBTortureRoom_Event_OnCurrentMeterChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTortureRoom.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTortureRoom::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTortureRoom");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTradeable.IsTradeable
	 * 		Flags  -> ()
	 */
	bool URBTradeable::IsTradeable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTradeable.IsTradeable");
		
		URBTradeable_IsTradeable_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTradeable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTradeable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTradeable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTradeWindow.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTradeWindow::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTradeWindow");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapDart.OnRep_Launched
	 * 		Flags  -> ()
	 */
	void ARBTrapDart::OnRep_Launched()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapDart.OnRep_Launched");
		
		ARBTrapDart_OnRep_Launched_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapDart.OnPawnBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBTrapDart::OnPawnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapDart.OnPawnBeginOverlap");
		
		ARBTrapDart_OnPawnBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComponent = OtherComponent;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapDart.Multicast_TriggerTrap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInitial                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTrapDart::Multicast_TriggerTrap(bool bInitial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapDart.Multicast_TriggerTrap");
		
		ARBTrapDart_Multicast_TriggerTrap_Params params {};
		params.bInitial = bInitial;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapDart.BP_OnReachedMaxLimitServer
	 * 		Flags  -> ()
	 */
	void ARBTrapDart::BP_OnReachedMaxLimitServer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapDart.BP_OnReachedMaxLimitServer");
		
		ARBTrapDart_BP_OnReachedMaxLimitServer_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapDart.BP_OnPlayerPsychosis
	 * 		Flags  -> ()
	 */
	void ARBTrapDart::BP_OnPlayerPsychosis()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapDart.BP_OnPlayerPsychosis");
		
		ARBTrapDart_BP_OnPlayerPsychosis_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapDart.BP_OnPlayerDamage
	 * 		Flags  -> ()
	 */
	void ARBTrapDart::BP_OnPlayerDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapDart.BP_OnPlayerDamage");
		
		ARBTrapDart_BP_OnPlayerDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapDart.BP_OnLaunchEvent
	 * 		Flags  -> ()
	 */
	void ARBTrapDart::BP_OnLaunchEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapDart.BP_OnLaunchEvent");
		
		ARBTrapDart_BP_OnLaunchEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapDart.BP_OnHitPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTrapDart::BP_OnHitPlayer(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapDart.BP_OnHitPlayer");
		
		ARBTrapDart_BP_OnHitPlayer_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapDart.BP_OnDetachFromPlayer
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTrapDart::BP_OnDetachFromPlayer(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapDart.BP_OnDetachFromPlayer");
		
		ARBTrapDart_BP_OnDetachFromPlayer_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapDart.BP_Launch
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Direction                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTrapDart::BP_Launch(const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapDart.BP_Launch");
		
		ARBTrapDart_BP_Launch_Params params {};
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapDart.BP_DoesPsychosis
	 * 		Flags  -> ()
	 */
	bool ARBTrapDart::BP_DoesPsychosis()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapDart.BP_DoesPsychosis");
		
		ARBTrapDart_BP_DoesPsychosis_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapDart.BP_DoesDamage
	 * 		Flags  -> ()
	 */
	bool ARBTrapDart::BP_DoesDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapDart.BP_DoesDamage");
		
		ARBTrapDart_BP_DoesDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTrapDart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTrapDart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTrapDart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapGroup.GenerateScenarioForEachTrap
	 * 		Flags  -> ()
	 */
	void ARBTrapGroup::GenerateScenarioForEachTrap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapGroup.GenerateScenarioForEachTrap");
		
		ARBTrapGroup_GenerateScenarioForEachTrap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTrapGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTrapGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTrapGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapTriggerable.IsCurrentlyTriggering
	 * 		Flags  -> ()
	 */
	bool ARBTrapTriggerable::IsCurrentlyTriggering()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapTriggerable.IsCurrentlyTriggering");
		
		ARBTrapTriggerable_IsCurrentlyTriggering_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrapTriggerable.BP_LinkTriggerTrap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBWireTriggerTrap*                          triggerTrap                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTrapTriggerable::BP_LinkTriggerTrap(class ARBWireTriggerTrap* triggerTrap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrapTriggerable.BP_LinkTriggerTrap");
		
		ARBTrapTriggerable_BP_LinkTriggerTrap_Params params {};
		params.triggerTrap = triggerTrap;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTrapTriggerable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTrapTriggerable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTrapTriggerable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTrialAsyncData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTrialAsyncData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTrialAsyncData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.WouldTrialCompletionUnlockProgram
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        outProgramId                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBTrialBoardMenuTabWidget::WouldTrialCompletionUnlockProgram(const class FName& TrialId, class FName* outProgramId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.WouldTrialCompletionUnlockProgram");
		
		URBTrialBoardMenuTabWidget_WouldTrialCompletionUnlockProgram_Params params {};
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outProgramId != nullptr)
			*outProgramId = params.outProgramId;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.StartMatchCountdown
	 * 		Flags  -> ()
	 */
	void URBTrialBoardMenuTabWidget::StartMatchCountdown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.StartMatchCountdown");
		
		URBTrialBoardMenuTabWidget_StartMatchCountdown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.ShowFilter
	 * 		Flags  -> ()
	 */
	bool URBTrialBoardMenuTabWidget::ShowFilter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.ShowFilter");
		
		URBTrialBoardMenuTabWidget_ShowFilter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.SetTrialId
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::SetTrialId(const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.SetTrialId");
		
		URBTrialBoardMenuTabWidget_SetTrialId_Params params {};
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.SetShowOtherPlayerOverlayWidgets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInShowOtherPlayerOverlayWidgets                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::SetShowOtherPlayerOverlayWidgets(bool bInShowOtherPlayerOverlayWidgets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.SetShowOtherPlayerOverlayWidgets");
		
		URBTrialBoardMenuTabWidget_SetShowOtherPlayerOverlayWidgets_Params params {};
		params.bInShowOtherPlayerOverlayWidgets = bInShowOtherPlayerOverlayWidgets;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.SetGameDifficulty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGameDifficulty                                    GameDifficulty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::SetGameDifficulty(EGameDifficulty GameDifficulty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.SetGameDifficulty");
		
		URBTrialBoardMenuTabWidget_SetGameDifficulty_Params params {};
		params.GameDifficulty = GameDifficulty;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.SetFilter
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERBSocialMenuEntryFilter                           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::SetFilter(ERBSocialMenuEntryFilter Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.SetFilter");
		
		URBTrialBoardMenuTabWidget_SetFilter_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.SetEnableCharacterOverlayWidgets
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInEnableCharacterOverlayWidgets                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::SetEnableCharacterOverlayWidgets(bool bInEnableCharacterOverlayWidgets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.SetEnableCharacterOverlayWidgets");
		
		URBTrialBoardMenuTabWidget_SetEnableCharacterOverlayWidgets_Params params {};
		params.bInEnableCharacterOverlayWidgets = bInEnableCharacterOverlayWidgets;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.SaveMatchSettings
	 * 		Flags  -> ()
	 */
	void URBTrialBoardMenuTabWidget::SaveMatchSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.SaveMatchSettings");
		
		URBTrialBoardMenuTabWidget_SaveMatchSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnSocialMenuEntryCustomizationUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuEntry*                          Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::OnSocialMenuEntryCustomizationUpdated(class URBSocialMenuEntry* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnSocialMenuEntryCustomizationUpdated");
		
		URBTrialBoardMenuTabWidget_OnSocialMenuEntryCustomizationUpdated_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnPlayerStatsDataAvailable
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<struct FRBStatContext>                      stats                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FRBUIReleasedCharacterDetails>       releasedCharacterDetailsList                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::OnPlayerStatsDataAvailable(TArray<struct FRBStatContext> stats, TArray<struct FRBUIReleasedCharacterDetails> releasedCharacterDetailsList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnPlayerStatsDataAvailable");
		
		URBTrialBoardMenuTabWidget_OnPlayerStatsDataAvailable_Params params {};
		params.stats = stats;
		params.releasedCharacterDetailsList = releasedCharacterDetailsList;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnPlayerLeftGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::OnPlayerLeftGame(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnPlayerLeftGame");
		
		URBTrialBoardMenuTabWidget_OnPlayerLeftGame_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnPlayerLeaving
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EPlayerLeaveTarget                                 Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::OnPlayerLeaving(EPlayerLeaveTarget Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnPlayerLeaving");
		
		URBTrialBoardMenuTabWidget_OnPlayerLeaving_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnPlayerJoinedGame
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::OnPlayerJoinedGame(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnPlayerJoinedGame");
		
		URBTrialBoardMenuTabWidget_OnPlayerJoinedGame_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnPartyOwnerMatchSettingsUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMatchSettings                              MatchSettings                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::OnPartyOwnerMatchSettingsUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchSettings& MatchSettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnPartyOwnerMatchSettingsUpdated");
		
		URBTrialBoardMenuTabWidget_OnPartyOwnerMatchSettingsUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.MatchSettings = MatchSettings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnMatchStateUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMatchState                                 MatchState                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::OnMatchStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FMatchState& MatchState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnMatchStateUpdated");
		
		URBTrialBoardMenuTabWidget_OnMatchStateUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.MatchState = MatchState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnMatchSettingsUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FMatchSettings                              MatchSettings                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::OnMatchSettingsUpdated(const struct FMatchSettings& MatchSettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnMatchSettingsUpdated");
		
		URBTrialBoardMenuTabWidget_OnMatchSettingsUpdated_Params params {};
		params.MatchSettings = MatchSettings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnGameStageInfoUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBGameStageInfo                            gameStageInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::OnGameStageInfoUpdated(const struct FRBGameStageInfo& gameStageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnGameStageInfoUpdated");
		
		URBTrialBoardMenuTabWidget_OnGameStageInfoUpdated_Params params {};
		params.gameStageInfo = gameStageInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnGameDifficultyChanged
	 * 		Flags  -> ()
	 */
	void URBTrialBoardMenuTabWidget::OnGameDifficultyChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnGameDifficultyChanged");
		
		URBTrialBoardMenuTabWidget_OnGameDifficultyChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnFindPartyStateUpdated
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLobbyPlayerState*                         RBLobbyPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FFindPartyState                             FindPartyState                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::OnFindPartyStateUpdated(class ARBLobbyPlayerState* RBLobbyPlayerState, const struct FFindPartyState& FindPartyState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnFindPartyStateUpdated");
		
		URBTrialBoardMenuTabWidget_OnFindPartyStateUpdated_Params params {};
		params.RBLobbyPlayerState = RBLobbyPlayerState;
		params.FindPartyState = FindPartyState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnFilterChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERBSocialMenuEntryFilter                           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::OnFilterChanged(ERBSocialMenuEntryFilter Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnFilterChanged");
		
		URBTrialBoardMenuTabWidget_OnFilterChanged_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnEntryActionRequested
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuEntry*                          Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERBSocialMenuEntryAction                           action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::OnEntryActionRequested(class URBSocialMenuEntry* Entry, ERBSocialMenuEntryAction action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnEntryActionRequested");
		
		URBTrialBoardMenuTabWidget_OnEntryActionRequested_Params params {};
		params.Entry = Entry;
		params.action = action;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.OnDrawHud
	 * 		Flags  -> ()
	 */
	void URBTrialBoardMenuTabWidget::OnDrawHud()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.OnDrawHud");
		
		URBTrialBoardMenuTabWidget_OnDrawHud_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.IsTrialUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBTrialBoardMenuTabWidget::IsTrialUnlocked(const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.IsTrialUnlocked");
		
		URBTrialBoardMenuTabWidget_IsTrialUnlocked_Params params {};
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.IsTrialEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBTrialBoardMenuTabWidget::IsTrialEnabled(const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.IsTrialEnabled");
		
		URBTrialBoardMenuTabWidget_IsTrialEnabled_Params params {};
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.IsTrialCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPerfect                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBTrialBoardMenuTabWidget::IsTrialCompleted(const class FName& TrialId, bool bPerfect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.IsTrialCompleted");
		
		URBTrialBoardMenuTabWidget_IsTrialCompleted_Params params {};
		params.TrialId = TrialId;
		params.bPerfect = bPerfect;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.IsSolo
	 * 		Flags  -> ()
	 */
	bool URBTrialBoardMenuTabWidget::IsSolo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.IsSolo");
		
		URBTrialBoardMenuTabWidget_IsSolo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.IsProgramUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ProgramId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBTrialBoardMenuTabWidget::IsProgramUnlocked(const class FName& ProgramId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.IsProgramUnlocked");
		
		URBTrialBoardMenuTabWidget_IsProgramUnlocked_Params params {};
		params.ProgramId = ProgramId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.IsProgramEnabled
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ProgramId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBTrialBoardMenuTabWidget::IsProgramEnabled(const class FName& ProgramId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.IsProgramEnabled");
		
		URBTrialBoardMenuTabWidget_IsProgramEnabled_Params params {};
		params.ProgramId = ProgramId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.IsOperationPending
	 * 		Flags  -> ()
	 */
	bool URBTrialBoardMenuTabWidget::IsOperationPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.IsOperationPending");
		
		URBTrialBoardMenuTabWidget_IsOperationPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.IsMatchOwner
	 * 		Flags  -> ()
	 */
	bool URBTrialBoardMenuTabWidget::IsMatchOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.IsMatchOwner");
		
		URBTrialBoardMenuTabWidget_IsMatchOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.IsDataPending
	 * 		Flags  -> ()
	 */
	bool URBTrialBoardMenuTabWidget::IsDataPending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.IsDataPending");
		
		URBTrialBoardMenuTabWidget_IsDataPending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.HasCompletedProgram
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ProgramId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBTrialBoardMenuTabWidget::HasCompletedProgram(const class FName& ProgramId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.HasCompletedProgram");
		
		URBTrialBoardMenuTabWidget_HasCompletedProgram_Params params {};
		params.ProgramId = ProgramId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.HasAttemptedTrial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBTrialBoardMenuTabWidget::HasAttemptedTrial(const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.HasAttemptedTrial");
		
		URBTrialBoardMenuTabWidget_HasAttemptedTrial_Params params {};
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.GetSocialMenuManager
	 * 		Flags  -> ()
	 */
	class URBSocialMenuManager* URBTrialBoardMenuTabWidget::GetSocialMenuManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.GetSocialMenuManager");
		
		URBTrialBoardMenuTabWidget_GetSocialMenuManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.GetSceneActor
	 * 		Flags  -> ()
	 */
	class ARBSocialMenuSceneActor* URBTrialBoardMenuTabWidget::GetSceneActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.GetSceneActor");
		
		URBTrialBoardMenuTabWidget_GetSceneActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.GetProgramTQ
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ProgramId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBTrialBoardMenuTabWidget::GetProgramTQ(const class FName& ProgramId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.GetProgramTQ");
		
		URBTrialBoardMenuTabWidget_GetProgramTQ_Params params {};
		params.ProgramId = ProgramId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.GetProgramId
	 * 		Flags  -> ()
	 */
	class FName URBTrialBoardMenuTabWidget::GetProgramId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.GetProgramId");
		
		URBTrialBoardMenuTabWidget_GetProgramId_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.GetPlatform
	 * 		Flags  -> ()
	 */
	EProfilePlatform URBTrialBoardMenuTabWidget::GetPlatform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.GetPlatform");
		
		URBTrialBoardMenuTabWidget_GetPlatform_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.GetMatchSettings
	 * 		Flags  -> ()
	 */
	struct FMatchSettings URBTrialBoardMenuTabWidget::GetMatchSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.GetMatchSettings");
		
		URBTrialBoardMenuTabWidget_GetMatchSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.GetMatchCurrentPlayerCount
	 * 		Flags  -> ()
	 */
	int32_t URBTrialBoardMenuTabWidget::GetMatchCurrentPlayerCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.GetMatchCurrentPlayerCount");
		
		URBTrialBoardMenuTabWidget_GetMatchCurrentPlayerCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.GetFilter
	 * 		Flags  -> ()
	 */
	ERBSocialMenuEntryFilter URBTrialBoardMenuTabWidget::GetFilter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.GetFilter");
		
		URBTrialBoardMenuTabWidget_GetFilter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.GetBestTrialPersonalTQ
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBTrialBoardMenuTabWidget::GetBestTrialPersonalTQ(const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.GetBestTrialPersonalTQ");
		
		URBTrialBoardMenuTabWidget_GetBestTrialPersonalTQ_Params params {};
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.FindParty
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ProgramId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::FindParty(const class FName& ProgramId, const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.FindParty");
		
		URBTrialBoardMenuTabWidget_FindParty_Params params {};
		params.ProgramId = ProgramId;
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.Event_UpdatePartyInviteWidgetVisibility
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldBeVisible                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::Event_UpdatePartyInviteWidgetVisibility(bool bShouldBeVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.Event_UpdatePartyInviteWidgetVisibility");
		
		URBTrialBoardMenuTabWidget_Event_UpdatePartyInviteWidgetVisibility_Params params {};
		params.bShouldBeVisible = bShouldBeVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.Event_ShowOptions
	 * 		Flags  -> ()
	 */
	void URBTrialBoardMenuTabWidget::Event_ShowOptions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.Event_ShowOptions");
		
		URBTrialBoardMenuTabWidget_Event_ShowOptions_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.Event_SetEntryPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuEntry*                          Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::Event_SetEntryPosition(class URBSocialMenuEntry* Entry, const struct FVector2D& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.Event_SetEntryPosition");
		
		URBTrialBoardMenuTabWidget_Event_SetEntryPosition_Params params {};
		params.Entry = Entry;
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.Event_RemoveEntry
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuEntry*                          Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::Event_RemoveEntry(class URBSocialMenuEntry* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.Event_RemoveEntry");
		
		URBTrialBoardMenuTabWidget_Event_RemoveEntry_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.Event_Refresh
	 * 		Flags  -> ()
	 */
	void URBTrialBoardMenuTabWidget::Event_Refresh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.Event_Refresh");
		
		URBTrialBoardMenuTabWidget_Event_Refresh_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.Event_OnFilterChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERBSocialMenuEntryFilter                           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::Event_OnFilterChanged(ERBSocialMenuEntryFilter Filter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.Event_OnFilterChanged");
		
		URBTrialBoardMenuTabWidget_Event_OnFilterChanged_Params params {};
		params.Filter = Filter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.Event_ChangeActiveSkill
	 * 		Flags  -> ()
	 */
	void URBTrialBoardMenuTabWidget::Event_ChangeActiveSkill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.Event_ChangeActiveSkill");
		
		URBTrialBoardMenuTabWidget_Event_ChangeActiveSkill_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.Event_AddEntry
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBSocialMenuEntry*                          Entry                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTrialBoardMenuTabWidget::Event_AddEntry(class URBSocialMenuEntry* Entry)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.Event_AddEntry");
		
		URBTrialBoardMenuTabWidget_Event_AddEntry_Params params {};
		params.Entry = Entry;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.CanStartMatch
	 * 		Flags  -> ()
	 */
	bool URBTrialBoardMenuTabWidget::CanStartMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.CanStartMatch");
		
		URBTrialBoardMenuTabWidget_CanStartMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.CanSendPartyInvite
	 * 		Flags  -> ()
	 */
	bool URBTrialBoardMenuTabWidget::CanSendPartyInvite()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.CanSendPartyInvite");
		
		URBTrialBoardMenuTabWidget_CanSendPartyInvite_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.CanSelectTrial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TrialId                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBTrialBoardMenuTabWidget::CanSelectTrial(const class FName& TrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.CanSelectTrial");
		
		URBTrialBoardMenuTabWidget_CanSelectTrial_Params params {};
		params.TrialId = TrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.CanFindParty
	 * 		Flags  -> ()
	 */
	bool URBTrialBoardMenuTabWidget::CanFindParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.CanFindParty");
		
		URBTrialBoardMenuTabWidget_CanFindParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.CancelMatchCountdown
	 * 		Flags  -> ()
	 */
	void URBTrialBoardMenuTabWidget::CancelMatchCountdown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.CancelMatchCountdown");
		
		URBTrialBoardMenuTabWidget_CancelMatchCountdown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.CancelFindParty
	 * 		Flags  -> ()
	 */
	void URBTrialBoardMenuTabWidget::CancelFindParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.CancelFindParty");
		
		URBTrialBoardMenuTabWidget_CancelFindParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.CanCancelMatch
	 * 		Flags  -> ()
	 */
	bool URBTrialBoardMenuTabWidget::CanCancelMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.CanCancelMatch");
		
		URBTrialBoardMenuTabWidget_CanCancelMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.CanCancelFindParty
	 * 		Flags  -> ()
	 */
	bool URBTrialBoardMenuTabWidget::CanCancelFindParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.CanCancelFindParty");
		
		URBTrialBoardMenuTabWidget_CanCancelFindParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.CanAddFriend
	 * 		Flags  -> ()
	 */
	bool URBTrialBoardMenuTabWidget::CanAddFriend()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.CanAddFriend");
		
		URBTrialBoardMenuTabWidget_CanAddFriend_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTrialBoardMenuTabWidget.AreTrialsFromSameProgram
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        firstTrialId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        secondTrialId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBTrialBoardMenuTabWidget::AreTrialsFromSameProgram(const class FName& firstTrialId, const class FName& secondTrialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTrialBoardMenuTabWidget.AreTrialsFromSameProgram");
		
		URBTrialBoardMenuTabWidget_AreTrialsFromSameProgram_Params params {};
		params.firstTrialId = firstTrialId;
		params.secondTrialId = secondTrialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTrialBoardMenuTabWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTrialBoardMenuTabWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTrialBoardMenuTabWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTrialSectionConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTrialSectionConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTrialSectionConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.OnRep_ShouldBeOpened
	 * 		Flags  -> ()
	 */
	void ARBTriggerableDoorWayDetector::OnRep_ShouldBeOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.OnRep_ShouldBeOpened");
		
		ARBTriggerableDoorWayDetector_OnRep_ShouldBeOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.OnRep_LockedClosed
	 * 		Flags  -> ()
	 */
	void ARBTriggerableDoorWayDetector::OnRep_LockedClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.OnRep_LockedClosed");
		
		ARBTriggerableDoorWayDetector_OnRep_LockedClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.OnRep_IsBlockingDoorWay
	 * 		Flags  -> ()
	 */
	void ARBTriggerableDoorWayDetector::OnRep_IsBlockingDoorWay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.OnRep_IsBlockingDoorWay");
		
		ARBTriggerableDoorWayDetector_OnRep_IsBlockingDoorWay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.OnRep_Enabled
	 * 		Flags  -> ()
	 */
	void ARBTriggerableDoorWayDetector::OnRep_Enabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.OnRep_Enabled");
		
		ARBTriggerableDoorWayDetector_OnRep_Enabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.OnLargePickupDropped
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBLargePickup*                              largePickup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerableDoorWayDetector::OnLargePickupDropped(class ARBLargePickup* largePickup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.OnLargePickupDropped");
		
		ARBTriggerableDoorWayDetector_OnLargePickupDropped_Params params {};
		params.largePickup = largePickup;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.OnComponentEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerableDoorWayDetector::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.OnComponentEndOverlap");
		
		ARBTriggerableDoorWayDetector_OnComponentEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.OnComponentBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerableDoorWayDetector::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.OnComponentBeginOverlap");
		
		ARBTriggerableDoorWayDetector_OnComponentBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.IsBlockingDoorWaybackChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerableDoorWayDetector::IsBlockingDoorWaybackChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.IsBlockingDoorWaybackChangedCallback");
		
		ARBTriggerableDoorWayDetector_IsBlockingDoorWaybackChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.IsBlockingDoorway
	 * 		Flags  -> ()
	 */
	bool ARBTriggerableDoorWayDetector::IsBlockingDoorway()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.IsBlockingDoorway");
		
		ARBTriggerableDoorWayDetector_IsBlockingDoorway_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.Event_OnShouldBeOpenedChanged
	 * 		Flags  -> ()
	 */
	void ARBTriggerableDoorWayDetector::Event_OnShouldBeOpenedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.Event_OnShouldBeOpenedChanged");
		
		ARBTriggerableDoorWayDetector_Event_OnShouldBeOpenedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.Event_OnLockedClosedChanged
	 * 		Flags  -> ()
	 */
	void ARBTriggerableDoorWayDetector::Event_OnLockedClosedChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.Event_OnLockedClosedChanged");
		
		ARBTriggerableDoorWayDetector_Event_OnLockedClosedChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.Event_OnIsBlockingDoorwayChanged
	 * 		Flags  -> ()
	 */
	void ARBTriggerableDoorWayDetector::Event_OnIsBlockingDoorwayChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.Event_OnIsBlockingDoorwayChanged");
		
		ARBTriggerableDoorWayDetector_Event_OnIsBlockingDoorwayChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.Event_OnEnabledChanged
	 * 		Flags  -> ()
	 */
	void ARBTriggerableDoorWayDetector::Event_OnEnabledChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.Event_OnEnabledChanged");
		
		ARBTriggerableDoorWayDetector_Event_OnEnabledChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableDoorWayDetector.BP_SetShouldBeOpened
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerableDoorWayDetector::BP_SetShouldBeOpened(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableDoorWayDetector.BP_SetShouldBeOpened");
		
		ARBTriggerableDoorWayDetector_BP_SetShouldBeOpened_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTriggerableDoorWayDetector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTriggerableDoorWayDetector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTriggerableDoorWayDetector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableGate.OnRep_VariatorLogicEnabled
	 * 		Flags  -> ()
	 */
	void ARBTriggerableGate::OnRep_VariatorLogicEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableGate.OnRep_VariatorLogicEnabled");
		
		ARBTriggerableGate_OnRep_VariatorLogicEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableGate.OnRep_CurrentVariatorType
	 * 		Flags  -> ()
	 */
	void ARBTriggerableGate::OnRep_CurrentVariatorType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableGate.OnRep_CurrentVariatorType");
		
		ARBTriggerableGate_OnRep_CurrentVariatorType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableGate.OnRep_BlockableState
	 * 		Flags  -> ()
	 */
	void ARBTriggerableGate::OnRep_BlockableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableGate.OnRep_BlockableState");
		
		ARBTriggerableGate_OnRep_BlockableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableGate.GetCurrentVariatorType
	 * 		Flags  -> ()
	 */
	ERollingGateVariatorType ARBTriggerableGate::GetCurrentVariatorType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableGate.GetCurrentVariatorType");
		
		ARBTriggerableGate_GetCurrentVariatorType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableGate.GetBlockableState
	 * 		Flags  -> ()
	 */
	EBlockableState ARBTriggerableGate::GetBlockableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableGate.GetBlockableState");
		
		ARBTriggerableGate_GetBlockableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableGate.Event_OnVariatorLogicEnabledChanged
	 * 		Flags  -> ()
	 */
	void ARBTriggerableGate::Event_OnVariatorLogicEnabledChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableGate.Event_OnVariatorLogicEnabledChanged");
		
		ARBTriggerableGate_Event_OnVariatorLogicEnabledChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableGate.Event_OnCurrentVariatorTypeChanged
	 * 		Flags  -> ()
	 */
	void ARBTriggerableGate::Event_OnCurrentVariatorTypeChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableGate.Event_OnCurrentVariatorTypeChanged");
		
		ARBTriggerableGate_Event_OnCurrentVariatorTypeChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableGate.Event_OnBlockableStateChanged
	 * 		Flags  -> ()
	 */
	void ARBTriggerableGate::Event_OnBlockableStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableGate.Event_OnBlockableStateChanged");
		
		ARBTriggerableGate_Event_OnBlockableStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTriggerableGate.BP_ForceVariatorType
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ERollingGateVariatorType                           VariatorType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBTriggerableGate::BP_ForceVariatorType(ERollingGateVariatorType VariatorType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTriggerableGate.BP_ForceVariatorType");
		
		ARBTriggerableGate_BP_ForceVariatorType_Params params {};
		params.VariatorType = VariatorType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTriggerableGate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTriggerableGate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTriggerableGate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBTriggerableGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBTriggerableGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTriggerableGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTutorialComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTutorialComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTutorialComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.CoordinatorTutorialInfo.OnCompletionInProgressChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               isProgressionInProgress                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               isCompletedByLocalPlayer                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCoordinatorTutorialInfo::OnCompletionInProgressChanged(bool isProgressionInProgress, bool isCompletedByLocalPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.CoordinatorTutorialInfo.OnCompletionInProgressChanged");
		
		UCoordinatorTutorialInfo_OnCompletionInProgressChanged_Params params {};
		params.isProgressionInProgress = isProgressionInProgress;
		params.isCompletedByLocalPlayer = isCompletedByLocalPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCoordinatorTutorialInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCoordinatorTutorialInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.CoordinatorTutorialInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTutorialManager.OnPlayerRevived
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   instigatorActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPlayer*                                   subjectActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTutorialManager::OnPlayerRevived(class ARBPlayer* instigatorActor, class ARBPlayer* subjectActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTutorialManager.OnPlayerRevived");
		
		URBTutorialManager_OnPlayerRevived_Params params {};
		params.instigatorActor = instigatorActor;
		params.subjectActor = subjectActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTutorialManager.OnObjectiveCoordinatorStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBaseObjectiveCoordinator*                 coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EObjectiveCoordinatorState                         State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTutorialManager::OnObjectiveCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* coordinator, EObjectiveCoordinatorState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTutorialManager.OnObjectiveCoordinatorStateChanged");
		
		URBTutorialManager_OnObjectiveCoordinatorStateChanged_Params params {};
		params.coordinator = coordinator;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTutorialManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTutorialManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTutorialManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBTutorialZoneComponent.OnObjectiveCoordinatorStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBaseObjectiveCoordinator*                 coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EObjectiveCoordinatorState                         State                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBTutorialZoneComponent::OnObjectiveCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* coordinator, EObjectiveCoordinatorState State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBTutorialZoneComponent.OnObjectiveCoordinatorStateChanged");
		
		URBTutorialZoneComponent_OnObjectiveCoordinatorStateChanged_Params params {};
		params.coordinator = coordinator;
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBTutorialZoneComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBTutorialZoneComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBTutorialZoneComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.UpdateLastLevelGainedInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUILevelInfo                                levelInfo                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::UpdateLastLevelGainedInfo(const struct FUILevelInfo& levelInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.UpdateLastLevelGainedInfo");
		
		URBUIBlueprintLibrary_UpdateLastLevelGainedInfo_Params params {};
		params.levelInfo = levelInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.TryClearMinigameProgressHUDOwner
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      progressOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::TryClearMinigameProgressHUDOwner(class AActor* progressOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.TryClearMinigameProgressHUDOwner");
		
		URBUIBlueprintLibrary_TryClearMinigameProgressHUDOwner_Params params {};
		params.progressOwner = progressOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.ShowContextualTutorial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        TutorialText                                               (Parm, NativeAccessSpecifierPublic)
	 * 		float                                              duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::ShowContextualTutorial(const class FText& TutorialText, float duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.ShowContextualTutorial");
		
		URBUIBlueprintLibrary_ShowContextualTutorial_Params params {};
		params.TutorialText = TutorialText;
		params.duration = duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.ShouldDisplayGenericPlatformIcon
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EProfilePlatform                                   Platform                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::ShouldDisplayGenericPlatformIcon(EProfilePlatform Platform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.ShouldDisplayGenericPlatformIcon");
		
		URBUIBlueprintLibrary_ShouldDisplayGenericPlatformIcon_Params params {};
		params.Platform = Platform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.SetTutorialPlayed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TutorialId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::SetTutorialPlayed(const class FName& TutorialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.SetTutorialPlayed");
		
		URBUIBlueprintLibrary_SetTutorialPlayed_Params params {};
		params.TutorialId = TutorialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.SetShouldReplayMenuTutorials
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               shouldReplay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::SetShouldReplayMenuTutorials(bool shouldReplay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.SetShouldReplayMenuTutorials");
		
		URBUIBlueprintLibrary_SetShouldReplayMenuTutorials_Params params {};
		params.shouldReplay = shouldReplay;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.SetNPCUnlockAnnouncementPlayed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMetaNPCType                                       NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::SetNPCUnlockAnnouncementPlayed(EMetaNPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.SetNPCUnlockAnnouncementPlayed");
		
		URBUIBlueprintLibrary_SetNPCUnlockAnnouncementPlayed_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.SetMinigameProgressHUDOwner
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      progressOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::SetMinigameProgressHUDOwner(class AActor* progressOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.SetMinigameProgressHUDOwner");
		
		URBUIBlueprintLibrary_SetMinigameProgressHUDOwner_Params params {};
		params.progressOwner = progressOwner;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.SetMenuTutorialPlayed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TutorialId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::SetMenuTutorialPlayed(const class FName& TutorialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.SetMenuTutorialPlayed");
		
		URBUIBlueprintLibrary_SetMenuTutorialPlayed_Params params {};
		params.TutorialId = TutorialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.SetMenuFocusAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     Source                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        action                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        Text                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::SetMenuFocusAction(class UWidget* Source, const class FName& action, const class FText& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.SetMenuFocusAction");
		
		URBUIBlueprintLibrary_SetMenuFocusAction_Params params {};
		params.Source = Source;
		params.action = action;
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.SetLastLevelGainedVoicelinePlayed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUILevelInfo                                levelInfo                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::SetLastLevelGainedVoicelinePlayed(const struct FUILevelInfo& levelInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.SetLastLevelGainedVoicelinePlayed");
		
		URBUIBlueprintLibrary_SetLastLevelGainedVoicelinePlayed_Params params {};
		params.levelInfo = levelInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.SetHasVisitedNPC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMetaNPCType                                       NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::SetHasVisitedNPC(EMetaNPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.SetHasVisitedNPC");
		
		URBUIBlueprintLibrary_SetHasVisitedNPC_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.SetHasSeenItemInMenu
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        OnlineID                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::SetHasSeenItemInMenu(const class FName& OnlineID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.SetHasSeenItemInMenu");
		
		URBUIBlueprintLibrary_SetHasSeenItemInMenu_Params params {};
		params.OnlineID = OnlineID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.SetHasSeenDocument
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::SetHasSeenDocument(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.SetHasSeenDocument");
		
		URBUIBlueprintLibrary_SetHasSeenDocument_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.SaveThumbnailForOutfits
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class URBCustomizationOutfit*>              rbCustomizationOutfits                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               forceCleanCategory                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::SaveThumbnailForOutfits(TArray<class URBCustomizationOutfit*> rbCustomizationOutfits, bool forceCleanCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.SaveThumbnailForOutfits");
		
		URBUIBlueprintLibrary_SaveThumbnailForOutfits_Params params {};
		params.rbCustomizationOutfits = rbCustomizationOutfits;
		params.forceCleanCategory = forceCleanCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.SaveThumbnailForOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class URBPlayerCustomizationOption*>        rbCustomizationOptions                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               forceCleanCategory                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::SaveThumbnailForOptions(TArray<class URBPlayerCustomizationOption*> rbCustomizationOptions, bool forceCleanCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.SaveThumbnailForOptions");
		
		URBUIBlueprintLibrary_SaveThumbnailForOptions_Params params {};
		params.rbCustomizationOptions = rbCustomizationOptions;
		params.forceCleanCategory = forceCleanCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.SaveThumbnailForCellItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		TArray<class URBPlayerCellItemDefinition*>         rbPlayerCellItems                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               forceCleanCategory                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::SaveThumbnailForCellItems(TArray<class URBPlayerCellItemDefinition*> rbPlayerCellItems, bool forceCleanCategory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.SaveThumbnailForCellItems");
		
		URBUIBlueprintLibrary_SaveThumbnailForCellItems_Params params {};
		params.rbPlayerCellItems = rbPlayerCellItems;
		params.forceCleanCategory = forceCleanCategory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.ResetNonMenuTutorials
	 * 		Flags  -> ()
	 */
	void URBUIBlueprintLibrary::ResetNonMenuTutorials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.ResetNonMenuTutorials");
		
		URBUIBlueprintLibrary_ResetNonMenuTutorials_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.ResetMenuTutorials
	 * 		Flags  -> ()
	 */
	void URBUIBlueprintLibrary::ResetMenuTutorials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.ResetMenuTutorials");
		
		URBUIBlueprintLibrary_ResetMenuTutorials_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.PushReleaseTutorials
	 * 		Flags  -> ()
	 */
	void URBUIBlueprintLibrary::PushReleaseTutorials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.PushReleaseTutorials");
		
		URBUIBlueprintLibrary_PushReleaseTutorials_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.PushProgramTutorials
	 * 		Flags  -> ()
	 */
	void URBUIBlueprintLibrary::PushProgramTutorials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.PushProgramTutorials");
		
		URBUIBlueprintLibrary_PushProgramTutorials_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.PushHUDTutorial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FHUDTutorialTextData                        HUDTutorialTextData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::PushHUDTutorial(const struct FHUDTutorialTextData& HUDTutorialTextData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.PushHUDTutorial");
		
		URBUIBlueprintLibrary_PushHUDTutorial_Params params {};
		params.HUDTutorialTextData = HUDTutorialTextData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.ParseTVChannelTextIntoLines
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class FString> URBUIBlueprintLibrary::ParseTVChannelTextIntoLines(const class FString& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.ParseTVChannelTextIntoLines");
		
		URBUIBlueprintLibrary_ParseTVChannelTextIntoLines_Params params {};
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.NormalizedScoreToText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText URBUIBlueprintLibrary::NormalizedScoreToText(float Score)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.NormalizedScoreToText");
		
		URBUIBlueprintLibrary_NormalizedScoreToText_Params params {};
		params.Score = Score;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.NormalizedScoreToRating
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPlayerTrialRating URBUIBlueprintLibrary::NormalizedScoreToRating(float Score)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.NormalizedScoreToRating");
		
		URBUIBlueprintLibrary_NormalizedScoreToRating_Params params {};
		params.Score = Score;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.IsWiderInputTexture
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::IsWiderInputTexture(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.IsWiderInputTexture");
		
		URBUIBlueprintLibrary_IsWiderInputTexture_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.IsShowingLoadingScreen
	 * 		Flags  -> ()
	 */
	bool URBUIBlueprintLibrary::IsShowingLoadingScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.IsShowingLoadingScreen");
		
		URBUIBlueprintLibrary_IsShowingLoadingScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.IsShippingBuild
	 * 		Flags  -> ()
	 */
	bool URBUIBlueprintLibrary::IsShippingBuild()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.IsShippingBuild");
		
		URBUIBlueprintLibrary_IsShippingBuild_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.IsReplayingMenuTutorials
	 * 		Flags  -> ()
	 */
	bool URBUIBlueprintLibrary::IsReplayingMenuTutorials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.IsReplayingMenuTutorials");
		
		URBUIBlueprintLibrary_IsReplayingMenuTutorials_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.IsMetaNPCUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMetaNPCType                                       NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::IsMetaNPCUnlocked(EMetaNPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.IsMetaNPCUnlocked");
		
		URBUIBlueprintLibrary_IsMetaNPCUnlocked_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.HideTutorial
	 * 		Flags  -> ()
	 */
	void URBUIBlueprintLibrary::HideTutorial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.HideTutorial");
		
		URBUIBlueprintLibrary_HideTutorial_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.HasVisitedNPC
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMetaNPCType                                       NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::HasVisitedNPC(EMetaNPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.HasVisitedNPC");
		
		URBUIBlueprintLibrary_HasVisitedNPC_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.HasUnseenAcquiredDocument
	 * 		Flags  -> ()
	 */
	bool URBUIBlueprintLibrary::HasUnseenAcquiredDocument()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.HasUnseenAcquiredDocument");
		
		URBUIBlueprintLibrary_HasUnseenAcquiredDocument_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.HasSeenDocument
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::HasSeenDocument(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.HasSeenDocument");
		
		URBUIBlueprintLibrary_HasSeenDocument_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.HasPlayedVoicelineForLastLevelGained
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FUILevelInfo                                levelInfo                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::HasPlayedVoicelineForLastLevelGained(const struct FUILevelInfo& levelInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.HasPlayedVoicelineForLastLevelGained");
		
		URBUIBlueprintLibrary_HasPlayedVoicelineForLastLevelGained_Params params {};
		params.levelInfo = levelInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.HasPlayedTutorial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TutorialId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::HasPlayedTutorial(const class FName& TutorialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.HasPlayedTutorial");
		
		URBUIBlueprintLibrary_HasPlayedTutorial_Params params {};
		params.TutorialId = TutorialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.HasPlayedNPCUnlockAnnouncement
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EMetaNPCType                                       NPCType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::HasPlayedNPCUnlockAnnouncement(EMetaNPCType NPCType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.HasPlayedNPCUnlockAnnouncement");
		
		URBUIBlueprintLibrary_HasPlayedNPCUnlockAnnouncement_Params params {};
		params.NPCType = NPCType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.HasPlayedMenuTutorial
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        TutorialId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::HasPlayedMenuTutorial(const class FName& TutorialId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.HasPlayedMenuTutorial");
		
		URBUIBlueprintLibrary_HasPlayedMenuTutorial_Params params {};
		params.TutorialId = TutorialId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.HasNewShopItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECustomizationMenuCategory                         Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::HasNewShopItem(ECustomizationMenuCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.HasNewShopItem");
		
		URBUIBlueprintLibrary_HasNewShopItem_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.HasAnyNewShopItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               isCustomizingFemale                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::HasAnyNewShopItem(bool isCustomizingFemale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.HasAnyNewShopItem");
		
		URBUIBlueprintLibrary_HasAnyNewShopItem_Params params {};
		params.isCustomizingFemale = isCustomizingFemale;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.GetPlayerDisplayName
	 * 		Flags  -> ()
	 */
	class FString URBUIBlueprintLibrary::GetPlayerDisplayName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.GetPlayerDisplayName");
		
		URBUIBlueprintLibrary_GetPlayerDisplayName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.GetMatchmakingRegionName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      region                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBUIBlueprintLibrary::GetMatchmakingRegionName(const class FString& region)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.GetMatchmakingRegionName");
		
		URBUIBlueprintLibrary_GetMatchmakingRegionName_Params params {};
		params.region = region;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.GetLocalCellMenuCharacter
	 * 		Flags  -> ()
	 */
	class AActor* URBUIBlueprintLibrary::GetLocalCellMenuCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.GetLocalCellMenuCharacter");
		
		URBUIBlueprintLibrary_GetLocalCellMenuCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.GetGamepadSpecificData
	 * 		Flags  -> ()
	 */
	class URBGamepadSpecificData* URBUIBlueprintLibrary::GetGamepadSpecificData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.GetGamepadSpecificData");
		
		URBUIBlueprintLibrary_GetGamepadSpecificData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.GetGamepadInputTextureFromKey
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* URBUIBlueprintLibrary::GetGamepadInputTextureFromKey(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.GetGamepadInputTextureFromKey");
		
		URBUIBlueprintLibrary_GetGamepadInputTextureFromKey_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.GetCurrencyReward
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FRBGeneratedRewardData                      RewardData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		ECurrencyType                                      currencyType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBUIBlueprintLibrary::GetCurrencyReward(const struct FRBGeneratedRewardData& RewardData, ECurrencyType currencyType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.GetCurrencyReward");
		
		URBUIBlueprintLibrary_GetCurrencyReward_Params params {};
		params.RewardData = RewardData;
		params.currencyType = currencyType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.FormatUpgradeEffectTexts
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        upgradeOnlineId                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class FText> URBUIBlueprintLibrary::FormatUpgradeEffectTexts(const class FName& upgradeOnlineId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.FormatUpgradeEffectTexts");
		
		URBUIBlueprintLibrary_FormatUpgradeEffectTexts_Params params {};
		params.upgradeOnlineId = upgradeOnlineId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.FormatUpgradeEffectText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        upgradeOnlineId                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText URBUIBlueprintLibrary::FormatUpgradeEffectText(const class FName& upgradeOnlineId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.FormatUpgradeEffectText");
		
		URBUIBlueprintLibrary_FormatUpgradeEffectText_Params params {};
		params.upgradeOnlineId = upgradeOnlineId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.FormatTextForDecorator
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            HeightOverride                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText URBUIBlueprintLibrary::FormatTextForDecorator(const class FText& Message, int32_t HeightOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.FormatTextForDecorator");
		
		URBUIBlueprintLibrary_FormatTextForDecorator_Params params {};
		params.Message = Message;
		params.HeightOverride = HeightOverride;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.FormatPlayerName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FString                                      DisplayName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            maxLength                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBUIBlueprintLibrary::FormatPlayerName(const class FString& DisplayName, int32_t maxLength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.FormatPlayerName");
		
		URBUIBlueprintLibrary_FormatPlayerName_Params params {};
		params.DisplayName = DisplayName;
		params.maxLength = maxLength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.CustomizationCategoryContainsSameItems
	 * 		Flags  -> ()
	 * Parameters:
	 * 		ECustomizationMenuCategory                         Source                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECustomizationMenuCategory                         Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::CustomizationCategoryContainsSameItems(ECustomizationMenuCategory Source, ECustomizationMenuCategory Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.CustomizationCategoryContainsSameItems");
		
		URBUIBlueprintLibrary_CustomizationCategoryContainsSameItems_Params params {};
		params.Source = Source;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.ClearMenuFocusAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UWidget*                                     Source                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUIBlueprintLibrary::ClearMenuFocusAction(class UWidget* Source)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.ClearMenuFocusAction");
		
		URBUIBlueprintLibrary_ClearMenuFocusAction_Params params {};
		params.Source = Source;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.BP_IsQuestGiverUnlocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBQuestGiver*                               questGiver                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::BP_IsQuestGiverUnlocked(class ARBQuestGiver* questGiver)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.BP_IsQuestGiverUnlocked");
		
		URBUIBlueprintLibrary_BP_IsQuestGiverUnlocked_Params params {};
		params.questGiver = questGiver;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.BP_IsInteractingWithCursorEnabledPanelComponent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   RBPlayer                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBUIBlueprintLibrary::BP_IsInteractingWithCursorEnabledPanelComponent(class ARBPlayer* RBPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.BP_IsInteractingWithCursorEnabledPanelComponent");
		
		URBUIBlueprintLibrary_BP_IsInteractingWithCursorEnabledPanelComponent_Params params {};
		params.RBPlayer = RBPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUIBlueprintLibrary.BP_GetRHIName
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EGraphicsRHI                                       Version                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString URBUIBlueprintLibrary::BP_GetRHIName(EGraphicsRHI Version)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUIBlueprintLibrary.BP_GetRHIName");
		
		URBUIBlueprintLibrary_BP_GetRHIName_Params params {};
		params.Version = Version;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBUIBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBUIBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBUIBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBUnlockableLargePickupRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBUnlockableLargePickupRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBUnlockableLargePickupRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUnlockableLargePickup.OnRep_Islocked
	 * 		Flags  -> ()
	 */
	void ARBUnlockableLargePickup::OnRep_Islocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUnlockableLargePickup.OnRep_Islocked");
		
		ARBUnlockableLargePickup_OnRep_Islocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUnlockableLargePickup.Event_OnIsLockedChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBUnlockableLargePickup::Event_OnIsLockedChanged(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUnlockableLargePickup.Event_OnIsLockedChanged");
		
		ARBUnlockableLargePickup_Event_OnIsLockedChanged_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUnlockableLargePickup.BP_SetIsLocked
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBUnlockableLargePickup::BP_SetIsLocked(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUnlockableLargePickup.BP_SetIsLocked");
		
		ARBUnlockableLargePickup_BP_SetIsLocked_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBUnlockableLargePickup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBUnlockableLargePickup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBUnlockableLargePickup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUpgradeMenuTab.TryAcquireUpgrade
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class FName                                        ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBUpgradeMenuTab::TryAcquireUpgrade(const class FName& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUpgradeMenuTab.TryAcquireUpgrade");
		
		URBUpgradeMenuTab_TryAcquireUpgrade_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUpgradeMenuTab.OnItemMouseUp
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FMenuUpgradeItemInfo                        itemInfo                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBUpgradeMenuTab::OnItemMouseUp(const struct FMenuUpgradeItemInfo& itemInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUpgradeMenuTab.OnItemMouseUp");
		
		URBUpgradeMenuTab_OnItemMouseUp_Params params {};
		params.itemInfo = itemInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUpgradeMenuTab.OnItemMouseDown
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FMenuUpgradeItemInfo                        itemInfo                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void URBUpgradeMenuTab::OnItemMouseDown(const struct FMenuUpgradeItemInfo& itemInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUpgradeMenuTab.OnItemMouseDown");
		
		URBUpgradeMenuTab_OnItemMouseDown_Params params {};
		params.itemInfo = itemInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBUpgradeMenuTab.Event_OnUpgradeAcquired
	 * 		Flags  -> ()
	 */
	void URBUpgradeMenuTab::Event_OnUpgradeAcquired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBUpgradeMenuTab.Event_OnUpgradeAcquired");
		
		URBUpgradeMenuTab_Event_OnUpgradeAcquired_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBUpgradeMenuTab.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBUpgradeMenuTab::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBUpgradeMenuTab");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBQuestItemSpawner.SpawnQuestItem
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UClass*                                      specificItemClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ARBPickup* URBQuestItemSpawner::SpawnQuestItem(class UClass* specificItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBQuestItemSpawner.SpawnQuestItem");
		
		URBQuestItemSpawner_SpawnQuestItem_Params params {};
		params.specificItemClass = specificItemClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBQuestItemSpawner.GetSpecificObjectiveActorTarget
	 * 		Flags  -> ()
	 */
	class AActor* URBQuestItemSpawner::GetSpecificObjectiveActorTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBQuestItemSpawner.GetSpecificObjectiveActorTarget");
		
		URBQuestItemSpawner_GetSpecificObjectiveActorTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBQuestItemSpawner.CleanQuestItem
	 * 		Flags  -> ()
	 */
	void URBQuestItemSpawner::CleanQuestItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBQuestItemSpawner.CleanQuestItem");
		
		URBQuestItemSpawner_CleanQuestItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBQuestItemSpawner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBQuestItemSpawner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBQuestItemSpawner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.OnUnlockingButtonStateChanged_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBCoopOperatableComponent*                  Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBValvePanelComponent::OnUnlockingButtonStateChanged_Server(class URBCoopOperatableComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.OnUnlockingButtonStateChanged_Server");
		
		URBValvePanelComponent_OnUnlockingButtonStateChanged_Server_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.OnRep_ValveType
	 * 		Flags  -> ()
	 */
	void URBValvePanelComponent::OnRep_ValveType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.OnRep_ValveType");
		
		URBValvePanelComponent_OnRep_ValveType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.OnRep_SuccessRatioTarget
	 * 		Flags  -> ()
	 */
	void URBValvePanelComponent::OnRep_SuccessRatioTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.OnRep_SuccessRatioTarget");
		
		URBValvePanelComponent_OnRep_SuccessRatioTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.OnRep_Locked
	 * 		Flags  -> ()
	 */
	void URBValvePanelComponent::OnRep_Locked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.OnRep_Locked");
		
		URBValvePanelComponent_OnRep_Locked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.OnRep_IsInSuccessZone
	 * 		Flags  -> ()
	 */
	void URBValvePanelComponent::OnRep_IsInSuccessZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.OnRep_IsInSuccessZone");
		
		URBValvePanelComponent_OnRep_IsInSuccessZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.OnRep_IsInFailureZone
	 * 		Flags  -> ()
	 */
	void URBValvePanelComponent::OnRep_IsInFailureZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.OnRep_IsInFailureZone");
		
		URBValvePanelComponent_OnRep_IsInFailureZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.OnRep_InputDirectionHeldSide
	 * 		Flags  -> ()
	 */
	void URBValvePanelComponent::OnRep_InputDirectionHeldSide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.OnRep_InputDirectionHeldSide");
		
		URBValvePanelComponent_OnRep_InputDirectionHeldSide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.OnRep_CurrentMeter
	 * 		Flags  -> ()
	 */
	void URBValvePanelComponent::OnRep_CurrentMeter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.OnRep_CurrentMeter");
		
		URBValvePanelComponent_OnRep_CurrentMeter_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.OnRep_CurrentGameplayRatio
	 * 		Flags  -> ()
	 */
	void URBValvePanelComponent::OnRep_CurrentGameplayRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.OnRep_CurrentGameplayRatio");
		
		URBValvePanelComponent_OnRep_CurrentGameplayRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.Multicast_OnPanelSucceeded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBValvePanelComponent::Multicast_OnPanelSucceeded(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.Multicast_OnPanelSucceeded");
		
		URBValvePanelComponent_Multicast_OnPanelSucceeded_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.IsInSuccessZoneChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBValvePanelComponent::IsInSuccessZoneChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.IsInSuccessZoneChangedCallback");
		
		URBValvePanelComponent_IsInSuccessZoneChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.IsInFailureZoneChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBValvePanelComponent::IsInFailureZoneChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.IsInFailureZoneChangedCallback");
		
		URBValvePanelComponent_IsInFailureZoneChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.IsCompleted
	 * 		Flags  -> ()
	 */
	bool URBValvePanelComponent::IsCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.IsCompleted");
		
		URBValvePanelComponent_IsCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.InputDirectionHeldSideChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBValvePanelComponent::InputDirectionHeldSideChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.InputDirectionHeldSideChangedCallback");
		
		URBValvePanelComponent_InputDirectionHeldSideChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.GetUnlockedTimeLeftRatio
	 * 		Flags  -> ()
	 */
	float URBValvePanelComponent::GetUnlockedTimeLeftRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.GetUnlockedTimeLeftRatio");
		
		URBValvePanelComponent_GetUnlockedTimeLeftRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.GetCurrentMeterRatio
	 * 		Flags  -> ()
	 */
	float URBValvePanelComponent::GetCurrentMeterRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.GetCurrentMeterRatio");
		
		URBValvePanelComponent_GetCurrentMeterRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.CurrentMeterChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBValvePanelComponent::CurrentMeterChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.CurrentMeterChangedCallback");
		
		URBValvePanelComponent_CurrentMeterChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.CurrentGameplayRatioChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changeType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBValvePanelComponent::CurrentGameplayRatioChangedCallback(EScheduledPropertyValueChangedType changeType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.CurrentGameplayRatioChangedCallback");
		
		URBValvePanelComponent_CurrentGameplayRatioChangedCallback_Params params {};
		params.changeType = changeType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.BP_IsInSuccessZone
	 * 		Flags  -> ()
	 */
	bool URBValvePanelComponent::BP_IsInSuccessZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.BP_IsInSuccessZone");
		
		URBValvePanelComponent_BP_IsInSuccessZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.BP_IsInFailureZone
	 * 		Flags  -> ()
	 */
	bool URBValvePanelComponent::BP_IsInFailureZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.BP_IsInFailureZone");
		
		URBValvePanelComponent_BP_IsInFailureZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBValvePanelComponent.BP_GetCurrentPawnTurningIntent
	 * 		Flags  -> ()
	 */
	float URBValvePanelComponent::BP_GetCurrentPawnTurningIntent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBValvePanelComponent.BP_GetCurrentPawnTurningIntent");
		
		URBValvePanelComponent_BP_GetCurrentPawnTurningIntent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBValvePanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBValvePanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBValvePanelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction_PlayerGameplayModifier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction_PlayerGameplayModifier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction_PlayerGameplayModifier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction_ChangeItemSpawing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction_ChangeItemSpawing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction_ChangeItemSpawing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction_StartingItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction_StartingItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction_StartingItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction_UniqueVariatorType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction_UniqueVariatorType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction_UniqueVariatorType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction_GlobalAudioSwitch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction_GlobalAudioSwitch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction_GlobalAudioSwitch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction_AIConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction_AIConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction_AIConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction_TrialConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction_TrialConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction_TrialConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction_RollingGate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction_RollingGate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction_RollingGate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction_SpectreConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction_SpectreConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction_SpectreConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction_PsyhosisBracketsConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction_PsyhosisBracketsConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction_PsyhosisBracketsConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction_SpookConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction_SpookConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction_SpookConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction_Bundle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction_Bundle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction_Bundle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorAction_AIDirectorSpawnModifier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorAction_AIDirectorSpawnModifier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorAction_AIDirectorSpawnModifier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVariatorInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVariatorInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBVariatorManager.OnRep_ReplicatedVariatorInfos
	 * 		Flags  -> ()
	 */
	void ARBVariatorManager::OnRep_ReplicatedVariatorInfos()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBVariatorManager.OnRep_ReplicatedVariatorInfos");
		
		ARBVariatorManager_OnRep_ReplicatedVariatorInfos_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBVariatorManager.IsVariatorUniqueTypeActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EUniqueVariatorType                                Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBVariatorManager::IsVariatorUniqueTypeActive(EUniqueVariatorType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBVariatorManager.IsVariatorUniqueTypeActive");
		
		ARBVariatorManager_IsVariatorUniqueTypeActive_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBVariatorManager.GetRandomRollingGateVariatorType
	 * 		Flags  -> ()
	 */
	ERollingGateVariatorType ARBVariatorManager::GetRandomRollingGateVariatorType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBVariatorManager.GetRandomRollingGateVariatorType");
		
		ARBVariatorManager_GetRandomRollingGateVariatorType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBVariatorManager.GetFixedRollingGateVariatorType
	 * 		Flags  -> ()
	 */
	ERollingGateVariatorType ARBVariatorManager::GetFixedRollingGateVariatorType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBVariatorManager.GetFixedRollingGateVariatorType");
		
		ARBVariatorManager_GetFixedRollingGateVariatorType_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBVariatorManager.GetCurrentVariatorConfigs
	 * 		Flags  -> ()
	 */
	TArray<class URBVariatorInfo*> ARBVariatorManager::GetCurrentVariatorConfigs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBVariatorManager.GetCurrentVariatorConfigs");
		
		ARBVariatorManager_GetCurrentVariatorConfigs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBVariatorManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBVariatorManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVariatorManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBVoiceChatManager.OnVoiceChatEnabledChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayerState*                              RBPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBVoiceChatManager::OnVoiceChatEnabledChanged(class ARBPlayerState* RBPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBVoiceChatManager.OnVoiceChatEnabledChanged");
		
		URBVoiceChatManager_OnVoiceChatEnabledChanged_Params params {};
		params.RBPlayerState = RBPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVoiceChatManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVoiceChatManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVoiceChatManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBVolumetricFog.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBVolumetricFog::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVolumetricFog");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVolumetricFogComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVolumetricFogComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVolumetricFogComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVOManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVOManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVOManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVOMapping.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVOMapping::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVOMapping");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVOMappingOverride.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVOMappingOverride::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVOMappingOverride");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBVOSoundComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBVOSoundComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBVOSoundComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBWarningsAndErrorsTestAgent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBWarningsAndErrorsTestAgent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBWarningsAndErrorsTestAgent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBWaterRippleEmitter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBWaterRippleEmitter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBWaterRippleEmitter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWaterValveObjectiveCoordinator.SelectAllLinkedActors
	 * 		Flags  -> ()
	 */
	void ARBWaterValveObjectiveCoordinator::SelectAllLinkedActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWaterValveObjectiveCoordinator.SelectAllLinkedActors");
		
		ARBWaterValveObjectiveCoordinator_SelectAllLinkedActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWaterValveObjectiveCoordinator.OnValveInitialInteraction_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     pawnInteracting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBWaterValveObjectiveCoordinator::OnValveInitialInteraction_Server(class URBInteractiblePanelComponent* panel, class ARBPawn* pawnInteracting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWaterValveObjectiveCoordinator.OnValveInitialInteraction_Server");
		
		ARBWaterValveObjectiveCoordinator_OnValveInitialInteraction_Server_Params params {};
		params.panel = panel;
		params.pawnInteracting = pawnInteracting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWaterValveObjectiveCoordinator.OnRep_WaterValveSectionData
	 * 		Flags  -> ()
	 */
	void ARBWaterValveObjectiveCoordinator::OnRep_WaterValveSectionData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWaterValveObjectiveCoordinator.OnRep_WaterValveSectionData");
		
		ARBWaterValveObjectiveCoordinator_OnRep_WaterValveSectionData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWaterValveObjectiveCoordinator.OnPumpInteractionEvent_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class URBInteractibleComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBWaterValveObjectiveCoordinator::OnPumpInteractionEvent_Server(class ARBPawn* interactor, class URBInteractibleComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWaterValveObjectiveCoordinator.OnPumpInteractionEvent_Server");
		
		ARBWaterValveObjectiveCoordinator_OnPumpInteractionEvent_Server_Params params {};
		params.interactor = interactor;
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWaterValveObjectiveCoordinator.OnPanelActiveChangedEvent_Server
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class URBInteractiblePanelComponent*               panel                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ARBPawn*                                     pawnInteracting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBWaterValveObjectiveCoordinator::OnPanelActiveChangedEvent_Server(class URBInteractiblePanelComponent* panel, class ARBPawn* pawnInteracting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWaterValveObjectiveCoordinator.OnPanelActiveChangedEvent_Server");
		
		ARBWaterValveObjectiveCoordinator_OnPanelActiveChangedEvent_Server_Params params {};
		params.panel = panel;
		params.pawnInteracting = pawnInteracting;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWaterValveObjectiveCoordinator.BP_StopWater
	 * 		Flags  -> ()
	 */
	void ARBWaterValveObjectiveCoordinator::BP_StopWater()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWaterValveObjectiveCoordinator.BP_StopWater");
		
		ARBWaterValveObjectiveCoordinator_BP_StopWater_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBWaterValveObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBWaterValveObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBWaterValveObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWaterVolume.OnWaterVolumeEndOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBWaterVolume::OnWaterVolumeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWaterVolume.OnWaterVolumeEndOverlap");
		
		ARBWaterVolume_OnWaterVolumeEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWaterVolume.OnWaterVolumeBeginOverlap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARBWaterVolume::OnWaterVolumeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWaterVolume.OnWaterVolumeBeginOverlap");
		
		ARBWaterVolume_OnWaterVolumeBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBWaterVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBWaterVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBWaterVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWaypoint.Event_OnReached
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBot*                                      bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBWaypoint::Event_OnReached(class ARBBot* bot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWaypoint.Event_OnReached");
		
		ARBWaypoint_Event_OnReached_Params params {};
		params.bot = bot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWaypoint.BP_IsEnabled
	 * 		Flags  -> ()
	 */
	bool ARBWaypoint::BP_IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWaypoint.BP_IsEnabled");
		
		ARBWaypoint_BP_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBWaypoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBWaypoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBWaypoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBWaypointGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBWaypointGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBWaypointGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBWhoWasWhere.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBWhoWasWhere::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBWhoWasWhere");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWindowShutter.OnRep_BlockableState
	 * 		Flags  -> ()
	 */
	void ARBWindowShutter::OnRep_BlockableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWindowShutter.OnRep_BlockableState");
		
		ARBWindowShutter_OnRep_BlockableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWindowShutter.GetBlockableState
	 * 		Flags  -> ()
	 */
	EBlockableState ARBWindowShutter::GetBlockableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWindowShutter.GetBlockableState");
		
		ARBWindowShutter_GetBlockableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWindowShutter.Event_OnBlockableStateChanged
	 * 		Flags  -> ()
	 */
	void ARBWindowShutter::Event_OnBlockableStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWindowShutter.Event_OnBlockableStateChanged");
		
		ARBWindowShutter_Event_OnBlockableStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWindowShutter.BP_ForceBlockableState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EBlockableState                                    inBlockableState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBWindowShutter::BP_ForceBlockableState(EBlockableState inBlockableState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWindowShutter.BP_ForceBlockableState");
		
		ARBWindowShutter_BP_ForceBlockableState_Params params {};
		params.inBlockableState = inBlockableState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBWindowShutter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBWindowShutter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBWindowShutter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.SetIsTriggered
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bInIsTriggered                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBWireTriggerTrap::SetIsTriggered(bool bInIsTriggered)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.SetIsTriggered");
		
		ARBWireTriggerTrap_SetIsTriggered_Params params {};
		params.bInIsTriggered = bInIsTriggered;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.OnRep_Triggered
	 * 		Flags  -> ()
	 */
	void ARBWireTriggerTrap::OnRep_Triggered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.OnRep_Triggered");
		
		ARBWireTriggerTrap_OnRep_Triggered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.OnRep_TrapBatteryState
	 * 		Flags  -> ()
	 */
	void ARBWireTriggerTrap::OnRep_TrapBatteryState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.OnRep_TrapBatteryState");
		
		ARBWireTriggerTrap_OnRep_TrapBatteryState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.OnRep_LinkedTraps
	 * 		Flags  -> ()
	 */
	void ARBWireTriggerTrap::OnRep_LinkedTraps()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.OnRep_LinkedTraps");
		
		ARBWireTriggerTrap_OnRep_LinkedTraps_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.OnRep_IsArmed
	 * 		Flags  -> ()
	 */
	void ARBWireTriggerTrap::OnRep_IsArmed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.OnRep_IsArmed");
		
		ARBWireTriggerTrap_OnRep_IsArmed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.OnRep_Enabled
	 * 		Flags  -> ()
	 */
	void ARBWireTriggerTrap::OnRep_Enabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.OnRep_Enabled");
		
		ARBWireTriggerTrap_OnRep_Enabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.OnLinkedDoorAction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDoorActionType                                    actionType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBWireTriggerTrap::OnLinkedDoorAction(class ARBPawn* Pawn, EDoorActionType actionType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.OnLinkedDoorAction");
		
		ARBWireTriggerTrap_OnLinkedDoorAction_Params params {};
		params.Pawn = Pawn;
		params.actionType = actionType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.OnLinkDoorInteraction
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOpening                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBWireTriggerTrap::OnLinkDoorInteraction(class ARBPawn* Pawn, bool bOpening)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.OnLinkDoorInteraction");
		
		ARBWireTriggerTrap_OnLinkDoorInteraction_Params params {};
		params.Pawn = Pawn;
		params.bOpening = bOpening;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.GetTrapBatteryState
	 * 		Flags  -> ()
	 */
	ETrapBatteryState ARBWireTriggerTrap::GetTrapBatteryState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.GetTrapBatteryState");
		
		ARBWireTriggerTrap_GetTrapBatteryState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.GetIsTriggered
	 * 		Flags  -> ()
	 */
	bool ARBWireTriggerTrap::GetIsTriggered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.GetIsTriggered");
		
		ARBWireTriggerTrap_GetIsTriggered_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.GetIsEnabled
	 * 		Flags  -> ()
	 */
	bool ARBWireTriggerTrap::GetIsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.GetIsEnabled");
		
		ARBWireTriggerTrap_GetIsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.GetIsArmed
	 * 		Flags  -> ()
	 */
	bool ARBWireTriggerTrap::GetIsArmed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.GetIsArmed");
		
		ARBWireTriggerTrap_GetIsArmed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.BP_TriggerTrap
	 * 		Flags  -> ()
	 */
	void ARBWireTriggerTrap::BP_TriggerTrap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.BP_TriggerTrap");
		
		ARBWireTriggerTrap_BP_TriggerTrap_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.BP_OnTrapBatteryStateChanged
	 * 		Flags  -> ()
	 */
	void ARBWireTriggerTrap::BP_OnTrapBatteryStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.BP_OnTrapBatteryStateChanged");
		
		ARBWireTriggerTrap_BP_OnTrapBatteryStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.BP_OnDisarmed
	 * 		Flags  -> ()
	 */
	void ARBWireTriggerTrap::BP_OnDisarmed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.BP_OnDisarmed");
		
		ARBWireTriggerTrap_BP_OnDisarmed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.BP_OnArmed
	 * 		Flags  -> ()
	 */
	void ARBWireTriggerTrap::BP_OnArmed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.BP_OnArmed");
		
		ARBWireTriggerTrap_BP_OnArmed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.BP_LinkTrap
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBTrapTriggerable*                          trap                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBWireTriggerTrap::BP_LinkTrap(class ARBTrapTriggerable* trap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.BP_LinkTrap");
		
		ARBWireTriggerTrap_BP_LinkTrap_Params params {};
		params.trap = trap;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.BP_IsTriggererOnWrongSide
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     outTriggerer                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               outIsOnWrongSide                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBWireTriggerTrap::BP_IsTriggererOnWrongSide(class ARBPawn** outTriggerer, bool* outIsOnWrongSide)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.BP_IsTriggererOnWrongSide");
		
		ARBWireTriggerTrap_BP_IsTriggererOnWrongSide_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outTriggerer != nullptr)
			*outTriggerer = params.outTriggerer;
		if (outIsOnWrongSide != nullptr)
			*outIsOnWrongSide = params.outIsOnWrongSide;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWireTriggerTrap.BP_ForceArmedState
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bArmed                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBWireTriggerTrap::BP_ForceArmedState(bool bArmed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWireTriggerTrap.BP_ForceArmedState");
		
		ARBWireTriggerTrap_BP_ForceArmedState_Params params {};
		params.bArmed = bArmed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBWireTriggerTrap.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBWireTriggerTrap::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBWireTriggerTrap");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorld.GetRBWaterSimulationComponent
	 * 		Flags  -> ()
	 */
	class URBWaterSimulationComponent* URBWorld::GetRBWaterSimulationComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorld.GetRBWaterSimulationComponent");
		
		URBWorld_GetRBWaterSimulationComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorld.GetRBRespawners
	 * 		Flags  -> ()
	 */
	TArray<class ARBPlayerRespawner*> URBWorld::GetRBRespawners()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorld.GetRBRespawners");
		
		URBWorld_GetRBRespawners_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorld.GetRBPlayers
	 * 		Flags  -> ()
	 */
	TArray<class ARBPlayer*> URBWorld::GetRBPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorld.GetRBPlayers");
		
		URBWorld_GetRBPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorld.GetRBPickups
	 * 		Flags  -> ()
	 */
	TArray<class ARBPickup*> URBWorld::GetRBPickups()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorld.GetRBPickups");
		
		URBWorld_GetRBPickups_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorld.GetRBPawns
	 * 		Flags  -> ()
	 */
	TArray<class ARBPawn*> URBWorld::GetRBPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorld.GetRBPawns");
		
		URBWorld_GetRBPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorld.GetRBLargePickups
	 * 		Flags  -> ()
	 */
	TArray<class ARBLargePickup*> URBWorld::GetRBLargePickups()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorld.GetRBLargePickups");
		
		URBWorld_GetRBLargePickups_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorld.GetRBInteractibles
	 * 		Flags  -> ()
	 */
	TArray<class ARBInteractible*> URBWorld::GetRBInteractibles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorld.GetRBInteractibles");
		
		URBWorld_GetRBInteractibles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorld.GetRBBreakableObstacles
	 * 		Flags  -> ()
	 */
	TArray<class ARBBreakableObstacle*> URBWorld::GetRBBreakableObstacles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorld.GetRBBreakableObstacles");
		
		URBWorld_GetRBBreakableObstacles_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorld.GetNPCs
	 * 		Flags  -> ()
	 */
	TArray<class ARBNPC*> URBWorld::GetNPCs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorld.GetNPCs");
		
		URBWorld_GetNPCs_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorld.GetMonsterClosets
	 * 		Flags  -> ()
	 */
	TArray<class ARBMonsterCloset*> URBWorld::GetMonsterClosets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorld.GetMonsterClosets");
		
		URBWorld_GetMonsterClosets_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorld.GetDoors
	 * 		Flags  -> ()
	 */
	TArray<class ARBDoor*> URBWorld::GetDoors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorld.GetDoors");
		
		URBWorld_GetDoors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorld.EstimateFogDensity
	 * 		Flags  -> ()
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBWorld::EstimateFogDensity(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorld.EstimateFogDensity");
		
		URBWorld_EstimateFogDensity_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorld.BP_RegisterActorToClean
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBWorld::BP_RegisterActorToClean(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorld.BP_RegisterActorToClean");
		
		URBWorld_BP_RegisterActorToClean_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBWorld.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBWorld::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBWorld");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorldSettings.ClearCurrentFootStepData
	 * 		Flags  -> ()
	 */
	void ARBWorldSettings::ClearCurrentFootStepData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorldSettings.ClearCurrentFootStepData");
		
		ARBWorldSettings_ClearCurrentFootStepData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWorldSettings.ClearAllFootStepData
	 * 		Flags  -> ()
	 */
	void ARBWorldSettings::ClearAllFootStepData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWorldSettings.ClearAllFootStepData");
		
		ARBWorldSettings_ClearAllFootStepData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBWorldSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBWorldSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBWorldSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.TogglePlayPause
	 * 		Flags  -> ()
	 */
	void URBWWWControlMenu::TogglePlayPause()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.TogglePlayPause");
		
		URBWWWControlMenu_TogglePlayPause_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.ShouldShowGameEvents
	 * 		Flags  -> ()
	 */
	bool URBWWWControlMenu::ShouldShowGameEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.ShouldShowGameEvents");
		
		URBWWWControlMenu_ShouldShowGameEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.ShouldShowAIDirectorInfo
	 * 		Flags  -> ()
	 */
	bool URBWWWControlMenu::ShouldShowAIDirectorInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.ShouldShowAIDirectorInfo");
		
		URBWWWControlMenu_ShouldShowAIDirectorInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.SetWWWPlaybackSpeed
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EWWWPlaybackSpeed                                  PlaybackSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBWWWControlMenu::SetWWWPlaybackSpeed(EWWWPlaybackSpeed PlaybackSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.SetWWWPlaybackSpeed");
		
		URBWWWControlMenu_SetWWWPlaybackSpeed_Params params {};
		params.PlaybackSpeed = PlaybackSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.SetTrackDrawOptions
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EWWWTrackDrawSelection                             drawSelection                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EWWWTrackDrawLength                                drawLength                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBWWWControlMenu::SetTrackDrawOptions(EWWWTrackDrawSelection drawSelection, EWWWTrackDrawLength drawLength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.SetTrackDrawOptions");
		
		URBWWWControlMenu_SetTrackDrawOptions_Params params {};
		params.drawSelection = drawSelection;
		params.drawLength = drawLength;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.SetShowGameEvents
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldShow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBWWWControlMenu::SetShowGameEvents(bool bShouldShow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.SetShowGameEvents");
		
		URBWWWControlMenu_SetShowGameEvents_Params params {};
		params.bShouldShow = bShouldShow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.SetShowAIDirectorInfo
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bShouldShow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBWWWControlMenu::SetShowAIDirectorInfo(bool bShouldShow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.SetShowAIDirectorInfo");
		
		URBWWWControlMenu_SetShowAIDirectorInfo_Params params {};
		params.bShouldShow = bShouldShow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.SetPlaybackTime
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              PlaybackTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBWWWControlMenu::SetPlaybackTime(float PlaybackTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.SetPlaybackTime");
		
		URBWWWControlMenu_SetPlaybackTime_Params params {};
		params.PlaybackTime = PlaybackTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.OnPlayControlButton
	 * 		Flags  -> ()
	 * Parameters:
	 * 		bool                                               bForward                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EWWWPlaybackSpeed                                  PlaybackSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBWWWControlMenu::OnPlayControlButton(bool bForward, EWWWPlaybackSpeed PlaybackSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.OnPlayControlButton");
		
		URBWWWControlMenu_OnPlayControlButton_Params params {};
		params.bForward = bForward;
		params.PlaybackSpeed = PlaybackSpeed;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.IsPlaying
	 * 		Flags  -> ()
	 */
	bool URBWWWControlMenu::IsPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.IsPlaying");
		
		URBWWWControlMenu_IsPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.GetWWWPlaybackSpeed
	 * 		Flags  -> ()
	 */
	EWWWPlaybackSpeed URBWWWControlMenu::GetWWWPlaybackSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.GetWWWPlaybackSpeed");
		
		URBWWWControlMenu_GetWWWPlaybackSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.GetPlaybackTime
	 * 		Flags  -> ()
	 */
	float URBWWWControlMenu::GetPlaybackTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.GetPlaybackTime");
		
		URBWWWControlMenu_GetPlaybackTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.GetPlaybackInfoText
	 * 		Flags  -> ()
	 */
	class FText URBWWWControlMenu::GetPlaybackInfoText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.GetPlaybackInfoText");
		
		URBWWWControlMenu_GetPlaybackInfoText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.Event_OnPlaybackSpeedChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		int32_t                                            speedIdx                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBWWWControlMenu::Event_OnPlaybackSpeedChanged(int32_t speedIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.Event_OnPlaybackSpeedChanged");
		
		URBWWWControlMenu_Event_OnPlaybackSpeedChanged_Params params {};
		params.speedIdx = speedIdx;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBWWWControlMenu.CloseWWW
	 * 		Flags  -> ()
	 */
	void URBWWWControlMenu::CloseWWW()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBWWWControlMenu.CloseWWW");
		
		URBWWWControlMenu_CloseWWW_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBWWWControlMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBWWWControlMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBWWWControlMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWWWObjectiveMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWWWObjectiveMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.WWWObjectiveMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWWWPawnPlaybackActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWWWPawnPlaybackActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.WWWPawnPlaybackActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneDefenceWatcherComponent.OnObjectiveCoordinatorStateChanged
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBBaseObjectiveCoordinator*                 coordinator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EObjectiveCoordinatorState                         newState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBZoneDefenceWatcherComponent::OnObjectiveCoordinatorStateChanged(class ARBBaseObjectiveCoordinator* coordinator, EObjectiveCoordinatorState newState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneDefenceWatcherComponent.OnObjectiveCoordinatorStateChanged");
		
		URBZoneDefenceWatcherComponent_OnObjectiveCoordinatorStateChanged_Params params {};
		params.coordinator = coordinator;
		params.newState = newState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneDefenceWatcherComponent.IsZoneCompleted
	 * 		Flags  -> ()
	 */
	bool URBZoneDefenceWatcherComponent::IsZoneCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneDefenceWatcherComponent.IsZoneCompleted");
		
		URBZoneDefenceWatcherComponent_IsZoneCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneDefenceWatcherComponent.IsZoneActive
	 * 		Flags  -> ()
	 */
	bool URBZoneDefenceWatcherComponent::IsZoneActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneDefenceWatcherComponent.IsZoneActive");
		
		URBZoneDefenceWatcherComponent_IsZoneActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneDefenceWatcherComponent.GetZoneProgress
	 * 		Flags  -> ()
	 */
	float URBZoneDefenceWatcherComponent::GetZoneProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneDefenceWatcherComponent.GetZoneProgress");
		
		URBZoneDefenceWatcherComponent_GetZoneProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBZoneDefenceWatcherComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBZoneDefenceWatcherComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBZoneDefenceWatcherComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneDefenceLocation.OnRep_RandomState
	 * 		Flags  -> ()
	 */
	void ARBZoneDefenceLocation::OnRep_RandomState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneDefenceLocation.OnRep_RandomState");
		
		ARBZoneDefenceLocation_OnRep_RandomState_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneDefenceLocation.IsEnabled
	 * 		Flags  -> ()
	 */
	bool ARBZoneDefenceLocation::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneDefenceLocation.IsEnabled");
		
		ARBZoneDefenceLocation_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBZoneDefenceLocation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBZoneDefenceLocation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBZoneDefenceLocation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneDefenceObjectiveCoordinator.OnRep_ObjectiveZoneInfos
	 * 		Flags  -> ()
	 */
	void ARBZoneDefenceObjectiveCoordinator::OnRep_ObjectiveZoneInfos()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneDefenceObjectiveCoordinator.OnRep_ObjectiveZoneInfos");
		
		ARBZoneDefenceObjectiveCoordinator_OnRep_ObjectiveZoneInfos_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneDefenceObjectiveCoordinator.OnPlayerExitedTrigger
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBZoneDefenceObjectiveCoordinator::OnPlayerExitedTrigger(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneDefenceObjectiveCoordinator.OnPlayerExitedTrigger");
		
		ARBZoneDefenceObjectiveCoordinator_OnPlayerExitedTrigger_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneDefenceObjectiveCoordinator.OnPlayerEnteredTrigger
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARBZoneDefenceObjectiveCoordinator::OnPlayerEnteredTrigger(class ARBPlayer* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneDefenceObjectiveCoordinator.OnPlayerEnteredTrigger");
		
		ARBZoneDefenceObjectiveCoordinator_OnPlayerEnteredTrigger_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneDefenceObjectiveCoordinator.IsZoneCompleted
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBZoneDefenceLocation*                      zone                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBZoneDefenceObjectiveCoordinator::IsZoneCompleted(class ARBZoneDefenceLocation* zone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneDefenceObjectiveCoordinator.IsZoneCompleted");
		
		ARBZoneDefenceObjectiveCoordinator_IsZoneCompleted_Params params {};
		params.zone = zone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneDefenceObjectiveCoordinator.IsZoneActive
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBZoneDefenceLocation*                      zone                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARBZoneDefenceObjectiveCoordinator::IsZoneActive(class ARBZoneDefenceLocation* zone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneDefenceObjectiveCoordinator.IsZoneActive");
		
		ARBZoneDefenceObjectiveCoordinator_IsZoneActive_Params params {};
		params.zone = zone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneDefenceObjectiveCoordinator.GetZoneProgress
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBZoneDefenceLocation*                      zone                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ARBZoneDefenceObjectiveCoordinator::GetZoneProgress(class ARBZoneDefenceLocation* zone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneDefenceObjectiveCoordinator.GetZoneProgress");
		
		ARBZoneDefenceObjectiveCoordinator_GetZoneProgress_Params params {};
		params.zone = zone;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBZoneDefenceObjectiveCoordinator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBZoneDefenceObjectiveCoordinator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBZoneDefenceObjectiveCoordinator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARBZoneDefenseMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARBZoneDefenseMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBZoneDefenseMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.OnRep_ThresholdReached
	 * 		Flags  -> ()
	 */
	void URBZoneTimingPanelComponent::OnRep_ThresholdReached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.OnRep_ThresholdReached");
		
		URBZoneTimingPanelComponent_OnRep_ThresholdReached_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.OnRep_TargetInfo
	 * 		Flags  -> ()
	 */
	void URBZoneTimingPanelComponent::OnRep_TargetInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.OnRep_TargetInfo");
		
		URBZoneTimingPanelComponent_OnRep_TargetInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.OnRep_NeedleResetTimeStamp
	 * 		Flags  -> ()
	 */
	void URBZoneTimingPanelComponent::OnRep_NeedleResetTimeStamp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.OnRep_NeedleResetTimeStamp");
		
		URBZoneTimingPanelComponent_OnRep_NeedleResetTimeStamp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.OnRep_NeedleResetInitialRatio
	 * 		Flags  -> ()
	 */
	void URBZoneTimingPanelComponent::OnRep_NeedleResetInitialRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.OnRep_NeedleResetInitialRatio");
		
		URBZoneTimingPanelComponent_OnRep_NeedleResetInitialRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.OnNeedleResetTimeStampChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBZoneTimingPanelComponent::OnNeedleResetTimeStampChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.OnNeedleResetTimeStampChangedCallback");
		
		URBZoneTimingPanelComponent_OnNeedleResetTimeStampChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.OnNeedleResetInitialRatioChangedCallback
	 * 		Flags  -> ()
	 * Parameters:
	 * 		EScheduledPropertyValueChangedType                 changedType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBZoneTimingPanelComponent::OnNeedleResetInitialRatioChangedCallback(EScheduledPropertyValueChangedType changedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.OnNeedleResetInitialRatioChangedCallback");
		
		URBZoneTimingPanelComponent_OnNeedleResetInitialRatioChangedCallback_Params params {};
		params.changedType = changedType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.Multicast_OnPanelSucceeded
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPawn*                                     Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBZoneTimingPanelComponent::Multicast_OnPanelSucceeded(class ARBPawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.Multicast_OnPanelSucceeded");
		
		URBZoneTimingPanelComponent_Multicast_OnPanelSucceeded_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.Multicast_OnPanelInput
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              needleRatio                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Timestamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETimingInputResultType                             Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBZoneTimingPanelComponent::Multicast_OnPanelInput(class ARBPlayer* Player, float needleRatio, float Timestamp, ETimingInputResultType Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.Multicast_OnPanelInput");
		
		URBZoneTimingPanelComponent_Multicast_OnPanelInput_Params params {};
		params.Player = Player;
		params.needleRatio = needleRatio;
		params.Timestamp = Timestamp;
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.GetZoneTimingCustomInteractionText
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        out_CustomInteractionText                                  (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		bool                                               out_bInteractionFail                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool URBZoneTimingPanelComponent::GetZoneTimingCustomInteractionText(class ARBPlayer* Player, class FText* out_CustomInteractionText, bool* out_bInteractionFail)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.GetZoneTimingCustomInteractionText");
		
		URBZoneTimingPanelComponent_GetZoneTimingCustomInteractionText_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (out_CustomInteractionText != nullptr)
			*out_CustomInteractionText = params.out_CustomInteractionText;
		if (out_bInteractionFail != nullptr)
			*out_bInteractionFail = params.out_bInteractionFail;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.GetResultIndexAtPosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              ratio                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t URBZoneTimingPanelComponent::GetResultIndexAtPosition(float ratio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.GetResultIndexAtPosition");
		
		URBZoneTimingPanelComponent_GetResultIndexAtPosition_Params params {};
		params.ratio = ratio;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.GetNeedleSpeed
	 * 		Flags  -> ()
	 */
	float URBZoneTimingPanelComponent::GetNeedleSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.GetNeedleSpeed");
		
		URBZoneTimingPanelComponent_GetNeedleSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.GetNeedlePosition
	 * 		Flags  -> ()
	 * Parameters:
	 * 		float                                              Timestamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float URBZoneTimingPanelComponent::GetNeedlePosition(float Timestamp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.GetNeedlePosition");
		
		URBZoneTimingPanelComponent_GetNeedlePosition_Params params {};
		params.Timestamp = Timestamp;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.GetMeterRatio
	 * 		Flags  -> ()
	 */
	float URBZoneTimingPanelComponent::GetMeterRatio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.GetMeterRatio");
		
		URBZoneTimingPanelComponent_GetMeterRatio_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.GetCurrentNeedlePosition
	 * 		Flags  -> ()
	 */
	float URBZoneTimingPanelComponent::GetCurrentNeedlePosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.GetCurrentNeedlePosition");
		
		URBZoneTimingPanelComponent_GetCurrentNeedlePosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.Event_OnThresholdReachedStateChanged
	 * 		Flags  -> ()
	 */
	void URBZoneTimingPanelComponent::Event_OnThresholdReachedStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.Event_OnThresholdReachedStateChanged");
		
		URBZoneTimingPanelComponent_Event_OnThresholdReachedStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.Event_OnTargetInfoChanged
	 * 		Flags  -> ()
	 */
	void URBZoneTimingPanelComponent::Event_OnTargetInfoChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.Event_OnTargetInfoChanged");
		
		URBZoneTimingPanelComponent_Event_OnTargetInfoChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.Event_OnInteractionAnimationDone
	 * 		Flags  -> ()
	 */
	void URBZoneTimingPanelComponent::Event_OnInteractionAnimationDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.Event_OnInteractionAnimationDone");
		
		URBZoneTimingPanelComponent_Event_OnInteractionAnimationDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.Event_OnInputEvent
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ARBPlayer*                                   Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            targetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Timestamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETimingInputResultType                             Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URBZoneTimingPanelComponent::Event_OnInputEvent(class ARBPlayer* Player, int32_t targetIndex, float Timestamp, ETimingInputResultType Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.Event_OnInputEvent");
		
		URBZoneTimingPanelComponent_Event_OnInputEvent_Params params {};
		params.Player = Player;
		params.targetIndex = targetIndex;
		params.Timestamp = Timestamp;
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.CompleteGameplay_Server
	 * 		Flags  -> ()
	 */
	void URBZoneTimingPanelComponent::CompleteGameplay_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.CompleteGameplay_Server");
		
		URBZoneTimingPanelComponent_CompleteGameplay_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> Function OPP.RBZoneTimingPanelComponent.AnimationDone
	 * 		Flags  -> ()
	 */
	void URBZoneTimingPanelComponent::AnimationDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function OPP.RBZoneTimingPanelComponent.AnimationDone");
		
		URBZoneTimingPanelComponent_AnimationDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URBZoneTimingPanelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URBZoneTimingPanelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class OPP.RBZoneTimingPanelComponent");
		return ptr;
	}

}


